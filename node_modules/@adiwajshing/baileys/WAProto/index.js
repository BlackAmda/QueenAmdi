/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.proto = (function() {

    /**
     * Namespace proto.
     * @exports proto
     * @namespace
     */
    var proto = {};

    proto.ADVDeviceIdentity = (function() {

        /**
         * Properties of a ADVDeviceIdentity.
         * @memberof proto
         * @interface IADVDeviceIdentity
         * @property {number|null} [rawId] ADVDeviceIdentity rawId
         * @property {number|Long|null} [timestamp] ADVDeviceIdentity timestamp
         * @property {number|null} [keyIndex] ADVDeviceIdentity keyIndex
         */

        /**
         * Constructs a new ADVDeviceIdentity.
         * @memberof proto
         * @classdesc Represents a ADVDeviceIdentity.
         * @implements IADVDeviceIdentity
         * @constructor
         * @param {proto.IADVDeviceIdentity=} [properties] Properties to set
         */
        function ADVDeviceIdentity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ADVDeviceIdentity rawId.
         * @member {number} rawId
         * @memberof proto.ADVDeviceIdentity
         * @instance
         */
        ADVDeviceIdentity.prototype.rawId = 0;

        /**
         * ADVDeviceIdentity timestamp.
         * @member {number|Long} timestamp
         * @memberof proto.ADVDeviceIdentity
         * @instance
         */
        ADVDeviceIdentity.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ADVDeviceIdentity keyIndex.
         * @member {number} keyIndex
         * @memberof proto.ADVDeviceIdentity
         * @instance
         */
        ADVDeviceIdentity.prototype.keyIndex = 0;

        /**
         * Creates a new ADVDeviceIdentity instance using the specified properties.
         * @function create
         * @memberof proto.ADVDeviceIdentity
         * @static
         * @param {proto.IADVDeviceIdentity=} [properties] Properties to set
         * @returns {proto.ADVDeviceIdentity} ADVDeviceIdentity instance
         */
        ADVDeviceIdentity.create = function create(properties) {
            return new ADVDeviceIdentity(properties);
        };

        /**
         * Encodes the specified ADVDeviceIdentity message. Does not implicitly {@link proto.ADVDeviceIdentity.verify|verify} messages.
         * @function encode
         * @memberof proto.ADVDeviceIdentity
         * @static
         * @param {proto.IADVDeviceIdentity} message ADVDeviceIdentity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVDeviceIdentity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawId != null && Object.hasOwnProperty.call(message, "rawId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rawId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
            if (message.keyIndex != null && Object.hasOwnProperty.call(message, "keyIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.keyIndex);
            return writer;
        };

        /**
         * Encodes the specified ADVDeviceIdentity message, length delimited. Does not implicitly {@link proto.ADVDeviceIdentity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ADVDeviceIdentity
         * @static
         * @param {proto.IADVDeviceIdentity} message ADVDeviceIdentity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVDeviceIdentity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ADVDeviceIdentity message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ADVDeviceIdentity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ADVDeviceIdentity} ADVDeviceIdentity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVDeviceIdentity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ADVDeviceIdentity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rawId = reader.uint32();
                    break;
                case 2:
                    message.timestamp = reader.uint64();
                    break;
                case 3:
                    message.keyIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ADVDeviceIdentity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ADVDeviceIdentity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ADVDeviceIdentity} ADVDeviceIdentity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVDeviceIdentity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ADVDeviceIdentity message.
         * @function verify
         * @memberof proto.ADVDeviceIdentity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ADVDeviceIdentity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawId != null && message.hasOwnProperty("rawId"))
                if (!$util.isInteger(message.rawId))
                    return "rawId: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.keyIndex != null && message.hasOwnProperty("keyIndex"))
                if (!$util.isInteger(message.keyIndex))
                    return "keyIndex: integer expected";
            return null;
        };

        /**
         * Creates a ADVDeviceIdentity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ADVDeviceIdentity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ADVDeviceIdentity} ADVDeviceIdentity
         */
        ADVDeviceIdentity.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ADVDeviceIdentity)
                return object;
            var message = new $root.proto.ADVDeviceIdentity();
            if (object.rawId != null)
                message.rawId = object.rawId >>> 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.keyIndex != null)
                message.keyIndex = object.keyIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ADVDeviceIdentity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ADVDeviceIdentity
         * @static
         * @param {proto.ADVDeviceIdentity} message ADVDeviceIdentity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ADVDeviceIdentity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rawId = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.keyIndex = 0;
            }
            if (message.rawId != null && message.hasOwnProperty("rawId"))
                object.rawId = message.rawId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.keyIndex != null && message.hasOwnProperty("keyIndex"))
                object.keyIndex = message.keyIndex;
            return object;
        };

        /**
         * Converts this ADVDeviceIdentity to JSON.
         * @function toJSON
         * @memberof proto.ADVDeviceIdentity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ADVDeviceIdentity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ADVDeviceIdentity;
    })();

    proto.ADVKeyIndexList = (function() {

        /**
         * Properties of a ADVKeyIndexList.
         * @memberof proto
         * @interface IADVKeyIndexList
         * @property {number|null} [rawId] ADVKeyIndexList rawId
         * @property {number|Long|null} [timestamp] ADVKeyIndexList timestamp
         * @property {number|null} [currentIndex] ADVKeyIndexList currentIndex
         * @property {Array.<number>|null} [validIndexes] ADVKeyIndexList validIndexes
         */

        /**
         * Constructs a new ADVKeyIndexList.
         * @memberof proto
         * @classdesc Represents a ADVKeyIndexList.
         * @implements IADVKeyIndexList
         * @constructor
         * @param {proto.IADVKeyIndexList=} [properties] Properties to set
         */
        function ADVKeyIndexList(properties) {
            this.validIndexes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ADVKeyIndexList rawId.
         * @member {number} rawId
         * @memberof proto.ADVKeyIndexList
         * @instance
         */
        ADVKeyIndexList.prototype.rawId = 0;

        /**
         * ADVKeyIndexList timestamp.
         * @member {number|Long} timestamp
         * @memberof proto.ADVKeyIndexList
         * @instance
         */
        ADVKeyIndexList.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ADVKeyIndexList currentIndex.
         * @member {number} currentIndex
         * @memberof proto.ADVKeyIndexList
         * @instance
         */
        ADVKeyIndexList.prototype.currentIndex = 0;

        /**
         * ADVKeyIndexList validIndexes.
         * @member {Array.<number>} validIndexes
         * @memberof proto.ADVKeyIndexList
         * @instance
         */
        ADVKeyIndexList.prototype.validIndexes = $util.emptyArray;

        /**
         * Creates a new ADVKeyIndexList instance using the specified properties.
         * @function create
         * @memberof proto.ADVKeyIndexList
         * @static
         * @param {proto.IADVKeyIndexList=} [properties] Properties to set
         * @returns {proto.ADVKeyIndexList} ADVKeyIndexList instance
         */
        ADVKeyIndexList.create = function create(properties) {
            return new ADVKeyIndexList(properties);
        };

        /**
         * Encodes the specified ADVKeyIndexList message. Does not implicitly {@link proto.ADVKeyIndexList.verify|verify} messages.
         * @function encode
         * @memberof proto.ADVKeyIndexList
         * @static
         * @param {proto.IADVKeyIndexList} message ADVKeyIndexList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVKeyIndexList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawId != null && Object.hasOwnProperty.call(message, "rawId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rawId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
            if (message.currentIndex != null && Object.hasOwnProperty.call(message, "currentIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.currentIndex);
            if (message.validIndexes != null && message.validIndexes.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.validIndexes.length; ++i)
                    writer.uint32(message.validIndexes[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ADVKeyIndexList message, length delimited. Does not implicitly {@link proto.ADVKeyIndexList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ADVKeyIndexList
         * @static
         * @param {proto.IADVKeyIndexList} message ADVKeyIndexList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVKeyIndexList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ADVKeyIndexList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ADVKeyIndexList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ADVKeyIndexList} ADVKeyIndexList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVKeyIndexList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ADVKeyIndexList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rawId = reader.uint32();
                    break;
                case 2:
                    message.timestamp = reader.uint64();
                    break;
                case 3:
                    message.currentIndex = reader.uint32();
                    break;
                case 4:
                    if (!(message.validIndexes && message.validIndexes.length))
                        message.validIndexes = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.validIndexes.push(reader.uint32());
                    } else
                        message.validIndexes.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ADVKeyIndexList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ADVKeyIndexList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ADVKeyIndexList} ADVKeyIndexList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVKeyIndexList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ADVKeyIndexList message.
         * @function verify
         * @memberof proto.ADVKeyIndexList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ADVKeyIndexList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawId != null && message.hasOwnProperty("rawId"))
                if (!$util.isInteger(message.rawId))
                    return "rawId: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.currentIndex != null && message.hasOwnProperty("currentIndex"))
                if (!$util.isInteger(message.currentIndex))
                    return "currentIndex: integer expected";
            if (message.validIndexes != null && message.hasOwnProperty("validIndexes")) {
                if (!Array.isArray(message.validIndexes))
                    return "validIndexes: array expected";
                for (var i = 0; i < message.validIndexes.length; ++i)
                    if (!$util.isInteger(message.validIndexes[i]))
                        return "validIndexes: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ADVKeyIndexList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ADVKeyIndexList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ADVKeyIndexList} ADVKeyIndexList
         */
        ADVKeyIndexList.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ADVKeyIndexList)
                return object;
            var message = new $root.proto.ADVKeyIndexList();
            if (object.rawId != null)
                message.rawId = object.rawId >>> 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.currentIndex != null)
                message.currentIndex = object.currentIndex >>> 0;
            if (object.validIndexes) {
                if (!Array.isArray(object.validIndexes))
                    throw TypeError(".proto.ADVKeyIndexList.validIndexes: array expected");
                message.validIndexes = [];
                for (var i = 0; i < object.validIndexes.length; ++i)
                    message.validIndexes[i] = object.validIndexes[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ADVKeyIndexList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ADVKeyIndexList
         * @static
         * @param {proto.ADVKeyIndexList} message ADVKeyIndexList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ADVKeyIndexList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.validIndexes = [];
            if (options.defaults) {
                object.rawId = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.currentIndex = 0;
            }
            if (message.rawId != null && message.hasOwnProperty("rawId"))
                object.rawId = message.rawId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.currentIndex != null && message.hasOwnProperty("currentIndex"))
                object.currentIndex = message.currentIndex;
            if (message.validIndexes && message.validIndexes.length) {
                object.validIndexes = [];
                for (var j = 0; j < message.validIndexes.length; ++j)
                    object.validIndexes[j] = message.validIndexes[j];
            }
            return object;
        };

        /**
         * Converts this ADVKeyIndexList to JSON.
         * @function toJSON
         * @memberof proto.ADVKeyIndexList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ADVKeyIndexList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ADVKeyIndexList;
    })();

    proto.ADVSignedDeviceIdentity = (function() {

        /**
         * Properties of a ADVSignedDeviceIdentity.
         * @memberof proto
         * @interface IADVSignedDeviceIdentity
         * @property {Uint8Array|null} [details] ADVSignedDeviceIdentity details
         * @property {Uint8Array|null} [accountSignatureKey] ADVSignedDeviceIdentity accountSignatureKey
         * @property {Uint8Array|null} [accountSignature] ADVSignedDeviceIdentity accountSignature
         * @property {Uint8Array|null} [deviceSignature] ADVSignedDeviceIdentity deviceSignature
         */

        /**
         * Constructs a new ADVSignedDeviceIdentity.
         * @memberof proto
         * @classdesc Represents a ADVSignedDeviceIdentity.
         * @implements IADVSignedDeviceIdentity
         * @constructor
         * @param {proto.IADVSignedDeviceIdentity=} [properties] Properties to set
         */
        function ADVSignedDeviceIdentity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ADVSignedDeviceIdentity details.
         * @member {Uint8Array} details
         * @memberof proto.ADVSignedDeviceIdentity
         * @instance
         */
        ADVSignedDeviceIdentity.prototype.details = $util.newBuffer([]);

        /**
         * ADVSignedDeviceIdentity accountSignatureKey.
         * @member {Uint8Array} accountSignatureKey
         * @memberof proto.ADVSignedDeviceIdentity
         * @instance
         */
        ADVSignedDeviceIdentity.prototype.accountSignatureKey = $util.newBuffer([]);

        /**
         * ADVSignedDeviceIdentity accountSignature.
         * @member {Uint8Array} accountSignature
         * @memberof proto.ADVSignedDeviceIdentity
         * @instance
         */
        ADVSignedDeviceIdentity.prototype.accountSignature = $util.newBuffer([]);

        /**
         * ADVSignedDeviceIdentity deviceSignature.
         * @member {Uint8Array} deviceSignature
         * @memberof proto.ADVSignedDeviceIdentity
         * @instance
         */
        ADVSignedDeviceIdentity.prototype.deviceSignature = $util.newBuffer([]);

        /**
         * Creates a new ADVSignedDeviceIdentity instance using the specified properties.
         * @function create
         * @memberof proto.ADVSignedDeviceIdentity
         * @static
         * @param {proto.IADVSignedDeviceIdentity=} [properties] Properties to set
         * @returns {proto.ADVSignedDeviceIdentity} ADVSignedDeviceIdentity instance
         */
        ADVSignedDeviceIdentity.create = function create(properties) {
            return new ADVSignedDeviceIdentity(properties);
        };

        /**
         * Encodes the specified ADVSignedDeviceIdentity message. Does not implicitly {@link proto.ADVSignedDeviceIdentity.verify|verify} messages.
         * @function encode
         * @memberof proto.ADVSignedDeviceIdentity
         * @static
         * @param {proto.IADVSignedDeviceIdentity} message ADVSignedDeviceIdentity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVSignedDeviceIdentity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.details);
            if (message.accountSignatureKey != null && Object.hasOwnProperty.call(message, "accountSignatureKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountSignatureKey);
            if (message.accountSignature != null && Object.hasOwnProperty.call(message, "accountSignature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.accountSignature);
            if (message.deviceSignature != null && Object.hasOwnProperty.call(message, "deviceSignature"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.deviceSignature);
            return writer;
        };

        /**
         * Encodes the specified ADVSignedDeviceIdentity message, length delimited. Does not implicitly {@link proto.ADVSignedDeviceIdentity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ADVSignedDeviceIdentity
         * @static
         * @param {proto.IADVSignedDeviceIdentity} message ADVSignedDeviceIdentity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVSignedDeviceIdentity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ADVSignedDeviceIdentity message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ADVSignedDeviceIdentity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ADVSignedDeviceIdentity} ADVSignedDeviceIdentity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVSignedDeviceIdentity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ADVSignedDeviceIdentity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.details = reader.bytes();
                    break;
                case 2:
                    message.accountSignatureKey = reader.bytes();
                    break;
                case 3:
                    message.accountSignature = reader.bytes();
                    break;
                case 4:
                    message.deviceSignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ADVSignedDeviceIdentity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ADVSignedDeviceIdentity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ADVSignedDeviceIdentity} ADVSignedDeviceIdentity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVSignedDeviceIdentity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ADVSignedDeviceIdentity message.
         * @function verify
         * @memberof proto.ADVSignedDeviceIdentity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ADVSignedDeviceIdentity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.details != null && message.hasOwnProperty("details"))
                if (!(message.details && typeof message.details.length === "number" || $util.isString(message.details)))
                    return "details: buffer expected";
            if (message.accountSignatureKey != null && message.hasOwnProperty("accountSignatureKey"))
                if (!(message.accountSignatureKey && typeof message.accountSignatureKey.length === "number" || $util.isString(message.accountSignatureKey)))
                    return "accountSignatureKey: buffer expected";
            if (message.accountSignature != null && message.hasOwnProperty("accountSignature"))
                if (!(message.accountSignature && typeof message.accountSignature.length === "number" || $util.isString(message.accountSignature)))
                    return "accountSignature: buffer expected";
            if (message.deviceSignature != null && message.hasOwnProperty("deviceSignature"))
                if (!(message.deviceSignature && typeof message.deviceSignature.length === "number" || $util.isString(message.deviceSignature)))
                    return "deviceSignature: buffer expected";
            return null;
        };

        /**
         * Creates a ADVSignedDeviceIdentity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ADVSignedDeviceIdentity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ADVSignedDeviceIdentity} ADVSignedDeviceIdentity
         */
        ADVSignedDeviceIdentity.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ADVSignedDeviceIdentity)
                return object;
            var message = new $root.proto.ADVSignedDeviceIdentity();
            if (object.details != null)
                if (typeof object.details === "string")
                    $util.base64.decode(object.details, message.details = $util.newBuffer($util.base64.length(object.details)), 0);
                else if (object.details.length)
                    message.details = object.details;
            if (object.accountSignatureKey != null)
                if (typeof object.accountSignatureKey === "string")
                    $util.base64.decode(object.accountSignatureKey, message.accountSignatureKey = $util.newBuffer($util.base64.length(object.accountSignatureKey)), 0);
                else if (object.accountSignatureKey.length)
                    message.accountSignatureKey = object.accountSignatureKey;
            if (object.accountSignature != null)
                if (typeof object.accountSignature === "string")
                    $util.base64.decode(object.accountSignature, message.accountSignature = $util.newBuffer($util.base64.length(object.accountSignature)), 0);
                else if (object.accountSignature.length)
                    message.accountSignature = object.accountSignature;
            if (object.deviceSignature != null)
                if (typeof object.deviceSignature === "string")
                    $util.base64.decode(object.deviceSignature, message.deviceSignature = $util.newBuffer($util.base64.length(object.deviceSignature)), 0);
                else if (object.deviceSignature.length)
                    message.deviceSignature = object.deviceSignature;
            return message;
        };

        /**
         * Creates a plain object from a ADVSignedDeviceIdentity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ADVSignedDeviceIdentity
         * @static
         * @param {proto.ADVSignedDeviceIdentity} message ADVSignedDeviceIdentity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ADVSignedDeviceIdentity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.details = "";
                else {
                    object.details = [];
                    if (options.bytes !== Array)
                        object.details = $util.newBuffer(object.details);
                }
                if (options.bytes === String)
                    object.accountSignatureKey = "";
                else {
                    object.accountSignatureKey = [];
                    if (options.bytes !== Array)
                        object.accountSignatureKey = $util.newBuffer(object.accountSignatureKey);
                }
                if (options.bytes === String)
                    object.accountSignature = "";
                else {
                    object.accountSignature = [];
                    if (options.bytes !== Array)
                        object.accountSignature = $util.newBuffer(object.accountSignature);
                }
                if (options.bytes === String)
                    object.deviceSignature = "";
                else {
                    object.deviceSignature = [];
                    if (options.bytes !== Array)
                        object.deviceSignature = $util.newBuffer(object.deviceSignature);
                }
            }
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = options.bytes === String ? $util.base64.encode(message.details, 0, message.details.length) : options.bytes === Array ? Array.prototype.slice.call(message.details) : message.details;
            if (message.accountSignatureKey != null && message.hasOwnProperty("accountSignatureKey"))
                object.accountSignatureKey = options.bytes === String ? $util.base64.encode(message.accountSignatureKey, 0, message.accountSignatureKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountSignatureKey) : message.accountSignatureKey;
            if (message.accountSignature != null && message.hasOwnProperty("accountSignature"))
                object.accountSignature = options.bytes === String ? $util.base64.encode(message.accountSignature, 0, message.accountSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountSignature) : message.accountSignature;
            if (message.deviceSignature != null && message.hasOwnProperty("deviceSignature"))
                object.deviceSignature = options.bytes === String ? $util.base64.encode(message.deviceSignature, 0, message.deviceSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.deviceSignature) : message.deviceSignature;
            return object;
        };

        /**
         * Converts this ADVSignedDeviceIdentity to JSON.
         * @function toJSON
         * @memberof proto.ADVSignedDeviceIdentity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ADVSignedDeviceIdentity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ADVSignedDeviceIdentity;
    })();

    proto.ADVSignedDeviceIdentityHMAC = (function() {

        /**
         * Properties of a ADVSignedDeviceIdentityHMAC.
         * @memberof proto
         * @interface IADVSignedDeviceIdentityHMAC
         * @property {Uint8Array|null} [details] ADVSignedDeviceIdentityHMAC details
         * @property {Uint8Array|null} [hmac] ADVSignedDeviceIdentityHMAC hmac
         */

        /**
         * Constructs a new ADVSignedDeviceIdentityHMAC.
         * @memberof proto
         * @classdesc Represents a ADVSignedDeviceIdentityHMAC.
         * @implements IADVSignedDeviceIdentityHMAC
         * @constructor
         * @param {proto.IADVSignedDeviceIdentityHMAC=} [properties] Properties to set
         */
        function ADVSignedDeviceIdentityHMAC(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ADVSignedDeviceIdentityHMAC details.
         * @member {Uint8Array} details
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @instance
         */
        ADVSignedDeviceIdentityHMAC.prototype.details = $util.newBuffer([]);

        /**
         * ADVSignedDeviceIdentityHMAC hmac.
         * @member {Uint8Array} hmac
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @instance
         */
        ADVSignedDeviceIdentityHMAC.prototype.hmac = $util.newBuffer([]);

        /**
         * Creates a new ADVSignedDeviceIdentityHMAC instance using the specified properties.
         * @function create
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @static
         * @param {proto.IADVSignedDeviceIdentityHMAC=} [properties] Properties to set
         * @returns {proto.ADVSignedDeviceIdentityHMAC} ADVSignedDeviceIdentityHMAC instance
         */
        ADVSignedDeviceIdentityHMAC.create = function create(properties) {
            return new ADVSignedDeviceIdentityHMAC(properties);
        };

        /**
         * Encodes the specified ADVSignedDeviceIdentityHMAC message. Does not implicitly {@link proto.ADVSignedDeviceIdentityHMAC.verify|verify} messages.
         * @function encode
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @static
         * @param {proto.IADVSignedDeviceIdentityHMAC} message ADVSignedDeviceIdentityHMAC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVSignedDeviceIdentityHMAC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.details);
            if (message.hmac != null && Object.hasOwnProperty.call(message, "hmac"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hmac);
            return writer;
        };

        /**
         * Encodes the specified ADVSignedDeviceIdentityHMAC message, length delimited. Does not implicitly {@link proto.ADVSignedDeviceIdentityHMAC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @static
         * @param {proto.IADVSignedDeviceIdentityHMAC} message ADVSignedDeviceIdentityHMAC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVSignedDeviceIdentityHMAC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ADVSignedDeviceIdentityHMAC message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ADVSignedDeviceIdentityHMAC} ADVSignedDeviceIdentityHMAC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVSignedDeviceIdentityHMAC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ADVSignedDeviceIdentityHMAC();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.details = reader.bytes();
                    break;
                case 2:
                    message.hmac = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ADVSignedDeviceIdentityHMAC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ADVSignedDeviceIdentityHMAC} ADVSignedDeviceIdentityHMAC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVSignedDeviceIdentityHMAC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ADVSignedDeviceIdentityHMAC message.
         * @function verify
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ADVSignedDeviceIdentityHMAC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.details != null && message.hasOwnProperty("details"))
                if (!(message.details && typeof message.details.length === "number" || $util.isString(message.details)))
                    return "details: buffer expected";
            if (message.hmac != null && message.hasOwnProperty("hmac"))
                if (!(message.hmac && typeof message.hmac.length === "number" || $util.isString(message.hmac)))
                    return "hmac: buffer expected";
            return null;
        };

        /**
         * Creates a ADVSignedDeviceIdentityHMAC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ADVSignedDeviceIdentityHMAC} ADVSignedDeviceIdentityHMAC
         */
        ADVSignedDeviceIdentityHMAC.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ADVSignedDeviceIdentityHMAC)
                return object;
            var message = new $root.proto.ADVSignedDeviceIdentityHMAC();
            if (object.details != null)
                if (typeof object.details === "string")
                    $util.base64.decode(object.details, message.details = $util.newBuffer($util.base64.length(object.details)), 0);
                else if (object.details.length)
                    message.details = object.details;
            if (object.hmac != null)
                if (typeof object.hmac === "string")
                    $util.base64.decode(object.hmac, message.hmac = $util.newBuffer($util.base64.length(object.hmac)), 0);
                else if (object.hmac.length)
                    message.hmac = object.hmac;
            return message;
        };

        /**
         * Creates a plain object from a ADVSignedDeviceIdentityHMAC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @static
         * @param {proto.ADVSignedDeviceIdentityHMAC} message ADVSignedDeviceIdentityHMAC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ADVSignedDeviceIdentityHMAC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.details = "";
                else {
                    object.details = [];
                    if (options.bytes !== Array)
                        object.details = $util.newBuffer(object.details);
                }
                if (options.bytes === String)
                    object.hmac = "";
                else {
                    object.hmac = [];
                    if (options.bytes !== Array)
                        object.hmac = $util.newBuffer(object.hmac);
                }
            }
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = options.bytes === String ? $util.base64.encode(message.details, 0, message.details.length) : options.bytes === Array ? Array.prototype.slice.call(message.details) : message.details;
            if (message.hmac != null && message.hasOwnProperty("hmac"))
                object.hmac = options.bytes === String ? $util.base64.encode(message.hmac, 0, message.hmac.length) : options.bytes === Array ? Array.prototype.slice.call(message.hmac) : message.hmac;
            return object;
        };

        /**
         * Converts this ADVSignedDeviceIdentityHMAC to JSON.
         * @function toJSON
         * @memberof proto.ADVSignedDeviceIdentityHMAC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ADVSignedDeviceIdentityHMAC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ADVSignedDeviceIdentityHMAC;
    })();

    proto.ADVSignedKeyIndexList = (function() {

        /**
         * Properties of a ADVSignedKeyIndexList.
         * @memberof proto
         * @interface IADVSignedKeyIndexList
         * @property {Uint8Array|null} [details] ADVSignedKeyIndexList details
         * @property {Uint8Array|null} [accountSignature] ADVSignedKeyIndexList accountSignature
         */

        /**
         * Constructs a new ADVSignedKeyIndexList.
         * @memberof proto
         * @classdesc Represents a ADVSignedKeyIndexList.
         * @implements IADVSignedKeyIndexList
         * @constructor
         * @param {proto.IADVSignedKeyIndexList=} [properties] Properties to set
         */
        function ADVSignedKeyIndexList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ADVSignedKeyIndexList details.
         * @member {Uint8Array} details
         * @memberof proto.ADVSignedKeyIndexList
         * @instance
         */
        ADVSignedKeyIndexList.prototype.details = $util.newBuffer([]);

        /**
         * ADVSignedKeyIndexList accountSignature.
         * @member {Uint8Array} accountSignature
         * @memberof proto.ADVSignedKeyIndexList
         * @instance
         */
        ADVSignedKeyIndexList.prototype.accountSignature = $util.newBuffer([]);

        /**
         * Creates a new ADVSignedKeyIndexList instance using the specified properties.
         * @function create
         * @memberof proto.ADVSignedKeyIndexList
         * @static
         * @param {proto.IADVSignedKeyIndexList=} [properties] Properties to set
         * @returns {proto.ADVSignedKeyIndexList} ADVSignedKeyIndexList instance
         */
        ADVSignedKeyIndexList.create = function create(properties) {
            return new ADVSignedKeyIndexList(properties);
        };

        /**
         * Encodes the specified ADVSignedKeyIndexList message. Does not implicitly {@link proto.ADVSignedKeyIndexList.verify|verify} messages.
         * @function encode
         * @memberof proto.ADVSignedKeyIndexList
         * @static
         * @param {proto.IADVSignedKeyIndexList} message ADVSignedKeyIndexList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVSignedKeyIndexList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.details);
            if (message.accountSignature != null && Object.hasOwnProperty.call(message, "accountSignature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountSignature);
            return writer;
        };

        /**
         * Encodes the specified ADVSignedKeyIndexList message, length delimited. Does not implicitly {@link proto.ADVSignedKeyIndexList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ADVSignedKeyIndexList
         * @static
         * @param {proto.IADVSignedKeyIndexList} message ADVSignedKeyIndexList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ADVSignedKeyIndexList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ADVSignedKeyIndexList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ADVSignedKeyIndexList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ADVSignedKeyIndexList} ADVSignedKeyIndexList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVSignedKeyIndexList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ADVSignedKeyIndexList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.details = reader.bytes();
                    break;
                case 2:
                    message.accountSignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ADVSignedKeyIndexList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ADVSignedKeyIndexList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ADVSignedKeyIndexList} ADVSignedKeyIndexList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ADVSignedKeyIndexList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ADVSignedKeyIndexList message.
         * @function verify
         * @memberof proto.ADVSignedKeyIndexList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ADVSignedKeyIndexList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.details != null && message.hasOwnProperty("details"))
                if (!(message.details && typeof message.details.length === "number" || $util.isString(message.details)))
                    return "details: buffer expected";
            if (message.accountSignature != null && message.hasOwnProperty("accountSignature"))
                if (!(message.accountSignature && typeof message.accountSignature.length === "number" || $util.isString(message.accountSignature)))
                    return "accountSignature: buffer expected";
            return null;
        };

        /**
         * Creates a ADVSignedKeyIndexList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ADVSignedKeyIndexList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ADVSignedKeyIndexList} ADVSignedKeyIndexList
         */
        ADVSignedKeyIndexList.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ADVSignedKeyIndexList)
                return object;
            var message = new $root.proto.ADVSignedKeyIndexList();
            if (object.details != null)
                if (typeof object.details === "string")
                    $util.base64.decode(object.details, message.details = $util.newBuffer($util.base64.length(object.details)), 0);
                else if (object.details.length)
                    message.details = object.details;
            if (object.accountSignature != null)
                if (typeof object.accountSignature === "string")
                    $util.base64.decode(object.accountSignature, message.accountSignature = $util.newBuffer($util.base64.length(object.accountSignature)), 0);
                else if (object.accountSignature.length)
                    message.accountSignature = object.accountSignature;
            return message;
        };

        /**
         * Creates a plain object from a ADVSignedKeyIndexList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ADVSignedKeyIndexList
         * @static
         * @param {proto.ADVSignedKeyIndexList} message ADVSignedKeyIndexList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ADVSignedKeyIndexList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.details = "";
                else {
                    object.details = [];
                    if (options.bytes !== Array)
                        object.details = $util.newBuffer(object.details);
                }
                if (options.bytes === String)
                    object.accountSignature = "";
                else {
                    object.accountSignature = [];
                    if (options.bytes !== Array)
                        object.accountSignature = $util.newBuffer(object.accountSignature);
                }
            }
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = options.bytes === String ? $util.base64.encode(message.details, 0, message.details.length) : options.bytes === Array ? Array.prototype.slice.call(message.details) : message.details;
            if (message.accountSignature != null && message.hasOwnProperty("accountSignature"))
                object.accountSignature = options.bytes === String ? $util.base64.encode(message.accountSignature, 0, message.accountSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountSignature) : message.accountSignature;
            return object;
        };

        /**
         * Converts this ADVSignedKeyIndexList to JSON.
         * @function toJSON
         * @memberof proto.ADVSignedKeyIndexList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ADVSignedKeyIndexList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ADVSignedKeyIndexList;
    })();

    proto.ActionLink = (function() {

        /**
         * Properties of an ActionLink.
         * @memberof proto
         * @interface IActionLink
         * @property {string|null} [url] ActionLink url
         * @property {string|null} [buttonTitle] ActionLink buttonTitle
         */

        /**
         * Constructs a new ActionLink.
         * @memberof proto
         * @classdesc Represents an ActionLink.
         * @implements IActionLink
         * @constructor
         * @param {proto.IActionLink=} [properties] Properties to set
         */
        function ActionLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionLink url.
         * @member {string} url
         * @memberof proto.ActionLink
         * @instance
         */
        ActionLink.prototype.url = "";

        /**
         * ActionLink buttonTitle.
         * @member {string} buttonTitle
         * @memberof proto.ActionLink
         * @instance
         */
        ActionLink.prototype.buttonTitle = "";

        /**
         * Creates a new ActionLink instance using the specified properties.
         * @function create
         * @memberof proto.ActionLink
         * @static
         * @param {proto.IActionLink=} [properties] Properties to set
         * @returns {proto.ActionLink} ActionLink instance
         */
        ActionLink.create = function create(properties) {
            return new ActionLink(properties);
        };

        /**
         * Encodes the specified ActionLink message. Does not implicitly {@link proto.ActionLink.verify|verify} messages.
         * @function encode
         * @memberof proto.ActionLink
         * @static
         * @param {proto.IActionLink} message ActionLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.buttonTitle != null && Object.hasOwnProperty.call(message, "buttonTitle"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.buttonTitle);
            return writer;
        };

        /**
         * Encodes the specified ActionLink message, length delimited. Does not implicitly {@link proto.ActionLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ActionLink
         * @static
         * @param {proto.IActionLink} message ActionLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionLink message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ActionLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ActionLink} ActionLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ActionLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.buttonTitle = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ActionLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ActionLink} ActionLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionLink message.
         * @function verify
         * @memberof proto.ActionLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.buttonTitle != null && message.hasOwnProperty("buttonTitle"))
                if (!$util.isString(message.buttonTitle))
                    return "buttonTitle: string expected";
            return null;
        };

        /**
         * Creates an ActionLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ActionLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ActionLink} ActionLink
         */
        ActionLink.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ActionLink)
                return object;
            var message = new $root.proto.ActionLink();
            if (object.url != null)
                message.url = String(object.url);
            if (object.buttonTitle != null)
                message.buttonTitle = String(object.buttonTitle);
            return message;
        };

        /**
         * Creates a plain object from an ActionLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ActionLink
         * @static
         * @param {proto.ActionLink} message ActionLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.url = "";
                object.buttonTitle = "";
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.buttonTitle != null && message.hasOwnProperty("buttonTitle"))
                object.buttonTitle = message.buttonTitle;
            return object;
        };

        /**
         * Converts this ActionLink to JSON.
         * @function toJSON
         * @memberof proto.ActionLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActionLink;
    })();

    proto.AutoDownloadSettings = (function() {

        /**
         * Properties of an AutoDownloadSettings.
         * @memberof proto
         * @interface IAutoDownloadSettings
         * @property {boolean|null} [downloadImages] AutoDownloadSettings downloadImages
         * @property {boolean|null} [downloadAudio] AutoDownloadSettings downloadAudio
         * @property {boolean|null} [downloadVideo] AutoDownloadSettings downloadVideo
         * @property {boolean|null} [downloadDocuments] AutoDownloadSettings downloadDocuments
         */

        /**
         * Constructs a new AutoDownloadSettings.
         * @memberof proto
         * @classdesc Represents an AutoDownloadSettings.
         * @implements IAutoDownloadSettings
         * @constructor
         * @param {proto.IAutoDownloadSettings=} [properties] Properties to set
         */
        function AutoDownloadSettings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AutoDownloadSettings downloadImages.
         * @member {boolean} downloadImages
         * @memberof proto.AutoDownloadSettings
         * @instance
         */
        AutoDownloadSettings.prototype.downloadImages = false;

        /**
         * AutoDownloadSettings downloadAudio.
         * @member {boolean} downloadAudio
         * @memberof proto.AutoDownloadSettings
         * @instance
         */
        AutoDownloadSettings.prototype.downloadAudio = false;

        /**
         * AutoDownloadSettings downloadVideo.
         * @member {boolean} downloadVideo
         * @memberof proto.AutoDownloadSettings
         * @instance
         */
        AutoDownloadSettings.prototype.downloadVideo = false;

        /**
         * AutoDownloadSettings downloadDocuments.
         * @member {boolean} downloadDocuments
         * @memberof proto.AutoDownloadSettings
         * @instance
         */
        AutoDownloadSettings.prototype.downloadDocuments = false;

        /**
         * Creates a new AutoDownloadSettings instance using the specified properties.
         * @function create
         * @memberof proto.AutoDownloadSettings
         * @static
         * @param {proto.IAutoDownloadSettings=} [properties] Properties to set
         * @returns {proto.AutoDownloadSettings} AutoDownloadSettings instance
         */
        AutoDownloadSettings.create = function create(properties) {
            return new AutoDownloadSettings(properties);
        };

        /**
         * Encodes the specified AutoDownloadSettings message. Does not implicitly {@link proto.AutoDownloadSettings.verify|verify} messages.
         * @function encode
         * @memberof proto.AutoDownloadSettings
         * @static
         * @param {proto.IAutoDownloadSettings} message AutoDownloadSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutoDownloadSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.downloadImages != null && Object.hasOwnProperty.call(message, "downloadImages"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.downloadImages);
            if (message.downloadAudio != null && Object.hasOwnProperty.call(message, "downloadAudio"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.downloadAudio);
            if (message.downloadVideo != null && Object.hasOwnProperty.call(message, "downloadVideo"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.downloadVideo);
            if (message.downloadDocuments != null && Object.hasOwnProperty.call(message, "downloadDocuments"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.downloadDocuments);
            return writer;
        };

        /**
         * Encodes the specified AutoDownloadSettings message, length delimited. Does not implicitly {@link proto.AutoDownloadSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.AutoDownloadSettings
         * @static
         * @param {proto.IAutoDownloadSettings} message AutoDownloadSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutoDownloadSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AutoDownloadSettings message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AutoDownloadSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.AutoDownloadSettings} AutoDownloadSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutoDownloadSettings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AutoDownloadSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.downloadImages = reader.bool();
                    break;
                case 2:
                    message.downloadAudio = reader.bool();
                    break;
                case 3:
                    message.downloadVideo = reader.bool();
                    break;
                case 4:
                    message.downloadDocuments = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AutoDownloadSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.AutoDownloadSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.AutoDownloadSettings} AutoDownloadSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutoDownloadSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AutoDownloadSettings message.
         * @function verify
         * @memberof proto.AutoDownloadSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AutoDownloadSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.downloadImages != null && message.hasOwnProperty("downloadImages"))
                if (typeof message.downloadImages !== "boolean")
                    return "downloadImages: boolean expected";
            if (message.downloadAudio != null && message.hasOwnProperty("downloadAudio"))
                if (typeof message.downloadAudio !== "boolean")
                    return "downloadAudio: boolean expected";
            if (message.downloadVideo != null && message.hasOwnProperty("downloadVideo"))
                if (typeof message.downloadVideo !== "boolean")
                    return "downloadVideo: boolean expected";
            if (message.downloadDocuments != null && message.hasOwnProperty("downloadDocuments"))
                if (typeof message.downloadDocuments !== "boolean")
                    return "downloadDocuments: boolean expected";
            return null;
        };

        /**
         * Creates an AutoDownloadSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.AutoDownloadSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.AutoDownloadSettings} AutoDownloadSettings
         */
        AutoDownloadSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.AutoDownloadSettings)
                return object;
            var message = new $root.proto.AutoDownloadSettings();
            if (object.downloadImages != null)
                message.downloadImages = Boolean(object.downloadImages);
            if (object.downloadAudio != null)
                message.downloadAudio = Boolean(object.downloadAudio);
            if (object.downloadVideo != null)
                message.downloadVideo = Boolean(object.downloadVideo);
            if (object.downloadDocuments != null)
                message.downloadDocuments = Boolean(object.downloadDocuments);
            return message;
        };

        /**
         * Creates a plain object from an AutoDownloadSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.AutoDownloadSettings
         * @static
         * @param {proto.AutoDownloadSettings} message AutoDownloadSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AutoDownloadSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.downloadImages = false;
                object.downloadAudio = false;
                object.downloadVideo = false;
                object.downloadDocuments = false;
            }
            if (message.downloadImages != null && message.hasOwnProperty("downloadImages"))
                object.downloadImages = message.downloadImages;
            if (message.downloadAudio != null && message.hasOwnProperty("downloadAudio"))
                object.downloadAudio = message.downloadAudio;
            if (message.downloadVideo != null && message.hasOwnProperty("downloadVideo"))
                object.downloadVideo = message.downloadVideo;
            if (message.downloadDocuments != null && message.hasOwnProperty("downloadDocuments"))
                object.downloadDocuments = message.downloadDocuments;
            return object;
        };

        /**
         * Converts this AutoDownloadSettings to JSON.
         * @function toJSON
         * @memberof proto.AutoDownloadSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AutoDownloadSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AutoDownloadSettings;
    })();

    proto.AvatarUserSettings = (function() {

        /**
         * Properties of an AvatarUserSettings.
         * @memberof proto
         * @interface IAvatarUserSettings
         * @property {string|null} [fbid] AvatarUserSettings fbid
         * @property {string|null} [password] AvatarUserSettings password
         */

        /**
         * Constructs a new AvatarUserSettings.
         * @memberof proto
         * @classdesc Represents an AvatarUserSettings.
         * @implements IAvatarUserSettings
         * @constructor
         * @param {proto.IAvatarUserSettings=} [properties] Properties to set
         */
        function AvatarUserSettings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AvatarUserSettings fbid.
         * @member {string} fbid
         * @memberof proto.AvatarUserSettings
         * @instance
         */
        AvatarUserSettings.prototype.fbid = "";

        /**
         * AvatarUserSettings password.
         * @member {string} password
         * @memberof proto.AvatarUserSettings
         * @instance
         */
        AvatarUserSettings.prototype.password = "";

        /**
         * Creates a new AvatarUserSettings instance using the specified properties.
         * @function create
         * @memberof proto.AvatarUserSettings
         * @static
         * @param {proto.IAvatarUserSettings=} [properties] Properties to set
         * @returns {proto.AvatarUserSettings} AvatarUserSettings instance
         */
        AvatarUserSettings.create = function create(properties) {
            return new AvatarUserSettings(properties);
        };

        /**
         * Encodes the specified AvatarUserSettings message. Does not implicitly {@link proto.AvatarUserSettings.verify|verify} messages.
         * @function encode
         * @memberof proto.AvatarUserSettings
         * @static
         * @param {proto.IAvatarUserSettings} message AvatarUserSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AvatarUserSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fbid != null && Object.hasOwnProperty.call(message, "fbid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fbid);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified AvatarUserSettings message, length delimited. Does not implicitly {@link proto.AvatarUserSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.AvatarUserSettings
         * @static
         * @param {proto.IAvatarUserSettings} message AvatarUserSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AvatarUserSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AvatarUserSettings message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AvatarUserSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.AvatarUserSettings} AvatarUserSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AvatarUserSettings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AvatarUserSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fbid = reader.string();
                    break;
                case 2:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AvatarUserSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.AvatarUserSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.AvatarUserSettings} AvatarUserSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AvatarUserSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AvatarUserSettings message.
         * @function verify
         * @memberof proto.AvatarUserSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AvatarUserSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fbid != null && message.hasOwnProperty("fbid"))
                if (!$util.isString(message.fbid))
                    return "fbid: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates an AvatarUserSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.AvatarUserSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.AvatarUserSettings} AvatarUserSettings
         */
        AvatarUserSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.AvatarUserSettings)
                return object;
            var message = new $root.proto.AvatarUserSettings();
            if (object.fbid != null)
                message.fbid = String(object.fbid);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from an AvatarUserSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.AvatarUserSettings
         * @static
         * @param {proto.AvatarUserSettings} message AvatarUserSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AvatarUserSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fbid = "";
                object.password = "";
            }
            if (message.fbid != null && message.hasOwnProperty("fbid"))
                object.fbid = message.fbid;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this AvatarUserSettings to JSON.
         * @function toJSON
         * @memberof proto.AvatarUserSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AvatarUserSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AvatarUserSettings;
    })();

    proto.BizAccountLinkInfo = (function() {

        /**
         * Properties of a BizAccountLinkInfo.
         * @memberof proto
         * @interface IBizAccountLinkInfo
         * @property {number|Long|null} [whatsappBizAcctFbid] BizAccountLinkInfo whatsappBizAcctFbid
         * @property {string|null} [whatsappAcctNumber] BizAccountLinkInfo whatsappAcctNumber
         * @property {number|Long|null} [issueTime] BizAccountLinkInfo issueTime
         * @property {proto.BizAccountLinkInfo.HostStorageType|null} [hostStorage] BizAccountLinkInfo hostStorage
         * @property {proto.BizAccountLinkInfo.AccountType|null} [accountType] BizAccountLinkInfo accountType
         */

        /**
         * Constructs a new BizAccountLinkInfo.
         * @memberof proto
         * @classdesc Represents a BizAccountLinkInfo.
         * @implements IBizAccountLinkInfo
         * @constructor
         * @param {proto.IBizAccountLinkInfo=} [properties] Properties to set
         */
        function BizAccountLinkInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BizAccountLinkInfo whatsappBizAcctFbid.
         * @member {number|Long} whatsappBizAcctFbid
         * @memberof proto.BizAccountLinkInfo
         * @instance
         */
        BizAccountLinkInfo.prototype.whatsappBizAcctFbid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BizAccountLinkInfo whatsappAcctNumber.
         * @member {string} whatsappAcctNumber
         * @memberof proto.BizAccountLinkInfo
         * @instance
         */
        BizAccountLinkInfo.prototype.whatsappAcctNumber = "";

        /**
         * BizAccountLinkInfo issueTime.
         * @member {number|Long} issueTime
         * @memberof proto.BizAccountLinkInfo
         * @instance
         */
        BizAccountLinkInfo.prototype.issueTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BizAccountLinkInfo hostStorage.
         * @member {proto.BizAccountLinkInfo.HostStorageType} hostStorage
         * @memberof proto.BizAccountLinkInfo
         * @instance
         */
        BizAccountLinkInfo.prototype.hostStorage = 0;

        /**
         * BizAccountLinkInfo accountType.
         * @member {proto.BizAccountLinkInfo.AccountType} accountType
         * @memberof proto.BizAccountLinkInfo
         * @instance
         */
        BizAccountLinkInfo.prototype.accountType = 0;

        /**
         * Creates a new BizAccountLinkInfo instance using the specified properties.
         * @function create
         * @memberof proto.BizAccountLinkInfo
         * @static
         * @param {proto.IBizAccountLinkInfo=} [properties] Properties to set
         * @returns {proto.BizAccountLinkInfo} BizAccountLinkInfo instance
         */
        BizAccountLinkInfo.create = function create(properties) {
            return new BizAccountLinkInfo(properties);
        };

        /**
         * Encodes the specified BizAccountLinkInfo message. Does not implicitly {@link proto.BizAccountLinkInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.BizAccountLinkInfo
         * @static
         * @param {proto.IBizAccountLinkInfo} message BizAccountLinkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BizAccountLinkInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.whatsappBizAcctFbid != null && Object.hasOwnProperty.call(message, "whatsappBizAcctFbid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.whatsappBizAcctFbid);
            if (message.whatsappAcctNumber != null && Object.hasOwnProperty.call(message, "whatsappAcctNumber"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.whatsappAcctNumber);
            if (message.issueTime != null && Object.hasOwnProperty.call(message, "issueTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.issueTime);
            if (message.hostStorage != null && Object.hasOwnProperty.call(message, "hostStorage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hostStorage);
            if (message.accountType != null && Object.hasOwnProperty.call(message, "accountType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.accountType);
            return writer;
        };

        /**
         * Encodes the specified BizAccountLinkInfo message, length delimited. Does not implicitly {@link proto.BizAccountLinkInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.BizAccountLinkInfo
         * @static
         * @param {proto.IBizAccountLinkInfo} message BizAccountLinkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BizAccountLinkInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BizAccountLinkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.BizAccountLinkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.BizAccountLinkInfo} BizAccountLinkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BizAccountLinkInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.BizAccountLinkInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.whatsappBizAcctFbid = reader.uint64();
                    break;
                case 2:
                    message.whatsappAcctNumber = reader.string();
                    break;
                case 3:
                    message.issueTime = reader.uint64();
                    break;
                case 4:
                    message.hostStorage = reader.int32();
                    break;
                case 5:
                    message.accountType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BizAccountLinkInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.BizAccountLinkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.BizAccountLinkInfo} BizAccountLinkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BizAccountLinkInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BizAccountLinkInfo message.
         * @function verify
         * @memberof proto.BizAccountLinkInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BizAccountLinkInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.whatsappBizAcctFbid != null && message.hasOwnProperty("whatsappBizAcctFbid"))
                if (!$util.isInteger(message.whatsappBizAcctFbid) && !(message.whatsappBizAcctFbid && $util.isInteger(message.whatsappBizAcctFbid.low) && $util.isInteger(message.whatsappBizAcctFbid.high)))
                    return "whatsappBizAcctFbid: integer|Long expected";
            if (message.whatsappAcctNumber != null && message.hasOwnProperty("whatsappAcctNumber"))
                if (!$util.isString(message.whatsappAcctNumber))
                    return "whatsappAcctNumber: string expected";
            if (message.issueTime != null && message.hasOwnProperty("issueTime"))
                if (!$util.isInteger(message.issueTime) && !(message.issueTime && $util.isInteger(message.issueTime.low) && $util.isInteger(message.issueTime.high)))
                    return "issueTime: integer|Long expected";
            if (message.hostStorage != null && message.hasOwnProperty("hostStorage"))
                switch (message.hostStorage) {
                default:
                    return "hostStorage: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                switch (message.accountType) {
                default:
                    return "accountType: enum value expected";
                case 0:
                    break;
                }
            return null;
        };

        /**
         * Creates a BizAccountLinkInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.BizAccountLinkInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.BizAccountLinkInfo} BizAccountLinkInfo
         */
        BizAccountLinkInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.BizAccountLinkInfo)
                return object;
            var message = new $root.proto.BizAccountLinkInfo();
            if (object.whatsappBizAcctFbid != null)
                if ($util.Long)
                    (message.whatsappBizAcctFbid = $util.Long.fromValue(object.whatsappBizAcctFbid)).unsigned = true;
                else if (typeof object.whatsappBizAcctFbid === "string")
                    message.whatsappBizAcctFbid = parseInt(object.whatsappBizAcctFbid, 10);
                else if (typeof object.whatsappBizAcctFbid === "number")
                    message.whatsappBizAcctFbid = object.whatsappBizAcctFbid;
                else if (typeof object.whatsappBizAcctFbid === "object")
                    message.whatsappBizAcctFbid = new $util.LongBits(object.whatsappBizAcctFbid.low >>> 0, object.whatsappBizAcctFbid.high >>> 0).toNumber(true);
            if (object.whatsappAcctNumber != null)
                message.whatsappAcctNumber = String(object.whatsappAcctNumber);
            if (object.issueTime != null)
                if ($util.Long)
                    (message.issueTime = $util.Long.fromValue(object.issueTime)).unsigned = true;
                else if (typeof object.issueTime === "string")
                    message.issueTime = parseInt(object.issueTime, 10);
                else if (typeof object.issueTime === "number")
                    message.issueTime = object.issueTime;
                else if (typeof object.issueTime === "object")
                    message.issueTime = new $util.LongBits(object.issueTime.low >>> 0, object.issueTime.high >>> 0).toNumber(true);
            switch (object.hostStorage) {
            case "ON_PREMISE":
            case 0:
                message.hostStorage = 0;
                break;
            case "FACEBOOK":
            case 1:
                message.hostStorage = 1;
                break;
            }
            switch (object.accountType) {
            case "ENTERPRISE":
            case 0:
                message.accountType = 0;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BizAccountLinkInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.BizAccountLinkInfo
         * @static
         * @param {proto.BizAccountLinkInfo} message BizAccountLinkInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BizAccountLinkInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.whatsappBizAcctFbid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.whatsappBizAcctFbid = options.longs === String ? "0" : 0;
                object.whatsappAcctNumber = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.issueTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issueTime = options.longs === String ? "0" : 0;
                object.hostStorage = options.enums === String ? "ON_PREMISE" : 0;
                object.accountType = options.enums === String ? "ENTERPRISE" : 0;
            }
            if (message.whatsappBizAcctFbid != null && message.hasOwnProperty("whatsappBizAcctFbid"))
                if (typeof message.whatsappBizAcctFbid === "number")
                    object.whatsappBizAcctFbid = options.longs === String ? String(message.whatsappBizAcctFbid) : message.whatsappBizAcctFbid;
                else
                    object.whatsappBizAcctFbid = options.longs === String ? $util.Long.prototype.toString.call(message.whatsappBizAcctFbid) : options.longs === Number ? new $util.LongBits(message.whatsappBizAcctFbid.low >>> 0, message.whatsappBizAcctFbid.high >>> 0).toNumber(true) : message.whatsappBizAcctFbid;
            if (message.whatsappAcctNumber != null && message.hasOwnProperty("whatsappAcctNumber"))
                object.whatsappAcctNumber = message.whatsappAcctNumber;
            if (message.issueTime != null && message.hasOwnProperty("issueTime"))
                if (typeof message.issueTime === "number")
                    object.issueTime = options.longs === String ? String(message.issueTime) : message.issueTime;
                else
                    object.issueTime = options.longs === String ? $util.Long.prototype.toString.call(message.issueTime) : options.longs === Number ? new $util.LongBits(message.issueTime.low >>> 0, message.issueTime.high >>> 0).toNumber(true) : message.issueTime;
            if (message.hostStorage != null && message.hasOwnProperty("hostStorage"))
                object.hostStorage = options.enums === String ? $root.proto.BizAccountLinkInfo.HostStorageType[message.hostStorage] : message.hostStorage;
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                object.accountType = options.enums === String ? $root.proto.BizAccountLinkInfo.AccountType[message.accountType] : message.accountType;
            return object;
        };

        /**
         * Converts this BizAccountLinkInfo to JSON.
         * @function toJSON
         * @memberof proto.BizAccountLinkInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BizAccountLinkInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * AccountType enum.
         * @name proto.BizAccountLinkInfo.AccountType
         * @enum {number}
         * @property {number} ENTERPRISE=0 ENTERPRISE value
         */
        BizAccountLinkInfo.AccountType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ENTERPRISE"] = 0;
            return values;
        })();

        /**
         * HostStorageType enum.
         * @name proto.BizAccountLinkInfo.HostStorageType
         * @enum {number}
         * @property {number} ON_PREMISE=0 ON_PREMISE value
         * @property {number} FACEBOOK=1 FACEBOOK value
         */
        BizAccountLinkInfo.HostStorageType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ON_PREMISE"] = 0;
            values[valuesById[1] = "FACEBOOK"] = 1;
            return values;
        })();

        return BizAccountLinkInfo;
    })();

    proto.BizAccountPayload = (function() {

        /**
         * Properties of a BizAccountPayload.
         * @memberof proto
         * @interface IBizAccountPayload
         * @property {proto.IVerifiedNameCertificate|null} [vnameCert] BizAccountPayload vnameCert
         * @property {Uint8Array|null} [bizAcctLinkInfo] BizAccountPayload bizAcctLinkInfo
         */

        /**
         * Constructs a new BizAccountPayload.
         * @memberof proto
         * @classdesc Represents a BizAccountPayload.
         * @implements IBizAccountPayload
         * @constructor
         * @param {proto.IBizAccountPayload=} [properties] Properties to set
         */
        function BizAccountPayload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BizAccountPayload vnameCert.
         * @member {proto.IVerifiedNameCertificate|null|undefined} vnameCert
         * @memberof proto.BizAccountPayload
         * @instance
         */
        BizAccountPayload.prototype.vnameCert = null;

        /**
         * BizAccountPayload bizAcctLinkInfo.
         * @member {Uint8Array} bizAcctLinkInfo
         * @memberof proto.BizAccountPayload
         * @instance
         */
        BizAccountPayload.prototype.bizAcctLinkInfo = $util.newBuffer([]);

        /**
         * Creates a new BizAccountPayload instance using the specified properties.
         * @function create
         * @memberof proto.BizAccountPayload
         * @static
         * @param {proto.IBizAccountPayload=} [properties] Properties to set
         * @returns {proto.BizAccountPayload} BizAccountPayload instance
         */
        BizAccountPayload.create = function create(properties) {
            return new BizAccountPayload(properties);
        };

        /**
         * Encodes the specified BizAccountPayload message. Does not implicitly {@link proto.BizAccountPayload.verify|verify} messages.
         * @function encode
         * @memberof proto.BizAccountPayload
         * @static
         * @param {proto.IBizAccountPayload} message BizAccountPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BizAccountPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vnameCert != null && Object.hasOwnProperty.call(message, "vnameCert"))
                $root.proto.VerifiedNameCertificate.encode(message.vnameCert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.bizAcctLinkInfo != null && Object.hasOwnProperty.call(message, "bizAcctLinkInfo"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bizAcctLinkInfo);
            return writer;
        };

        /**
         * Encodes the specified BizAccountPayload message, length delimited. Does not implicitly {@link proto.BizAccountPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.BizAccountPayload
         * @static
         * @param {proto.IBizAccountPayload} message BizAccountPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BizAccountPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BizAccountPayload message from the specified reader or buffer.
         * @function decode
         * @memberof proto.BizAccountPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.BizAccountPayload} BizAccountPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BizAccountPayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.BizAccountPayload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.vnameCert = $root.proto.VerifiedNameCertificate.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.bizAcctLinkInfo = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BizAccountPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.BizAccountPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.BizAccountPayload} BizAccountPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BizAccountPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BizAccountPayload message.
         * @function verify
         * @memberof proto.BizAccountPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BizAccountPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vnameCert != null && message.hasOwnProperty("vnameCert")) {
                var error = $root.proto.VerifiedNameCertificate.verify(message.vnameCert);
                if (error)
                    return "vnameCert." + error;
            }
            if (message.bizAcctLinkInfo != null && message.hasOwnProperty("bizAcctLinkInfo"))
                if (!(message.bizAcctLinkInfo && typeof message.bizAcctLinkInfo.length === "number" || $util.isString(message.bizAcctLinkInfo)))
                    return "bizAcctLinkInfo: buffer expected";
            return null;
        };

        /**
         * Creates a BizAccountPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.BizAccountPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.BizAccountPayload} BizAccountPayload
         */
        BizAccountPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.BizAccountPayload)
                return object;
            var message = new $root.proto.BizAccountPayload();
            if (object.vnameCert != null) {
                if (typeof object.vnameCert !== "object")
                    throw TypeError(".proto.BizAccountPayload.vnameCert: object expected");
                message.vnameCert = $root.proto.VerifiedNameCertificate.fromObject(object.vnameCert);
            }
            if (object.bizAcctLinkInfo != null)
                if (typeof object.bizAcctLinkInfo === "string")
                    $util.base64.decode(object.bizAcctLinkInfo, message.bizAcctLinkInfo = $util.newBuffer($util.base64.length(object.bizAcctLinkInfo)), 0);
                else if (object.bizAcctLinkInfo.length)
                    message.bizAcctLinkInfo = object.bizAcctLinkInfo;
            return message;
        };

        /**
         * Creates a plain object from a BizAccountPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.BizAccountPayload
         * @static
         * @param {proto.BizAccountPayload} message BizAccountPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BizAccountPayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.vnameCert = null;
                if (options.bytes === String)
                    object.bizAcctLinkInfo = "";
                else {
                    object.bizAcctLinkInfo = [];
                    if (options.bytes !== Array)
                        object.bizAcctLinkInfo = $util.newBuffer(object.bizAcctLinkInfo);
                }
            }
            if (message.vnameCert != null && message.hasOwnProperty("vnameCert"))
                object.vnameCert = $root.proto.VerifiedNameCertificate.toObject(message.vnameCert, options);
            if (message.bizAcctLinkInfo != null && message.hasOwnProperty("bizAcctLinkInfo"))
                object.bizAcctLinkInfo = options.bytes === String ? $util.base64.encode(message.bizAcctLinkInfo, 0, message.bizAcctLinkInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.bizAcctLinkInfo) : message.bizAcctLinkInfo;
            return object;
        };

        /**
         * Converts this BizAccountPayload to JSON.
         * @function toJSON
         * @memberof proto.BizAccountPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BizAccountPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BizAccountPayload;
    })();

    proto.BizIdentityInfo = (function() {

        /**
         * Properties of a BizIdentityInfo.
         * @memberof proto
         * @interface IBizIdentityInfo
         * @property {proto.BizIdentityInfo.VerifiedLevelValue|null} [vlevel] BizIdentityInfo vlevel
         * @property {proto.IVerifiedNameCertificate|null} [vnameCert] BizIdentityInfo vnameCert
         * @property {boolean|null} [signed] BizIdentityInfo signed
         * @property {boolean|null} [revoked] BizIdentityInfo revoked
         * @property {proto.BizIdentityInfo.HostStorageType|null} [hostStorage] BizIdentityInfo hostStorage
         * @property {proto.BizIdentityInfo.ActualActorsType|null} [actualActors] BizIdentityInfo actualActors
         * @property {number|Long|null} [privacyModeTs] BizIdentityInfo privacyModeTs
         * @property {number|Long|null} [featureControls] BizIdentityInfo featureControls
         */

        /**
         * Constructs a new BizIdentityInfo.
         * @memberof proto
         * @classdesc Represents a BizIdentityInfo.
         * @implements IBizIdentityInfo
         * @constructor
         * @param {proto.IBizIdentityInfo=} [properties] Properties to set
         */
        function BizIdentityInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BizIdentityInfo vlevel.
         * @member {proto.BizIdentityInfo.VerifiedLevelValue} vlevel
         * @memberof proto.BizIdentityInfo
         * @instance
         */
        BizIdentityInfo.prototype.vlevel = 0;

        /**
         * BizIdentityInfo vnameCert.
         * @member {proto.IVerifiedNameCertificate|null|undefined} vnameCert
         * @memberof proto.BizIdentityInfo
         * @instance
         */
        BizIdentityInfo.prototype.vnameCert = null;

        /**
         * BizIdentityInfo signed.
         * @member {boolean} signed
         * @memberof proto.BizIdentityInfo
         * @instance
         */
        BizIdentityInfo.prototype.signed = false;

        /**
         * BizIdentityInfo revoked.
         * @member {boolean} revoked
         * @memberof proto.BizIdentityInfo
         * @instance
         */
        BizIdentityInfo.prototype.revoked = false;

        /**
         * BizIdentityInfo hostStorage.
         * @member {proto.BizIdentityInfo.HostStorageType} hostStorage
         * @memberof proto.BizIdentityInfo
         * @instance
         */
        BizIdentityInfo.prototype.hostStorage = 0;

        /**
         * BizIdentityInfo actualActors.
         * @member {proto.BizIdentityInfo.ActualActorsType} actualActors
         * @memberof proto.BizIdentityInfo
         * @instance
         */
        BizIdentityInfo.prototype.actualActors = 0;

        /**
         * BizIdentityInfo privacyModeTs.
         * @member {number|Long} privacyModeTs
         * @memberof proto.BizIdentityInfo
         * @instance
         */
        BizIdentityInfo.prototype.privacyModeTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BizIdentityInfo featureControls.
         * @member {number|Long} featureControls
         * @memberof proto.BizIdentityInfo
         * @instance
         */
        BizIdentityInfo.prototype.featureControls = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new BizIdentityInfo instance using the specified properties.
         * @function create
         * @memberof proto.BizIdentityInfo
         * @static
         * @param {proto.IBizIdentityInfo=} [properties] Properties to set
         * @returns {proto.BizIdentityInfo} BizIdentityInfo instance
         */
        BizIdentityInfo.create = function create(properties) {
            return new BizIdentityInfo(properties);
        };

        /**
         * Encodes the specified BizIdentityInfo message. Does not implicitly {@link proto.BizIdentityInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.BizIdentityInfo
         * @static
         * @param {proto.IBizIdentityInfo} message BizIdentityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BizIdentityInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vlevel != null && Object.hasOwnProperty.call(message, "vlevel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.vlevel);
            if (message.vnameCert != null && Object.hasOwnProperty.call(message, "vnameCert"))
                $root.proto.VerifiedNameCertificate.encode(message.vnameCert, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signed != null && Object.hasOwnProperty.call(message, "signed"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.signed);
            if (message.revoked != null && Object.hasOwnProperty.call(message, "revoked"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.revoked);
            if (message.hostStorage != null && Object.hasOwnProperty.call(message, "hostStorage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.hostStorage);
            if (message.actualActors != null && Object.hasOwnProperty.call(message, "actualActors"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.actualActors);
            if (message.privacyModeTs != null && Object.hasOwnProperty.call(message, "privacyModeTs"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.privacyModeTs);
            if (message.featureControls != null && Object.hasOwnProperty.call(message, "featureControls"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.featureControls);
            return writer;
        };

        /**
         * Encodes the specified BizIdentityInfo message, length delimited. Does not implicitly {@link proto.BizIdentityInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.BizIdentityInfo
         * @static
         * @param {proto.IBizIdentityInfo} message BizIdentityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BizIdentityInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BizIdentityInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.BizIdentityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.BizIdentityInfo} BizIdentityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BizIdentityInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.BizIdentityInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.vlevel = reader.int32();
                    break;
                case 2:
                    message.vnameCert = $root.proto.VerifiedNameCertificate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signed = reader.bool();
                    break;
                case 4:
                    message.revoked = reader.bool();
                    break;
                case 5:
                    message.hostStorage = reader.int32();
                    break;
                case 6:
                    message.actualActors = reader.int32();
                    break;
                case 7:
                    message.privacyModeTs = reader.uint64();
                    break;
                case 8:
                    message.featureControls = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BizIdentityInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.BizIdentityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.BizIdentityInfo} BizIdentityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BizIdentityInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BizIdentityInfo message.
         * @function verify
         * @memberof proto.BizIdentityInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BizIdentityInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vlevel != null && message.hasOwnProperty("vlevel"))
                switch (message.vlevel) {
                default:
                    return "vlevel: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.vnameCert != null && message.hasOwnProperty("vnameCert")) {
                var error = $root.proto.VerifiedNameCertificate.verify(message.vnameCert);
                if (error)
                    return "vnameCert." + error;
            }
            if (message.signed != null && message.hasOwnProperty("signed"))
                if (typeof message.signed !== "boolean")
                    return "signed: boolean expected";
            if (message.revoked != null && message.hasOwnProperty("revoked"))
                if (typeof message.revoked !== "boolean")
                    return "revoked: boolean expected";
            if (message.hostStorage != null && message.hasOwnProperty("hostStorage"))
                switch (message.hostStorage) {
                default:
                    return "hostStorage: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.actualActors != null && message.hasOwnProperty("actualActors"))
                switch (message.actualActors) {
                default:
                    return "actualActors: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.privacyModeTs != null && message.hasOwnProperty("privacyModeTs"))
                if (!$util.isInteger(message.privacyModeTs) && !(message.privacyModeTs && $util.isInteger(message.privacyModeTs.low) && $util.isInteger(message.privacyModeTs.high)))
                    return "privacyModeTs: integer|Long expected";
            if (message.featureControls != null && message.hasOwnProperty("featureControls"))
                if (!$util.isInteger(message.featureControls) && !(message.featureControls && $util.isInteger(message.featureControls.low) && $util.isInteger(message.featureControls.high)))
                    return "featureControls: integer|Long expected";
            return null;
        };

        /**
         * Creates a BizIdentityInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.BizIdentityInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.BizIdentityInfo} BizIdentityInfo
         */
        BizIdentityInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.BizIdentityInfo)
                return object;
            var message = new $root.proto.BizIdentityInfo();
            switch (object.vlevel) {
            case "UNKNOWN":
            case 0:
                message.vlevel = 0;
                break;
            case "LOW":
            case 1:
                message.vlevel = 1;
                break;
            case "HIGH":
            case 2:
                message.vlevel = 2;
                break;
            }
            if (object.vnameCert != null) {
                if (typeof object.vnameCert !== "object")
                    throw TypeError(".proto.BizIdentityInfo.vnameCert: object expected");
                message.vnameCert = $root.proto.VerifiedNameCertificate.fromObject(object.vnameCert);
            }
            if (object.signed != null)
                message.signed = Boolean(object.signed);
            if (object.revoked != null)
                message.revoked = Boolean(object.revoked);
            switch (object.hostStorage) {
            case "ON_PREMISE":
            case 0:
                message.hostStorage = 0;
                break;
            case "FACEBOOK":
            case 1:
                message.hostStorage = 1;
                break;
            }
            switch (object.actualActors) {
            case "SELF":
            case 0:
                message.actualActors = 0;
                break;
            case "BSP":
            case 1:
                message.actualActors = 1;
                break;
            }
            if (object.privacyModeTs != null)
                if ($util.Long)
                    (message.privacyModeTs = $util.Long.fromValue(object.privacyModeTs)).unsigned = true;
                else if (typeof object.privacyModeTs === "string")
                    message.privacyModeTs = parseInt(object.privacyModeTs, 10);
                else if (typeof object.privacyModeTs === "number")
                    message.privacyModeTs = object.privacyModeTs;
                else if (typeof object.privacyModeTs === "object")
                    message.privacyModeTs = new $util.LongBits(object.privacyModeTs.low >>> 0, object.privacyModeTs.high >>> 0).toNumber(true);
            if (object.featureControls != null)
                if ($util.Long)
                    (message.featureControls = $util.Long.fromValue(object.featureControls)).unsigned = true;
                else if (typeof object.featureControls === "string")
                    message.featureControls = parseInt(object.featureControls, 10);
                else if (typeof object.featureControls === "number")
                    message.featureControls = object.featureControls;
                else if (typeof object.featureControls === "object")
                    message.featureControls = new $util.LongBits(object.featureControls.low >>> 0, object.featureControls.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a BizIdentityInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.BizIdentityInfo
         * @static
         * @param {proto.BizIdentityInfo} message BizIdentityInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BizIdentityInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.vlevel = options.enums === String ? "UNKNOWN" : 0;
                object.vnameCert = null;
                object.signed = false;
                object.revoked = false;
                object.hostStorage = options.enums === String ? "ON_PREMISE" : 0;
                object.actualActors = options.enums === String ? "SELF" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.privacyModeTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.privacyModeTs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.featureControls = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.featureControls = options.longs === String ? "0" : 0;
            }
            if (message.vlevel != null && message.hasOwnProperty("vlevel"))
                object.vlevel = options.enums === String ? $root.proto.BizIdentityInfo.VerifiedLevelValue[message.vlevel] : message.vlevel;
            if (message.vnameCert != null && message.hasOwnProperty("vnameCert"))
                object.vnameCert = $root.proto.VerifiedNameCertificate.toObject(message.vnameCert, options);
            if (message.signed != null && message.hasOwnProperty("signed"))
                object.signed = message.signed;
            if (message.revoked != null && message.hasOwnProperty("revoked"))
                object.revoked = message.revoked;
            if (message.hostStorage != null && message.hasOwnProperty("hostStorage"))
                object.hostStorage = options.enums === String ? $root.proto.BizIdentityInfo.HostStorageType[message.hostStorage] : message.hostStorage;
            if (message.actualActors != null && message.hasOwnProperty("actualActors"))
                object.actualActors = options.enums === String ? $root.proto.BizIdentityInfo.ActualActorsType[message.actualActors] : message.actualActors;
            if (message.privacyModeTs != null && message.hasOwnProperty("privacyModeTs"))
                if (typeof message.privacyModeTs === "number")
                    object.privacyModeTs = options.longs === String ? String(message.privacyModeTs) : message.privacyModeTs;
                else
                    object.privacyModeTs = options.longs === String ? $util.Long.prototype.toString.call(message.privacyModeTs) : options.longs === Number ? new $util.LongBits(message.privacyModeTs.low >>> 0, message.privacyModeTs.high >>> 0).toNumber(true) : message.privacyModeTs;
            if (message.featureControls != null && message.hasOwnProperty("featureControls"))
                if (typeof message.featureControls === "number")
                    object.featureControls = options.longs === String ? String(message.featureControls) : message.featureControls;
                else
                    object.featureControls = options.longs === String ? $util.Long.prototype.toString.call(message.featureControls) : options.longs === Number ? new $util.LongBits(message.featureControls.low >>> 0, message.featureControls.high >>> 0).toNumber(true) : message.featureControls;
            return object;
        };

        /**
         * Converts this BizIdentityInfo to JSON.
         * @function toJSON
         * @memberof proto.BizIdentityInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BizIdentityInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ActualActorsType enum.
         * @name proto.BizIdentityInfo.ActualActorsType
         * @enum {number}
         * @property {number} SELF=0 SELF value
         * @property {number} BSP=1 BSP value
         */
        BizIdentityInfo.ActualActorsType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SELF"] = 0;
            values[valuesById[1] = "BSP"] = 1;
            return values;
        })();

        /**
         * HostStorageType enum.
         * @name proto.BizIdentityInfo.HostStorageType
         * @enum {number}
         * @property {number} ON_PREMISE=0 ON_PREMISE value
         * @property {number} FACEBOOK=1 FACEBOOK value
         */
        BizIdentityInfo.HostStorageType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ON_PREMISE"] = 0;
            values[valuesById[1] = "FACEBOOK"] = 1;
            return values;
        })();

        /**
         * VerifiedLevelValue enum.
         * @name proto.BizIdentityInfo.VerifiedLevelValue
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} LOW=1 LOW value
         * @property {number} HIGH=2 HIGH value
         */
        BizIdentityInfo.VerifiedLevelValue = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "LOW"] = 1;
            values[valuesById[2] = "HIGH"] = 2;
            return values;
        })();

        return BizIdentityInfo;
    })();

    proto.CertChain = (function() {

        /**
         * Properties of a CertChain.
         * @memberof proto
         * @interface ICertChain
         * @property {proto.CertChain.INoiseCertificate|null} [leaf] CertChain leaf
         * @property {proto.CertChain.INoiseCertificate|null} [intermediate] CertChain intermediate
         */

        /**
         * Constructs a new CertChain.
         * @memberof proto
         * @classdesc Represents a CertChain.
         * @implements ICertChain
         * @constructor
         * @param {proto.ICertChain=} [properties] Properties to set
         */
        function CertChain(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CertChain leaf.
         * @member {proto.CertChain.INoiseCertificate|null|undefined} leaf
         * @memberof proto.CertChain
         * @instance
         */
        CertChain.prototype.leaf = null;

        /**
         * CertChain intermediate.
         * @member {proto.CertChain.INoiseCertificate|null|undefined} intermediate
         * @memberof proto.CertChain
         * @instance
         */
        CertChain.prototype.intermediate = null;

        /**
         * Creates a new CertChain instance using the specified properties.
         * @function create
         * @memberof proto.CertChain
         * @static
         * @param {proto.ICertChain=} [properties] Properties to set
         * @returns {proto.CertChain} CertChain instance
         */
        CertChain.create = function create(properties) {
            return new CertChain(properties);
        };

        /**
         * Encodes the specified CertChain message. Does not implicitly {@link proto.CertChain.verify|verify} messages.
         * @function encode
         * @memberof proto.CertChain
         * @static
         * @param {proto.ICertChain} message CertChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertChain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.leaf != null && Object.hasOwnProperty.call(message, "leaf"))
                $root.proto.CertChain.NoiseCertificate.encode(message.leaf, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.intermediate != null && Object.hasOwnProperty.call(message, "intermediate"))
                $root.proto.CertChain.NoiseCertificate.encode(message.intermediate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CertChain message, length delimited. Does not implicitly {@link proto.CertChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.CertChain
         * @static
         * @param {proto.ICertChain} message CertChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertChain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CertChain message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CertChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.CertChain} CertChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertChain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CertChain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.leaf = $root.proto.CertChain.NoiseCertificate.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.intermediate = $root.proto.CertChain.NoiseCertificate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CertChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.CertChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.CertChain} CertChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertChain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CertChain message.
         * @function verify
         * @memberof proto.CertChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CertChain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.leaf != null && message.hasOwnProperty("leaf")) {
                var error = $root.proto.CertChain.NoiseCertificate.verify(message.leaf);
                if (error)
                    return "leaf." + error;
            }
            if (message.intermediate != null && message.hasOwnProperty("intermediate")) {
                var error = $root.proto.CertChain.NoiseCertificate.verify(message.intermediate);
                if (error)
                    return "intermediate." + error;
            }
            return null;
        };

        /**
         * Creates a CertChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.CertChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.CertChain} CertChain
         */
        CertChain.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.CertChain)
                return object;
            var message = new $root.proto.CertChain();
            if (object.leaf != null) {
                if (typeof object.leaf !== "object")
                    throw TypeError(".proto.CertChain.leaf: object expected");
                message.leaf = $root.proto.CertChain.NoiseCertificate.fromObject(object.leaf);
            }
            if (object.intermediate != null) {
                if (typeof object.intermediate !== "object")
                    throw TypeError(".proto.CertChain.intermediate: object expected");
                message.intermediate = $root.proto.CertChain.NoiseCertificate.fromObject(object.intermediate);
            }
            return message;
        };

        /**
         * Creates a plain object from a CertChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.CertChain
         * @static
         * @param {proto.CertChain} message CertChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CertChain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.leaf = null;
                object.intermediate = null;
            }
            if (message.leaf != null && message.hasOwnProperty("leaf"))
                object.leaf = $root.proto.CertChain.NoiseCertificate.toObject(message.leaf, options);
            if (message.intermediate != null && message.hasOwnProperty("intermediate"))
                object.intermediate = $root.proto.CertChain.NoiseCertificate.toObject(message.intermediate, options);
            return object;
        };

        /**
         * Converts this CertChain to JSON.
         * @function toJSON
         * @memberof proto.CertChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CertChain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CertChain.NoiseCertificate = (function() {

            /**
             * Properties of a NoiseCertificate.
             * @memberof proto.CertChain
             * @interface INoiseCertificate
             * @property {Uint8Array|null} [details] NoiseCertificate details
             * @property {Uint8Array|null} [signature] NoiseCertificate signature
             */

            /**
             * Constructs a new NoiseCertificate.
             * @memberof proto.CertChain
             * @classdesc Represents a NoiseCertificate.
             * @implements INoiseCertificate
             * @constructor
             * @param {proto.CertChain.INoiseCertificate=} [properties] Properties to set
             */
            function NoiseCertificate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NoiseCertificate details.
             * @member {Uint8Array} details
             * @memberof proto.CertChain.NoiseCertificate
             * @instance
             */
            NoiseCertificate.prototype.details = $util.newBuffer([]);

            /**
             * NoiseCertificate signature.
             * @member {Uint8Array} signature
             * @memberof proto.CertChain.NoiseCertificate
             * @instance
             */
            NoiseCertificate.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new NoiseCertificate instance using the specified properties.
             * @function create
             * @memberof proto.CertChain.NoiseCertificate
             * @static
             * @param {proto.CertChain.INoiseCertificate=} [properties] Properties to set
             * @returns {proto.CertChain.NoiseCertificate} NoiseCertificate instance
             */
            NoiseCertificate.create = function create(properties) {
                return new NoiseCertificate(properties);
            };

            /**
             * Encodes the specified NoiseCertificate message. Does not implicitly {@link proto.CertChain.NoiseCertificate.verify|verify} messages.
             * @function encode
             * @memberof proto.CertChain.NoiseCertificate
             * @static
             * @param {proto.CertChain.INoiseCertificate} message NoiseCertificate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoiseCertificate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.details);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified NoiseCertificate message, length delimited. Does not implicitly {@link proto.CertChain.NoiseCertificate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.CertChain.NoiseCertificate
             * @static
             * @param {proto.CertChain.INoiseCertificate} message NoiseCertificate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoiseCertificate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NoiseCertificate message from the specified reader or buffer.
             * @function decode
             * @memberof proto.CertChain.NoiseCertificate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.CertChain.NoiseCertificate} NoiseCertificate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoiseCertificate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CertChain.NoiseCertificate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.details = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NoiseCertificate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.CertChain.NoiseCertificate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.CertChain.NoiseCertificate} NoiseCertificate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoiseCertificate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NoiseCertificate message.
             * @function verify
             * @memberof proto.CertChain.NoiseCertificate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NoiseCertificate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.details != null && message.hasOwnProperty("details"))
                    if (!(message.details && typeof message.details.length === "number" || $util.isString(message.details)))
                        return "details: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a NoiseCertificate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.CertChain.NoiseCertificate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.CertChain.NoiseCertificate} NoiseCertificate
             */
            NoiseCertificate.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.CertChain.NoiseCertificate)
                    return object;
                var message = new $root.proto.CertChain.NoiseCertificate();
                if (object.details != null)
                    if (typeof object.details === "string")
                        $util.base64.decode(object.details, message.details = $util.newBuffer($util.base64.length(object.details)), 0);
                    else if (object.details.length)
                        message.details = object.details;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a NoiseCertificate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.CertChain.NoiseCertificate
             * @static
             * @param {proto.CertChain.NoiseCertificate} message NoiseCertificate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NoiseCertificate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.details = "";
                    else {
                        object.details = [];
                        if (options.bytes !== Array)
                            object.details = $util.newBuffer(object.details);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.details != null && message.hasOwnProperty("details"))
                    object.details = options.bytes === String ? $util.base64.encode(message.details, 0, message.details.length) : options.bytes === Array ? Array.prototype.slice.call(message.details) : message.details;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this NoiseCertificate to JSON.
             * @function toJSON
             * @memberof proto.CertChain.NoiseCertificate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NoiseCertificate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            NoiseCertificate.Details = (function() {

                /**
                 * Properties of a Details.
                 * @memberof proto.CertChain.NoiseCertificate
                 * @interface IDetails
                 * @property {number|null} [serial] Details serial
                 * @property {number|null} [issuerSerial] Details issuerSerial
                 * @property {Uint8Array|null} [key] Details key
                 * @property {number|Long|null} [notBefore] Details notBefore
                 * @property {number|Long|null} [notAfter] Details notAfter
                 */

                /**
                 * Constructs a new Details.
                 * @memberof proto.CertChain.NoiseCertificate
                 * @classdesc Represents a Details.
                 * @implements IDetails
                 * @constructor
                 * @param {proto.CertChain.NoiseCertificate.IDetails=} [properties] Properties to set
                 */
                function Details(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Details serial.
                 * @member {number} serial
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @instance
                 */
                Details.prototype.serial = 0;

                /**
                 * Details issuerSerial.
                 * @member {number} issuerSerial
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @instance
                 */
                Details.prototype.issuerSerial = 0;

                /**
                 * Details key.
                 * @member {Uint8Array} key
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @instance
                 */
                Details.prototype.key = $util.newBuffer([]);

                /**
                 * Details notBefore.
                 * @member {number|Long} notBefore
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @instance
                 */
                Details.prototype.notBefore = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Details notAfter.
                 * @member {number|Long} notAfter
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @instance
                 */
                Details.prototype.notAfter = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new Details instance using the specified properties.
                 * @function create
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @static
                 * @param {proto.CertChain.NoiseCertificate.IDetails=} [properties] Properties to set
                 * @returns {proto.CertChain.NoiseCertificate.Details} Details instance
                 */
                Details.create = function create(properties) {
                    return new Details(properties);
                };

                /**
                 * Encodes the specified Details message. Does not implicitly {@link proto.CertChain.NoiseCertificate.Details.verify|verify} messages.
                 * @function encode
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @static
                 * @param {proto.CertChain.NoiseCertificate.IDetails} message Details message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Details.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.serial != null && Object.hasOwnProperty.call(message, "serial"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.serial);
                    if (message.issuerSerial != null && Object.hasOwnProperty.call(message, "issuerSerial"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.issuerSerial);
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.key);
                    if (message.notBefore != null && Object.hasOwnProperty.call(message, "notBefore"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.notBefore);
                    if (message.notAfter != null && Object.hasOwnProperty.call(message, "notAfter"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.notAfter);
                    return writer;
                };

                /**
                 * Encodes the specified Details message, length delimited. Does not implicitly {@link proto.CertChain.NoiseCertificate.Details.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @static
                 * @param {proto.CertChain.NoiseCertificate.IDetails} message Details message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Details.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Details message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.CertChain.NoiseCertificate.Details} Details
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Details.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CertChain.NoiseCertificate.Details();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.serial = reader.uint32();
                            break;
                        case 2:
                            message.issuerSerial = reader.uint32();
                            break;
                        case 3:
                            message.key = reader.bytes();
                            break;
                        case 4:
                            message.notBefore = reader.uint64();
                            break;
                        case 5:
                            message.notAfter = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Details message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.CertChain.NoiseCertificate.Details} Details
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Details.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Details message.
                 * @function verify
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Details.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.serial != null && message.hasOwnProperty("serial"))
                        if (!$util.isInteger(message.serial))
                            return "serial: integer expected";
                    if (message.issuerSerial != null && message.hasOwnProperty("issuerSerial"))
                        if (!$util.isInteger(message.issuerSerial))
                            return "issuerSerial: integer expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    if (message.notBefore != null && message.hasOwnProperty("notBefore"))
                        if (!$util.isInteger(message.notBefore) && !(message.notBefore && $util.isInteger(message.notBefore.low) && $util.isInteger(message.notBefore.high)))
                            return "notBefore: integer|Long expected";
                    if (message.notAfter != null && message.hasOwnProperty("notAfter"))
                        if (!$util.isInteger(message.notAfter) && !(message.notAfter && $util.isInteger(message.notAfter.low) && $util.isInteger(message.notAfter.high)))
                            return "notAfter: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Details message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.CertChain.NoiseCertificate.Details} Details
                 */
                Details.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.CertChain.NoiseCertificate.Details)
                        return object;
                    var message = new $root.proto.CertChain.NoiseCertificate.Details();
                    if (object.serial != null)
                        message.serial = object.serial >>> 0;
                    if (object.issuerSerial != null)
                        message.issuerSerial = object.issuerSerial >>> 0;
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    if (object.notBefore != null)
                        if ($util.Long)
                            (message.notBefore = $util.Long.fromValue(object.notBefore)).unsigned = true;
                        else if (typeof object.notBefore === "string")
                            message.notBefore = parseInt(object.notBefore, 10);
                        else if (typeof object.notBefore === "number")
                            message.notBefore = object.notBefore;
                        else if (typeof object.notBefore === "object")
                            message.notBefore = new $util.LongBits(object.notBefore.low >>> 0, object.notBefore.high >>> 0).toNumber(true);
                    if (object.notAfter != null)
                        if ($util.Long)
                            (message.notAfter = $util.Long.fromValue(object.notAfter)).unsigned = true;
                        else if (typeof object.notAfter === "string")
                            message.notAfter = parseInt(object.notAfter, 10);
                        else if (typeof object.notAfter === "number")
                            message.notAfter = object.notAfter;
                        else if (typeof object.notAfter === "object")
                            message.notAfter = new $util.LongBits(object.notAfter.low >>> 0, object.notAfter.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a Details message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @static
                 * @param {proto.CertChain.NoiseCertificate.Details} message Details
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Details.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.serial = 0;
                        object.issuerSerial = 0;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.notBefore = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.notBefore = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.notAfter = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.notAfter = options.longs === String ? "0" : 0;
                    }
                    if (message.serial != null && message.hasOwnProperty("serial"))
                        object.serial = message.serial;
                    if (message.issuerSerial != null && message.hasOwnProperty("issuerSerial"))
                        object.issuerSerial = message.issuerSerial;
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    if (message.notBefore != null && message.hasOwnProperty("notBefore"))
                        if (typeof message.notBefore === "number")
                            object.notBefore = options.longs === String ? String(message.notBefore) : message.notBefore;
                        else
                            object.notBefore = options.longs === String ? $util.Long.prototype.toString.call(message.notBefore) : options.longs === Number ? new $util.LongBits(message.notBefore.low >>> 0, message.notBefore.high >>> 0).toNumber(true) : message.notBefore;
                    if (message.notAfter != null && message.hasOwnProperty("notAfter"))
                        if (typeof message.notAfter === "number")
                            object.notAfter = options.longs === String ? String(message.notAfter) : message.notAfter;
                        else
                            object.notAfter = options.longs === String ? $util.Long.prototype.toString.call(message.notAfter) : options.longs === Number ? new $util.LongBits(message.notAfter.low >>> 0, message.notAfter.high >>> 0).toNumber(true) : message.notAfter;
                    return object;
                };

                /**
                 * Converts this Details to JSON.
                 * @function toJSON
                 * @memberof proto.CertChain.NoiseCertificate.Details
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Details.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Details;
            })();

            return NoiseCertificate;
        })();

        return CertChain;
    })();

    proto.Chain = (function() {

        /**
         * Properties of a Chain.
         * @memberof proto
         * @interface IChain
         * @property {Uint8Array|null} [senderRatchetKey] Chain senderRatchetKey
         * @property {Uint8Array|null} [senderRatchetKeyPrivate] Chain senderRatchetKeyPrivate
         * @property {proto.IChainKey|null} [chainKey] Chain chainKey
         * @property {Array.<proto.IMessageKey>|null} [messageKeys] Chain messageKeys
         */

        /**
         * Constructs a new Chain.
         * @memberof proto
         * @classdesc Represents a Chain.
         * @implements IChain
         * @constructor
         * @param {proto.IChain=} [properties] Properties to set
         */
        function Chain(properties) {
            this.messageKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Chain senderRatchetKey.
         * @member {Uint8Array} senderRatchetKey
         * @memberof proto.Chain
         * @instance
         */
        Chain.prototype.senderRatchetKey = $util.newBuffer([]);

        /**
         * Chain senderRatchetKeyPrivate.
         * @member {Uint8Array} senderRatchetKeyPrivate
         * @memberof proto.Chain
         * @instance
         */
        Chain.prototype.senderRatchetKeyPrivate = $util.newBuffer([]);

        /**
         * Chain chainKey.
         * @member {proto.IChainKey|null|undefined} chainKey
         * @memberof proto.Chain
         * @instance
         */
        Chain.prototype.chainKey = null;

        /**
         * Chain messageKeys.
         * @member {Array.<proto.IMessageKey>} messageKeys
         * @memberof proto.Chain
         * @instance
         */
        Chain.prototype.messageKeys = $util.emptyArray;

        /**
         * Creates a new Chain instance using the specified properties.
         * @function create
         * @memberof proto.Chain
         * @static
         * @param {proto.IChain=} [properties] Properties to set
         * @returns {proto.Chain} Chain instance
         */
        Chain.create = function create(properties) {
            return new Chain(properties);
        };

        /**
         * Encodes the specified Chain message. Does not implicitly {@link proto.Chain.verify|verify} messages.
         * @function encode
         * @memberof proto.Chain
         * @static
         * @param {proto.IChain} message Chain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderRatchetKey != null && Object.hasOwnProperty.call(message, "senderRatchetKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.senderRatchetKey);
            if (message.senderRatchetKeyPrivate != null && Object.hasOwnProperty.call(message, "senderRatchetKeyPrivate"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderRatchetKeyPrivate);
            if (message.chainKey != null && Object.hasOwnProperty.call(message, "chainKey"))
                $root.proto.ChainKey.encode(message.chainKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.messageKeys != null && message.messageKeys.length)
                for (var i = 0; i < message.messageKeys.length; ++i)
                    $root.proto.MessageKey.encode(message.messageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Chain message, length delimited. Does not implicitly {@link proto.Chain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Chain
         * @static
         * @param {proto.IChain} message Chain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Chain message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Chain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Chain} Chain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Chain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.senderRatchetKey = reader.bytes();
                    break;
                case 2:
                    message.senderRatchetKeyPrivate = reader.bytes();
                    break;
                case 3:
                    message.chainKey = $root.proto.ChainKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.messageKeys && message.messageKeys.length))
                        message.messageKeys = [];
                    message.messageKeys.push($root.proto.MessageKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Chain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Chain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Chain} Chain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Chain message.
         * @function verify
         * @memberof proto.Chain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Chain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderRatchetKey != null && message.hasOwnProperty("senderRatchetKey"))
                if (!(message.senderRatchetKey && typeof message.senderRatchetKey.length === "number" || $util.isString(message.senderRatchetKey)))
                    return "senderRatchetKey: buffer expected";
            if (message.senderRatchetKeyPrivate != null && message.hasOwnProperty("senderRatchetKeyPrivate"))
                if (!(message.senderRatchetKeyPrivate && typeof message.senderRatchetKeyPrivate.length === "number" || $util.isString(message.senderRatchetKeyPrivate)))
                    return "senderRatchetKeyPrivate: buffer expected";
            if (message.chainKey != null && message.hasOwnProperty("chainKey")) {
                var error = $root.proto.ChainKey.verify(message.chainKey);
                if (error)
                    return "chainKey." + error;
            }
            if (message.messageKeys != null && message.hasOwnProperty("messageKeys")) {
                if (!Array.isArray(message.messageKeys))
                    return "messageKeys: array expected";
                for (var i = 0; i < message.messageKeys.length; ++i) {
                    var error = $root.proto.MessageKey.verify(message.messageKeys[i]);
                    if (error)
                        return "messageKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Chain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Chain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Chain} Chain
         */
        Chain.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Chain)
                return object;
            var message = new $root.proto.Chain();
            if (object.senderRatchetKey != null)
                if (typeof object.senderRatchetKey === "string")
                    $util.base64.decode(object.senderRatchetKey, message.senderRatchetKey = $util.newBuffer($util.base64.length(object.senderRatchetKey)), 0);
                else if (object.senderRatchetKey.length)
                    message.senderRatchetKey = object.senderRatchetKey;
            if (object.senderRatchetKeyPrivate != null)
                if (typeof object.senderRatchetKeyPrivate === "string")
                    $util.base64.decode(object.senderRatchetKeyPrivate, message.senderRatchetKeyPrivate = $util.newBuffer($util.base64.length(object.senderRatchetKeyPrivate)), 0);
                else if (object.senderRatchetKeyPrivate.length)
                    message.senderRatchetKeyPrivate = object.senderRatchetKeyPrivate;
            if (object.chainKey != null) {
                if (typeof object.chainKey !== "object")
                    throw TypeError(".proto.Chain.chainKey: object expected");
                message.chainKey = $root.proto.ChainKey.fromObject(object.chainKey);
            }
            if (object.messageKeys) {
                if (!Array.isArray(object.messageKeys))
                    throw TypeError(".proto.Chain.messageKeys: array expected");
                message.messageKeys = [];
                for (var i = 0; i < object.messageKeys.length; ++i) {
                    if (typeof object.messageKeys[i] !== "object")
                        throw TypeError(".proto.Chain.messageKeys: object expected");
                    message.messageKeys[i] = $root.proto.MessageKey.fromObject(object.messageKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Chain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Chain
         * @static
         * @param {proto.Chain} message Chain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Chain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.messageKeys = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.senderRatchetKey = "";
                else {
                    object.senderRatchetKey = [];
                    if (options.bytes !== Array)
                        object.senderRatchetKey = $util.newBuffer(object.senderRatchetKey);
                }
                if (options.bytes === String)
                    object.senderRatchetKeyPrivate = "";
                else {
                    object.senderRatchetKeyPrivate = [];
                    if (options.bytes !== Array)
                        object.senderRatchetKeyPrivate = $util.newBuffer(object.senderRatchetKeyPrivate);
                }
                object.chainKey = null;
            }
            if (message.senderRatchetKey != null && message.hasOwnProperty("senderRatchetKey"))
                object.senderRatchetKey = options.bytes === String ? $util.base64.encode(message.senderRatchetKey, 0, message.senderRatchetKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderRatchetKey) : message.senderRatchetKey;
            if (message.senderRatchetKeyPrivate != null && message.hasOwnProperty("senderRatchetKeyPrivate"))
                object.senderRatchetKeyPrivate = options.bytes === String ? $util.base64.encode(message.senderRatchetKeyPrivate, 0, message.senderRatchetKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderRatchetKeyPrivate) : message.senderRatchetKeyPrivate;
            if (message.chainKey != null && message.hasOwnProperty("chainKey"))
                object.chainKey = $root.proto.ChainKey.toObject(message.chainKey, options);
            if (message.messageKeys && message.messageKeys.length) {
                object.messageKeys = [];
                for (var j = 0; j < message.messageKeys.length; ++j)
                    object.messageKeys[j] = $root.proto.MessageKey.toObject(message.messageKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this Chain to JSON.
         * @function toJSON
         * @memberof proto.Chain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Chain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Chain;
    })();

    proto.ChainKey = (function() {

        /**
         * Properties of a ChainKey.
         * @memberof proto
         * @interface IChainKey
         * @property {number|null} [index] ChainKey index
         * @property {Uint8Array|null} [key] ChainKey key
         */

        /**
         * Constructs a new ChainKey.
         * @memberof proto
         * @classdesc Represents a ChainKey.
         * @implements IChainKey
         * @constructor
         * @param {proto.IChainKey=} [properties] Properties to set
         */
        function ChainKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChainKey index.
         * @member {number} index
         * @memberof proto.ChainKey
         * @instance
         */
        ChainKey.prototype.index = 0;

        /**
         * ChainKey key.
         * @member {Uint8Array} key
         * @memberof proto.ChainKey
         * @instance
         */
        ChainKey.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new ChainKey instance using the specified properties.
         * @function create
         * @memberof proto.ChainKey
         * @static
         * @param {proto.IChainKey=} [properties] Properties to set
         * @returns {proto.ChainKey} ChainKey instance
         */
        ChainKey.create = function create(properties) {
            return new ChainKey(properties);
        };

        /**
         * Encodes the specified ChainKey message. Does not implicitly {@link proto.ChainKey.verify|verify} messages.
         * @function encode
         * @memberof proto.ChainKey
         * @static
         * @param {proto.IChainKey} message ChainKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified ChainKey message, length delimited. Does not implicitly {@link proto.ChainKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ChainKey
         * @static
         * @param {proto.IChainKey} message ChainKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChainKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChainKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChainKey} ChainKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChainKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.uint32();
                    break;
                case 2:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChainKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ChainKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ChainKey} ChainKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChainKey message.
         * @function verify
         * @memberof proto.ChainKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChainKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates a ChainKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ChainKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ChainKey} ChainKey
         */
        ChainKey.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ChainKey)
                return object;
            var message = new $root.proto.ChainKey();
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from a ChainKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ChainKey
         * @static
         * @param {proto.ChainKey} message ChainKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChainKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this ChainKey to JSON.
         * @function toJSON
         * @memberof proto.ChainKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChainKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChainKey;
    })();

    proto.ClientPayload = (function() {

        /**
         * Properties of a ClientPayload.
         * @memberof proto
         * @interface IClientPayload
         * @property {number|Long|null} [username] ClientPayload username
         * @property {boolean|null} [passive] ClientPayload passive
         * @property {proto.ClientPayload.IUserAgent|null} [userAgent] ClientPayload userAgent
         * @property {proto.ClientPayload.IWebInfo|null} [webInfo] ClientPayload webInfo
         * @property {string|null} [pushName] ClientPayload pushName
         * @property {number|null} [sessionId] ClientPayload sessionId
         * @property {boolean|null} [shortConnect] ClientPayload shortConnect
         * @property {proto.ClientPayload.ConnectType|null} [connectType] ClientPayload connectType
         * @property {proto.ClientPayload.ConnectReason|null} [connectReason] ClientPayload connectReason
         * @property {Array.<number>|null} [shards] ClientPayload shards
         * @property {proto.ClientPayload.IDNSSource|null} [dnsSource] ClientPayload dnsSource
         * @property {number|null} [connectAttemptCount] ClientPayload connectAttemptCount
         * @property {number|null} [device] ClientPayload device
         * @property {proto.ClientPayload.IDevicePairingRegistrationData|null} [devicePairingData] ClientPayload devicePairingData
         * @property {proto.ClientPayload.Product|null} [product] ClientPayload product
         * @property {Uint8Array|null} [fbCat] ClientPayload fbCat
         * @property {Uint8Array|null} [fbUserAgent] ClientPayload fbUserAgent
         * @property {boolean|null} [oc] ClientPayload oc
         * @property {number|null} [lc] ClientPayload lc
         * @property {proto.ClientPayload.IOSAppExtension|null} [iosAppExtension] ClientPayload iosAppExtension
         * @property {number|Long|null} [fbAppId] ClientPayload fbAppId
         * @property {Uint8Array|null} [fbDeviceId] ClientPayload fbDeviceId
         * @property {boolean|null} [pull] ClientPayload pull
         * @property {Uint8Array|null} [paddingBytes] ClientPayload paddingBytes
         * @property {proto.ClientPayload.BizMarketSegment|null} [bizMarketSegment] ClientPayload bizMarketSegment
         * @property {number|null} [yearClass] ClientPayload yearClass
         * @property {number|null} [memClass] ClientPayload memClass
         */

        /**
         * Constructs a new ClientPayload.
         * @memberof proto
         * @classdesc Represents a ClientPayload.
         * @implements IClientPayload
         * @constructor
         * @param {proto.IClientPayload=} [properties] Properties to set
         */
        function ClientPayload(properties) {
            this.shards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPayload username.
         * @member {number|Long} username
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.username = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ClientPayload passive.
         * @member {boolean} passive
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.passive = false;

        /**
         * ClientPayload userAgent.
         * @member {proto.ClientPayload.IUserAgent|null|undefined} userAgent
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.userAgent = null;

        /**
         * ClientPayload webInfo.
         * @member {proto.ClientPayload.IWebInfo|null|undefined} webInfo
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.webInfo = null;

        /**
         * ClientPayload pushName.
         * @member {string} pushName
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.pushName = "";

        /**
         * ClientPayload sessionId.
         * @member {number} sessionId
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.sessionId = 0;

        /**
         * ClientPayload shortConnect.
         * @member {boolean} shortConnect
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.shortConnect = false;

        /**
         * ClientPayload connectType.
         * @member {proto.ClientPayload.ConnectType} connectType
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.connectType = 0;

        /**
         * ClientPayload connectReason.
         * @member {proto.ClientPayload.ConnectReason} connectReason
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.connectReason = 0;

        /**
         * ClientPayload shards.
         * @member {Array.<number>} shards
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.shards = $util.emptyArray;

        /**
         * ClientPayload dnsSource.
         * @member {proto.ClientPayload.IDNSSource|null|undefined} dnsSource
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.dnsSource = null;

        /**
         * ClientPayload connectAttemptCount.
         * @member {number} connectAttemptCount
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.connectAttemptCount = 0;

        /**
         * ClientPayload device.
         * @member {number} device
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.device = 0;

        /**
         * ClientPayload devicePairingData.
         * @member {proto.ClientPayload.IDevicePairingRegistrationData|null|undefined} devicePairingData
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.devicePairingData = null;

        /**
         * ClientPayload product.
         * @member {proto.ClientPayload.Product} product
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.product = 0;

        /**
         * ClientPayload fbCat.
         * @member {Uint8Array} fbCat
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.fbCat = $util.newBuffer([]);

        /**
         * ClientPayload fbUserAgent.
         * @member {Uint8Array} fbUserAgent
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.fbUserAgent = $util.newBuffer([]);

        /**
         * ClientPayload oc.
         * @member {boolean} oc
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.oc = false;

        /**
         * ClientPayload lc.
         * @member {number} lc
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.lc = 0;

        /**
         * ClientPayload iosAppExtension.
         * @member {proto.ClientPayload.IOSAppExtension} iosAppExtension
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.iosAppExtension = 0;

        /**
         * ClientPayload fbAppId.
         * @member {number|Long} fbAppId
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.fbAppId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ClientPayload fbDeviceId.
         * @member {Uint8Array} fbDeviceId
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.fbDeviceId = $util.newBuffer([]);

        /**
         * ClientPayload pull.
         * @member {boolean} pull
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.pull = false;

        /**
         * ClientPayload paddingBytes.
         * @member {Uint8Array} paddingBytes
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.paddingBytes = $util.newBuffer([]);

        /**
         * ClientPayload bizMarketSegment.
         * @member {proto.ClientPayload.BizMarketSegment} bizMarketSegment
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.bizMarketSegment = 0;

        /**
         * ClientPayload yearClass.
         * @member {number} yearClass
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.yearClass = 0;

        /**
         * ClientPayload memClass.
         * @member {number} memClass
         * @memberof proto.ClientPayload
         * @instance
         */
        ClientPayload.prototype.memClass = 0;

        /**
         * Creates a new ClientPayload instance using the specified properties.
         * @function create
         * @memberof proto.ClientPayload
         * @static
         * @param {proto.IClientPayload=} [properties] Properties to set
         * @returns {proto.ClientPayload} ClientPayload instance
         */
        ClientPayload.create = function create(properties) {
            return new ClientPayload(properties);
        };

        /**
         * Encodes the specified ClientPayload message. Does not implicitly {@link proto.ClientPayload.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientPayload
         * @static
         * @param {proto.IClientPayload} message ClientPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.username);
            if (message.passive != null && Object.hasOwnProperty.call(message, "passive"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.passive);
            if (message.userAgent != null && Object.hasOwnProperty.call(message, "userAgent"))
                $root.proto.ClientPayload.UserAgent.encode(message.userAgent, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.webInfo != null && Object.hasOwnProperty.call(message, "webInfo"))
                $root.proto.ClientPayload.WebInfo.encode(message.webInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.pushName != null && Object.hasOwnProperty.call(message, "pushName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.pushName);
            if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                writer.uint32(/* id 9, wireType 5 =*/77).sfixed32(message.sessionId);
            if (message.shortConnect != null && Object.hasOwnProperty.call(message, "shortConnect"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.shortConnect);
            if (message.connectType != null && Object.hasOwnProperty.call(message, "connectType"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.connectType);
            if (message.connectReason != null && Object.hasOwnProperty.call(message, "connectReason"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.connectReason);
            if (message.shards != null && message.shards.length)
                for (var i = 0; i < message.shards.length; ++i)
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.shards[i]);
            if (message.dnsSource != null && Object.hasOwnProperty.call(message, "dnsSource"))
                $root.proto.ClientPayload.DNSSource.encode(message.dnsSource, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.connectAttemptCount != null && Object.hasOwnProperty.call(message, "connectAttemptCount"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.connectAttemptCount);
            if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.device);
            if (message.devicePairingData != null && Object.hasOwnProperty.call(message, "devicePairingData"))
                $root.proto.ClientPayload.DevicePairingRegistrationData.encode(message.devicePairingData, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.product != null && Object.hasOwnProperty.call(message, "product"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.product);
            if (message.fbCat != null && Object.hasOwnProperty.call(message, "fbCat"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.fbCat);
            if (message.fbUserAgent != null && Object.hasOwnProperty.call(message, "fbUserAgent"))
                writer.uint32(/* id 22, wireType 2 =*/178).bytes(message.fbUserAgent);
            if (message.oc != null && Object.hasOwnProperty.call(message, "oc"))
                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.oc);
            if (message.lc != null && Object.hasOwnProperty.call(message, "lc"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.lc);
            if (message.iosAppExtension != null && Object.hasOwnProperty.call(message, "iosAppExtension"))
                writer.uint32(/* id 30, wireType 0 =*/240).int32(message.iosAppExtension);
            if (message.fbAppId != null && Object.hasOwnProperty.call(message, "fbAppId"))
                writer.uint32(/* id 31, wireType 0 =*/248).uint64(message.fbAppId);
            if (message.fbDeviceId != null && Object.hasOwnProperty.call(message, "fbDeviceId"))
                writer.uint32(/* id 32, wireType 2 =*/258).bytes(message.fbDeviceId);
            if (message.pull != null && Object.hasOwnProperty.call(message, "pull"))
                writer.uint32(/* id 33, wireType 0 =*/264).bool(message.pull);
            if (message.paddingBytes != null && Object.hasOwnProperty.call(message, "paddingBytes"))
                writer.uint32(/* id 34, wireType 2 =*/274).bytes(message.paddingBytes);
            if (message.bizMarketSegment != null && Object.hasOwnProperty.call(message, "bizMarketSegment"))
                writer.uint32(/* id 35, wireType 0 =*/280).int32(message.bizMarketSegment);
            if (message.yearClass != null && Object.hasOwnProperty.call(message, "yearClass"))
                writer.uint32(/* id 36, wireType 0 =*/288).int32(message.yearClass);
            if (message.memClass != null && Object.hasOwnProperty.call(message, "memClass"))
                writer.uint32(/* id 37, wireType 0 =*/296).int32(message.memClass);
            return writer;
        };

        /**
         * Encodes the specified ClientPayload message, length delimited. Does not implicitly {@link proto.ClientPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ClientPayload
         * @static
         * @param {proto.IClientPayload} message ClientPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPayload message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientPayload} ClientPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPayload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.uint64();
                    break;
                case 3:
                    message.passive = reader.bool();
                    break;
                case 5:
                    message.userAgent = $root.proto.ClientPayload.UserAgent.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.webInfo = $root.proto.ClientPayload.WebInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.pushName = reader.string();
                    break;
                case 9:
                    message.sessionId = reader.sfixed32();
                    break;
                case 10:
                    message.shortConnect = reader.bool();
                    break;
                case 12:
                    message.connectType = reader.int32();
                    break;
                case 13:
                    message.connectReason = reader.int32();
                    break;
                case 14:
                    if (!(message.shards && message.shards.length))
                        message.shards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shards.push(reader.int32());
                    } else
                        message.shards.push(reader.int32());
                    break;
                case 15:
                    message.dnsSource = $root.proto.ClientPayload.DNSSource.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.connectAttemptCount = reader.uint32();
                    break;
                case 18:
                    message.device = reader.uint32();
                    break;
                case 19:
                    message.devicePairingData = $root.proto.ClientPayload.DevicePairingRegistrationData.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.product = reader.int32();
                    break;
                case 21:
                    message.fbCat = reader.bytes();
                    break;
                case 22:
                    message.fbUserAgent = reader.bytes();
                    break;
                case 23:
                    message.oc = reader.bool();
                    break;
                case 24:
                    message.lc = reader.int32();
                    break;
                case 30:
                    message.iosAppExtension = reader.int32();
                    break;
                case 31:
                    message.fbAppId = reader.uint64();
                    break;
                case 32:
                    message.fbDeviceId = reader.bytes();
                    break;
                case 33:
                    message.pull = reader.bool();
                    break;
                case 34:
                    message.paddingBytes = reader.bytes();
                    break;
                case 35:
                    message.bizMarketSegment = reader.int32();
                    break;
                case 36:
                    message.yearClass = reader.int32();
                    break;
                case 37:
                    message.memClass = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ClientPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ClientPayload} ClientPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPayload message.
         * @function verify
         * @memberof proto.ClientPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isInteger(message.username) && !(message.username && $util.isInteger(message.username.low) && $util.isInteger(message.username.high)))
                    return "username: integer|Long expected";
            if (message.passive != null && message.hasOwnProperty("passive"))
                if (typeof message.passive !== "boolean")
                    return "passive: boolean expected";
            if (message.userAgent != null && message.hasOwnProperty("userAgent")) {
                var error = $root.proto.ClientPayload.UserAgent.verify(message.userAgent);
                if (error)
                    return "userAgent." + error;
            }
            if (message.webInfo != null && message.hasOwnProperty("webInfo")) {
                var error = $root.proto.ClientPayload.WebInfo.verify(message.webInfo);
                if (error)
                    return "webInfo." + error;
            }
            if (message.pushName != null && message.hasOwnProperty("pushName"))
                if (!$util.isString(message.pushName))
                    return "pushName: string expected";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                if (!$util.isInteger(message.sessionId))
                    return "sessionId: integer expected";
            if (message.shortConnect != null && message.hasOwnProperty("shortConnect"))
                if (typeof message.shortConnect !== "boolean")
                    return "shortConnect: boolean expected";
            if (message.connectType != null && message.hasOwnProperty("connectType"))
                switch (message.connectType) {
                default:
                    return "connectType: enum value expected";
                case 0:
                case 1:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                    break;
                }
            if (message.connectReason != null && message.hasOwnProperty("connectReason"))
                switch (message.connectReason) {
                default:
                    return "connectReason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.shards != null && message.hasOwnProperty("shards")) {
                if (!Array.isArray(message.shards))
                    return "shards: array expected";
                for (var i = 0; i < message.shards.length; ++i)
                    if (!$util.isInteger(message.shards[i]))
                        return "shards: integer[] expected";
            }
            if (message.dnsSource != null && message.hasOwnProperty("dnsSource")) {
                var error = $root.proto.ClientPayload.DNSSource.verify(message.dnsSource);
                if (error)
                    return "dnsSource." + error;
            }
            if (message.connectAttemptCount != null && message.hasOwnProperty("connectAttemptCount"))
                if (!$util.isInteger(message.connectAttemptCount))
                    return "connectAttemptCount: integer expected";
            if (message.device != null && message.hasOwnProperty("device"))
                if (!$util.isInteger(message.device))
                    return "device: integer expected";
            if (message.devicePairingData != null && message.hasOwnProperty("devicePairingData")) {
                var error = $root.proto.ClientPayload.DevicePairingRegistrationData.verify(message.devicePairingData);
                if (error)
                    return "devicePairingData." + error;
            }
            if (message.product != null && message.hasOwnProperty("product"))
                switch (message.product) {
                default:
                    return "product: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.fbCat != null && message.hasOwnProperty("fbCat"))
                if (!(message.fbCat && typeof message.fbCat.length === "number" || $util.isString(message.fbCat)))
                    return "fbCat: buffer expected";
            if (message.fbUserAgent != null && message.hasOwnProperty("fbUserAgent"))
                if (!(message.fbUserAgent && typeof message.fbUserAgent.length === "number" || $util.isString(message.fbUserAgent)))
                    return "fbUserAgent: buffer expected";
            if (message.oc != null && message.hasOwnProperty("oc"))
                if (typeof message.oc !== "boolean")
                    return "oc: boolean expected";
            if (message.lc != null && message.hasOwnProperty("lc"))
                if (!$util.isInteger(message.lc))
                    return "lc: integer expected";
            if (message.iosAppExtension != null && message.hasOwnProperty("iosAppExtension"))
                switch (message.iosAppExtension) {
                default:
                    return "iosAppExtension: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.fbAppId != null && message.hasOwnProperty("fbAppId"))
                if (!$util.isInteger(message.fbAppId) && !(message.fbAppId && $util.isInteger(message.fbAppId.low) && $util.isInteger(message.fbAppId.high)))
                    return "fbAppId: integer|Long expected";
            if (message.fbDeviceId != null && message.hasOwnProperty("fbDeviceId"))
                if (!(message.fbDeviceId && typeof message.fbDeviceId.length === "number" || $util.isString(message.fbDeviceId)))
                    return "fbDeviceId: buffer expected";
            if (message.pull != null && message.hasOwnProperty("pull"))
                if (typeof message.pull !== "boolean")
                    return "pull: boolean expected";
            if (message.paddingBytes != null && message.hasOwnProperty("paddingBytes"))
                if (!(message.paddingBytes && typeof message.paddingBytes.length === "number" || $util.isString(message.paddingBytes)))
                    return "paddingBytes: buffer expected";
            if (message.bizMarketSegment != null && message.hasOwnProperty("bizMarketSegment"))
                switch (message.bizMarketSegment) {
                default:
                    return "bizMarketSegment: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.yearClass != null && message.hasOwnProperty("yearClass"))
                if (!$util.isInteger(message.yearClass))
                    return "yearClass: integer expected";
            if (message.memClass != null && message.hasOwnProperty("memClass"))
                if (!$util.isInteger(message.memClass))
                    return "memClass: integer expected";
            return null;
        };

        /**
         * Creates a ClientPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ClientPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ClientPayload} ClientPayload
         */
        ClientPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ClientPayload)
                return object;
            var message = new $root.proto.ClientPayload();
            if (object.username != null)
                if ($util.Long)
                    (message.username = $util.Long.fromValue(object.username)).unsigned = true;
                else if (typeof object.username === "string")
                    message.username = parseInt(object.username, 10);
                else if (typeof object.username === "number")
                    message.username = object.username;
                else if (typeof object.username === "object")
                    message.username = new $util.LongBits(object.username.low >>> 0, object.username.high >>> 0).toNumber(true);
            if (object.passive != null)
                message.passive = Boolean(object.passive);
            if (object.userAgent != null) {
                if (typeof object.userAgent !== "object")
                    throw TypeError(".proto.ClientPayload.userAgent: object expected");
                message.userAgent = $root.proto.ClientPayload.UserAgent.fromObject(object.userAgent);
            }
            if (object.webInfo != null) {
                if (typeof object.webInfo !== "object")
                    throw TypeError(".proto.ClientPayload.webInfo: object expected");
                message.webInfo = $root.proto.ClientPayload.WebInfo.fromObject(object.webInfo);
            }
            if (object.pushName != null)
                message.pushName = String(object.pushName);
            if (object.sessionId != null)
                message.sessionId = object.sessionId | 0;
            if (object.shortConnect != null)
                message.shortConnect = Boolean(object.shortConnect);
            switch (object.connectType) {
            case "CELLULAR_UNKNOWN":
            case 0:
                message.connectType = 0;
                break;
            case "WIFI_UNKNOWN":
            case 1:
                message.connectType = 1;
                break;
            case "CELLULAR_EDGE":
            case 100:
                message.connectType = 100;
                break;
            case "CELLULAR_IDEN":
            case 101:
                message.connectType = 101;
                break;
            case "CELLULAR_UMTS":
            case 102:
                message.connectType = 102;
                break;
            case "CELLULAR_EVDO":
            case 103:
                message.connectType = 103;
                break;
            case "CELLULAR_GPRS":
            case 104:
                message.connectType = 104;
                break;
            case "CELLULAR_HSDPA":
            case 105:
                message.connectType = 105;
                break;
            case "CELLULAR_HSUPA":
            case 106:
                message.connectType = 106;
                break;
            case "CELLULAR_HSPA":
            case 107:
                message.connectType = 107;
                break;
            case "CELLULAR_CDMA":
            case 108:
                message.connectType = 108;
                break;
            case "CELLULAR_1XRTT":
            case 109:
                message.connectType = 109;
                break;
            case "CELLULAR_EHRPD":
            case 110:
                message.connectType = 110;
                break;
            case "CELLULAR_LTE":
            case 111:
                message.connectType = 111;
                break;
            case "CELLULAR_HSPAP":
            case 112:
                message.connectType = 112;
                break;
            }
            switch (object.connectReason) {
            case "PUSH":
            case 0:
                message.connectReason = 0;
                break;
            case "USER_ACTIVATED":
            case 1:
                message.connectReason = 1;
                break;
            case "SCHEDULED":
            case 2:
                message.connectReason = 2;
                break;
            case "ERROR_RECONNECT":
            case 3:
                message.connectReason = 3;
                break;
            case "NETWORK_SWITCH":
            case 4:
                message.connectReason = 4;
                break;
            case "PING_RECONNECT":
            case 5:
                message.connectReason = 5;
                break;
            }
            if (object.shards) {
                if (!Array.isArray(object.shards))
                    throw TypeError(".proto.ClientPayload.shards: array expected");
                message.shards = [];
                for (var i = 0; i < object.shards.length; ++i)
                    message.shards[i] = object.shards[i] | 0;
            }
            if (object.dnsSource != null) {
                if (typeof object.dnsSource !== "object")
                    throw TypeError(".proto.ClientPayload.dnsSource: object expected");
                message.dnsSource = $root.proto.ClientPayload.DNSSource.fromObject(object.dnsSource);
            }
            if (object.connectAttemptCount != null)
                message.connectAttemptCount = object.connectAttemptCount >>> 0;
            if (object.device != null)
                message.device = object.device >>> 0;
            if (object.devicePairingData != null) {
                if (typeof object.devicePairingData !== "object")
                    throw TypeError(".proto.ClientPayload.devicePairingData: object expected");
                message.devicePairingData = $root.proto.ClientPayload.DevicePairingRegistrationData.fromObject(object.devicePairingData);
            }
            switch (object.product) {
            case "WHATSAPP":
            case 0:
                message.product = 0;
                break;
            case "MESSENGER":
            case 1:
                message.product = 1;
                break;
            }
            if (object.fbCat != null)
                if (typeof object.fbCat === "string")
                    $util.base64.decode(object.fbCat, message.fbCat = $util.newBuffer($util.base64.length(object.fbCat)), 0);
                else if (object.fbCat.length)
                    message.fbCat = object.fbCat;
            if (object.fbUserAgent != null)
                if (typeof object.fbUserAgent === "string")
                    $util.base64.decode(object.fbUserAgent, message.fbUserAgent = $util.newBuffer($util.base64.length(object.fbUserAgent)), 0);
                else if (object.fbUserAgent.length)
                    message.fbUserAgent = object.fbUserAgent;
            if (object.oc != null)
                message.oc = Boolean(object.oc);
            if (object.lc != null)
                message.lc = object.lc | 0;
            switch (object.iosAppExtension) {
            case "SHARE_EXTENSION":
            case 0:
                message.iosAppExtension = 0;
                break;
            case "SERVICE_EXTENSION":
            case 1:
                message.iosAppExtension = 1;
                break;
            case "INTENTS_EXTENSION":
            case 2:
                message.iosAppExtension = 2;
                break;
            }
            if (object.fbAppId != null)
                if ($util.Long)
                    (message.fbAppId = $util.Long.fromValue(object.fbAppId)).unsigned = true;
                else if (typeof object.fbAppId === "string")
                    message.fbAppId = parseInt(object.fbAppId, 10);
                else if (typeof object.fbAppId === "number")
                    message.fbAppId = object.fbAppId;
                else if (typeof object.fbAppId === "object")
                    message.fbAppId = new $util.LongBits(object.fbAppId.low >>> 0, object.fbAppId.high >>> 0).toNumber(true);
            if (object.fbDeviceId != null)
                if (typeof object.fbDeviceId === "string")
                    $util.base64.decode(object.fbDeviceId, message.fbDeviceId = $util.newBuffer($util.base64.length(object.fbDeviceId)), 0);
                else if (object.fbDeviceId.length)
                    message.fbDeviceId = object.fbDeviceId;
            if (object.pull != null)
                message.pull = Boolean(object.pull);
            if (object.paddingBytes != null)
                if (typeof object.paddingBytes === "string")
                    $util.base64.decode(object.paddingBytes, message.paddingBytes = $util.newBuffer($util.base64.length(object.paddingBytes)), 0);
                else if (object.paddingBytes.length)
                    message.paddingBytes = object.paddingBytes;
            switch (object.bizMarketSegment) {
            case "DEFAULT":
            case 0:
                message.bizMarketSegment = 0;
                break;
            case "DEVX":
            case 1:
                message.bizMarketSegment = 1;
                break;
            case "INBOX":
            case 2:
                message.bizMarketSegment = 2;
                break;
            }
            if (object.yearClass != null)
                message.yearClass = object.yearClass | 0;
            if (object.memClass != null)
                message.memClass = object.memClass | 0;
            return message;
        };

        /**
         * Creates a plain object from a ClientPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ClientPayload
         * @static
         * @param {proto.ClientPayload} message ClientPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shards = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.username = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.username = options.longs === String ? "0" : 0;
                object.passive = false;
                object.userAgent = null;
                object.webInfo = null;
                object.pushName = "";
                object.sessionId = 0;
                object.shortConnect = false;
                object.connectType = options.enums === String ? "CELLULAR_UNKNOWN" : 0;
                object.connectReason = options.enums === String ? "PUSH" : 0;
                object.dnsSource = null;
                object.connectAttemptCount = 0;
                object.device = 0;
                object.devicePairingData = null;
                object.product = options.enums === String ? "WHATSAPP" : 0;
                if (options.bytes === String)
                    object.fbCat = "";
                else {
                    object.fbCat = [];
                    if (options.bytes !== Array)
                        object.fbCat = $util.newBuffer(object.fbCat);
                }
                if (options.bytes === String)
                    object.fbUserAgent = "";
                else {
                    object.fbUserAgent = [];
                    if (options.bytes !== Array)
                        object.fbUserAgent = $util.newBuffer(object.fbUserAgent);
                }
                object.oc = false;
                object.lc = 0;
                object.iosAppExtension = options.enums === String ? "SHARE_EXTENSION" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fbAppId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fbAppId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.fbDeviceId = "";
                else {
                    object.fbDeviceId = [];
                    if (options.bytes !== Array)
                        object.fbDeviceId = $util.newBuffer(object.fbDeviceId);
                }
                object.pull = false;
                if (options.bytes === String)
                    object.paddingBytes = "";
                else {
                    object.paddingBytes = [];
                    if (options.bytes !== Array)
                        object.paddingBytes = $util.newBuffer(object.paddingBytes);
                }
                object.bizMarketSegment = options.enums === String ? "DEFAULT" : 0;
                object.yearClass = 0;
                object.memClass = 0;
            }
            if (message.username != null && message.hasOwnProperty("username"))
                if (typeof message.username === "number")
                    object.username = options.longs === String ? String(message.username) : message.username;
                else
                    object.username = options.longs === String ? $util.Long.prototype.toString.call(message.username) : options.longs === Number ? new $util.LongBits(message.username.low >>> 0, message.username.high >>> 0).toNumber(true) : message.username;
            if (message.passive != null && message.hasOwnProperty("passive"))
                object.passive = message.passive;
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = $root.proto.ClientPayload.UserAgent.toObject(message.userAgent, options);
            if (message.webInfo != null && message.hasOwnProperty("webInfo"))
                object.webInfo = $root.proto.ClientPayload.WebInfo.toObject(message.webInfo, options);
            if (message.pushName != null && message.hasOwnProperty("pushName"))
                object.pushName = message.pushName;
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                object.sessionId = message.sessionId;
            if (message.shortConnect != null && message.hasOwnProperty("shortConnect"))
                object.shortConnect = message.shortConnect;
            if (message.connectType != null && message.hasOwnProperty("connectType"))
                object.connectType = options.enums === String ? $root.proto.ClientPayload.ConnectType[message.connectType] : message.connectType;
            if (message.connectReason != null && message.hasOwnProperty("connectReason"))
                object.connectReason = options.enums === String ? $root.proto.ClientPayload.ConnectReason[message.connectReason] : message.connectReason;
            if (message.shards && message.shards.length) {
                object.shards = [];
                for (var j = 0; j < message.shards.length; ++j)
                    object.shards[j] = message.shards[j];
            }
            if (message.dnsSource != null && message.hasOwnProperty("dnsSource"))
                object.dnsSource = $root.proto.ClientPayload.DNSSource.toObject(message.dnsSource, options);
            if (message.connectAttemptCount != null && message.hasOwnProperty("connectAttemptCount"))
                object.connectAttemptCount = message.connectAttemptCount;
            if (message.device != null && message.hasOwnProperty("device"))
                object.device = message.device;
            if (message.devicePairingData != null && message.hasOwnProperty("devicePairingData"))
                object.devicePairingData = $root.proto.ClientPayload.DevicePairingRegistrationData.toObject(message.devicePairingData, options);
            if (message.product != null && message.hasOwnProperty("product"))
                object.product = options.enums === String ? $root.proto.ClientPayload.Product[message.product] : message.product;
            if (message.fbCat != null && message.hasOwnProperty("fbCat"))
                object.fbCat = options.bytes === String ? $util.base64.encode(message.fbCat, 0, message.fbCat.length) : options.bytes === Array ? Array.prototype.slice.call(message.fbCat) : message.fbCat;
            if (message.fbUserAgent != null && message.hasOwnProperty("fbUserAgent"))
                object.fbUserAgent = options.bytes === String ? $util.base64.encode(message.fbUserAgent, 0, message.fbUserAgent.length) : options.bytes === Array ? Array.prototype.slice.call(message.fbUserAgent) : message.fbUserAgent;
            if (message.oc != null && message.hasOwnProperty("oc"))
                object.oc = message.oc;
            if (message.lc != null && message.hasOwnProperty("lc"))
                object.lc = message.lc;
            if (message.iosAppExtension != null && message.hasOwnProperty("iosAppExtension"))
                object.iosAppExtension = options.enums === String ? $root.proto.ClientPayload.IOSAppExtension[message.iosAppExtension] : message.iosAppExtension;
            if (message.fbAppId != null && message.hasOwnProperty("fbAppId"))
                if (typeof message.fbAppId === "number")
                    object.fbAppId = options.longs === String ? String(message.fbAppId) : message.fbAppId;
                else
                    object.fbAppId = options.longs === String ? $util.Long.prototype.toString.call(message.fbAppId) : options.longs === Number ? new $util.LongBits(message.fbAppId.low >>> 0, message.fbAppId.high >>> 0).toNumber(true) : message.fbAppId;
            if (message.fbDeviceId != null && message.hasOwnProperty("fbDeviceId"))
                object.fbDeviceId = options.bytes === String ? $util.base64.encode(message.fbDeviceId, 0, message.fbDeviceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.fbDeviceId) : message.fbDeviceId;
            if (message.pull != null && message.hasOwnProperty("pull"))
                object.pull = message.pull;
            if (message.paddingBytes != null && message.hasOwnProperty("paddingBytes"))
                object.paddingBytes = options.bytes === String ? $util.base64.encode(message.paddingBytes, 0, message.paddingBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.paddingBytes) : message.paddingBytes;
            if (message.bizMarketSegment != null && message.hasOwnProperty("bizMarketSegment"))
                object.bizMarketSegment = options.enums === String ? $root.proto.ClientPayload.BizMarketSegment[message.bizMarketSegment] : message.bizMarketSegment;
            if (message.yearClass != null && message.hasOwnProperty("yearClass"))
                object.yearClass = message.yearClass;
            if (message.memClass != null && message.hasOwnProperty("memClass"))
                object.memClass = message.memClass;
            return object;
        };

        /**
         * Converts this ClientPayload to JSON.
         * @function toJSON
         * @memberof proto.ClientPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * BizMarketSegment enum.
         * @name proto.ClientPayload.BizMarketSegment
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} DEVX=1 DEVX value
         * @property {number} INBOX=2 INBOX value
         */
        ClientPayload.BizMarketSegment = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "DEVX"] = 1;
            values[valuesById[2] = "INBOX"] = 2;
            return values;
        })();

        /**
         * ConnectReason enum.
         * @name proto.ClientPayload.ConnectReason
         * @enum {number}
         * @property {number} PUSH=0 PUSH value
         * @property {number} USER_ACTIVATED=1 USER_ACTIVATED value
         * @property {number} SCHEDULED=2 SCHEDULED value
         * @property {number} ERROR_RECONNECT=3 ERROR_RECONNECT value
         * @property {number} NETWORK_SWITCH=4 NETWORK_SWITCH value
         * @property {number} PING_RECONNECT=5 PING_RECONNECT value
         */
        ClientPayload.ConnectReason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PUSH"] = 0;
            values[valuesById[1] = "USER_ACTIVATED"] = 1;
            values[valuesById[2] = "SCHEDULED"] = 2;
            values[valuesById[3] = "ERROR_RECONNECT"] = 3;
            values[valuesById[4] = "NETWORK_SWITCH"] = 4;
            values[valuesById[5] = "PING_RECONNECT"] = 5;
            return values;
        })();

        /**
         * ConnectType enum.
         * @name proto.ClientPayload.ConnectType
         * @enum {number}
         * @property {number} CELLULAR_UNKNOWN=0 CELLULAR_UNKNOWN value
         * @property {number} WIFI_UNKNOWN=1 WIFI_UNKNOWN value
         * @property {number} CELLULAR_EDGE=100 CELLULAR_EDGE value
         * @property {number} CELLULAR_IDEN=101 CELLULAR_IDEN value
         * @property {number} CELLULAR_UMTS=102 CELLULAR_UMTS value
         * @property {number} CELLULAR_EVDO=103 CELLULAR_EVDO value
         * @property {number} CELLULAR_GPRS=104 CELLULAR_GPRS value
         * @property {number} CELLULAR_HSDPA=105 CELLULAR_HSDPA value
         * @property {number} CELLULAR_HSUPA=106 CELLULAR_HSUPA value
         * @property {number} CELLULAR_HSPA=107 CELLULAR_HSPA value
         * @property {number} CELLULAR_CDMA=108 CELLULAR_CDMA value
         * @property {number} CELLULAR_1XRTT=109 CELLULAR_1XRTT value
         * @property {number} CELLULAR_EHRPD=110 CELLULAR_EHRPD value
         * @property {number} CELLULAR_LTE=111 CELLULAR_LTE value
         * @property {number} CELLULAR_HSPAP=112 CELLULAR_HSPAP value
         */
        ClientPayload.ConnectType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CELLULAR_UNKNOWN"] = 0;
            values[valuesById[1] = "WIFI_UNKNOWN"] = 1;
            values[valuesById[100] = "CELLULAR_EDGE"] = 100;
            values[valuesById[101] = "CELLULAR_IDEN"] = 101;
            values[valuesById[102] = "CELLULAR_UMTS"] = 102;
            values[valuesById[103] = "CELLULAR_EVDO"] = 103;
            values[valuesById[104] = "CELLULAR_GPRS"] = 104;
            values[valuesById[105] = "CELLULAR_HSDPA"] = 105;
            values[valuesById[106] = "CELLULAR_HSUPA"] = 106;
            values[valuesById[107] = "CELLULAR_HSPA"] = 107;
            values[valuesById[108] = "CELLULAR_CDMA"] = 108;
            values[valuesById[109] = "CELLULAR_1XRTT"] = 109;
            values[valuesById[110] = "CELLULAR_EHRPD"] = 110;
            values[valuesById[111] = "CELLULAR_LTE"] = 111;
            values[valuesById[112] = "CELLULAR_HSPAP"] = 112;
            return values;
        })();

        ClientPayload.DNSSource = (function() {

            /**
             * Properties of a DNSSource.
             * @memberof proto.ClientPayload
             * @interface IDNSSource
             * @property {proto.ClientPayload.DNSSource.DNSResolutionMethod|null} [dnsMethod] DNSSource dnsMethod
             * @property {boolean|null} [appCached] DNSSource appCached
             */

            /**
             * Constructs a new DNSSource.
             * @memberof proto.ClientPayload
             * @classdesc Represents a DNSSource.
             * @implements IDNSSource
             * @constructor
             * @param {proto.ClientPayload.IDNSSource=} [properties] Properties to set
             */
            function DNSSource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DNSSource dnsMethod.
             * @member {proto.ClientPayload.DNSSource.DNSResolutionMethod} dnsMethod
             * @memberof proto.ClientPayload.DNSSource
             * @instance
             */
            DNSSource.prototype.dnsMethod = 0;

            /**
             * DNSSource appCached.
             * @member {boolean} appCached
             * @memberof proto.ClientPayload.DNSSource
             * @instance
             */
            DNSSource.prototype.appCached = false;

            /**
             * Creates a new DNSSource instance using the specified properties.
             * @function create
             * @memberof proto.ClientPayload.DNSSource
             * @static
             * @param {proto.ClientPayload.IDNSSource=} [properties] Properties to set
             * @returns {proto.ClientPayload.DNSSource} DNSSource instance
             */
            DNSSource.create = function create(properties) {
                return new DNSSource(properties);
            };

            /**
             * Encodes the specified DNSSource message. Does not implicitly {@link proto.ClientPayload.DNSSource.verify|verify} messages.
             * @function encode
             * @memberof proto.ClientPayload.DNSSource
             * @static
             * @param {proto.ClientPayload.IDNSSource} message DNSSource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DNSSource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dnsMethod != null && Object.hasOwnProperty.call(message, "dnsMethod"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.dnsMethod);
                if (message.appCached != null && Object.hasOwnProperty.call(message, "appCached"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.appCached);
                return writer;
            };

            /**
             * Encodes the specified DNSSource message, length delimited. Does not implicitly {@link proto.ClientPayload.DNSSource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.ClientPayload.DNSSource
             * @static
             * @param {proto.ClientPayload.IDNSSource} message DNSSource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DNSSource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DNSSource message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ClientPayload.DNSSource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ClientPayload.DNSSource} DNSSource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DNSSource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPayload.DNSSource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 15:
                        message.dnsMethod = reader.int32();
                        break;
                    case 16:
                        message.appCached = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DNSSource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.ClientPayload.DNSSource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.ClientPayload.DNSSource} DNSSource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DNSSource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DNSSource message.
             * @function verify
             * @memberof proto.ClientPayload.DNSSource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DNSSource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dnsMethod != null && message.hasOwnProperty("dnsMethod"))
                    switch (message.dnsMethod) {
                    default:
                        return "dnsMethod: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.appCached != null && message.hasOwnProperty("appCached"))
                    if (typeof message.appCached !== "boolean")
                        return "appCached: boolean expected";
                return null;
            };

            /**
             * Creates a DNSSource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.ClientPayload.DNSSource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.ClientPayload.DNSSource} DNSSource
             */
            DNSSource.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.ClientPayload.DNSSource)
                    return object;
                var message = new $root.proto.ClientPayload.DNSSource();
                switch (object.dnsMethod) {
                case "SYSTEM":
                case 0:
                    message.dnsMethod = 0;
                    break;
                case "GOOGLE":
                case 1:
                    message.dnsMethod = 1;
                    break;
                case "HARDCODED":
                case 2:
                    message.dnsMethod = 2;
                    break;
                case "OVERRIDE":
                case 3:
                    message.dnsMethod = 3;
                    break;
                case "FALLBACK":
                case 4:
                    message.dnsMethod = 4;
                    break;
                }
                if (object.appCached != null)
                    message.appCached = Boolean(object.appCached);
                return message;
            };

            /**
             * Creates a plain object from a DNSSource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.ClientPayload.DNSSource
             * @static
             * @param {proto.ClientPayload.DNSSource} message DNSSource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DNSSource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dnsMethod = options.enums === String ? "SYSTEM" : 0;
                    object.appCached = false;
                }
                if (message.dnsMethod != null && message.hasOwnProperty("dnsMethod"))
                    object.dnsMethod = options.enums === String ? $root.proto.ClientPayload.DNSSource.DNSResolutionMethod[message.dnsMethod] : message.dnsMethod;
                if (message.appCached != null && message.hasOwnProperty("appCached"))
                    object.appCached = message.appCached;
                return object;
            };

            /**
             * Converts this DNSSource to JSON.
             * @function toJSON
             * @memberof proto.ClientPayload.DNSSource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DNSSource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * DNSResolutionMethod enum.
             * @name proto.ClientPayload.DNSSource.DNSResolutionMethod
             * @enum {number}
             * @property {number} SYSTEM=0 SYSTEM value
             * @property {number} GOOGLE=1 GOOGLE value
             * @property {number} HARDCODED=2 HARDCODED value
             * @property {number} OVERRIDE=3 OVERRIDE value
             * @property {number} FALLBACK=4 FALLBACK value
             */
            DNSSource.DNSResolutionMethod = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SYSTEM"] = 0;
                values[valuesById[1] = "GOOGLE"] = 1;
                values[valuesById[2] = "HARDCODED"] = 2;
                values[valuesById[3] = "OVERRIDE"] = 3;
                values[valuesById[4] = "FALLBACK"] = 4;
                return values;
            })();

            return DNSSource;
        })();

        ClientPayload.DevicePairingRegistrationData = (function() {

            /**
             * Properties of a DevicePairingRegistrationData.
             * @memberof proto.ClientPayload
             * @interface IDevicePairingRegistrationData
             * @property {Uint8Array|null} [eRegid] DevicePairingRegistrationData eRegid
             * @property {Uint8Array|null} [eKeytype] DevicePairingRegistrationData eKeytype
             * @property {Uint8Array|null} [eIdent] DevicePairingRegistrationData eIdent
             * @property {Uint8Array|null} [eSkeyId] DevicePairingRegistrationData eSkeyId
             * @property {Uint8Array|null} [eSkeyVal] DevicePairingRegistrationData eSkeyVal
             * @property {Uint8Array|null} [eSkeySig] DevicePairingRegistrationData eSkeySig
             * @property {Uint8Array|null} [buildHash] DevicePairingRegistrationData buildHash
             * @property {Uint8Array|null} [deviceProps] DevicePairingRegistrationData deviceProps
             */

            /**
             * Constructs a new DevicePairingRegistrationData.
             * @memberof proto.ClientPayload
             * @classdesc Represents a DevicePairingRegistrationData.
             * @implements IDevicePairingRegistrationData
             * @constructor
             * @param {proto.ClientPayload.IDevicePairingRegistrationData=} [properties] Properties to set
             */
            function DevicePairingRegistrationData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DevicePairingRegistrationData eRegid.
             * @member {Uint8Array} eRegid
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             */
            DevicePairingRegistrationData.prototype.eRegid = $util.newBuffer([]);

            /**
             * DevicePairingRegistrationData eKeytype.
             * @member {Uint8Array} eKeytype
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             */
            DevicePairingRegistrationData.prototype.eKeytype = $util.newBuffer([]);

            /**
             * DevicePairingRegistrationData eIdent.
             * @member {Uint8Array} eIdent
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             */
            DevicePairingRegistrationData.prototype.eIdent = $util.newBuffer([]);

            /**
             * DevicePairingRegistrationData eSkeyId.
             * @member {Uint8Array} eSkeyId
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             */
            DevicePairingRegistrationData.prototype.eSkeyId = $util.newBuffer([]);

            /**
             * DevicePairingRegistrationData eSkeyVal.
             * @member {Uint8Array} eSkeyVal
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             */
            DevicePairingRegistrationData.prototype.eSkeyVal = $util.newBuffer([]);

            /**
             * DevicePairingRegistrationData eSkeySig.
             * @member {Uint8Array} eSkeySig
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             */
            DevicePairingRegistrationData.prototype.eSkeySig = $util.newBuffer([]);

            /**
             * DevicePairingRegistrationData buildHash.
             * @member {Uint8Array} buildHash
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             */
            DevicePairingRegistrationData.prototype.buildHash = $util.newBuffer([]);

            /**
             * DevicePairingRegistrationData deviceProps.
             * @member {Uint8Array} deviceProps
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             */
            DevicePairingRegistrationData.prototype.deviceProps = $util.newBuffer([]);

            /**
             * Creates a new DevicePairingRegistrationData instance using the specified properties.
             * @function create
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @static
             * @param {proto.ClientPayload.IDevicePairingRegistrationData=} [properties] Properties to set
             * @returns {proto.ClientPayload.DevicePairingRegistrationData} DevicePairingRegistrationData instance
             */
            DevicePairingRegistrationData.create = function create(properties) {
                return new DevicePairingRegistrationData(properties);
            };

            /**
             * Encodes the specified DevicePairingRegistrationData message. Does not implicitly {@link proto.ClientPayload.DevicePairingRegistrationData.verify|verify} messages.
             * @function encode
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @static
             * @param {proto.ClientPayload.IDevicePairingRegistrationData} message DevicePairingRegistrationData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DevicePairingRegistrationData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eRegid != null && Object.hasOwnProperty.call(message, "eRegid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.eRegid);
                if (message.eKeytype != null && Object.hasOwnProperty.call(message, "eKeytype"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.eKeytype);
                if (message.eIdent != null && Object.hasOwnProperty.call(message, "eIdent"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.eIdent);
                if (message.eSkeyId != null && Object.hasOwnProperty.call(message, "eSkeyId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.eSkeyId);
                if (message.eSkeyVal != null && Object.hasOwnProperty.call(message, "eSkeyVal"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.eSkeyVal);
                if (message.eSkeySig != null && Object.hasOwnProperty.call(message, "eSkeySig"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.eSkeySig);
                if (message.buildHash != null && Object.hasOwnProperty.call(message, "buildHash"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.buildHash);
                if (message.deviceProps != null && Object.hasOwnProperty.call(message, "deviceProps"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.deviceProps);
                return writer;
            };

            /**
             * Encodes the specified DevicePairingRegistrationData message, length delimited. Does not implicitly {@link proto.ClientPayload.DevicePairingRegistrationData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @static
             * @param {proto.ClientPayload.IDevicePairingRegistrationData} message DevicePairingRegistrationData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DevicePairingRegistrationData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DevicePairingRegistrationData message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ClientPayload.DevicePairingRegistrationData} DevicePairingRegistrationData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DevicePairingRegistrationData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPayload.DevicePairingRegistrationData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.eRegid = reader.bytes();
                        break;
                    case 2:
                        message.eKeytype = reader.bytes();
                        break;
                    case 3:
                        message.eIdent = reader.bytes();
                        break;
                    case 4:
                        message.eSkeyId = reader.bytes();
                        break;
                    case 5:
                        message.eSkeyVal = reader.bytes();
                        break;
                    case 6:
                        message.eSkeySig = reader.bytes();
                        break;
                    case 7:
                        message.buildHash = reader.bytes();
                        break;
                    case 8:
                        message.deviceProps = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DevicePairingRegistrationData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.ClientPayload.DevicePairingRegistrationData} DevicePairingRegistrationData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DevicePairingRegistrationData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DevicePairingRegistrationData message.
             * @function verify
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DevicePairingRegistrationData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eRegid != null && message.hasOwnProperty("eRegid"))
                    if (!(message.eRegid && typeof message.eRegid.length === "number" || $util.isString(message.eRegid)))
                        return "eRegid: buffer expected";
                if (message.eKeytype != null && message.hasOwnProperty("eKeytype"))
                    if (!(message.eKeytype && typeof message.eKeytype.length === "number" || $util.isString(message.eKeytype)))
                        return "eKeytype: buffer expected";
                if (message.eIdent != null && message.hasOwnProperty("eIdent"))
                    if (!(message.eIdent && typeof message.eIdent.length === "number" || $util.isString(message.eIdent)))
                        return "eIdent: buffer expected";
                if (message.eSkeyId != null && message.hasOwnProperty("eSkeyId"))
                    if (!(message.eSkeyId && typeof message.eSkeyId.length === "number" || $util.isString(message.eSkeyId)))
                        return "eSkeyId: buffer expected";
                if (message.eSkeyVal != null && message.hasOwnProperty("eSkeyVal"))
                    if (!(message.eSkeyVal && typeof message.eSkeyVal.length === "number" || $util.isString(message.eSkeyVal)))
                        return "eSkeyVal: buffer expected";
                if (message.eSkeySig != null && message.hasOwnProperty("eSkeySig"))
                    if (!(message.eSkeySig && typeof message.eSkeySig.length === "number" || $util.isString(message.eSkeySig)))
                        return "eSkeySig: buffer expected";
                if (message.buildHash != null && message.hasOwnProperty("buildHash"))
                    if (!(message.buildHash && typeof message.buildHash.length === "number" || $util.isString(message.buildHash)))
                        return "buildHash: buffer expected";
                if (message.deviceProps != null && message.hasOwnProperty("deviceProps"))
                    if (!(message.deviceProps && typeof message.deviceProps.length === "number" || $util.isString(message.deviceProps)))
                        return "deviceProps: buffer expected";
                return null;
            };

            /**
             * Creates a DevicePairingRegistrationData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.ClientPayload.DevicePairingRegistrationData} DevicePairingRegistrationData
             */
            DevicePairingRegistrationData.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.ClientPayload.DevicePairingRegistrationData)
                    return object;
                var message = new $root.proto.ClientPayload.DevicePairingRegistrationData();
                if (object.eRegid != null)
                    if (typeof object.eRegid === "string")
                        $util.base64.decode(object.eRegid, message.eRegid = $util.newBuffer($util.base64.length(object.eRegid)), 0);
                    else if (object.eRegid.length)
                        message.eRegid = object.eRegid;
                if (object.eKeytype != null)
                    if (typeof object.eKeytype === "string")
                        $util.base64.decode(object.eKeytype, message.eKeytype = $util.newBuffer($util.base64.length(object.eKeytype)), 0);
                    else if (object.eKeytype.length)
                        message.eKeytype = object.eKeytype;
                if (object.eIdent != null)
                    if (typeof object.eIdent === "string")
                        $util.base64.decode(object.eIdent, message.eIdent = $util.newBuffer($util.base64.length(object.eIdent)), 0);
                    else if (object.eIdent.length)
                        message.eIdent = object.eIdent;
                if (object.eSkeyId != null)
                    if (typeof object.eSkeyId === "string")
                        $util.base64.decode(object.eSkeyId, message.eSkeyId = $util.newBuffer($util.base64.length(object.eSkeyId)), 0);
                    else if (object.eSkeyId.length)
                        message.eSkeyId = object.eSkeyId;
                if (object.eSkeyVal != null)
                    if (typeof object.eSkeyVal === "string")
                        $util.base64.decode(object.eSkeyVal, message.eSkeyVal = $util.newBuffer($util.base64.length(object.eSkeyVal)), 0);
                    else if (object.eSkeyVal.length)
                        message.eSkeyVal = object.eSkeyVal;
                if (object.eSkeySig != null)
                    if (typeof object.eSkeySig === "string")
                        $util.base64.decode(object.eSkeySig, message.eSkeySig = $util.newBuffer($util.base64.length(object.eSkeySig)), 0);
                    else if (object.eSkeySig.length)
                        message.eSkeySig = object.eSkeySig;
                if (object.buildHash != null)
                    if (typeof object.buildHash === "string")
                        $util.base64.decode(object.buildHash, message.buildHash = $util.newBuffer($util.base64.length(object.buildHash)), 0);
                    else if (object.buildHash.length)
                        message.buildHash = object.buildHash;
                if (object.deviceProps != null)
                    if (typeof object.deviceProps === "string")
                        $util.base64.decode(object.deviceProps, message.deviceProps = $util.newBuffer($util.base64.length(object.deviceProps)), 0);
                    else if (object.deviceProps.length)
                        message.deviceProps = object.deviceProps;
                return message;
            };

            /**
             * Creates a plain object from a DevicePairingRegistrationData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @static
             * @param {proto.ClientPayload.DevicePairingRegistrationData} message DevicePairingRegistrationData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DevicePairingRegistrationData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.eRegid = "";
                    else {
                        object.eRegid = [];
                        if (options.bytes !== Array)
                            object.eRegid = $util.newBuffer(object.eRegid);
                    }
                    if (options.bytes === String)
                        object.eKeytype = "";
                    else {
                        object.eKeytype = [];
                        if (options.bytes !== Array)
                            object.eKeytype = $util.newBuffer(object.eKeytype);
                    }
                    if (options.bytes === String)
                        object.eIdent = "";
                    else {
                        object.eIdent = [];
                        if (options.bytes !== Array)
                            object.eIdent = $util.newBuffer(object.eIdent);
                    }
                    if (options.bytes === String)
                        object.eSkeyId = "";
                    else {
                        object.eSkeyId = [];
                        if (options.bytes !== Array)
                            object.eSkeyId = $util.newBuffer(object.eSkeyId);
                    }
                    if (options.bytes === String)
                        object.eSkeyVal = "";
                    else {
                        object.eSkeyVal = [];
                        if (options.bytes !== Array)
                            object.eSkeyVal = $util.newBuffer(object.eSkeyVal);
                    }
                    if (options.bytes === String)
                        object.eSkeySig = "";
                    else {
                        object.eSkeySig = [];
                        if (options.bytes !== Array)
                            object.eSkeySig = $util.newBuffer(object.eSkeySig);
                    }
                    if (options.bytes === String)
                        object.buildHash = "";
                    else {
                        object.buildHash = [];
                        if (options.bytes !== Array)
                            object.buildHash = $util.newBuffer(object.buildHash);
                    }
                    if (options.bytes === String)
                        object.deviceProps = "";
                    else {
                        object.deviceProps = [];
                        if (options.bytes !== Array)
                            object.deviceProps = $util.newBuffer(object.deviceProps);
                    }
                }
                if (message.eRegid != null && message.hasOwnProperty("eRegid"))
                    object.eRegid = options.bytes === String ? $util.base64.encode(message.eRegid, 0, message.eRegid.length) : options.bytes === Array ? Array.prototype.slice.call(message.eRegid) : message.eRegid;
                if (message.eKeytype != null && message.hasOwnProperty("eKeytype"))
                    object.eKeytype = options.bytes === String ? $util.base64.encode(message.eKeytype, 0, message.eKeytype.length) : options.bytes === Array ? Array.prototype.slice.call(message.eKeytype) : message.eKeytype;
                if (message.eIdent != null && message.hasOwnProperty("eIdent"))
                    object.eIdent = options.bytes === String ? $util.base64.encode(message.eIdent, 0, message.eIdent.length) : options.bytes === Array ? Array.prototype.slice.call(message.eIdent) : message.eIdent;
                if (message.eSkeyId != null && message.hasOwnProperty("eSkeyId"))
                    object.eSkeyId = options.bytes === String ? $util.base64.encode(message.eSkeyId, 0, message.eSkeyId.length) : options.bytes === Array ? Array.prototype.slice.call(message.eSkeyId) : message.eSkeyId;
                if (message.eSkeyVal != null && message.hasOwnProperty("eSkeyVal"))
                    object.eSkeyVal = options.bytes === String ? $util.base64.encode(message.eSkeyVal, 0, message.eSkeyVal.length) : options.bytes === Array ? Array.prototype.slice.call(message.eSkeyVal) : message.eSkeyVal;
                if (message.eSkeySig != null && message.hasOwnProperty("eSkeySig"))
                    object.eSkeySig = options.bytes === String ? $util.base64.encode(message.eSkeySig, 0, message.eSkeySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.eSkeySig) : message.eSkeySig;
                if (message.buildHash != null && message.hasOwnProperty("buildHash"))
                    object.buildHash = options.bytes === String ? $util.base64.encode(message.buildHash, 0, message.buildHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.buildHash) : message.buildHash;
                if (message.deviceProps != null && message.hasOwnProperty("deviceProps"))
                    object.deviceProps = options.bytes === String ? $util.base64.encode(message.deviceProps, 0, message.deviceProps.length) : options.bytes === Array ? Array.prototype.slice.call(message.deviceProps) : message.deviceProps;
                return object;
            };

            /**
             * Converts this DevicePairingRegistrationData to JSON.
             * @function toJSON
             * @memberof proto.ClientPayload.DevicePairingRegistrationData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DevicePairingRegistrationData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DevicePairingRegistrationData;
        })();

        /**
         * IOSAppExtension enum.
         * @name proto.ClientPayload.IOSAppExtension
         * @enum {number}
         * @property {number} SHARE_EXTENSION=0 SHARE_EXTENSION value
         * @property {number} SERVICE_EXTENSION=1 SERVICE_EXTENSION value
         * @property {number} INTENTS_EXTENSION=2 INTENTS_EXTENSION value
         */
        ClientPayload.IOSAppExtension = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SHARE_EXTENSION"] = 0;
            values[valuesById[1] = "SERVICE_EXTENSION"] = 1;
            values[valuesById[2] = "INTENTS_EXTENSION"] = 2;
            return values;
        })();

        /**
         * Product enum.
         * @name proto.ClientPayload.Product
         * @enum {number}
         * @property {number} WHATSAPP=0 WHATSAPP value
         * @property {number} MESSENGER=1 MESSENGER value
         */
        ClientPayload.Product = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "WHATSAPP"] = 0;
            values[valuesById[1] = "MESSENGER"] = 1;
            return values;
        })();

        ClientPayload.UserAgent = (function() {

            /**
             * Properties of a UserAgent.
             * @memberof proto.ClientPayload
             * @interface IUserAgent
             * @property {proto.ClientPayload.UserAgent.Platform|null} [platform] UserAgent platform
             * @property {proto.ClientPayload.UserAgent.IAppVersion|null} [appVersion] UserAgent appVersion
             * @property {string|null} [mcc] UserAgent mcc
             * @property {string|null} [mnc] UserAgent mnc
             * @property {string|null} [osVersion] UserAgent osVersion
             * @property {string|null} [manufacturer] UserAgent manufacturer
             * @property {string|null} [device] UserAgent device
             * @property {string|null} [osBuildNumber] UserAgent osBuildNumber
             * @property {string|null} [phoneId] UserAgent phoneId
             * @property {proto.ClientPayload.UserAgent.ReleaseChannel|null} [releaseChannel] UserAgent releaseChannel
             * @property {string|null} [localeLanguageIso6391] UserAgent localeLanguageIso6391
             * @property {string|null} [localeCountryIso31661Alpha2] UserAgent localeCountryIso31661Alpha2
             * @property {string|null} [deviceBoard] UserAgent deviceBoard
             */

            /**
             * Constructs a new UserAgent.
             * @memberof proto.ClientPayload
             * @classdesc Represents a UserAgent.
             * @implements IUserAgent
             * @constructor
             * @param {proto.ClientPayload.IUserAgent=} [properties] Properties to set
             */
            function UserAgent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserAgent platform.
             * @member {proto.ClientPayload.UserAgent.Platform} platform
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.platform = 0;

            /**
             * UserAgent appVersion.
             * @member {proto.ClientPayload.UserAgent.IAppVersion|null|undefined} appVersion
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.appVersion = null;

            /**
             * UserAgent mcc.
             * @member {string} mcc
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.mcc = "";

            /**
             * UserAgent mnc.
             * @member {string} mnc
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.mnc = "";

            /**
             * UserAgent osVersion.
             * @member {string} osVersion
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.osVersion = "";

            /**
             * UserAgent manufacturer.
             * @member {string} manufacturer
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.manufacturer = "";

            /**
             * UserAgent device.
             * @member {string} device
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.device = "";

            /**
             * UserAgent osBuildNumber.
             * @member {string} osBuildNumber
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.osBuildNumber = "";

            /**
             * UserAgent phoneId.
             * @member {string} phoneId
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.phoneId = "";

            /**
             * UserAgent releaseChannel.
             * @member {proto.ClientPayload.UserAgent.ReleaseChannel} releaseChannel
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.releaseChannel = 0;

            /**
             * UserAgent localeLanguageIso6391.
             * @member {string} localeLanguageIso6391
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.localeLanguageIso6391 = "";

            /**
             * UserAgent localeCountryIso31661Alpha2.
             * @member {string} localeCountryIso31661Alpha2
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.localeCountryIso31661Alpha2 = "";

            /**
             * UserAgent deviceBoard.
             * @member {string} deviceBoard
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             */
            UserAgent.prototype.deviceBoard = "";

            /**
             * Creates a new UserAgent instance using the specified properties.
             * @function create
             * @memberof proto.ClientPayload.UserAgent
             * @static
             * @param {proto.ClientPayload.IUserAgent=} [properties] Properties to set
             * @returns {proto.ClientPayload.UserAgent} UserAgent instance
             */
            UserAgent.create = function create(properties) {
                return new UserAgent(properties);
            };

            /**
             * Encodes the specified UserAgent message. Does not implicitly {@link proto.ClientPayload.UserAgent.verify|verify} messages.
             * @function encode
             * @memberof proto.ClientPayload.UserAgent
             * @static
             * @param {proto.ClientPayload.IUserAgent} message UserAgent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserAgent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platform);
                if (message.appVersion != null && Object.hasOwnProperty.call(message, "appVersion"))
                    $root.proto.ClientPayload.UserAgent.AppVersion.encode(message.appVersion, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.mcc != null && Object.hasOwnProperty.call(message, "mcc"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.mcc);
                if (message.mnc != null && Object.hasOwnProperty.call(message, "mnc"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.mnc);
                if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.osVersion);
                if (message.manufacturer != null && Object.hasOwnProperty.call(message, "manufacturer"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.manufacturer);
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.device);
                if (message.osBuildNumber != null && Object.hasOwnProperty.call(message, "osBuildNumber"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.osBuildNumber);
                if (message.phoneId != null && Object.hasOwnProperty.call(message, "phoneId"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.phoneId);
                if (message.releaseChannel != null && Object.hasOwnProperty.call(message, "releaseChannel"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.releaseChannel);
                if (message.localeLanguageIso6391 != null && Object.hasOwnProperty.call(message, "localeLanguageIso6391"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.localeLanguageIso6391);
                if (message.localeCountryIso31661Alpha2 != null && Object.hasOwnProperty.call(message, "localeCountryIso31661Alpha2"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.localeCountryIso31661Alpha2);
                if (message.deviceBoard != null && Object.hasOwnProperty.call(message, "deviceBoard"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.deviceBoard);
                return writer;
            };

            /**
             * Encodes the specified UserAgent message, length delimited. Does not implicitly {@link proto.ClientPayload.UserAgent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.ClientPayload.UserAgent
             * @static
             * @param {proto.ClientPayload.IUserAgent} message UserAgent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserAgent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserAgent message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ClientPayload.UserAgent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ClientPayload.UserAgent} UserAgent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserAgent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPayload.UserAgent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.platform = reader.int32();
                        break;
                    case 2:
                        message.appVersion = $root.proto.ClientPayload.UserAgent.AppVersion.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.mcc = reader.string();
                        break;
                    case 4:
                        message.mnc = reader.string();
                        break;
                    case 5:
                        message.osVersion = reader.string();
                        break;
                    case 6:
                        message.manufacturer = reader.string();
                        break;
                    case 7:
                        message.device = reader.string();
                        break;
                    case 8:
                        message.osBuildNumber = reader.string();
                        break;
                    case 9:
                        message.phoneId = reader.string();
                        break;
                    case 10:
                        message.releaseChannel = reader.int32();
                        break;
                    case 11:
                        message.localeLanguageIso6391 = reader.string();
                        break;
                    case 12:
                        message.localeCountryIso31661Alpha2 = reader.string();
                        break;
                    case 13:
                        message.deviceBoard = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserAgent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.ClientPayload.UserAgent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.ClientPayload.UserAgent} UserAgent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserAgent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserAgent message.
             * @function verify
             * @memberof proto.ClientPayload.UserAgent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserAgent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.platform != null && message.hasOwnProperty("platform"))
                    switch (message.platform) {
                    default:
                        return "platform: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                        break;
                    }
                if (message.appVersion != null && message.hasOwnProperty("appVersion")) {
                    var error = $root.proto.ClientPayload.UserAgent.AppVersion.verify(message.appVersion);
                    if (error)
                        return "appVersion." + error;
                }
                if (message.mcc != null && message.hasOwnProperty("mcc"))
                    if (!$util.isString(message.mcc))
                        return "mcc: string expected";
                if (message.mnc != null && message.hasOwnProperty("mnc"))
                    if (!$util.isString(message.mnc))
                        return "mnc: string expected";
                if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                    if (!$util.isString(message.osVersion))
                        return "osVersion: string expected";
                if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
                    if (!$util.isString(message.manufacturer))
                        return "manufacturer: string expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.osBuildNumber != null && message.hasOwnProperty("osBuildNumber"))
                    if (!$util.isString(message.osBuildNumber))
                        return "osBuildNumber: string expected";
                if (message.phoneId != null && message.hasOwnProperty("phoneId"))
                    if (!$util.isString(message.phoneId))
                        return "phoneId: string expected";
                if (message.releaseChannel != null && message.hasOwnProperty("releaseChannel"))
                    switch (message.releaseChannel) {
                    default:
                        return "releaseChannel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.localeLanguageIso6391 != null && message.hasOwnProperty("localeLanguageIso6391"))
                    if (!$util.isString(message.localeLanguageIso6391))
                        return "localeLanguageIso6391: string expected";
                if (message.localeCountryIso31661Alpha2 != null && message.hasOwnProperty("localeCountryIso31661Alpha2"))
                    if (!$util.isString(message.localeCountryIso31661Alpha2))
                        return "localeCountryIso31661Alpha2: string expected";
                if (message.deviceBoard != null && message.hasOwnProperty("deviceBoard"))
                    if (!$util.isString(message.deviceBoard))
                        return "deviceBoard: string expected";
                return null;
            };

            /**
             * Creates a UserAgent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.ClientPayload.UserAgent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.ClientPayload.UserAgent} UserAgent
             */
            UserAgent.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.ClientPayload.UserAgent)
                    return object;
                var message = new $root.proto.ClientPayload.UserAgent();
                switch (object.platform) {
                case "ANDROID":
                case 0:
                    message.platform = 0;
                    break;
                case "IOS":
                case 1:
                    message.platform = 1;
                    break;
                case "WINDOWS_PHONE":
                case 2:
                    message.platform = 2;
                    break;
                case "BLACKBERRY":
                case 3:
                    message.platform = 3;
                    break;
                case "BLACKBERRYX":
                case 4:
                    message.platform = 4;
                    break;
                case "S40":
                case 5:
                    message.platform = 5;
                    break;
                case "S60":
                case 6:
                    message.platform = 6;
                    break;
                case "PYTHON_CLIENT":
                case 7:
                    message.platform = 7;
                    break;
                case "TIZEN":
                case 8:
                    message.platform = 8;
                    break;
                case "ENTERPRISE":
                case 9:
                    message.platform = 9;
                    break;
                case "SMB_ANDROID":
                case 10:
                    message.platform = 10;
                    break;
                case "KAIOS":
                case 11:
                    message.platform = 11;
                    break;
                case "SMB_IOS":
                case 12:
                    message.platform = 12;
                    break;
                case "WINDOWS":
                case 13:
                    message.platform = 13;
                    break;
                case "WEB":
                case 14:
                    message.platform = 14;
                    break;
                case "PORTAL":
                case 15:
                    message.platform = 15;
                    break;
                case "GREEN_ANDROID":
                case 16:
                    message.platform = 16;
                    break;
                case "GREEN_IPHONE":
                case 17:
                    message.platform = 17;
                    break;
                case "BLUE_ANDROID":
                case 18:
                    message.platform = 18;
                    break;
                case "BLUE_IPHONE":
                case 19:
                    message.platform = 19;
                    break;
                case "FBLITE_ANDROID":
                case 20:
                    message.platform = 20;
                    break;
                case "MLITE_ANDROID":
                case 21:
                    message.platform = 21;
                    break;
                case "IGLITE_ANDROID":
                case 22:
                    message.platform = 22;
                    break;
                case "PAGE":
                case 23:
                    message.platform = 23;
                    break;
                case "MACOS":
                case 24:
                    message.platform = 24;
                    break;
                case "OCULUS_MSG":
                case 25:
                    message.platform = 25;
                    break;
                case "OCULUS_CALL":
                case 26:
                    message.platform = 26;
                    break;
                case "MILAN":
                case 27:
                    message.platform = 27;
                    break;
                case "CAPI":
                case 28:
                    message.platform = 28;
                    break;
                case "WEAROS":
                case 29:
                    message.platform = 29;
                    break;
                case "ARDEVICE":
                case 30:
                    message.platform = 30;
                    break;
                case "VRDEVICE":
                case 31:
                    message.platform = 31;
                    break;
                }
                if (object.appVersion != null) {
                    if (typeof object.appVersion !== "object")
                        throw TypeError(".proto.ClientPayload.UserAgent.appVersion: object expected");
                    message.appVersion = $root.proto.ClientPayload.UserAgent.AppVersion.fromObject(object.appVersion);
                }
                if (object.mcc != null)
                    message.mcc = String(object.mcc);
                if (object.mnc != null)
                    message.mnc = String(object.mnc);
                if (object.osVersion != null)
                    message.osVersion = String(object.osVersion);
                if (object.manufacturer != null)
                    message.manufacturer = String(object.manufacturer);
                if (object.device != null)
                    message.device = String(object.device);
                if (object.osBuildNumber != null)
                    message.osBuildNumber = String(object.osBuildNumber);
                if (object.phoneId != null)
                    message.phoneId = String(object.phoneId);
                switch (object.releaseChannel) {
                case "RELEASE":
                case 0:
                    message.releaseChannel = 0;
                    break;
                case "BETA":
                case 1:
                    message.releaseChannel = 1;
                    break;
                case "ALPHA":
                case 2:
                    message.releaseChannel = 2;
                    break;
                case "DEBUG":
                case 3:
                    message.releaseChannel = 3;
                    break;
                }
                if (object.localeLanguageIso6391 != null)
                    message.localeLanguageIso6391 = String(object.localeLanguageIso6391);
                if (object.localeCountryIso31661Alpha2 != null)
                    message.localeCountryIso31661Alpha2 = String(object.localeCountryIso31661Alpha2);
                if (object.deviceBoard != null)
                    message.deviceBoard = String(object.deviceBoard);
                return message;
            };

            /**
             * Creates a plain object from a UserAgent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.ClientPayload.UserAgent
             * @static
             * @param {proto.ClientPayload.UserAgent} message UserAgent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserAgent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.platform = options.enums === String ? "ANDROID" : 0;
                    object.appVersion = null;
                    object.mcc = "";
                    object.mnc = "";
                    object.osVersion = "";
                    object.manufacturer = "";
                    object.device = "";
                    object.osBuildNumber = "";
                    object.phoneId = "";
                    object.releaseChannel = options.enums === String ? "RELEASE" : 0;
                    object.localeLanguageIso6391 = "";
                    object.localeCountryIso31661Alpha2 = "";
                    object.deviceBoard = "";
                }
                if (message.platform != null && message.hasOwnProperty("platform"))
                    object.platform = options.enums === String ? $root.proto.ClientPayload.UserAgent.Platform[message.platform] : message.platform;
                if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                    object.appVersion = $root.proto.ClientPayload.UserAgent.AppVersion.toObject(message.appVersion, options);
                if (message.mcc != null && message.hasOwnProperty("mcc"))
                    object.mcc = message.mcc;
                if (message.mnc != null && message.hasOwnProperty("mnc"))
                    object.mnc = message.mnc;
                if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                    object.osVersion = message.osVersion;
                if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
                    object.manufacturer = message.manufacturer;
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.osBuildNumber != null && message.hasOwnProperty("osBuildNumber"))
                    object.osBuildNumber = message.osBuildNumber;
                if (message.phoneId != null && message.hasOwnProperty("phoneId"))
                    object.phoneId = message.phoneId;
                if (message.releaseChannel != null && message.hasOwnProperty("releaseChannel"))
                    object.releaseChannel = options.enums === String ? $root.proto.ClientPayload.UserAgent.ReleaseChannel[message.releaseChannel] : message.releaseChannel;
                if (message.localeLanguageIso6391 != null && message.hasOwnProperty("localeLanguageIso6391"))
                    object.localeLanguageIso6391 = message.localeLanguageIso6391;
                if (message.localeCountryIso31661Alpha2 != null && message.hasOwnProperty("localeCountryIso31661Alpha2"))
                    object.localeCountryIso31661Alpha2 = message.localeCountryIso31661Alpha2;
                if (message.deviceBoard != null && message.hasOwnProperty("deviceBoard"))
                    object.deviceBoard = message.deviceBoard;
                return object;
            };

            /**
             * Converts this UserAgent to JSON.
             * @function toJSON
             * @memberof proto.ClientPayload.UserAgent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserAgent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UserAgent.AppVersion = (function() {

                /**
                 * Properties of an AppVersion.
                 * @memberof proto.ClientPayload.UserAgent
                 * @interface IAppVersion
                 * @property {number|null} [primary] AppVersion primary
                 * @property {number|null} [secondary] AppVersion secondary
                 * @property {number|null} [tertiary] AppVersion tertiary
                 * @property {number|null} [quaternary] AppVersion quaternary
                 * @property {number|null} [quinary] AppVersion quinary
                 */

                /**
                 * Constructs a new AppVersion.
                 * @memberof proto.ClientPayload.UserAgent
                 * @classdesc Represents an AppVersion.
                 * @implements IAppVersion
                 * @constructor
                 * @param {proto.ClientPayload.UserAgent.IAppVersion=} [properties] Properties to set
                 */
                function AppVersion(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AppVersion primary.
                 * @member {number} primary
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @instance
                 */
                AppVersion.prototype.primary = 0;

                /**
                 * AppVersion secondary.
                 * @member {number} secondary
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @instance
                 */
                AppVersion.prototype.secondary = 0;

                /**
                 * AppVersion tertiary.
                 * @member {number} tertiary
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @instance
                 */
                AppVersion.prototype.tertiary = 0;

                /**
                 * AppVersion quaternary.
                 * @member {number} quaternary
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @instance
                 */
                AppVersion.prototype.quaternary = 0;

                /**
                 * AppVersion quinary.
                 * @member {number} quinary
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @instance
                 */
                AppVersion.prototype.quinary = 0;

                /**
                 * Creates a new AppVersion instance using the specified properties.
                 * @function create
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @static
                 * @param {proto.ClientPayload.UserAgent.IAppVersion=} [properties] Properties to set
                 * @returns {proto.ClientPayload.UserAgent.AppVersion} AppVersion instance
                 */
                AppVersion.create = function create(properties) {
                    return new AppVersion(properties);
                };

                /**
                 * Encodes the specified AppVersion message. Does not implicitly {@link proto.ClientPayload.UserAgent.AppVersion.verify|verify} messages.
                 * @function encode
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @static
                 * @param {proto.ClientPayload.UserAgent.IAppVersion} message AppVersion message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AppVersion.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.primary);
                    if (message.secondary != null && Object.hasOwnProperty.call(message, "secondary"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.secondary);
                    if (message.tertiary != null && Object.hasOwnProperty.call(message, "tertiary"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tertiary);
                    if (message.quaternary != null && Object.hasOwnProperty.call(message, "quaternary"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.quaternary);
                    if (message.quinary != null && Object.hasOwnProperty.call(message, "quinary"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.quinary);
                    return writer;
                };

                /**
                 * Encodes the specified AppVersion message, length delimited. Does not implicitly {@link proto.ClientPayload.UserAgent.AppVersion.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @static
                 * @param {proto.ClientPayload.UserAgent.IAppVersion} message AppVersion message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AppVersion.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AppVersion message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.ClientPayload.UserAgent.AppVersion} AppVersion
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AppVersion.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPayload.UserAgent.AppVersion();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.primary = reader.uint32();
                            break;
                        case 2:
                            message.secondary = reader.uint32();
                            break;
                        case 3:
                            message.tertiary = reader.uint32();
                            break;
                        case 4:
                            message.quaternary = reader.uint32();
                            break;
                        case 5:
                            message.quinary = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AppVersion message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.ClientPayload.UserAgent.AppVersion} AppVersion
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AppVersion.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AppVersion message.
                 * @function verify
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AppVersion.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.primary != null && message.hasOwnProperty("primary"))
                        if (!$util.isInteger(message.primary))
                            return "primary: integer expected";
                    if (message.secondary != null && message.hasOwnProperty("secondary"))
                        if (!$util.isInteger(message.secondary))
                            return "secondary: integer expected";
                    if (message.tertiary != null && message.hasOwnProperty("tertiary"))
                        if (!$util.isInteger(message.tertiary))
                            return "tertiary: integer expected";
                    if (message.quaternary != null && message.hasOwnProperty("quaternary"))
                        if (!$util.isInteger(message.quaternary))
                            return "quaternary: integer expected";
                    if (message.quinary != null && message.hasOwnProperty("quinary"))
                        if (!$util.isInteger(message.quinary))
                            return "quinary: integer expected";
                    return null;
                };

                /**
                 * Creates an AppVersion message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.ClientPayload.UserAgent.AppVersion} AppVersion
                 */
                AppVersion.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.ClientPayload.UserAgent.AppVersion)
                        return object;
                    var message = new $root.proto.ClientPayload.UserAgent.AppVersion();
                    if (object.primary != null)
                        message.primary = object.primary >>> 0;
                    if (object.secondary != null)
                        message.secondary = object.secondary >>> 0;
                    if (object.tertiary != null)
                        message.tertiary = object.tertiary >>> 0;
                    if (object.quaternary != null)
                        message.quaternary = object.quaternary >>> 0;
                    if (object.quinary != null)
                        message.quinary = object.quinary >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an AppVersion message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @static
                 * @param {proto.ClientPayload.UserAgent.AppVersion} message AppVersion
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AppVersion.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.primary = 0;
                        object.secondary = 0;
                        object.tertiary = 0;
                        object.quaternary = 0;
                        object.quinary = 0;
                    }
                    if (message.primary != null && message.hasOwnProperty("primary"))
                        object.primary = message.primary;
                    if (message.secondary != null && message.hasOwnProperty("secondary"))
                        object.secondary = message.secondary;
                    if (message.tertiary != null && message.hasOwnProperty("tertiary"))
                        object.tertiary = message.tertiary;
                    if (message.quaternary != null && message.hasOwnProperty("quaternary"))
                        object.quaternary = message.quaternary;
                    if (message.quinary != null && message.hasOwnProperty("quinary"))
                        object.quinary = message.quinary;
                    return object;
                };

                /**
                 * Converts this AppVersion to JSON.
                 * @function toJSON
                 * @memberof proto.ClientPayload.UserAgent.AppVersion
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AppVersion.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AppVersion;
            })();

            /**
             * Platform enum.
             * @name proto.ClientPayload.UserAgent.Platform
             * @enum {number}
             * @property {number} ANDROID=0 ANDROID value
             * @property {number} IOS=1 IOS value
             * @property {number} WINDOWS_PHONE=2 WINDOWS_PHONE value
             * @property {number} BLACKBERRY=3 BLACKBERRY value
             * @property {number} BLACKBERRYX=4 BLACKBERRYX value
             * @property {number} S40=5 S40 value
             * @property {number} S60=6 S60 value
             * @property {number} PYTHON_CLIENT=7 PYTHON_CLIENT value
             * @property {number} TIZEN=8 TIZEN value
             * @property {number} ENTERPRISE=9 ENTERPRISE value
             * @property {number} SMB_ANDROID=10 SMB_ANDROID value
             * @property {number} KAIOS=11 KAIOS value
             * @property {number} SMB_IOS=12 SMB_IOS value
             * @property {number} WINDOWS=13 WINDOWS value
             * @property {number} WEB=14 WEB value
             * @property {number} PORTAL=15 PORTAL value
             * @property {number} GREEN_ANDROID=16 GREEN_ANDROID value
             * @property {number} GREEN_IPHONE=17 GREEN_IPHONE value
             * @property {number} BLUE_ANDROID=18 BLUE_ANDROID value
             * @property {number} BLUE_IPHONE=19 BLUE_IPHONE value
             * @property {number} FBLITE_ANDROID=20 FBLITE_ANDROID value
             * @property {number} MLITE_ANDROID=21 MLITE_ANDROID value
             * @property {number} IGLITE_ANDROID=22 IGLITE_ANDROID value
             * @property {number} PAGE=23 PAGE value
             * @property {number} MACOS=24 MACOS value
             * @property {number} OCULUS_MSG=25 OCULUS_MSG value
             * @property {number} OCULUS_CALL=26 OCULUS_CALL value
             * @property {number} MILAN=27 MILAN value
             * @property {number} CAPI=28 CAPI value
             * @property {number} WEAROS=29 WEAROS value
             * @property {number} ARDEVICE=30 ARDEVICE value
             * @property {number} VRDEVICE=31 VRDEVICE value
             */
            UserAgent.Platform = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ANDROID"] = 0;
                values[valuesById[1] = "IOS"] = 1;
                values[valuesById[2] = "WINDOWS_PHONE"] = 2;
                values[valuesById[3] = "BLACKBERRY"] = 3;
                values[valuesById[4] = "BLACKBERRYX"] = 4;
                values[valuesById[5] = "S40"] = 5;
                values[valuesById[6] = "S60"] = 6;
                values[valuesById[7] = "PYTHON_CLIENT"] = 7;
                values[valuesById[8] = "TIZEN"] = 8;
                values[valuesById[9] = "ENTERPRISE"] = 9;
                values[valuesById[10] = "SMB_ANDROID"] = 10;
                values[valuesById[11] = "KAIOS"] = 11;
                values[valuesById[12] = "SMB_IOS"] = 12;
                values[valuesById[13] = "WINDOWS"] = 13;
                values[valuesById[14] = "WEB"] = 14;
                values[valuesById[15] = "PORTAL"] = 15;
                values[valuesById[16] = "GREEN_ANDROID"] = 16;
                values[valuesById[17] = "GREEN_IPHONE"] = 17;
                values[valuesById[18] = "BLUE_ANDROID"] = 18;
                values[valuesById[19] = "BLUE_IPHONE"] = 19;
                values[valuesById[20] = "FBLITE_ANDROID"] = 20;
                values[valuesById[21] = "MLITE_ANDROID"] = 21;
                values[valuesById[22] = "IGLITE_ANDROID"] = 22;
                values[valuesById[23] = "PAGE"] = 23;
                values[valuesById[24] = "MACOS"] = 24;
                values[valuesById[25] = "OCULUS_MSG"] = 25;
                values[valuesById[26] = "OCULUS_CALL"] = 26;
                values[valuesById[27] = "MILAN"] = 27;
                values[valuesById[28] = "CAPI"] = 28;
                values[valuesById[29] = "WEAROS"] = 29;
                values[valuesById[30] = "ARDEVICE"] = 30;
                values[valuesById[31] = "VRDEVICE"] = 31;
                return values;
            })();

            /**
             * ReleaseChannel enum.
             * @name proto.ClientPayload.UserAgent.ReleaseChannel
             * @enum {number}
             * @property {number} RELEASE=0 RELEASE value
             * @property {number} BETA=1 BETA value
             * @property {number} ALPHA=2 ALPHA value
             * @property {number} DEBUG=3 DEBUG value
             */
            UserAgent.ReleaseChannel = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RELEASE"] = 0;
                values[valuesById[1] = "BETA"] = 1;
                values[valuesById[2] = "ALPHA"] = 2;
                values[valuesById[3] = "DEBUG"] = 3;
                return values;
            })();

            return UserAgent;
        })();

        ClientPayload.WebInfo = (function() {

            /**
             * Properties of a WebInfo.
             * @memberof proto.ClientPayload
             * @interface IWebInfo
             * @property {string|null} [refToken] WebInfo refToken
             * @property {string|null} [version] WebInfo version
             * @property {proto.ClientPayload.WebInfo.IWebdPayload|null} [webdPayload] WebInfo webdPayload
             * @property {proto.ClientPayload.WebInfo.WebSubPlatform|null} [webSubPlatform] WebInfo webSubPlatform
             */

            /**
             * Constructs a new WebInfo.
             * @memberof proto.ClientPayload
             * @classdesc Represents a WebInfo.
             * @implements IWebInfo
             * @constructor
             * @param {proto.ClientPayload.IWebInfo=} [properties] Properties to set
             */
            function WebInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WebInfo refToken.
             * @member {string} refToken
             * @memberof proto.ClientPayload.WebInfo
             * @instance
             */
            WebInfo.prototype.refToken = "";

            /**
             * WebInfo version.
             * @member {string} version
             * @memberof proto.ClientPayload.WebInfo
             * @instance
             */
            WebInfo.prototype.version = "";

            /**
             * WebInfo webdPayload.
             * @member {proto.ClientPayload.WebInfo.IWebdPayload|null|undefined} webdPayload
             * @memberof proto.ClientPayload.WebInfo
             * @instance
             */
            WebInfo.prototype.webdPayload = null;

            /**
             * WebInfo webSubPlatform.
             * @member {proto.ClientPayload.WebInfo.WebSubPlatform} webSubPlatform
             * @memberof proto.ClientPayload.WebInfo
             * @instance
             */
            WebInfo.prototype.webSubPlatform = 0;

            /**
             * Creates a new WebInfo instance using the specified properties.
             * @function create
             * @memberof proto.ClientPayload.WebInfo
             * @static
             * @param {proto.ClientPayload.IWebInfo=} [properties] Properties to set
             * @returns {proto.ClientPayload.WebInfo} WebInfo instance
             */
            WebInfo.create = function create(properties) {
                return new WebInfo(properties);
            };

            /**
             * Encodes the specified WebInfo message. Does not implicitly {@link proto.ClientPayload.WebInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.ClientPayload.WebInfo
             * @static
             * @param {proto.ClientPayload.IWebInfo} message WebInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WebInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refToken != null && Object.hasOwnProperty.call(message, "refToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.refToken);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.webdPayload != null && Object.hasOwnProperty.call(message, "webdPayload"))
                    $root.proto.ClientPayload.WebInfo.WebdPayload.encode(message.webdPayload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.webSubPlatform != null && Object.hasOwnProperty.call(message, "webSubPlatform"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.webSubPlatform);
                return writer;
            };

            /**
             * Encodes the specified WebInfo message, length delimited. Does not implicitly {@link proto.ClientPayload.WebInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.ClientPayload.WebInfo
             * @static
             * @param {proto.ClientPayload.IWebInfo} message WebInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WebInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WebInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ClientPayload.WebInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ClientPayload.WebInfo} WebInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WebInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPayload.WebInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.refToken = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.webdPayload = $root.proto.ClientPayload.WebInfo.WebdPayload.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.webSubPlatform = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WebInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.ClientPayload.WebInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.ClientPayload.WebInfo} WebInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WebInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WebInfo message.
             * @function verify
             * @memberof proto.ClientPayload.WebInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WebInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.refToken != null && message.hasOwnProperty("refToken"))
                    if (!$util.isString(message.refToken))
                        return "refToken: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.webdPayload != null && message.hasOwnProperty("webdPayload")) {
                    var error = $root.proto.ClientPayload.WebInfo.WebdPayload.verify(message.webdPayload);
                    if (error)
                        return "webdPayload." + error;
                }
                if (message.webSubPlatform != null && message.hasOwnProperty("webSubPlatform"))
                    switch (message.webSubPlatform) {
                    default:
                        return "webSubPlatform: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates a WebInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.ClientPayload.WebInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.ClientPayload.WebInfo} WebInfo
             */
            WebInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.ClientPayload.WebInfo)
                    return object;
                var message = new $root.proto.ClientPayload.WebInfo();
                if (object.refToken != null)
                    message.refToken = String(object.refToken);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.webdPayload != null) {
                    if (typeof object.webdPayload !== "object")
                        throw TypeError(".proto.ClientPayload.WebInfo.webdPayload: object expected");
                    message.webdPayload = $root.proto.ClientPayload.WebInfo.WebdPayload.fromObject(object.webdPayload);
                }
                switch (object.webSubPlatform) {
                case "WEB_BROWSER":
                case 0:
                    message.webSubPlatform = 0;
                    break;
                case "APP_STORE":
                case 1:
                    message.webSubPlatform = 1;
                    break;
                case "WIN_STORE":
                case 2:
                    message.webSubPlatform = 2;
                    break;
                case "DARWIN":
                case 3:
                    message.webSubPlatform = 3;
                    break;
                case "WIN32":
                case 4:
                    message.webSubPlatform = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a WebInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.ClientPayload.WebInfo
             * @static
             * @param {proto.ClientPayload.WebInfo} message WebInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WebInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.refToken = "";
                    object.version = "";
                    object.webdPayload = null;
                    object.webSubPlatform = options.enums === String ? "WEB_BROWSER" : 0;
                }
                if (message.refToken != null && message.hasOwnProperty("refToken"))
                    object.refToken = message.refToken;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.webdPayload != null && message.hasOwnProperty("webdPayload"))
                    object.webdPayload = $root.proto.ClientPayload.WebInfo.WebdPayload.toObject(message.webdPayload, options);
                if (message.webSubPlatform != null && message.hasOwnProperty("webSubPlatform"))
                    object.webSubPlatform = options.enums === String ? $root.proto.ClientPayload.WebInfo.WebSubPlatform[message.webSubPlatform] : message.webSubPlatform;
                return object;
            };

            /**
             * Converts this WebInfo to JSON.
             * @function toJSON
             * @memberof proto.ClientPayload.WebInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WebInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * WebSubPlatform enum.
             * @name proto.ClientPayload.WebInfo.WebSubPlatform
             * @enum {number}
             * @property {number} WEB_BROWSER=0 WEB_BROWSER value
             * @property {number} APP_STORE=1 APP_STORE value
             * @property {number} WIN_STORE=2 WIN_STORE value
             * @property {number} DARWIN=3 DARWIN value
             * @property {number} WIN32=4 WIN32 value
             */
            WebInfo.WebSubPlatform = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "WEB_BROWSER"] = 0;
                values[valuesById[1] = "APP_STORE"] = 1;
                values[valuesById[2] = "WIN_STORE"] = 2;
                values[valuesById[3] = "DARWIN"] = 3;
                values[valuesById[4] = "WIN32"] = 4;
                return values;
            })();

            WebInfo.WebdPayload = (function() {

                /**
                 * Properties of a WebdPayload.
                 * @memberof proto.ClientPayload.WebInfo
                 * @interface IWebdPayload
                 * @property {boolean|null} [usesParticipantInKey] WebdPayload usesParticipantInKey
                 * @property {boolean|null} [supportsStarredMessages] WebdPayload supportsStarredMessages
                 * @property {boolean|null} [supportsDocumentMessages] WebdPayload supportsDocumentMessages
                 * @property {boolean|null} [supportsUrlMessages] WebdPayload supportsUrlMessages
                 * @property {boolean|null} [supportsMediaRetry] WebdPayload supportsMediaRetry
                 * @property {boolean|null} [supportsE2EImage] WebdPayload supportsE2EImage
                 * @property {boolean|null} [supportsE2EVideo] WebdPayload supportsE2EVideo
                 * @property {boolean|null} [supportsE2EAudio] WebdPayload supportsE2EAudio
                 * @property {boolean|null} [supportsE2EDocument] WebdPayload supportsE2EDocument
                 * @property {string|null} [documentTypes] WebdPayload documentTypes
                 * @property {Uint8Array|null} [features] WebdPayload features
                 */

                /**
                 * Constructs a new WebdPayload.
                 * @memberof proto.ClientPayload.WebInfo
                 * @classdesc Represents a WebdPayload.
                 * @implements IWebdPayload
                 * @constructor
                 * @param {proto.ClientPayload.WebInfo.IWebdPayload=} [properties] Properties to set
                 */
                function WebdPayload(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WebdPayload usesParticipantInKey.
                 * @member {boolean} usesParticipantInKey
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.usesParticipantInKey = false;

                /**
                 * WebdPayload supportsStarredMessages.
                 * @member {boolean} supportsStarredMessages
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsStarredMessages = false;

                /**
                 * WebdPayload supportsDocumentMessages.
                 * @member {boolean} supportsDocumentMessages
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsDocumentMessages = false;

                /**
                 * WebdPayload supportsUrlMessages.
                 * @member {boolean} supportsUrlMessages
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsUrlMessages = false;

                /**
                 * WebdPayload supportsMediaRetry.
                 * @member {boolean} supportsMediaRetry
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsMediaRetry = false;

                /**
                 * WebdPayload supportsE2EImage.
                 * @member {boolean} supportsE2EImage
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsE2EImage = false;

                /**
                 * WebdPayload supportsE2EVideo.
                 * @member {boolean} supportsE2EVideo
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsE2EVideo = false;

                /**
                 * WebdPayload supportsE2EAudio.
                 * @member {boolean} supportsE2EAudio
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsE2EAudio = false;

                /**
                 * WebdPayload supportsE2EDocument.
                 * @member {boolean} supportsE2EDocument
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsE2EDocument = false;

                /**
                 * WebdPayload documentTypes.
                 * @member {string} documentTypes
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.documentTypes = "";

                /**
                 * WebdPayload features.
                 * @member {Uint8Array} features
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.features = $util.newBuffer([]);

                /**
                 * Creates a new WebdPayload instance using the specified properties.
                 * @function create
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @static
                 * @param {proto.ClientPayload.WebInfo.IWebdPayload=} [properties] Properties to set
                 * @returns {proto.ClientPayload.WebInfo.WebdPayload} WebdPayload instance
                 */
                WebdPayload.create = function create(properties) {
                    return new WebdPayload(properties);
                };

                /**
                 * Encodes the specified WebdPayload message. Does not implicitly {@link proto.ClientPayload.WebInfo.WebdPayload.verify|verify} messages.
                 * @function encode
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @static
                 * @param {proto.ClientPayload.WebInfo.IWebdPayload} message WebdPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WebdPayload.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.usesParticipantInKey != null && Object.hasOwnProperty.call(message, "usesParticipantInKey"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.usesParticipantInKey);
                    if (message.supportsStarredMessages != null && Object.hasOwnProperty.call(message, "supportsStarredMessages"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.supportsStarredMessages);
                    if (message.supportsDocumentMessages != null && Object.hasOwnProperty.call(message, "supportsDocumentMessages"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.supportsDocumentMessages);
                    if (message.supportsUrlMessages != null && Object.hasOwnProperty.call(message, "supportsUrlMessages"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.supportsUrlMessages);
                    if (message.supportsMediaRetry != null && Object.hasOwnProperty.call(message, "supportsMediaRetry"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.supportsMediaRetry);
                    if (message.supportsE2EImage != null && Object.hasOwnProperty.call(message, "supportsE2EImage"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.supportsE2EImage);
                    if (message.supportsE2EVideo != null && Object.hasOwnProperty.call(message, "supportsE2EVideo"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.supportsE2EVideo);
                    if (message.supportsE2EAudio != null && Object.hasOwnProperty.call(message, "supportsE2EAudio"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.supportsE2EAudio);
                    if (message.supportsE2EDocument != null && Object.hasOwnProperty.call(message, "supportsE2EDocument"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.supportsE2EDocument);
                    if (message.documentTypes != null && Object.hasOwnProperty.call(message, "documentTypes"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.documentTypes);
                    if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.features);
                    return writer;
                };

                /**
                 * Encodes the specified WebdPayload message, length delimited. Does not implicitly {@link proto.ClientPayload.WebInfo.WebdPayload.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @static
                 * @param {proto.ClientPayload.WebInfo.IWebdPayload} message WebdPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WebdPayload.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WebdPayload message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.ClientPayload.WebInfo.WebdPayload} WebdPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WebdPayload.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPayload.WebInfo.WebdPayload();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.usesParticipantInKey = reader.bool();
                            break;
                        case 2:
                            message.supportsStarredMessages = reader.bool();
                            break;
                        case 3:
                            message.supportsDocumentMessages = reader.bool();
                            break;
                        case 4:
                            message.supportsUrlMessages = reader.bool();
                            break;
                        case 5:
                            message.supportsMediaRetry = reader.bool();
                            break;
                        case 6:
                            message.supportsE2EImage = reader.bool();
                            break;
                        case 7:
                            message.supportsE2EVideo = reader.bool();
                            break;
                        case 8:
                            message.supportsE2EAudio = reader.bool();
                            break;
                        case 9:
                            message.supportsE2EDocument = reader.bool();
                            break;
                        case 10:
                            message.documentTypes = reader.string();
                            break;
                        case 11:
                            message.features = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WebdPayload message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.ClientPayload.WebInfo.WebdPayload} WebdPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WebdPayload.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WebdPayload message.
                 * @function verify
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WebdPayload.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.usesParticipantInKey != null && message.hasOwnProperty("usesParticipantInKey"))
                        if (typeof message.usesParticipantInKey !== "boolean")
                            return "usesParticipantInKey: boolean expected";
                    if (message.supportsStarredMessages != null && message.hasOwnProperty("supportsStarredMessages"))
                        if (typeof message.supportsStarredMessages !== "boolean")
                            return "supportsStarredMessages: boolean expected";
                    if (message.supportsDocumentMessages != null && message.hasOwnProperty("supportsDocumentMessages"))
                        if (typeof message.supportsDocumentMessages !== "boolean")
                            return "supportsDocumentMessages: boolean expected";
                    if (message.supportsUrlMessages != null && message.hasOwnProperty("supportsUrlMessages"))
                        if (typeof message.supportsUrlMessages !== "boolean")
                            return "supportsUrlMessages: boolean expected";
                    if (message.supportsMediaRetry != null && message.hasOwnProperty("supportsMediaRetry"))
                        if (typeof message.supportsMediaRetry !== "boolean")
                            return "supportsMediaRetry: boolean expected";
                    if (message.supportsE2EImage != null && message.hasOwnProperty("supportsE2EImage"))
                        if (typeof message.supportsE2EImage !== "boolean")
                            return "supportsE2EImage: boolean expected";
                    if (message.supportsE2EVideo != null && message.hasOwnProperty("supportsE2EVideo"))
                        if (typeof message.supportsE2EVideo !== "boolean")
                            return "supportsE2EVideo: boolean expected";
                    if (message.supportsE2EAudio != null && message.hasOwnProperty("supportsE2EAudio"))
                        if (typeof message.supportsE2EAudio !== "boolean")
                            return "supportsE2EAudio: boolean expected";
                    if (message.supportsE2EDocument != null && message.hasOwnProperty("supportsE2EDocument"))
                        if (typeof message.supportsE2EDocument !== "boolean")
                            return "supportsE2EDocument: boolean expected";
                    if (message.documentTypes != null && message.hasOwnProperty("documentTypes"))
                        if (!$util.isString(message.documentTypes))
                            return "documentTypes: string expected";
                    if (message.features != null && message.hasOwnProperty("features"))
                        if (!(message.features && typeof message.features.length === "number" || $util.isString(message.features)))
                            return "features: buffer expected";
                    return null;
                };

                /**
                 * Creates a WebdPayload message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.ClientPayload.WebInfo.WebdPayload} WebdPayload
                 */
                WebdPayload.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.ClientPayload.WebInfo.WebdPayload)
                        return object;
                    var message = new $root.proto.ClientPayload.WebInfo.WebdPayload();
                    if (object.usesParticipantInKey != null)
                        message.usesParticipantInKey = Boolean(object.usesParticipantInKey);
                    if (object.supportsStarredMessages != null)
                        message.supportsStarredMessages = Boolean(object.supportsStarredMessages);
                    if (object.supportsDocumentMessages != null)
                        message.supportsDocumentMessages = Boolean(object.supportsDocumentMessages);
                    if (object.supportsUrlMessages != null)
                        message.supportsUrlMessages = Boolean(object.supportsUrlMessages);
                    if (object.supportsMediaRetry != null)
                        message.supportsMediaRetry = Boolean(object.supportsMediaRetry);
                    if (object.supportsE2EImage != null)
                        message.supportsE2EImage = Boolean(object.supportsE2EImage);
                    if (object.supportsE2EVideo != null)
                        message.supportsE2EVideo = Boolean(object.supportsE2EVideo);
                    if (object.supportsE2EAudio != null)
                        message.supportsE2EAudio = Boolean(object.supportsE2EAudio);
                    if (object.supportsE2EDocument != null)
                        message.supportsE2EDocument = Boolean(object.supportsE2EDocument);
                    if (object.documentTypes != null)
                        message.documentTypes = String(object.documentTypes);
                    if (object.features != null)
                        if (typeof object.features === "string")
                            $util.base64.decode(object.features, message.features = $util.newBuffer($util.base64.length(object.features)), 0);
                        else if (object.features.length)
                            message.features = object.features;
                    return message;
                };

                /**
                 * Creates a plain object from a WebdPayload message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @static
                 * @param {proto.ClientPayload.WebInfo.WebdPayload} message WebdPayload
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WebdPayload.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.usesParticipantInKey = false;
                        object.supportsStarredMessages = false;
                        object.supportsDocumentMessages = false;
                        object.supportsUrlMessages = false;
                        object.supportsMediaRetry = false;
                        object.supportsE2EImage = false;
                        object.supportsE2EVideo = false;
                        object.supportsE2EAudio = false;
                        object.supportsE2EDocument = false;
                        object.documentTypes = "";
                        if (options.bytes === String)
                            object.features = "";
                        else {
                            object.features = [];
                            if (options.bytes !== Array)
                                object.features = $util.newBuffer(object.features);
                        }
                    }
                    if (message.usesParticipantInKey != null && message.hasOwnProperty("usesParticipantInKey"))
                        object.usesParticipantInKey = message.usesParticipantInKey;
                    if (message.supportsStarredMessages != null && message.hasOwnProperty("supportsStarredMessages"))
                        object.supportsStarredMessages = message.supportsStarredMessages;
                    if (message.supportsDocumentMessages != null && message.hasOwnProperty("supportsDocumentMessages"))
                        object.supportsDocumentMessages = message.supportsDocumentMessages;
                    if (message.supportsUrlMessages != null && message.hasOwnProperty("supportsUrlMessages"))
                        object.supportsUrlMessages = message.supportsUrlMessages;
                    if (message.supportsMediaRetry != null && message.hasOwnProperty("supportsMediaRetry"))
                        object.supportsMediaRetry = message.supportsMediaRetry;
                    if (message.supportsE2EImage != null && message.hasOwnProperty("supportsE2EImage"))
                        object.supportsE2EImage = message.supportsE2EImage;
                    if (message.supportsE2EVideo != null && message.hasOwnProperty("supportsE2EVideo"))
                        object.supportsE2EVideo = message.supportsE2EVideo;
                    if (message.supportsE2EAudio != null && message.hasOwnProperty("supportsE2EAudio"))
                        object.supportsE2EAudio = message.supportsE2EAudio;
                    if (message.supportsE2EDocument != null && message.hasOwnProperty("supportsE2EDocument"))
                        object.supportsE2EDocument = message.supportsE2EDocument;
                    if (message.documentTypes != null && message.hasOwnProperty("documentTypes"))
                        object.documentTypes = message.documentTypes;
                    if (message.features != null && message.hasOwnProperty("features"))
                        object.features = options.bytes === String ? $util.base64.encode(message.features, 0, message.features.length) : options.bytes === Array ? Array.prototype.slice.call(message.features) : message.features;
                    return object;
                };

                /**
                 * Converts this WebdPayload to JSON.
                 * @function toJSON
                 * @memberof proto.ClientPayload.WebInfo.WebdPayload
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WebdPayload.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return WebdPayload;
            })();

            return WebInfo;
        })();

        return ClientPayload;
    })();

    proto.ContextInfo = (function() {

        /**
         * Properties of a ContextInfo.
         * @memberof proto
         * @interface IContextInfo
         * @property {string|null} [stanzaId] ContextInfo stanzaId
         * @property {string|null} [participant] ContextInfo participant
         * @property {proto.IMessage|null} [quotedMessage] ContextInfo quotedMessage
         * @property {string|null} [remoteJid] ContextInfo remoteJid
         * @property {Array.<string>|null} [mentionedJid] ContextInfo mentionedJid
         * @property {string|null} [conversionSource] ContextInfo conversionSource
         * @property {Uint8Array|null} [conversionData] ContextInfo conversionData
         * @property {number|null} [conversionDelaySeconds] ContextInfo conversionDelaySeconds
         * @property {number|null} [forwardingScore] ContextInfo forwardingScore
         * @property {boolean|null} [isForwarded] ContextInfo isForwarded
         * @property {proto.ContextInfo.IAdReplyInfo|null} [quotedAd] ContextInfo quotedAd
         * @property {proto.IMessageKey|null} [placeholderKey] ContextInfo placeholderKey
         * @property {number|null} [expiration] ContextInfo expiration
         * @property {number|Long|null} [ephemeralSettingTimestamp] ContextInfo ephemeralSettingTimestamp
         * @property {Uint8Array|null} [ephemeralSharedSecret] ContextInfo ephemeralSharedSecret
         * @property {proto.ContextInfo.IExternalAdReplyInfo|null} [externalAdReply] ContextInfo externalAdReply
         * @property {string|null} [entryPointConversionSource] ContextInfo entryPointConversionSource
         * @property {string|null} [entryPointConversionApp] ContextInfo entryPointConversionApp
         * @property {number|null} [entryPointConversionDelaySeconds] ContextInfo entryPointConversionDelaySeconds
         * @property {proto.IDisappearingMode|null} [disappearingMode] ContextInfo disappearingMode
         * @property {proto.IActionLink|null} [actionLink] ContextInfo actionLink
         * @property {string|null} [groupSubject] ContextInfo groupSubject
         * @property {string|null} [parentGroupJid] ContextInfo parentGroupJid
         * @property {string|null} [trustBannerType] ContextInfo trustBannerType
         * @property {number|null} [trustBannerAction] ContextInfo trustBannerAction
         */

        /**
         * Constructs a new ContextInfo.
         * @memberof proto
         * @classdesc Represents a ContextInfo.
         * @implements IContextInfo
         * @constructor
         * @param {proto.IContextInfo=} [properties] Properties to set
         */
        function ContextInfo(properties) {
            this.mentionedJid = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContextInfo stanzaId.
         * @member {string} stanzaId
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.stanzaId = "";

        /**
         * ContextInfo participant.
         * @member {string} participant
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.participant = "";

        /**
         * ContextInfo quotedMessage.
         * @member {proto.IMessage|null|undefined} quotedMessage
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.quotedMessage = null;

        /**
         * ContextInfo remoteJid.
         * @member {string} remoteJid
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.remoteJid = "";

        /**
         * ContextInfo mentionedJid.
         * @member {Array.<string>} mentionedJid
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.mentionedJid = $util.emptyArray;

        /**
         * ContextInfo conversionSource.
         * @member {string} conversionSource
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.conversionSource = "";

        /**
         * ContextInfo conversionData.
         * @member {Uint8Array} conversionData
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.conversionData = $util.newBuffer([]);

        /**
         * ContextInfo conversionDelaySeconds.
         * @member {number} conversionDelaySeconds
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.conversionDelaySeconds = 0;

        /**
         * ContextInfo forwardingScore.
         * @member {number} forwardingScore
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.forwardingScore = 0;

        /**
         * ContextInfo isForwarded.
         * @member {boolean} isForwarded
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.isForwarded = false;

        /**
         * ContextInfo quotedAd.
         * @member {proto.ContextInfo.IAdReplyInfo|null|undefined} quotedAd
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.quotedAd = null;

        /**
         * ContextInfo placeholderKey.
         * @member {proto.IMessageKey|null|undefined} placeholderKey
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.placeholderKey = null;

        /**
         * ContextInfo expiration.
         * @member {number} expiration
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.expiration = 0;

        /**
         * ContextInfo ephemeralSettingTimestamp.
         * @member {number|Long} ephemeralSettingTimestamp
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.ephemeralSettingTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContextInfo ephemeralSharedSecret.
         * @member {Uint8Array} ephemeralSharedSecret
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.ephemeralSharedSecret = $util.newBuffer([]);

        /**
         * ContextInfo externalAdReply.
         * @member {proto.ContextInfo.IExternalAdReplyInfo|null|undefined} externalAdReply
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.externalAdReply = null;

        /**
         * ContextInfo entryPointConversionSource.
         * @member {string} entryPointConversionSource
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.entryPointConversionSource = "";

        /**
         * ContextInfo entryPointConversionApp.
         * @member {string} entryPointConversionApp
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.entryPointConversionApp = "";

        /**
         * ContextInfo entryPointConversionDelaySeconds.
         * @member {number} entryPointConversionDelaySeconds
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.entryPointConversionDelaySeconds = 0;

        /**
         * ContextInfo disappearingMode.
         * @member {proto.IDisappearingMode|null|undefined} disappearingMode
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.disappearingMode = null;

        /**
         * ContextInfo actionLink.
         * @member {proto.IActionLink|null|undefined} actionLink
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.actionLink = null;

        /**
         * ContextInfo groupSubject.
         * @member {string} groupSubject
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.groupSubject = "";

        /**
         * ContextInfo parentGroupJid.
         * @member {string} parentGroupJid
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.parentGroupJid = "";

        /**
         * ContextInfo trustBannerType.
         * @member {string} trustBannerType
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.trustBannerType = "";

        /**
         * ContextInfo trustBannerAction.
         * @member {number} trustBannerAction
         * @memberof proto.ContextInfo
         * @instance
         */
        ContextInfo.prototype.trustBannerAction = 0;

        /**
         * Creates a new ContextInfo instance using the specified properties.
         * @function create
         * @memberof proto.ContextInfo
         * @static
         * @param {proto.IContextInfo=} [properties] Properties to set
         * @returns {proto.ContextInfo} ContextInfo instance
         */
        ContextInfo.create = function create(properties) {
            return new ContextInfo(properties);
        };

        /**
         * Encodes the specified ContextInfo message. Does not implicitly {@link proto.ContextInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ContextInfo
         * @static
         * @param {proto.IContextInfo} message ContextInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContextInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stanzaId != null && Object.hasOwnProperty.call(message, "stanzaId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stanzaId);
            if (message.participant != null && Object.hasOwnProperty.call(message, "participant"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.participant);
            if (message.quotedMessage != null && Object.hasOwnProperty.call(message, "quotedMessage"))
                $root.proto.Message.encode(message.quotedMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.remoteJid != null && Object.hasOwnProperty.call(message, "remoteJid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.remoteJid);
            if (message.mentionedJid != null && message.mentionedJid.length)
                for (var i = 0; i < message.mentionedJid.length; ++i)
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.mentionedJid[i]);
            if (message.conversionSource != null && Object.hasOwnProperty.call(message, "conversionSource"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.conversionSource);
            if (message.conversionData != null && Object.hasOwnProperty.call(message, "conversionData"))
                writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.conversionData);
            if (message.conversionDelaySeconds != null && Object.hasOwnProperty.call(message, "conversionDelaySeconds"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.conversionDelaySeconds);
            if (message.forwardingScore != null && Object.hasOwnProperty.call(message, "forwardingScore"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.forwardingScore);
            if (message.isForwarded != null && Object.hasOwnProperty.call(message, "isForwarded"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.isForwarded);
            if (message.quotedAd != null && Object.hasOwnProperty.call(message, "quotedAd"))
                $root.proto.ContextInfo.AdReplyInfo.encode(message.quotedAd, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.placeholderKey != null && Object.hasOwnProperty.call(message, "placeholderKey"))
                $root.proto.MessageKey.encode(message.placeholderKey, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                writer.uint32(/* id 25, wireType 0 =*/200).uint32(message.expiration);
            if (message.ephemeralSettingTimestamp != null && Object.hasOwnProperty.call(message, "ephemeralSettingTimestamp"))
                writer.uint32(/* id 26, wireType 0 =*/208).int64(message.ephemeralSettingTimestamp);
            if (message.ephemeralSharedSecret != null && Object.hasOwnProperty.call(message, "ephemeralSharedSecret"))
                writer.uint32(/* id 27, wireType 2 =*/218).bytes(message.ephemeralSharedSecret);
            if (message.externalAdReply != null && Object.hasOwnProperty.call(message, "externalAdReply"))
                $root.proto.ContextInfo.ExternalAdReplyInfo.encode(message.externalAdReply, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.entryPointConversionSource != null && Object.hasOwnProperty.call(message, "entryPointConversionSource"))
                writer.uint32(/* id 29, wireType 2 =*/234).string(message.entryPointConversionSource);
            if (message.entryPointConversionApp != null && Object.hasOwnProperty.call(message, "entryPointConversionApp"))
                writer.uint32(/* id 30, wireType 2 =*/242).string(message.entryPointConversionApp);
            if (message.entryPointConversionDelaySeconds != null && Object.hasOwnProperty.call(message, "entryPointConversionDelaySeconds"))
                writer.uint32(/* id 31, wireType 0 =*/248).uint32(message.entryPointConversionDelaySeconds);
            if (message.disappearingMode != null && Object.hasOwnProperty.call(message, "disappearingMode"))
                $root.proto.DisappearingMode.encode(message.disappearingMode, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.actionLink != null && Object.hasOwnProperty.call(message, "actionLink"))
                $root.proto.ActionLink.encode(message.actionLink, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.groupSubject != null && Object.hasOwnProperty.call(message, "groupSubject"))
                writer.uint32(/* id 34, wireType 2 =*/274).string(message.groupSubject);
            if (message.parentGroupJid != null && Object.hasOwnProperty.call(message, "parentGroupJid"))
                writer.uint32(/* id 35, wireType 2 =*/282).string(message.parentGroupJid);
            if (message.trustBannerType != null && Object.hasOwnProperty.call(message, "trustBannerType"))
                writer.uint32(/* id 37, wireType 2 =*/298).string(message.trustBannerType);
            if (message.trustBannerAction != null && Object.hasOwnProperty.call(message, "trustBannerAction"))
                writer.uint32(/* id 38, wireType 0 =*/304).uint32(message.trustBannerAction);
            return writer;
        };

        /**
         * Encodes the specified ContextInfo message, length delimited. Does not implicitly {@link proto.ContextInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ContextInfo
         * @static
         * @param {proto.IContextInfo} message ContextInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContextInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContextInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContextInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ContextInfo} ContextInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContextInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContextInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stanzaId = reader.string();
                    break;
                case 2:
                    message.participant = reader.string();
                    break;
                case 3:
                    message.quotedMessage = $root.proto.Message.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.remoteJid = reader.string();
                    break;
                case 15:
                    if (!(message.mentionedJid && message.mentionedJid.length))
                        message.mentionedJid = [];
                    message.mentionedJid.push(reader.string());
                    break;
                case 18:
                    message.conversionSource = reader.string();
                    break;
                case 19:
                    message.conversionData = reader.bytes();
                    break;
                case 20:
                    message.conversionDelaySeconds = reader.uint32();
                    break;
                case 21:
                    message.forwardingScore = reader.uint32();
                    break;
                case 22:
                    message.isForwarded = reader.bool();
                    break;
                case 23:
                    message.quotedAd = $root.proto.ContextInfo.AdReplyInfo.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.placeholderKey = $root.proto.MessageKey.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.expiration = reader.uint32();
                    break;
                case 26:
                    message.ephemeralSettingTimestamp = reader.int64();
                    break;
                case 27:
                    message.ephemeralSharedSecret = reader.bytes();
                    break;
                case 28:
                    message.externalAdReply = $root.proto.ContextInfo.ExternalAdReplyInfo.decode(reader, reader.uint32());
                    break;
                case 29:
                    message.entryPointConversionSource = reader.string();
                    break;
                case 30:
                    message.entryPointConversionApp = reader.string();
                    break;
                case 31:
                    message.entryPointConversionDelaySeconds = reader.uint32();
                    break;
                case 32:
                    message.disappearingMode = $root.proto.DisappearingMode.decode(reader, reader.uint32());
                    break;
                case 33:
                    message.actionLink = $root.proto.ActionLink.decode(reader, reader.uint32());
                    break;
                case 34:
                    message.groupSubject = reader.string();
                    break;
                case 35:
                    message.parentGroupJid = reader.string();
                    break;
                case 37:
                    message.trustBannerType = reader.string();
                    break;
                case 38:
                    message.trustBannerAction = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContextInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ContextInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ContextInfo} ContextInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContextInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContextInfo message.
         * @function verify
         * @memberof proto.ContextInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContextInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                if (!$util.isString(message.stanzaId))
                    return "stanzaId: string expected";
            if (message.participant != null && message.hasOwnProperty("participant"))
                if (!$util.isString(message.participant))
                    return "participant: string expected";
            if (message.quotedMessage != null && message.hasOwnProperty("quotedMessage")) {
                var error = $root.proto.Message.verify(message.quotedMessage);
                if (error)
                    return "quotedMessage." + error;
            }
            if (message.remoteJid != null && message.hasOwnProperty("remoteJid"))
                if (!$util.isString(message.remoteJid))
                    return "remoteJid: string expected";
            if (message.mentionedJid != null && message.hasOwnProperty("mentionedJid")) {
                if (!Array.isArray(message.mentionedJid))
                    return "mentionedJid: array expected";
                for (var i = 0; i < message.mentionedJid.length; ++i)
                    if (!$util.isString(message.mentionedJid[i]))
                        return "mentionedJid: string[] expected";
            }
            if (message.conversionSource != null && message.hasOwnProperty("conversionSource"))
                if (!$util.isString(message.conversionSource))
                    return "conversionSource: string expected";
            if (message.conversionData != null && message.hasOwnProperty("conversionData"))
                if (!(message.conversionData && typeof message.conversionData.length === "number" || $util.isString(message.conversionData)))
                    return "conversionData: buffer expected";
            if (message.conversionDelaySeconds != null && message.hasOwnProperty("conversionDelaySeconds"))
                if (!$util.isInteger(message.conversionDelaySeconds))
                    return "conversionDelaySeconds: integer expected";
            if (message.forwardingScore != null && message.hasOwnProperty("forwardingScore"))
                if (!$util.isInteger(message.forwardingScore))
                    return "forwardingScore: integer expected";
            if (message.isForwarded != null && message.hasOwnProperty("isForwarded"))
                if (typeof message.isForwarded !== "boolean")
                    return "isForwarded: boolean expected";
            if (message.quotedAd != null && message.hasOwnProperty("quotedAd")) {
                var error = $root.proto.ContextInfo.AdReplyInfo.verify(message.quotedAd);
                if (error)
                    return "quotedAd." + error;
            }
            if (message.placeholderKey != null && message.hasOwnProperty("placeholderKey")) {
                var error = $root.proto.MessageKey.verify(message.placeholderKey);
                if (error)
                    return "placeholderKey." + error;
            }
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration))
                    return "expiration: integer expected";
            if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                if (!$util.isInteger(message.ephemeralSettingTimestamp) && !(message.ephemeralSettingTimestamp && $util.isInteger(message.ephemeralSettingTimestamp.low) && $util.isInteger(message.ephemeralSettingTimestamp.high)))
                    return "ephemeralSettingTimestamp: integer|Long expected";
            if (message.ephemeralSharedSecret != null && message.hasOwnProperty("ephemeralSharedSecret"))
                if (!(message.ephemeralSharedSecret && typeof message.ephemeralSharedSecret.length === "number" || $util.isString(message.ephemeralSharedSecret)))
                    return "ephemeralSharedSecret: buffer expected";
            if (message.externalAdReply != null && message.hasOwnProperty("externalAdReply")) {
                var error = $root.proto.ContextInfo.ExternalAdReplyInfo.verify(message.externalAdReply);
                if (error)
                    return "externalAdReply." + error;
            }
            if (message.entryPointConversionSource != null && message.hasOwnProperty("entryPointConversionSource"))
                if (!$util.isString(message.entryPointConversionSource))
                    return "entryPointConversionSource: string expected";
            if (message.entryPointConversionApp != null && message.hasOwnProperty("entryPointConversionApp"))
                if (!$util.isString(message.entryPointConversionApp))
                    return "entryPointConversionApp: string expected";
            if (message.entryPointConversionDelaySeconds != null && message.hasOwnProperty("entryPointConversionDelaySeconds"))
                if (!$util.isInteger(message.entryPointConversionDelaySeconds))
                    return "entryPointConversionDelaySeconds: integer expected";
            if (message.disappearingMode != null && message.hasOwnProperty("disappearingMode")) {
                var error = $root.proto.DisappearingMode.verify(message.disappearingMode);
                if (error)
                    return "disappearingMode." + error;
            }
            if (message.actionLink != null && message.hasOwnProperty("actionLink")) {
                var error = $root.proto.ActionLink.verify(message.actionLink);
                if (error)
                    return "actionLink." + error;
            }
            if (message.groupSubject != null && message.hasOwnProperty("groupSubject"))
                if (!$util.isString(message.groupSubject))
                    return "groupSubject: string expected";
            if (message.parentGroupJid != null && message.hasOwnProperty("parentGroupJid"))
                if (!$util.isString(message.parentGroupJid))
                    return "parentGroupJid: string expected";
            if (message.trustBannerType != null && message.hasOwnProperty("trustBannerType"))
                if (!$util.isString(message.trustBannerType))
                    return "trustBannerType: string expected";
            if (message.trustBannerAction != null && message.hasOwnProperty("trustBannerAction"))
                if (!$util.isInteger(message.trustBannerAction))
                    return "trustBannerAction: integer expected";
            return null;
        };

        /**
         * Creates a ContextInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ContextInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ContextInfo} ContextInfo
         */
        ContextInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ContextInfo)
                return object;
            var message = new $root.proto.ContextInfo();
            if (object.stanzaId != null)
                message.stanzaId = String(object.stanzaId);
            if (object.participant != null)
                message.participant = String(object.participant);
            if (object.quotedMessage != null) {
                if (typeof object.quotedMessage !== "object")
                    throw TypeError(".proto.ContextInfo.quotedMessage: object expected");
                message.quotedMessage = $root.proto.Message.fromObject(object.quotedMessage);
            }
            if (object.remoteJid != null)
                message.remoteJid = String(object.remoteJid);
            if (object.mentionedJid) {
                if (!Array.isArray(object.mentionedJid))
                    throw TypeError(".proto.ContextInfo.mentionedJid: array expected");
                message.mentionedJid = [];
                for (var i = 0; i < object.mentionedJid.length; ++i)
                    message.mentionedJid[i] = String(object.mentionedJid[i]);
            }
            if (object.conversionSource != null)
                message.conversionSource = String(object.conversionSource);
            if (object.conversionData != null)
                if (typeof object.conversionData === "string")
                    $util.base64.decode(object.conversionData, message.conversionData = $util.newBuffer($util.base64.length(object.conversionData)), 0);
                else if (object.conversionData.length)
                    message.conversionData = object.conversionData;
            if (object.conversionDelaySeconds != null)
                message.conversionDelaySeconds = object.conversionDelaySeconds >>> 0;
            if (object.forwardingScore != null)
                message.forwardingScore = object.forwardingScore >>> 0;
            if (object.isForwarded != null)
                message.isForwarded = Boolean(object.isForwarded);
            if (object.quotedAd != null) {
                if (typeof object.quotedAd !== "object")
                    throw TypeError(".proto.ContextInfo.quotedAd: object expected");
                message.quotedAd = $root.proto.ContextInfo.AdReplyInfo.fromObject(object.quotedAd);
            }
            if (object.placeholderKey != null) {
                if (typeof object.placeholderKey !== "object")
                    throw TypeError(".proto.ContextInfo.placeholderKey: object expected");
                message.placeholderKey = $root.proto.MessageKey.fromObject(object.placeholderKey);
            }
            if (object.expiration != null)
                message.expiration = object.expiration >>> 0;
            if (object.ephemeralSettingTimestamp != null)
                if ($util.Long)
                    (message.ephemeralSettingTimestamp = $util.Long.fromValue(object.ephemeralSettingTimestamp)).unsigned = false;
                else if (typeof object.ephemeralSettingTimestamp === "string")
                    message.ephemeralSettingTimestamp = parseInt(object.ephemeralSettingTimestamp, 10);
                else if (typeof object.ephemeralSettingTimestamp === "number")
                    message.ephemeralSettingTimestamp = object.ephemeralSettingTimestamp;
                else if (typeof object.ephemeralSettingTimestamp === "object")
                    message.ephemeralSettingTimestamp = new $util.LongBits(object.ephemeralSettingTimestamp.low >>> 0, object.ephemeralSettingTimestamp.high >>> 0).toNumber();
            if (object.ephemeralSharedSecret != null)
                if (typeof object.ephemeralSharedSecret === "string")
                    $util.base64.decode(object.ephemeralSharedSecret, message.ephemeralSharedSecret = $util.newBuffer($util.base64.length(object.ephemeralSharedSecret)), 0);
                else if (object.ephemeralSharedSecret.length)
                    message.ephemeralSharedSecret = object.ephemeralSharedSecret;
            if (object.externalAdReply != null) {
                if (typeof object.externalAdReply !== "object")
                    throw TypeError(".proto.ContextInfo.externalAdReply: object expected");
                message.externalAdReply = $root.proto.ContextInfo.ExternalAdReplyInfo.fromObject(object.externalAdReply);
            }
            if (object.entryPointConversionSource != null)
                message.entryPointConversionSource = String(object.entryPointConversionSource);
            if (object.entryPointConversionApp != null)
                message.entryPointConversionApp = String(object.entryPointConversionApp);
            if (object.entryPointConversionDelaySeconds != null)
                message.entryPointConversionDelaySeconds = object.entryPointConversionDelaySeconds >>> 0;
            if (object.disappearingMode != null) {
                if (typeof object.disappearingMode !== "object")
                    throw TypeError(".proto.ContextInfo.disappearingMode: object expected");
                message.disappearingMode = $root.proto.DisappearingMode.fromObject(object.disappearingMode);
            }
            if (object.actionLink != null) {
                if (typeof object.actionLink !== "object")
                    throw TypeError(".proto.ContextInfo.actionLink: object expected");
                message.actionLink = $root.proto.ActionLink.fromObject(object.actionLink);
            }
            if (object.groupSubject != null)
                message.groupSubject = String(object.groupSubject);
            if (object.parentGroupJid != null)
                message.parentGroupJid = String(object.parentGroupJid);
            if (object.trustBannerType != null)
                message.trustBannerType = String(object.trustBannerType);
            if (object.trustBannerAction != null)
                message.trustBannerAction = object.trustBannerAction >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ContextInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ContextInfo
         * @static
         * @param {proto.ContextInfo} message ContextInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContextInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mentionedJid = [];
            if (options.defaults) {
                object.stanzaId = "";
                object.participant = "";
                object.quotedMessage = null;
                object.remoteJid = "";
                object.conversionSource = "";
                if (options.bytes === String)
                    object.conversionData = "";
                else {
                    object.conversionData = [];
                    if (options.bytes !== Array)
                        object.conversionData = $util.newBuffer(object.conversionData);
                }
                object.conversionDelaySeconds = 0;
                object.forwardingScore = 0;
                object.isForwarded = false;
                object.quotedAd = null;
                object.placeholderKey = null;
                object.expiration = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.ephemeralSettingTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ephemeralSettingTimestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.ephemeralSharedSecret = "";
                else {
                    object.ephemeralSharedSecret = [];
                    if (options.bytes !== Array)
                        object.ephemeralSharedSecret = $util.newBuffer(object.ephemeralSharedSecret);
                }
                object.externalAdReply = null;
                object.entryPointConversionSource = "";
                object.entryPointConversionApp = "";
                object.entryPointConversionDelaySeconds = 0;
                object.disappearingMode = null;
                object.actionLink = null;
                object.groupSubject = "";
                object.parentGroupJid = "";
                object.trustBannerType = "";
                object.trustBannerAction = 0;
            }
            if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                object.stanzaId = message.stanzaId;
            if (message.participant != null && message.hasOwnProperty("participant"))
                object.participant = message.participant;
            if (message.quotedMessage != null && message.hasOwnProperty("quotedMessage"))
                object.quotedMessage = $root.proto.Message.toObject(message.quotedMessage, options);
            if (message.remoteJid != null && message.hasOwnProperty("remoteJid"))
                object.remoteJid = message.remoteJid;
            if (message.mentionedJid && message.mentionedJid.length) {
                object.mentionedJid = [];
                for (var j = 0; j < message.mentionedJid.length; ++j)
                    object.mentionedJid[j] = message.mentionedJid[j];
            }
            if (message.conversionSource != null && message.hasOwnProperty("conversionSource"))
                object.conversionSource = message.conversionSource;
            if (message.conversionData != null && message.hasOwnProperty("conversionData"))
                object.conversionData = options.bytes === String ? $util.base64.encode(message.conversionData, 0, message.conversionData.length) : options.bytes === Array ? Array.prototype.slice.call(message.conversionData) : message.conversionData;
            if (message.conversionDelaySeconds != null && message.hasOwnProperty("conversionDelaySeconds"))
                object.conversionDelaySeconds = message.conversionDelaySeconds;
            if (message.forwardingScore != null && message.hasOwnProperty("forwardingScore"))
                object.forwardingScore = message.forwardingScore;
            if (message.isForwarded != null && message.hasOwnProperty("isForwarded"))
                object.isForwarded = message.isForwarded;
            if (message.quotedAd != null && message.hasOwnProperty("quotedAd"))
                object.quotedAd = $root.proto.ContextInfo.AdReplyInfo.toObject(message.quotedAd, options);
            if (message.placeholderKey != null && message.hasOwnProperty("placeholderKey"))
                object.placeholderKey = $root.proto.MessageKey.toObject(message.placeholderKey, options);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                object.expiration = message.expiration;
            if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                if (typeof message.ephemeralSettingTimestamp === "number")
                    object.ephemeralSettingTimestamp = options.longs === String ? String(message.ephemeralSettingTimestamp) : message.ephemeralSettingTimestamp;
                else
                    object.ephemeralSettingTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.ephemeralSettingTimestamp) : options.longs === Number ? new $util.LongBits(message.ephemeralSettingTimestamp.low >>> 0, message.ephemeralSettingTimestamp.high >>> 0).toNumber() : message.ephemeralSettingTimestamp;
            if (message.ephemeralSharedSecret != null && message.hasOwnProperty("ephemeralSharedSecret"))
                object.ephemeralSharedSecret = options.bytes === String ? $util.base64.encode(message.ephemeralSharedSecret, 0, message.ephemeralSharedSecret.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralSharedSecret) : message.ephemeralSharedSecret;
            if (message.externalAdReply != null && message.hasOwnProperty("externalAdReply"))
                object.externalAdReply = $root.proto.ContextInfo.ExternalAdReplyInfo.toObject(message.externalAdReply, options);
            if (message.entryPointConversionSource != null && message.hasOwnProperty("entryPointConversionSource"))
                object.entryPointConversionSource = message.entryPointConversionSource;
            if (message.entryPointConversionApp != null && message.hasOwnProperty("entryPointConversionApp"))
                object.entryPointConversionApp = message.entryPointConversionApp;
            if (message.entryPointConversionDelaySeconds != null && message.hasOwnProperty("entryPointConversionDelaySeconds"))
                object.entryPointConversionDelaySeconds = message.entryPointConversionDelaySeconds;
            if (message.disappearingMode != null && message.hasOwnProperty("disappearingMode"))
                object.disappearingMode = $root.proto.DisappearingMode.toObject(message.disappearingMode, options);
            if (message.actionLink != null && message.hasOwnProperty("actionLink"))
                object.actionLink = $root.proto.ActionLink.toObject(message.actionLink, options);
            if (message.groupSubject != null && message.hasOwnProperty("groupSubject"))
                object.groupSubject = message.groupSubject;
            if (message.parentGroupJid != null && message.hasOwnProperty("parentGroupJid"))
                object.parentGroupJid = message.parentGroupJid;
            if (message.trustBannerType != null && message.hasOwnProperty("trustBannerType"))
                object.trustBannerType = message.trustBannerType;
            if (message.trustBannerAction != null && message.hasOwnProperty("trustBannerAction"))
                object.trustBannerAction = message.trustBannerAction;
            return object;
        };

        /**
         * Converts this ContextInfo to JSON.
         * @function toJSON
         * @memberof proto.ContextInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContextInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ContextInfo.AdReplyInfo = (function() {

            /**
             * Properties of an AdReplyInfo.
             * @memberof proto.ContextInfo
             * @interface IAdReplyInfo
             * @property {string|null} [advertiserName] AdReplyInfo advertiserName
             * @property {proto.ContextInfo.AdReplyInfo.MediaType|null} [mediaType] AdReplyInfo mediaType
             * @property {Uint8Array|null} [jpegThumbnail] AdReplyInfo jpegThumbnail
             * @property {string|null} [caption] AdReplyInfo caption
             */

            /**
             * Constructs a new AdReplyInfo.
             * @memberof proto.ContextInfo
             * @classdesc Represents an AdReplyInfo.
             * @implements IAdReplyInfo
             * @constructor
             * @param {proto.ContextInfo.IAdReplyInfo=} [properties] Properties to set
             */
            function AdReplyInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AdReplyInfo advertiserName.
             * @member {string} advertiserName
             * @memberof proto.ContextInfo.AdReplyInfo
             * @instance
             */
            AdReplyInfo.prototype.advertiserName = "";

            /**
             * AdReplyInfo mediaType.
             * @member {proto.ContextInfo.AdReplyInfo.MediaType} mediaType
             * @memberof proto.ContextInfo.AdReplyInfo
             * @instance
             */
            AdReplyInfo.prototype.mediaType = 0;

            /**
             * AdReplyInfo jpegThumbnail.
             * @member {Uint8Array} jpegThumbnail
             * @memberof proto.ContextInfo.AdReplyInfo
             * @instance
             */
            AdReplyInfo.prototype.jpegThumbnail = $util.newBuffer([]);

            /**
             * AdReplyInfo caption.
             * @member {string} caption
             * @memberof proto.ContextInfo.AdReplyInfo
             * @instance
             */
            AdReplyInfo.prototype.caption = "";

            /**
             * Creates a new AdReplyInfo instance using the specified properties.
             * @function create
             * @memberof proto.ContextInfo.AdReplyInfo
             * @static
             * @param {proto.ContextInfo.IAdReplyInfo=} [properties] Properties to set
             * @returns {proto.ContextInfo.AdReplyInfo} AdReplyInfo instance
             */
            AdReplyInfo.create = function create(properties) {
                return new AdReplyInfo(properties);
            };

            /**
             * Encodes the specified AdReplyInfo message. Does not implicitly {@link proto.ContextInfo.AdReplyInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.ContextInfo.AdReplyInfo
             * @static
             * @param {proto.ContextInfo.IAdReplyInfo} message AdReplyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AdReplyInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.advertiserName != null && Object.hasOwnProperty.call(message, "advertiserName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.advertiserName);
                if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mediaType);
                if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
                if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                    writer.uint32(/* id 17, wireType 2 =*/138).string(message.caption);
                return writer;
            };

            /**
             * Encodes the specified AdReplyInfo message, length delimited. Does not implicitly {@link proto.ContextInfo.AdReplyInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.ContextInfo.AdReplyInfo
             * @static
             * @param {proto.ContextInfo.IAdReplyInfo} message AdReplyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AdReplyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AdReplyInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ContextInfo.AdReplyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ContextInfo.AdReplyInfo} AdReplyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AdReplyInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContextInfo.AdReplyInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.advertiserName = reader.string();
                        break;
                    case 2:
                        message.mediaType = reader.int32();
                        break;
                    case 16:
                        message.jpegThumbnail = reader.bytes();
                        break;
                    case 17:
                        message.caption = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AdReplyInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.ContextInfo.AdReplyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.ContextInfo.AdReplyInfo} AdReplyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AdReplyInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AdReplyInfo message.
             * @function verify
             * @memberof proto.ContextInfo.AdReplyInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AdReplyInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.advertiserName != null && message.hasOwnProperty("advertiserName"))
                    if (!$util.isString(message.advertiserName))
                        return "advertiserName: string expected";
                if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                    switch (message.mediaType) {
                    default:
                        return "mediaType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                        return "jpegThumbnail: buffer expected";
                if (message.caption != null && message.hasOwnProperty("caption"))
                    if (!$util.isString(message.caption))
                        return "caption: string expected";
                return null;
            };

            /**
             * Creates an AdReplyInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.ContextInfo.AdReplyInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.ContextInfo.AdReplyInfo} AdReplyInfo
             */
            AdReplyInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.ContextInfo.AdReplyInfo)
                    return object;
                var message = new $root.proto.ContextInfo.AdReplyInfo();
                if (object.advertiserName != null)
                    message.advertiserName = String(object.advertiserName);
                switch (object.mediaType) {
                case "NONE":
                case 0:
                    message.mediaType = 0;
                    break;
                case "IMAGE":
                case 1:
                    message.mediaType = 1;
                    break;
                case "VIDEO":
                case 2:
                    message.mediaType = 2;
                    break;
                }
                if (object.jpegThumbnail != null)
                    if (typeof object.jpegThumbnail === "string")
                        $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                    else if (object.jpegThumbnail.length)
                        message.jpegThumbnail = object.jpegThumbnail;
                if (object.caption != null)
                    message.caption = String(object.caption);
                return message;
            };

            /**
             * Creates a plain object from an AdReplyInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.ContextInfo.AdReplyInfo
             * @static
             * @param {proto.ContextInfo.AdReplyInfo} message AdReplyInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AdReplyInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.advertiserName = "";
                    object.mediaType = options.enums === String ? "NONE" : 0;
                    if (options.bytes === String)
                        object.jpegThumbnail = "";
                    else {
                        object.jpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                    }
                    object.caption = "";
                }
                if (message.advertiserName != null && message.hasOwnProperty("advertiserName"))
                    object.advertiserName = message.advertiserName;
                if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                    object.mediaType = options.enums === String ? $root.proto.ContextInfo.AdReplyInfo.MediaType[message.mediaType] : message.mediaType;
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                if (message.caption != null && message.hasOwnProperty("caption"))
                    object.caption = message.caption;
                return object;
            };

            /**
             * Converts this AdReplyInfo to JSON.
             * @function toJSON
             * @memberof proto.ContextInfo.AdReplyInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AdReplyInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * MediaType enum.
             * @name proto.ContextInfo.AdReplyInfo.MediaType
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} IMAGE=1 IMAGE value
             * @property {number} VIDEO=2 VIDEO value
             */
            AdReplyInfo.MediaType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "IMAGE"] = 1;
                values[valuesById[2] = "VIDEO"] = 2;
                return values;
            })();

            return AdReplyInfo;
        })();

        ContextInfo.ExternalAdReplyInfo = (function() {

            /**
             * Properties of an ExternalAdReplyInfo.
             * @memberof proto.ContextInfo
             * @interface IExternalAdReplyInfo
             * @property {string|null} [title] ExternalAdReplyInfo title
             * @property {string|null} [body] ExternalAdReplyInfo body
             * @property {proto.ContextInfo.ExternalAdReplyInfo.MediaType|null} [mediaType] ExternalAdReplyInfo mediaType
             * @property {string|null} [thumbnailUrl] ExternalAdReplyInfo thumbnailUrl
             * @property {string|null} [mediaUrl] ExternalAdReplyInfo mediaUrl
             * @property {Uint8Array|null} [thumbnail] ExternalAdReplyInfo thumbnail
             * @property {string|null} [sourceType] ExternalAdReplyInfo sourceType
             * @property {string|null} [sourceId] ExternalAdReplyInfo sourceId
             * @property {string|null} [sourceUrl] ExternalAdReplyInfo sourceUrl
             * @property {boolean|null} [containsAutoReply] ExternalAdReplyInfo containsAutoReply
             * @property {boolean|null} [renderLargerThumbnail] ExternalAdReplyInfo renderLargerThumbnail
             * @property {boolean|null} [showAdAttribution] ExternalAdReplyInfo showAdAttribution
             * @property {string|null} [ctwaClid] ExternalAdReplyInfo ctwaClid
             */

            /**
             * Constructs a new ExternalAdReplyInfo.
             * @memberof proto.ContextInfo
             * @classdesc Represents an ExternalAdReplyInfo.
             * @implements IExternalAdReplyInfo
             * @constructor
             * @param {proto.ContextInfo.IExternalAdReplyInfo=} [properties] Properties to set
             */
            function ExternalAdReplyInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExternalAdReplyInfo title.
             * @member {string} title
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.title = "";

            /**
             * ExternalAdReplyInfo body.
             * @member {string} body
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.body = "";

            /**
             * ExternalAdReplyInfo mediaType.
             * @member {proto.ContextInfo.ExternalAdReplyInfo.MediaType} mediaType
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.mediaType = 0;

            /**
             * ExternalAdReplyInfo thumbnailUrl.
             * @member {string} thumbnailUrl
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.thumbnailUrl = "";

            /**
             * ExternalAdReplyInfo mediaUrl.
             * @member {string} mediaUrl
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.mediaUrl = "";

            /**
             * ExternalAdReplyInfo thumbnail.
             * @member {Uint8Array} thumbnail
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.thumbnail = $util.newBuffer([]);

            /**
             * ExternalAdReplyInfo sourceType.
             * @member {string} sourceType
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.sourceType = "";

            /**
             * ExternalAdReplyInfo sourceId.
             * @member {string} sourceId
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.sourceId = "";

            /**
             * ExternalAdReplyInfo sourceUrl.
             * @member {string} sourceUrl
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.sourceUrl = "";

            /**
             * ExternalAdReplyInfo containsAutoReply.
             * @member {boolean} containsAutoReply
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.containsAutoReply = false;

            /**
             * ExternalAdReplyInfo renderLargerThumbnail.
             * @member {boolean} renderLargerThumbnail
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.renderLargerThumbnail = false;

            /**
             * ExternalAdReplyInfo showAdAttribution.
             * @member {boolean} showAdAttribution
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.showAdAttribution = false;

            /**
             * ExternalAdReplyInfo ctwaClid.
             * @member {string} ctwaClid
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             */
            ExternalAdReplyInfo.prototype.ctwaClid = "";

            /**
             * Creates a new ExternalAdReplyInfo instance using the specified properties.
             * @function create
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @static
             * @param {proto.ContextInfo.IExternalAdReplyInfo=} [properties] Properties to set
             * @returns {proto.ContextInfo.ExternalAdReplyInfo} ExternalAdReplyInfo instance
             */
            ExternalAdReplyInfo.create = function create(properties) {
                return new ExternalAdReplyInfo(properties);
            };

            /**
             * Encodes the specified ExternalAdReplyInfo message. Does not implicitly {@link proto.ContextInfo.ExternalAdReplyInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @static
             * @param {proto.ContextInfo.IExternalAdReplyInfo} message ExternalAdReplyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExternalAdReplyInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);
                if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mediaType);
                if (message.thumbnailUrl != null && Object.hasOwnProperty.call(message, "thumbnailUrl"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.thumbnailUrl);
                if (message.mediaUrl != null && Object.hasOwnProperty.call(message, "mediaUrl"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.mediaUrl);
                if (message.thumbnail != null && Object.hasOwnProperty.call(message, "thumbnail"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.thumbnail);
                if (message.sourceType != null && Object.hasOwnProperty.call(message, "sourceType"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.sourceType);
                if (message.sourceId != null && Object.hasOwnProperty.call(message, "sourceId"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.sourceId);
                if (message.sourceUrl != null && Object.hasOwnProperty.call(message, "sourceUrl"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.sourceUrl);
                if (message.containsAutoReply != null && Object.hasOwnProperty.call(message, "containsAutoReply"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.containsAutoReply);
                if (message.renderLargerThumbnail != null && Object.hasOwnProperty.call(message, "renderLargerThumbnail"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.renderLargerThumbnail);
                if (message.showAdAttribution != null && Object.hasOwnProperty.call(message, "showAdAttribution"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.showAdAttribution);
                if (message.ctwaClid != null && Object.hasOwnProperty.call(message, "ctwaClid"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.ctwaClid);
                return writer;
            };

            /**
             * Encodes the specified ExternalAdReplyInfo message, length delimited. Does not implicitly {@link proto.ContextInfo.ExternalAdReplyInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @static
             * @param {proto.ContextInfo.IExternalAdReplyInfo} message ExternalAdReplyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExternalAdReplyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExternalAdReplyInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ContextInfo.ExternalAdReplyInfo} ExternalAdReplyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExternalAdReplyInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContextInfo.ExternalAdReplyInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.title = reader.string();
                        break;
                    case 2:
                        message.body = reader.string();
                        break;
                    case 3:
                        message.mediaType = reader.int32();
                        break;
                    case 4:
                        message.thumbnailUrl = reader.string();
                        break;
                    case 5:
                        message.mediaUrl = reader.string();
                        break;
                    case 6:
                        message.thumbnail = reader.bytes();
                        break;
                    case 7:
                        message.sourceType = reader.string();
                        break;
                    case 8:
                        message.sourceId = reader.string();
                        break;
                    case 9:
                        message.sourceUrl = reader.string();
                        break;
                    case 10:
                        message.containsAutoReply = reader.bool();
                        break;
                    case 11:
                        message.renderLargerThumbnail = reader.bool();
                        break;
                    case 12:
                        message.showAdAttribution = reader.bool();
                        break;
                    case 13:
                        message.ctwaClid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExternalAdReplyInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.ContextInfo.ExternalAdReplyInfo} ExternalAdReplyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExternalAdReplyInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExternalAdReplyInfo message.
             * @function verify
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExternalAdReplyInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                    switch (message.mediaType) {
                    default:
                        return "mediaType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.thumbnailUrl != null && message.hasOwnProperty("thumbnailUrl"))
                    if (!$util.isString(message.thumbnailUrl))
                        return "thumbnailUrl: string expected";
                if (message.mediaUrl != null && message.hasOwnProperty("mediaUrl"))
                    if (!$util.isString(message.mediaUrl))
                        return "mediaUrl: string expected";
                if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                    if (!(message.thumbnail && typeof message.thumbnail.length === "number" || $util.isString(message.thumbnail)))
                        return "thumbnail: buffer expected";
                if (message.sourceType != null && message.hasOwnProperty("sourceType"))
                    if (!$util.isString(message.sourceType))
                        return "sourceType: string expected";
                if (message.sourceId != null && message.hasOwnProperty("sourceId"))
                    if (!$util.isString(message.sourceId))
                        return "sourceId: string expected";
                if (message.sourceUrl != null && message.hasOwnProperty("sourceUrl"))
                    if (!$util.isString(message.sourceUrl))
                        return "sourceUrl: string expected";
                if (message.containsAutoReply != null && message.hasOwnProperty("containsAutoReply"))
                    if (typeof message.containsAutoReply !== "boolean")
                        return "containsAutoReply: boolean expected";
                if (message.renderLargerThumbnail != null && message.hasOwnProperty("renderLargerThumbnail"))
                    if (typeof message.renderLargerThumbnail !== "boolean")
                        return "renderLargerThumbnail: boolean expected";
                if (message.showAdAttribution != null && message.hasOwnProperty("showAdAttribution"))
                    if (typeof message.showAdAttribution !== "boolean")
                        return "showAdAttribution: boolean expected";
                if (message.ctwaClid != null && message.hasOwnProperty("ctwaClid"))
                    if (!$util.isString(message.ctwaClid))
                        return "ctwaClid: string expected";
                return null;
            };

            /**
             * Creates an ExternalAdReplyInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.ContextInfo.ExternalAdReplyInfo} ExternalAdReplyInfo
             */
            ExternalAdReplyInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.ContextInfo.ExternalAdReplyInfo)
                    return object;
                var message = new $root.proto.ContextInfo.ExternalAdReplyInfo();
                if (object.title != null)
                    message.title = String(object.title);
                if (object.body != null)
                    message.body = String(object.body);
                switch (object.mediaType) {
                case "NONE":
                case 0:
                    message.mediaType = 0;
                    break;
                case "IMAGE":
                case 1:
                    message.mediaType = 1;
                    break;
                case "VIDEO":
                case 2:
                    message.mediaType = 2;
                    break;
                }
                if (object.thumbnailUrl != null)
                    message.thumbnailUrl = String(object.thumbnailUrl);
                if (object.mediaUrl != null)
                    message.mediaUrl = String(object.mediaUrl);
                if (object.thumbnail != null)
                    if (typeof object.thumbnail === "string")
                        $util.base64.decode(object.thumbnail, message.thumbnail = $util.newBuffer($util.base64.length(object.thumbnail)), 0);
                    else if (object.thumbnail.length)
                        message.thumbnail = object.thumbnail;
                if (object.sourceType != null)
                    message.sourceType = String(object.sourceType);
                if (object.sourceId != null)
                    message.sourceId = String(object.sourceId);
                if (object.sourceUrl != null)
                    message.sourceUrl = String(object.sourceUrl);
                if (object.containsAutoReply != null)
                    message.containsAutoReply = Boolean(object.containsAutoReply);
                if (object.renderLargerThumbnail != null)
                    message.renderLargerThumbnail = Boolean(object.renderLargerThumbnail);
                if (object.showAdAttribution != null)
                    message.showAdAttribution = Boolean(object.showAdAttribution);
                if (object.ctwaClid != null)
                    message.ctwaClid = String(object.ctwaClid);
                return message;
            };

            /**
             * Creates a plain object from an ExternalAdReplyInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @static
             * @param {proto.ContextInfo.ExternalAdReplyInfo} message ExternalAdReplyInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExternalAdReplyInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.title = "";
                    object.body = "";
                    object.mediaType = options.enums === String ? "NONE" : 0;
                    object.thumbnailUrl = "";
                    object.mediaUrl = "";
                    if (options.bytes === String)
                        object.thumbnail = "";
                    else {
                        object.thumbnail = [];
                        if (options.bytes !== Array)
                            object.thumbnail = $util.newBuffer(object.thumbnail);
                    }
                    object.sourceType = "";
                    object.sourceId = "";
                    object.sourceUrl = "";
                    object.containsAutoReply = false;
                    object.renderLargerThumbnail = false;
                    object.showAdAttribution = false;
                    object.ctwaClid = "";
                }
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                    object.mediaType = options.enums === String ? $root.proto.ContextInfo.ExternalAdReplyInfo.MediaType[message.mediaType] : message.mediaType;
                if (message.thumbnailUrl != null && message.hasOwnProperty("thumbnailUrl"))
                    object.thumbnailUrl = message.thumbnailUrl;
                if (message.mediaUrl != null && message.hasOwnProperty("mediaUrl"))
                    object.mediaUrl = message.mediaUrl;
                if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                    object.thumbnail = options.bytes === String ? $util.base64.encode(message.thumbnail, 0, message.thumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnail) : message.thumbnail;
                if (message.sourceType != null && message.hasOwnProperty("sourceType"))
                    object.sourceType = message.sourceType;
                if (message.sourceId != null && message.hasOwnProperty("sourceId"))
                    object.sourceId = message.sourceId;
                if (message.sourceUrl != null && message.hasOwnProperty("sourceUrl"))
                    object.sourceUrl = message.sourceUrl;
                if (message.containsAutoReply != null && message.hasOwnProperty("containsAutoReply"))
                    object.containsAutoReply = message.containsAutoReply;
                if (message.renderLargerThumbnail != null && message.hasOwnProperty("renderLargerThumbnail"))
                    object.renderLargerThumbnail = message.renderLargerThumbnail;
                if (message.showAdAttribution != null && message.hasOwnProperty("showAdAttribution"))
                    object.showAdAttribution = message.showAdAttribution;
                if (message.ctwaClid != null && message.hasOwnProperty("ctwaClid"))
                    object.ctwaClid = message.ctwaClid;
                return object;
            };

            /**
             * Converts this ExternalAdReplyInfo to JSON.
             * @function toJSON
             * @memberof proto.ContextInfo.ExternalAdReplyInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExternalAdReplyInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * MediaType enum.
             * @name proto.ContextInfo.ExternalAdReplyInfo.MediaType
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} IMAGE=1 IMAGE value
             * @property {number} VIDEO=2 VIDEO value
             */
            ExternalAdReplyInfo.MediaType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "IMAGE"] = 1;
                values[valuesById[2] = "VIDEO"] = 2;
                return values;
            })();

            return ExternalAdReplyInfo;
        })();

        return ContextInfo;
    })();

    proto.Conversation = (function() {

        /**
         * Properties of a Conversation.
         * @memberof proto
         * @interface IConversation
         * @property {string} id Conversation id
         * @property {Array.<proto.IHistorySyncMsg>|null} [messages] Conversation messages
         * @property {string|null} [newJid] Conversation newJid
         * @property {string|null} [oldJid] Conversation oldJid
         * @property {number|Long|null} [lastMsgTimestamp] Conversation lastMsgTimestamp
         * @property {number|null} [unreadCount] Conversation unreadCount
         * @property {boolean|null} [readOnly] Conversation readOnly
         * @property {boolean|null} [endOfHistoryTransfer] Conversation endOfHistoryTransfer
         * @property {number|null} [ephemeralExpiration] Conversation ephemeralExpiration
         * @property {number|Long|null} [ephemeralSettingTimestamp] Conversation ephemeralSettingTimestamp
         * @property {proto.Conversation.EndOfHistoryTransferType|null} [endOfHistoryTransferType] Conversation endOfHistoryTransferType
         * @property {number|Long|null} [conversationTimestamp] Conversation conversationTimestamp
         * @property {string|null} [name] Conversation name
         * @property {string|null} [pHash] Conversation pHash
         * @property {boolean|null} [notSpam] Conversation notSpam
         * @property {boolean|null} [archived] Conversation archived
         * @property {proto.IDisappearingMode|null} [disappearingMode] Conversation disappearingMode
         * @property {number|null} [unreadMentionCount] Conversation unreadMentionCount
         * @property {boolean|null} [markedAsUnread] Conversation markedAsUnread
         * @property {Array.<proto.IGroupParticipant>|null} [participant] Conversation participant
         * @property {Uint8Array|null} [tcToken] Conversation tcToken
         * @property {number|Long|null} [tcTokenTimestamp] Conversation tcTokenTimestamp
         * @property {Uint8Array|null} [contactPrimaryIdentityKey] Conversation contactPrimaryIdentityKey
         * @property {number|null} [pinned] Conversation pinned
         * @property {number|Long|null} [muteEndTime] Conversation muteEndTime
         * @property {proto.IWallpaperSettings|null} [wallpaper] Conversation wallpaper
         * @property {proto.MediaVisibility|null} [mediaVisibility] Conversation mediaVisibility
         * @property {number|Long|null} [tcTokenSenderTimestamp] Conversation tcTokenSenderTimestamp
         * @property {boolean|null} [suspended] Conversation suspended
         * @property {boolean|null} [terminated] Conversation terminated
         * @property {number|Long|null} [createdAt] Conversation createdAt
         * @property {string|null} [createdBy] Conversation createdBy
         * @property {string|null} [description] Conversation description
         * @property {boolean|null} [support] Conversation support
         * @property {boolean|null} [isParentGroup] Conversation isParentGroup
         * @property {boolean|null} [isDefaultSubgroup] Conversation isDefaultSubgroup
         * @property {string|null} [parentGroupId] Conversation parentGroupId
         * @property {string|null} [displayName] Conversation displayName
         * @property {string|null} [pnJid] Conversation pnJid
         * @property {boolean|null} [shareOwnPn] Conversation shareOwnPn
         * @property {boolean|null} [pnhDuplicateLidThread] Conversation pnhDuplicateLidThread
         * @property {string|null} [lidJid] Conversation lidJid
         */

        /**
         * Constructs a new Conversation.
         * @memberof proto
         * @classdesc Represents a Conversation.
         * @implements IConversation
         * @constructor
         * @param {proto.IConversation=} [properties] Properties to set
         */
        function Conversation(properties) {
            this.messages = [];
            this.participant = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Conversation id.
         * @member {string} id
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.id = "";

        /**
         * Conversation messages.
         * @member {Array.<proto.IHistorySyncMsg>} messages
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.messages = $util.emptyArray;

        /**
         * Conversation newJid.
         * @member {string} newJid
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.newJid = "";

        /**
         * Conversation oldJid.
         * @member {string} oldJid
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.oldJid = "";

        /**
         * Conversation lastMsgTimestamp.
         * @member {number|Long} lastMsgTimestamp
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.lastMsgTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Conversation unreadCount.
         * @member {number} unreadCount
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.unreadCount = 0;

        /**
         * Conversation readOnly.
         * @member {boolean} readOnly
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.readOnly = false;

        /**
         * Conversation endOfHistoryTransfer.
         * @member {boolean} endOfHistoryTransfer
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.endOfHistoryTransfer = false;

        /**
         * Conversation ephemeralExpiration.
         * @member {number} ephemeralExpiration
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.ephemeralExpiration = 0;

        /**
         * Conversation ephemeralSettingTimestamp.
         * @member {number|Long} ephemeralSettingTimestamp
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.ephemeralSettingTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Conversation endOfHistoryTransferType.
         * @member {proto.Conversation.EndOfHistoryTransferType} endOfHistoryTransferType
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.endOfHistoryTransferType = 0;

        /**
         * Conversation conversationTimestamp.
         * @member {number|Long} conversationTimestamp
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.conversationTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Conversation name.
         * @member {string} name
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.name = "";

        /**
         * Conversation pHash.
         * @member {string} pHash
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.pHash = "";

        /**
         * Conversation notSpam.
         * @member {boolean} notSpam
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.notSpam = false;

        /**
         * Conversation archived.
         * @member {boolean} archived
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.archived = false;

        /**
         * Conversation disappearingMode.
         * @member {proto.IDisappearingMode|null|undefined} disappearingMode
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.disappearingMode = null;

        /**
         * Conversation unreadMentionCount.
         * @member {number} unreadMentionCount
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.unreadMentionCount = 0;

        /**
         * Conversation markedAsUnread.
         * @member {boolean} markedAsUnread
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.markedAsUnread = false;

        /**
         * Conversation participant.
         * @member {Array.<proto.IGroupParticipant>} participant
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.participant = $util.emptyArray;

        /**
         * Conversation tcToken.
         * @member {Uint8Array} tcToken
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.tcToken = $util.newBuffer([]);

        /**
         * Conversation tcTokenTimestamp.
         * @member {number|Long} tcTokenTimestamp
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.tcTokenTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Conversation contactPrimaryIdentityKey.
         * @member {Uint8Array} contactPrimaryIdentityKey
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.contactPrimaryIdentityKey = $util.newBuffer([]);

        /**
         * Conversation pinned.
         * @member {number} pinned
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.pinned = 0;

        /**
         * Conversation muteEndTime.
         * @member {number|Long} muteEndTime
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.muteEndTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Conversation wallpaper.
         * @member {proto.IWallpaperSettings|null|undefined} wallpaper
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.wallpaper = null;

        /**
         * Conversation mediaVisibility.
         * @member {proto.MediaVisibility} mediaVisibility
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.mediaVisibility = 0;

        /**
         * Conversation tcTokenSenderTimestamp.
         * @member {number|Long} tcTokenSenderTimestamp
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.tcTokenSenderTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Conversation suspended.
         * @member {boolean} suspended
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.suspended = false;

        /**
         * Conversation terminated.
         * @member {boolean} terminated
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.terminated = false;

        /**
         * Conversation createdAt.
         * @member {number|Long} createdAt
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.createdAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Conversation createdBy.
         * @member {string} createdBy
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.createdBy = "";

        /**
         * Conversation description.
         * @member {string} description
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.description = "";

        /**
         * Conversation support.
         * @member {boolean} support
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.support = false;

        /**
         * Conversation isParentGroup.
         * @member {boolean} isParentGroup
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.isParentGroup = false;

        /**
         * Conversation isDefaultSubgroup.
         * @member {boolean} isDefaultSubgroup
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.isDefaultSubgroup = false;

        /**
         * Conversation parentGroupId.
         * @member {string} parentGroupId
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.parentGroupId = "";

        /**
         * Conversation displayName.
         * @member {string} displayName
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.displayName = "";

        /**
         * Conversation pnJid.
         * @member {string} pnJid
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.pnJid = "";

        /**
         * Conversation shareOwnPn.
         * @member {boolean} shareOwnPn
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.shareOwnPn = false;

        /**
         * Conversation pnhDuplicateLidThread.
         * @member {boolean} pnhDuplicateLidThread
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.pnhDuplicateLidThread = false;

        /**
         * Conversation lidJid.
         * @member {string} lidJid
         * @memberof proto.Conversation
         * @instance
         */
        Conversation.prototype.lidJid = "";

        /**
         * Creates a new Conversation instance using the specified properties.
         * @function create
         * @memberof proto.Conversation
         * @static
         * @param {proto.IConversation=} [properties] Properties to set
         * @returns {proto.Conversation} Conversation instance
         */
        Conversation.create = function create(properties) {
            return new Conversation(properties);
        };

        /**
         * Encodes the specified Conversation message. Does not implicitly {@link proto.Conversation.verify|verify} messages.
         * @function encode
         * @memberof proto.Conversation
         * @static
         * @param {proto.IConversation} message Conversation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Conversation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.proto.HistorySyncMsg.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.newJid != null && Object.hasOwnProperty.call(message, "newJid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.newJid);
            if (message.oldJid != null && Object.hasOwnProperty.call(message, "oldJid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.oldJid);
            if (message.lastMsgTimestamp != null && Object.hasOwnProperty.call(message, "lastMsgTimestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.lastMsgTimestamp);
            if (message.unreadCount != null && Object.hasOwnProperty.call(message, "unreadCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.unreadCount);
            if (message.readOnly != null && Object.hasOwnProperty.call(message, "readOnly"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.readOnly);
            if (message.endOfHistoryTransfer != null && Object.hasOwnProperty.call(message, "endOfHistoryTransfer"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.endOfHistoryTransfer);
            if (message.ephemeralExpiration != null && Object.hasOwnProperty.call(message, "ephemeralExpiration"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.ephemeralExpiration);
            if (message.ephemeralSettingTimestamp != null && Object.hasOwnProperty.call(message, "ephemeralSettingTimestamp"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.ephemeralSettingTimestamp);
            if (message.endOfHistoryTransferType != null && Object.hasOwnProperty.call(message, "endOfHistoryTransferType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.endOfHistoryTransferType);
            if (message.conversationTimestamp != null && Object.hasOwnProperty.call(message, "conversationTimestamp"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.conversationTimestamp);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.name);
            if (message.pHash != null && Object.hasOwnProperty.call(message, "pHash"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.pHash);
            if (message.notSpam != null && Object.hasOwnProperty.call(message, "notSpam"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.notSpam);
            if (message.archived != null && Object.hasOwnProperty.call(message, "archived"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.archived);
            if (message.disappearingMode != null && Object.hasOwnProperty.call(message, "disappearingMode"))
                $root.proto.DisappearingMode.encode(message.disappearingMode, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.unreadMentionCount != null && Object.hasOwnProperty.call(message, "unreadMentionCount"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.unreadMentionCount);
            if (message.markedAsUnread != null && Object.hasOwnProperty.call(message, "markedAsUnread"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.markedAsUnread);
            if (message.participant != null && message.participant.length)
                for (var i = 0; i < message.participant.length; ++i)
                    $root.proto.GroupParticipant.encode(message.participant[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.tcToken != null && Object.hasOwnProperty.call(message, "tcToken"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.tcToken);
            if (message.tcTokenTimestamp != null && Object.hasOwnProperty.call(message, "tcTokenTimestamp"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint64(message.tcTokenTimestamp);
            if (message.contactPrimaryIdentityKey != null && Object.hasOwnProperty.call(message, "contactPrimaryIdentityKey"))
                writer.uint32(/* id 23, wireType 2 =*/186).bytes(message.contactPrimaryIdentityKey);
            if (message.pinned != null && Object.hasOwnProperty.call(message, "pinned"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.pinned);
            if (message.muteEndTime != null && Object.hasOwnProperty.call(message, "muteEndTime"))
                writer.uint32(/* id 25, wireType 0 =*/200).uint64(message.muteEndTime);
            if (message.wallpaper != null && Object.hasOwnProperty.call(message, "wallpaper"))
                $root.proto.WallpaperSettings.encode(message.wallpaper, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.mediaVisibility != null && Object.hasOwnProperty.call(message, "mediaVisibility"))
                writer.uint32(/* id 27, wireType 0 =*/216).int32(message.mediaVisibility);
            if (message.tcTokenSenderTimestamp != null && Object.hasOwnProperty.call(message, "tcTokenSenderTimestamp"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint64(message.tcTokenSenderTimestamp);
            if (message.suspended != null && Object.hasOwnProperty.call(message, "suspended"))
                writer.uint32(/* id 29, wireType 0 =*/232).bool(message.suspended);
            if (message.terminated != null && Object.hasOwnProperty.call(message, "terminated"))
                writer.uint32(/* id 30, wireType 0 =*/240).bool(message.terminated);
            if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
                writer.uint32(/* id 31, wireType 0 =*/248).uint64(message.createdAt);
            if (message.createdBy != null && Object.hasOwnProperty.call(message, "createdBy"))
                writer.uint32(/* id 32, wireType 2 =*/258).string(message.createdBy);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 33, wireType 2 =*/266).string(message.description);
            if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                writer.uint32(/* id 34, wireType 0 =*/272).bool(message.support);
            if (message.isParentGroup != null && Object.hasOwnProperty.call(message, "isParentGroup"))
                writer.uint32(/* id 35, wireType 0 =*/280).bool(message.isParentGroup);
            if (message.isDefaultSubgroup != null && Object.hasOwnProperty.call(message, "isDefaultSubgroup"))
                writer.uint32(/* id 36, wireType 0 =*/288).bool(message.isDefaultSubgroup);
            if (message.parentGroupId != null && Object.hasOwnProperty.call(message, "parentGroupId"))
                writer.uint32(/* id 37, wireType 2 =*/298).string(message.parentGroupId);
            if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                writer.uint32(/* id 38, wireType 2 =*/306).string(message.displayName);
            if (message.pnJid != null && Object.hasOwnProperty.call(message, "pnJid"))
                writer.uint32(/* id 39, wireType 2 =*/314).string(message.pnJid);
            if (message.shareOwnPn != null && Object.hasOwnProperty.call(message, "shareOwnPn"))
                writer.uint32(/* id 40, wireType 0 =*/320).bool(message.shareOwnPn);
            if (message.pnhDuplicateLidThread != null && Object.hasOwnProperty.call(message, "pnhDuplicateLidThread"))
                writer.uint32(/* id 41, wireType 0 =*/328).bool(message.pnhDuplicateLidThread);
            if (message.lidJid != null && Object.hasOwnProperty.call(message, "lidJid"))
                writer.uint32(/* id 42, wireType 2 =*/338).string(message.lidJid);
            return writer;
        };

        /**
         * Encodes the specified Conversation message, length delimited. Does not implicitly {@link proto.Conversation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Conversation
         * @static
         * @param {proto.IConversation} message Conversation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Conversation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Conversation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Conversation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Conversation} Conversation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Conversation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Conversation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.proto.HistorySyncMsg.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.newJid = reader.string();
                    break;
                case 4:
                    message.oldJid = reader.string();
                    break;
                case 5:
                    message.lastMsgTimestamp = reader.uint64();
                    break;
                case 6:
                    message.unreadCount = reader.uint32();
                    break;
                case 7:
                    message.readOnly = reader.bool();
                    break;
                case 8:
                    message.endOfHistoryTransfer = reader.bool();
                    break;
                case 9:
                    message.ephemeralExpiration = reader.uint32();
                    break;
                case 10:
                    message.ephemeralSettingTimestamp = reader.int64();
                    break;
                case 11:
                    message.endOfHistoryTransferType = reader.int32();
                    break;
                case 12:
                    message.conversationTimestamp = reader.uint64();
                    break;
                case 13:
                    message.name = reader.string();
                    break;
                case 14:
                    message.pHash = reader.string();
                    break;
                case 15:
                    message.notSpam = reader.bool();
                    break;
                case 16:
                    message.archived = reader.bool();
                    break;
                case 17:
                    message.disappearingMode = $root.proto.DisappearingMode.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.unreadMentionCount = reader.uint32();
                    break;
                case 19:
                    message.markedAsUnread = reader.bool();
                    break;
                case 20:
                    if (!(message.participant && message.participant.length))
                        message.participant = [];
                    message.participant.push($root.proto.GroupParticipant.decode(reader, reader.uint32()));
                    break;
                case 21:
                    message.tcToken = reader.bytes();
                    break;
                case 22:
                    message.tcTokenTimestamp = reader.uint64();
                    break;
                case 23:
                    message.contactPrimaryIdentityKey = reader.bytes();
                    break;
                case 24:
                    message.pinned = reader.uint32();
                    break;
                case 25:
                    message.muteEndTime = reader.uint64();
                    break;
                case 26:
                    message.wallpaper = $root.proto.WallpaperSettings.decode(reader, reader.uint32());
                    break;
                case 27:
                    message.mediaVisibility = reader.int32();
                    break;
                case 28:
                    message.tcTokenSenderTimestamp = reader.uint64();
                    break;
                case 29:
                    message.suspended = reader.bool();
                    break;
                case 30:
                    message.terminated = reader.bool();
                    break;
                case 31:
                    message.createdAt = reader.uint64();
                    break;
                case 32:
                    message.createdBy = reader.string();
                    break;
                case 33:
                    message.description = reader.string();
                    break;
                case 34:
                    message.support = reader.bool();
                    break;
                case 35:
                    message.isParentGroup = reader.bool();
                    break;
                case 36:
                    message.isDefaultSubgroup = reader.bool();
                    break;
                case 37:
                    message.parentGroupId = reader.string();
                    break;
                case 38:
                    message.displayName = reader.string();
                    break;
                case 39:
                    message.pnJid = reader.string();
                    break;
                case 40:
                    message.shareOwnPn = reader.bool();
                    break;
                case 41:
                    message.pnhDuplicateLidThread = reader.bool();
                    break;
                case 42:
                    message.lidJid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a Conversation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Conversation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Conversation} Conversation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Conversation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Conversation message.
         * @function verify
         * @memberof proto.Conversation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Conversation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.id))
                return "id: string expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i) {
                    var error = $root.proto.HistorySyncMsg.verify(message.messages[i]);
                    if (error)
                        return "messages." + error;
                }
            }
            if (message.newJid != null && message.hasOwnProperty("newJid"))
                if (!$util.isString(message.newJid))
                    return "newJid: string expected";
            if (message.oldJid != null && message.hasOwnProperty("oldJid"))
                if (!$util.isString(message.oldJid))
                    return "oldJid: string expected";
            if (message.lastMsgTimestamp != null && message.hasOwnProperty("lastMsgTimestamp"))
                if (!$util.isInteger(message.lastMsgTimestamp) && !(message.lastMsgTimestamp && $util.isInteger(message.lastMsgTimestamp.low) && $util.isInteger(message.lastMsgTimestamp.high)))
                    return "lastMsgTimestamp: integer|Long expected";
            if (message.unreadCount != null && message.hasOwnProperty("unreadCount"))
                if (!$util.isInteger(message.unreadCount))
                    return "unreadCount: integer expected";
            if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                if (typeof message.readOnly !== "boolean")
                    return "readOnly: boolean expected";
            if (message.endOfHistoryTransfer != null && message.hasOwnProperty("endOfHistoryTransfer"))
                if (typeof message.endOfHistoryTransfer !== "boolean")
                    return "endOfHistoryTransfer: boolean expected";
            if (message.ephemeralExpiration != null && message.hasOwnProperty("ephemeralExpiration"))
                if (!$util.isInteger(message.ephemeralExpiration))
                    return "ephemeralExpiration: integer expected";
            if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                if (!$util.isInteger(message.ephemeralSettingTimestamp) && !(message.ephemeralSettingTimestamp && $util.isInteger(message.ephemeralSettingTimestamp.low) && $util.isInteger(message.ephemeralSettingTimestamp.high)))
                    return "ephemeralSettingTimestamp: integer|Long expected";
            if (message.endOfHistoryTransferType != null && message.hasOwnProperty("endOfHistoryTransferType"))
                switch (message.endOfHistoryTransferType) {
                default:
                    return "endOfHistoryTransferType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.conversationTimestamp != null && message.hasOwnProperty("conversationTimestamp"))
                if (!$util.isInteger(message.conversationTimestamp) && !(message.conversationTimestamp && $util.isInteger(message.conversationTimestamp.low) && $util.isInteger(message.conversationTimestamp.high)))
                    return "conversationTimestamp: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.pHash != null && message.hasOwnProperty("pHash"))
                if (!$util.isString(message.pHash))
                    return "pHash: string expected";
            if (message.notSpam != null && message.hasOwnProperty("notSpam"))
                if (typeof message.notSpam !== "boolean")
                    return "notSpam: boolean expected";
            if (message.archived != null && message.hasOwnProperty("archived"))
                if (typeof message.archived !== "boolean")
                    return "archived: boolean expected";
            if (message.disappearingMode != null && message.hasOwnProperty("disappearingMode")) {
                var error = $root.proto.DisappearingMode.verify(message.disappearingMode);
                if (error)
                    return "disappearingMode." + error;
            }
            if (message.unreadMentionCount != null && message.hasOwnProperty("unreadMentionCount"))
                if (!$util.isInteger(message.unreadMentionCount))
                    return "unreadMentionCount: integer expected";
            if (message.markedAsUnread != null && message.hasOwnProperty("markedAsUnread"))
                if (typeof message.markedAsUnread !== "boolean")
                    return "markedAsUnread: boolean expected";
            if (message.participant != null && message.hasOwnProperty("participant")) {
                if (!Array.isArray(message.participant))
                    return "participant: array expected";
                for (var i = 0; i < message.participant.length; ++i) {
                    var error = $root.proto.GroupParticipant.verify(message.participant[i]);
                    if (error)
                        return "participant." + error;
                }
            }
            if (message.tcToken != null && message.hasOwnProperty("tcToken"))
                if (!(message.tcToken && typeof message.tcToken.length === "number" || $util.isString(message.tcToken)))
                    return "tcToken: buffer expected";
            if (message.tcTokenTimestamp != null && message.hasOwnProperty("tcTokenTimestamp"))
                if (!$util.isInteger(message.tcTokenTimestamp) && !(message.tcTokenTimestamp && $util.isInteger(message.tcTokenTimestamp.low) && $util.isInteger(message.tcTokenTimestamp.high)))
                    return "tcTokenTimestamp: integer|Long expected";
            if (message.contactPrimaryIdentityKey != null && message.hasOwnProperty("contactPrimaryIdentityKey"))
                if (!(message.contactPrimaryIdentityKey && typeof message.contactPrimaryIdentityKey.length === "number" || $util.isString(message.contactPrimaryIdentityKey)))
                    return "contactPrimaryIdentityKey: buffer expected";
            if (message.pinned != null && message.hasOwnProperty("pinned"))
                if (!$util.isInteger(message.pinned))
                    return "pinned: integer expected";
            if (message.muteEndTime != null && message.hasOwnProperty("muteEndTime"))
                if (!$util.isInteger(message.muteEndTime) && !(message.muteEndTime && $util.isInteger(message.muteEndTime.low) && $util.isInteger(message.muteEndTime.high)))
                    return "muteEndTime: integer|Long expected";
            if (message.wallpaper != null && message.hasOwnProperty("wallpaper")) {
                var error = $root.proto.WallpaperSettings.verify(message.wallpaper);
                if (error)
                    return "wallpaper." + error;
            }
            if (message.mediaVisibility != null && message.hasOwnProperty("mediaVisibility"))
                switch (message.mediaVisibility) {
                default:
                    return "mediaVisibility: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.tcTokenSenderTimestamp != null && message.hasOwnProperty("tcTokenSenderTimestamp"))
                if (!$util.isInteger(message.tcTokenSenderTimestamp) && !(message.tcTokenSenderTimestamp && $util.isInteger(message.tcTokenSenderTimestamp.low) && $util.isInteger(message.tcTokenSenderTimestamp.high)))
                    return "tcTokenSenderTimestamp: integer|Long expected";
            if (message.suspended != null && message.hasOwnProperty("suspended"))
                if (typeof message.suspended !== "boolean")
                    return "suspended: boolean expected";
            if (message.terminated != null && message.hasOwnProperty("terminated"))
                if (typeof message.terminated !== "boolean")
                    return "terminated: boolean expected";
            if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                if (!$util.isInteger(message.createdAt) && !(message.createdAt && $util.isInteger(message.createdAt.low) && $util.isInteger(message.createdAt.high)))
                    return "createdAt: integer|Long expected";
            if (message.createdBy != null && message.hasOwnProperty("createdBy"))
                if (!$util.isString(message.createdBy))
                    return "createdBy: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.support != null && message.hasOwnProperty("support"))
                if (typeof message.support !== "boolean")
                    return "support: boolean expected";
            if (message.isParentGroup != null && message.hasOwnProperty("isParentGroup"))
                if (typeof message.isParentGroup !== "boolean")
                    return "isParentGroup: boolean expected";
            if (message.isDefaultSubgroup != null && message.hasOwnProperty("isDefaultSubgroup"))
                if (typeof message.isDefaultSubgroup !== "boolean")
                    return "isDefaultSubgroup: boolean expected";
            if (message.parentGroupId != null && message.hasOwnProperty("parentGroupId"))
                if (!$util.isString(message.parentGroupId))
                    return "parentGroupId: string expected";
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                if (!$util.isString(message.displayName))
                    return "displayName: string expected";
            if (message.pnJid != null && message.hasOwnProperty("pnJid"))
                if (!$util.isString(message.pnJid))
                    return "pnJid: string expected";
            if (message.shareOwnPn != null && message.hasOwnProperty("shareOwnPn"))
                if (typeof message.shareOwnPn !== "boolean")
                    return "shareOwnPn: boolean expected";
            if (message.pnhDuplicateLidThread != null && message.hasOwnProperty("pnhDuplicateLidThread"))
                if (typeof message.pnhDuplicateLidThread !== "boolean")
                    return "pnhDuplicateLidThread: boolean expected";
            if (message.lidJid != null && message.hasOwnProperty("lidJid"))
                if (!$util.isString(message.lidJid))
                    return "lidJid: string expected";
            return null;
        };

        /**
         * Creates a Conversation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Conversation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Conversation} Conversation
         */
        Conversation.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Conversation)
                return object;
            var message = new $root.proto.Conversation();
            if (object.id != null)
                message.id = String(object.id);
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".proto.Conversation.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i) {
                    if (typeof object.messages[i] !== "object")
                        throw TypeError(".proto.Conversation.messages: object expected");
                    message.messages[i] = $root.proto.HistorySyncMsg.fromObject(object.messages[i]);
                }
            }
            if (object.newJid != null)
                message.newJid = String(object.newJid);
            if (object.oldJid != null)
                message.oldJid = String(object.oldJid);
            if (object.lastMsgTimestamp != null)
                if ($util.Long)
                    (message.lastMsgTimestamp = $util.Long.fromValue(object.lastMsgTimestamp)).unsigned = true;
                else if (typeof object.lastMsgTimestamp === "string")
                    message.lastMsgTimestamp = parseInt(object.lastMsgTimestamp, 10);
                else if (typeof object.lastMsgTimestamp === "number")
                    message.lastMsgTimestamp = object.lastMsgTimestamp;
                else if (typeof object.lastMsgTimestamp === "object")
                    message.lastMsgTimestamp = new $util.LongBits(object.lastMsgTimestamp.low >>> 0, object.lastMsgTimestamp.high >>> 0).toNumber(true);
            if (object.unreadCount != null)
                message.unreadCount = object.unreadCount >>> 0;
            if (object.readOnly != null)
                message.readOnly = Boolean(object.readOnly);
            if (object.endOfHistoryTransfer != null)
                message.endOfHistoryTransfer = Boolean(object.endOfHistoryTransfer);
            if (object.ephemeralExpiration != null)
                message.ephemeralExpiration = object.ephemeralExpiration >>> 0;
            if (object.ephemeralSettingTimestamp != null)
                if ($util.Long)
                    (message.ephemeralSettingTimestamp = $util.Long.fromValue(object.ephemeralSettingTimestamp)).unsigned = false;
                else if (typeof object.ephemeralSettingTimestamp === "string")
                    message.ephemeralSettingTimestamp = parseInt(object.ephemeralSettingTimestamp, 10);
                else if (typeof object.ephemeralSettingTimestamp === "number")
                    message.ephemeralSettingTimestamp = object.ephemeralSettingTimestamp;
                else if (typeof object.ephemeralSettingTimestamp === "object")
                    message.ephemeralSettingTimestamp = new $util.LongBits(object.ephemeralSettingTimestamp.low >>> 0, object.ephemeralSettingTimestamp.high >>> 0).toNumber();
            switch (object.endOfHistoryTransferType) {
            case "COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY":
            case 0:
                message.endOfHistoryTransferType = 0;
                break;
            case "COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY":
            case 1:
                message.endOfHistoryTransferType = 1;
                break;
            }
            if (object.conversationTimestamp != null)
                if ($util.Long)
                    (message.conversationTimestamp = $util.Long.fromValue(object.conversationTimestamp)).unsigned = true;
                else if (typeof object.conversationTimestamp === "string")
                    message.conversationTimestamp = parseInt(object.conversationTimestamp, 10);
                else if (typeof object.conversationTimestamp === "number")
                    message.conversationTimestamp = object.conversationTimestamp;
                else if (typeof object.conversationTimestamp === "object")
                    message.conversationTimestamp = new $util.LongBits(object.conversationTimestamp.low >>> 0, object.conversationTimestamp.high >>> 0).toNumber(true);
            if (object.name != null)
                message.name = String(object.name);
            if (object.pHash != null)
                message.pHash = String(object.pHash);
            if (object.notSpam != null)
                message.notSpam = Boolean(object.notSpam);
            if (object.archived != null)
                message.archived = Boolean(object.archived);
            if (object.disappearingMode != null) {
                if (typeof object.disappearingMode !== "object")
                    throw TypeError(".proto.Conversation.disappearingMode: object expected");
                message.disappearingMode = $root.proto.DisappearingMode.fromObject(object.disappearingMode);
            }
            if (object.unreadMentionCount != null)
                message.unreadMentionCount = object.unreadMentionCount >>> 0;
            if (object.markedAsUnread != null)
                message.markedAsUnread = Boolean(object.markedAsUnread);
            if (object.participant) {
                if (!Array.isArray(object.participant))
                    throw TypeError(".proto.Conversation.participant: array expected");
                message.participant = [];
                for (var i = 0; i < object.participant.length; ++i) {
                    if (typeof object.participant[i] !== "object")
                        throw TypeError(".proto.Conversation.participant: object expected");
                    message.participant[i] = $root.proto.GroupParticipant.fromObject(object.participant[i]);
                }
            }
            if (object.tcToken != null)
                if (typeof object.tcToken === "string")
                    $util.base64.decode(object.tcToken, message.tcToken = $util.newBuffer($util.base64.length(object.tcToken)), 0);
                else if (object.tcToken.length)
                    message.tcToken = object.tcToken;
            if (object.tcTokenTimestamp != null)
                if ($util.Long)
                    (message.tcTokenTimestamp = $util.Long.fromValue(object.tcTokenTimestamp)).unsigned = true;
                else if (typeof object.tcTokenTimestamp === "string")
                    message.tcTokenTimestamp = parseInt(object.tcTokenTimestamp, 10);
                else if (typeof object.tcTokenTimestamp === "number")
                    message.tcTokenTimestamp = object.tcTokenTimestamp;
                else if (typeof object.tcTokenTimestamp === "object")
                    message.tcTokenTimestamp = new $util.LongBits(object.tcTokenTimestamp.low >>> 0, object.tcTokenTimestamp.high >>> 0).toNumber(true);
            if (object.contactPrimaryIdentityKey != null)
                if (typeof object.contactPrimaryIdentityKey === "string")
                    $util.base64.decode(object.contactPrimaryIdentityKey, message.contactPrimaryIdentityKey = $util.newBuffer($util.base64.length(object.contactPrimaryIdentityKey)), 0);
                else if (object.contactPrimaryIdentityKey.length)
                    message.contactPrimaryIdentityKey = object.contactPrimaryIdentityKey;
            if (object.pinned != null)
                message.pinned = object.pinned >>> 0;
            if (object.muteEndTime != null)
                if ($util.Long)
                    (message.muteEndTime = $util.Long.fromValue(object.muteEndTime)).unsigned = true;
                else if (typeof object.muteEndTime === "string")
                    message.muteEndTime = parseInt(object.muteEndTime, 10);
                else if (typeof object.muteEndTime === "number")
                    message.muteEndTime = object.muteEndTime;
                else if (typeof object.muteEndTime === "object")
                    message.muteEndTime = new $util.LongBits(object.muteEndTime.low >>> 0, object.muteEndTime.high >>> 0).toNumber(true);
            if (object.wallpaper != null) {
                if (typeof object.wallpaper !== "object")
                    throw TypeError(".proto.Conversation.wallpaper: object expected");
                message.wallpaper = $root.proto.WallpaperSettings.fromObject(object.wallpaper);
            }
            switch (object.mediaVisibility) {
            case "DEFAULT":
            case 0:
                message.mediaVisibility = 0;
                break;
            case "OFF":
            case 1:
                message.mediaVisibility = 1;
                break;
            case "ON":
            case 2:
                message.mediaVisibility = 2;
                break;
            }
            if (object.tcTokenSenderTimestamp != null)
                if ($util.Long)
                    (message.tcTokenSenderTimestamp = $util.Long.fromValue(object.tcTokenSenderTimestamp)).unsigned = true;
                else if (typeof object.tcTokenSenderTimestamp === "string")
                    message.tcTokenSenderTimestamp = parseInt(object.tcTokenSenderTimestamp, 10);
                else if (typeof object.tcTokenSenderTimestamp === "number")
                    message.tcTokenSenderTimestamp = object.tcTokenSenderTimestamp;
                else if (typeof object.tcTokenSenderTimestamp === "object")
                    message.tcTokenSenderTimestamp = new $util.LongBits(object.tcTokenSenderTimestamp.low >>> 0, object.tcTokenSenderTimestamp.high >>> 0).toNumber(true);
            if (object.suspended != null)
                message.suspended = Boolean(object.suspended);
            if (object.terminated != null)
                message.terminated = Boolean(object.terminated);
            if (object.createdAt != null)
                if ($util.Long)
                    (message.createdAt = $util.Long.fromValue(object.createdAt)).unsigned = true;
                else if (typeof object.createdAt === "string")
                    message.createdAt = parseInt(object.createdAt, 10);
                else if (typeof object.createdAt === "number")
                    message.createdAt = object.createdAt;
                else if (typeof object.createdAt === "object")
                    message.createdAt = new $util.LongBits(object.createdAt.low >>> 0, object.createdAt.high >>> 0).toNumber(true);
            if (object.createdBy != null)
                message.createdBy = String(object.createdBy);
            if (object.description != null)
                message.description = String(object.description);
            if (object.support != null)
                message.support = Boolean(object.support);
            if (object.isParentGroup != null)
                message.isParentGroup = Boolean(object.isParentGroup);
            if (object.isDefaultSubgroup != null)
                message.isDefaultSubgroup = Boolean(object.isDefaultSubgroup);
            if (object.parentGroupId != null)
                message.parentGroupId = String(object.parentGroupId);
            if (object.displayName != null)
                message.displayName = String(object.displayName);
            if (object.pnJid != null)
                message.pnJid = String(object.pnJid);
            if (object.shareOwnPn != null)
                message.shareOwnPn = Boolean(object.shareOwnPn);
            if (object.pnhDuplicateLidThread != null)
                message.pnhDuplicateLidThread = Boolean(object.pnhDuplicateLidThread);
            if (object.lidJid != null)
                message.lidJid = String(object.lidJid);
            return message;
        };

        /**
         * Creates a plain object from a Conversation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Conversation
         * @static
         * @param {proto.Conversation} message Conversation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Conversation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.messages = [];
                object.participant = [];
            }
            if (options.defaults) {
                object.id = "";
                object.newJid = "";
                object.oldJid = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.lastMsgTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastMsgTimestamp = options.longs === String ? "0" : 0;
                object.unreadCount = 0;
                object.readOnly = false;
                object.endOfHistoryTransfer = false;
                object.ephemeralExpiration = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.ephemeralSettingTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ephemeralSettingTimestamp = options.longs === String ? "0" : 0;
                object.endOfHistoryTransferType = options.enums === String ? "COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.conversationTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.conversationTimestamp = options.longs === String ? "0" : 0;
                object.name = "";
                object.pHash = "";
                object.notSpam = false;
                object.archived = false;
                object.disappearingMode = null;
                object.unreadMentionCount = 0;
                object.markedAsUnread = false;
                if (options.bytes === String)
                    object.tcToken = "";
                else {
                    object.tcToken = [];
                    if (options.bytes !== Array)
                        object.tcToken = $util.newBuffer(object.tcToken);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.tcTokenTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tcTokenTimestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.contactPrimaryIdentityKey = "";
                else {
                    object.contactPrimaryIdentityKey = [];
                    if (options.bytes !== Array)
                        object.contactPrimaryIdentityKey = $util.newBuffer(object.contactPrimaryIdentityKey);
                }
                object.pinned = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.muteEndTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.muteEndTime = options.longs === String ? "0" : 0;
                object.wallpaper = null;
                object.mediaVisibility = options.enums === String ? "DEFAULT" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.tcTokenSenderTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tcTokenSenderTimestamp = options.longs === String ? "0" : 0;
                object.suspended = false;
                object.terminated = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.createdAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdAt = options.longs === String ? "0" : 0;
                object.createdBy = "";
                object.description = "";
                object.support = false;
                object.isParentGroup = false;
                object.isDefaultSubgroup = false;
                object.parentGroupId = "";
                object.displayName = "";
                object.pnJid = "";
                object.shareOwnPn = false;
                object.pnhDuplicateLidThread = false;
                object.lidJid = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = $root.proto.HistorySyncMsg.toObject(message.messages[j], options);
            }
            if (message.newJid != null && message.hasOwnProperty("newJid"))
                object.newJid = message.newJid;
            if (message.oldJid != null && message.hasOwnProperty("oldJid"))
                object.oldJid = message.oldJid;
            if (message.lastMsgTimestamp != null && message.hasOwnProperty("lastMsgTimestamp"))
                if (typeof message.lastMsgTimestamp === "number")
                    object.lastMsgTimestamp = options.longs === String ? String(message.lastMsgTimestamp) : message.lastMsgTimestamp;
                else
                    object.lastMsgTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.lastMsgTimestamp) : options.longs === Number ? new $util.LongBits(message.lastMsgTimestamp.low >>> 0, message.lastMsgTimestamp.high >>> 0).toNumber(true) : message.lastMsgTimestamp;
            if (message.unreadCount != null && message.hasOwnProperty("unreadCount"))
                object.unreadCount = message.unreadCount;
            if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                object.readOnly = message.readOnly;
            if (message.endOfHistoryTransfer != null && message.hasOwnProperty("endOfHistoryTransfer"))
                object.endOfHistoryTransfer = message.endOfHistoryTransfer;
            if (message.ephemeralExpiration != null && message.hasOwnProperty("ephemeralExpiration"))
                object.ephemeralExpiration = message.ephemeralExpiration;
            if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                if (typeof message.ephemeralSettingTimestamp === "number")
                    object.ephemeralSettingTimestamp = options.longs === String ? String(message.ephemeralSettingTimestamp) : message.ephemeralSettingTimestamp;
                else
                    object.ephemeralSettingTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.ephemeralSettingTimestamp) : options.longs === Number ? new $util.LongBits(message.ephemeralSettingTimestamp.low >>> 0, message.ephemeralSettingTimestamp.high >>> 0).toNumber() : message.ephemeralSettingTimestamp;
            if (message.endOfHistoryTransferType != null && message.hasOwnProperty("endOfHistoryTransferType"))
                object.endOfHistoryTransferType = options.enums === String ? $root.proto.Conversation.EndOfHistoryTransferType[message.endOfHistoryTransferType] : message.endOfHistoryTransferType;
            if (message.conversationTimestamp != null && message.hasOwnProperty("conversationTimestamp"))
                if (typeof message.conversationTimestamp === "number")
                    object.conversationTimestamp = options.longs === String ? String(message.conversationTimestamp) : message.conversationTimestamp;
                else
                    object.conversationTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.conversationTimestamp) : options.longs === Number ? new $util.LongBits(message.conversationTimestamp.low >>> 0, message.conversationTimestamp.high >>> 0).toNumber(true) : message.conversationTimestamp;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.pHash != null && message.hasOwnProperty("pHash"))
                object.pHash = message.pHash;
            if (message.notSpam != null && message.hasOwnProperty("notSpam"))
                object.notSpam = message.notSpam;
            if (message.archived != null && message.hasOwnProperty("archived"))
                object.archived = message.archived;
            if (message.disappearingMode != null && message.hasOwnProperty("disappearingMode"))
                object.disappearingMode = $root.proto.DisappearingMode.toObject(message.disappearingMode, options);
            if (message.unreadMentionCount != null && message.hasOwnProperty("unreadMentionCount"))
                object.unreadMentionCount = message.unreadMentionCount;
            if (message.markedAsUnread != null && message.hasOwnProperty("markedAsUnread"))
                object.markedAsUnread = message.markedAsUnread;
            if (message.participant && message.participant.length) {
                object.participant = [];
                for (var j = 0; j < message.participant.length; ++j)
                    object.participant[j] = $root.proto.GroupParticipant.toObject(message.participant[j], options);
            }
            if (message.tcToken != null && message.hasOwnProperty("tcToken"))
                object.tcToken = options.bytes === String ? $util.base64.encode(message.tcToken, 0, message.tcToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.tcToken) : message.tcToken;
            if (message.tcTokenTimestamp != null && message.hasOwnProperty("tcTokenTimestamp"))
                if (typeof message.tcTokenTimestamp === "number")
                    object.tcTokenTimestamp = options.longs === String ? String(message.tcTokenTimestamp) : message.tcTokenTimestamp;
                else
                    object.tcTokenTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.tcTokenTimestamp) : options.longs === Number ? new $util.LongBits(message.tcTokenTimestamp.low >>> 0, message.tcTokenTimestamp.high >>> 0).toNumber(true) : message.tcTokenTimestamp;
            if (message.contactPrimaryIdentityKey != null && message.hasOwnProperty("contactPrimaryIdentityKey"))
                object.contactPrimaryIdentityKey = options.bytes === String ? $util.base64.encode(message.contactPrimaryIdentityKey, 0, message.contactPrimaryIdentityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.contactPrimaryIdentityKey) : message.contactPrimaryIdentityKey;
            if (message.pinned != null && message.hasOwnProperty("pinned"))
                object.pinned = message.pinned;
            if (message.muteEndTime != null && message.hasOwnProperty("muteEndTime"))
                if (typeof message.muteEndTime === "number")
                    object.muteEndTime = options.longs === String ? String(message.muteEndTime) : message.muteEndTime;
                else
                    object.muteEndTime = options.longs === String ? $util.Long.prototype.toString.call(message.muteEndTime) : options.longs === Number ? new $util.LongBits(message.muteEndTime.low >>> 0, message.muteEndTime.high >>> 0).toNumber(true) : message.muteEndTime;
            if (message.wallpaper != null && message.hasOwnProperty("wallpaper"))
                object.wallpaper = $root.proto.WallpaperSettings.toObject(message.wallpaper, options);
            if (message.mediaVisibility != null && message.hasOwnProperty("mediaVisibility"))
                object.mediaVisibility = options.enums === String ? $root.proto.MediaVisibility[message.mediaVisibility] : message.mediaVisibility;
            if (message.tcTokenSenderTimestamp != null && message.hasOwnProperty("tcTokenSenderTimestamp"))
                if (typeof message.tcTokenSenderTimestamp === "number")
                    object.tcTokenSenderTimestamp = options.longs === String ? String(message.tcTokenSenderTimestamp) : message.tcTokenSenderTimestamp;
                else
                    object.tcTokenSenderTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.tcTokenSenderTimestamp) : options.longs === Number ? new $util.LongBits(message.tcTokenSenderTimestamp.low >>> 0, message.tcTokenSenderTimestamp.high >>> 0).toNumber(true) : message.tcTokenSenderTimestamp;
            if (message.suspended != null && message.hasOwnProperty("suspended"))
                object.suspended = message.suspended;
            if (message.terminated != null && message.hasOwnProperty("terminated"))
                object.terminated = message.terminated;
            if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                if (typeof message.createdAt === "number")
                    object.createdAt = options.longs === String ? String(message.createdAt) : message.createdAt;
                else
                    object.createdAt = options.longs === String ? $util.Long.prototype.toString.call(message.createdAt) : options.longs === Number ? new $util.LongBits(message.createdAt.low >>> 0, message.createdAt.high >>> 0).toNumber(true) : message.createdAt;
            if (message.createdBy != null && message.hasOwnProperty("createdBy"))
                object.createdBy = message.createdBy;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.support != null && message.hasOwnProperty("support"))
                object.support = message.support;
            if (message.isParentGroup != null && message.hasOwnProperty("isParentGroup"))
                object.isParentGroup = message.isParentGroup;
            if (message.isDefaultSubgroup != null && message.hasOwnProperty("isDefaultSubgroup"))
                object.isDefaultSubgroup = message.isDefaultSubgroup;
            if (message.parentGroupId != null && message.hasOwnProperty("parentGroupId"))
                object.parentGroupId = message.parentGroupId;
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                object.displayName = message.displayName;
            if (message.pnJid != null && message.hasOwnProperty("pnJid"))
                object.pnJid = message.pnJid;
            if (message.shareOwnPn != null && message.hasOwnProperty("shareOwnPn"))
                object.shareOwnPn = message.shareOwnPn;
            if (message.pnhDuplicateLidThread != null && message.hasOwnProperty("pnhDuplicateLidThread"))
                object.pnhDuplicateLidThread = message.pnhDuplicateLidThread;
            if (message.lidJid != null && message.hasOwnProperty("lidJid"))
                object.lidJid = message.lidJid;
            return object;
        };

        /**
         * Converts this Conversation to JSON.
         * @function toJSON
         * @memberof proto.Conversation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Conversation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * EndOfHistoryTransferType enum.
         * @name proto.Conversation.EndOfHistoryTransferType
         * @enum {number}
         * @property {number} COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY=0 COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY value
         * @property {number} COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY=1 COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY value
         */
        Conversation.EndOfHistoryTransferType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY"] = 0;
            values[valuesById[1] = "COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY"] = 1;
            return values;
        })();

        return Conversation;
    })();

    proto.DeviceListMetadata = (function() {

        /**
         * Properties of a DeviceListMetadata.
         * @memberof proto
         * @interface IDeviceListMetadata
         * @property {Uint8Array|null} [senderKeyHash] DeviceListMetadata senderKeyHash
         * @property {number|Long|null} [senderTimestamp] DeviceListMetadata senderTimestamp
         * @property {Array.<number>|null} [senderKeyIndexes] DeviceListMetadata senderKeyIndexes
         * @property {Uint8Array|null} [recipientKeyHash] DeviceListMetadata recipientKeyHash
         * @property {number|Long|null} [recipientTimestamp] DeviceListMetadata recipientTimestamp
         * @property {Array.<number>|null} [recipientKeyIndexes] DeviceListMetadata recipientKeyIndexes
         */

        /**
         * Constructs a new DeviceListMetadata.
         * @memberof proto
         * @classdesc Represents a DeviceListMetadata.
         * @implements IDeviceListMetadata
         * @constructor
         * @param {proto.IDeviceListMetadata=} [properties] Properties to set
         */
        function DeviceListMetadata(properties) {
            this.senderKeyIndexes = [];
            this.recipientKeyIndexes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceListMetadata senderKeyHash.
         * @member {Uint8Array} senderKeyHash
         * @memberof proto.DeviceListMetadata
         * @instance
         */
        DeviceListMetadata.prototype.senderKeyHash = $util.newBuffer([]);

        /**
         * DeviceListMetadata senderTimestamp.
         * @member {number|Long} senderTimestamp
         * @memberof proto.DeviceListMetadata
         * @instance
         */
        DeviceListMetadata.prototype.senderTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DeviceListMetadata senderKeyIndexes.
         * @member {Array.<number>} senderKeyIndexes
         * @memberof proto.DeviceListMetadata
         * @instance
         */
        DeviceListMetadata.prototype.senderKeyIndexes = $util.emptyArray;

        /**
         * DeviceListMetadata recipientKeyHash.
         * @member {Uint8Array} recipientKeyHash
         * @memberof proto.DeviceListMetadata
         * @instance
         */
        DeviceListMetadata.prototype.recipientKeyHash = $util.newBuffer([]);

        /**
         * DeviceListMetadata recipientTimestamp.
         * @member {number|Long} recipientTimestamp
         * @memberof proto.DeviceListMetadata
         * @instance
         */
        DeviceListMetadata.prototype.recipientTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DeviceListMetadata recipientKeyIndexes.
         * @member {Array.<number>} recipientKeyIndexes
         * @memberof proto.DeviceListMetadata
         * @instance
         */
        DeviceListMetadata.prototype.recipientKeyIndexes = $util.emptyArray;

        /**
         * Creates a new DeviceListMetadata instance using the specified properties.
         * @function create
         * @memberof proto.DeviceListMetadata
         * @static
         * @param {proto.IDeviceListMetadata=} [properties] Properties to set
         * @returns {proto.DeviceListMetadata} DeviceListMetadata instance
         */
        DeviceListMetadata.create = function create(properties) {
            return new DeviceListMetadata(properties);
        };

        /**
         * Encodes the specified DeviceListMetadata message. Does not implicitly {@link proto.DeviceListMetadata.verify|verify} messages.
         * @function encode
         * @memberof proto.DeviceListMetadata
         * @static
         * @param {proto.IDeviceListMetadata} message DeviceListMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceListMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderKeyHash != null && Object.hasOwnProperty.call(message, "senderKeyHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.senderKeyHash);
            if (message.senderTimestamp != null && Object.hasOwnProperty.call(message, "senderTimestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.senderTimestamp);
            if (message.senderKeyIndexes != null && message.senderKeyIndexes.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.senderKeyIndexes.length; ++i)
                    writer.uint32(message.senderKeyIndexes[i]);
                writer.ldelim();
            }
            if (message.recipientKeyHash != null && Object.hasOwnProperty.call(message, "recipientKeyHash"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.recipientKeyHash);
            if (message.recipientTimestamp != null && Object.hasOwnProperty.call(message, "recipientTimestamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.recipientTimestamp);
            if (message.recipientKeyIndexes != null && message.recipientKeyIndexes.length) {
                writer.uint32(/* id 10, wireType 2 =*/82).fork();
                for (var i = 0; i < message.recipientKeyIndexes.length; ++i)
                    writer.uint32(message.recipientKeyIndexes[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified DeviceListMetadata message, length delimited. Does not implicitly {@link proto.DeviceListMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.DeviceListMetadata
         * @static
         * @param {proto.IDeviceListMetadata} message DeviceListMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceListMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceListMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof proto.DeviceListMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.DeviceListMetadata} DeviceListMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceListMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.DeviceListMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.senderKeyHash = reader.bytes();
                    break;
                case 2:
                    message.senderTimestamp = reader.uint64();
                    break;
                case 3:
                    if (!(message.senderKeyIndexes && message.senderKeyIndexes.length))
                        message.senderKeyIndexes = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.senderKeyIndexes.push(reader.uint32());
                    } else
                        message.senderKeyIndexes.push(reader.uint32());
                    break;
                case 8:
                    message.recipientKeyHash = reader.bytes();
                    break;
                case 9:
                    message.recipientTimestamp = reader.uint64();
                    break;
                case 10:
                    if (!(message.recipientKeyIndexes && message.recipientKeyIndexes.length))
                        message.recipientKeyIndexes = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.recipientKeyIndexes.push(reader.uint32());
                    } else
                        message.recipientKeyIndexes.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceListMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.DeviceListMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.DeviceListMetadata} DeviceListMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceListMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceListMetadata message.
         * @function verify
         * @memberof proto.DeviceListMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceListMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderKeyHash != null && message.hasOwnProperty("senderKeyHash"))
                if (!(message.senderKeyHash && typeof message.senderKeyHash.length === "number" || $util.isString(message.senderKeyHash)))
                    return "senderKeyHash: buffer expected";
            if (message.senderTimestamp != null && message.hasOwnProperty("senderTimestamp"))
                if (!$util.isInteger(message.senderTimestamp) && !(message.senderTimestamp && $util.isInteger(message.senderTimestamp.low) && $util.isInteger(message.senderTimestamp.high)))
                    return "senderTimestamp: integer|Long expected";
            if (message.senderKeyIndexes != null && message.hasOwnProperty("senderKeyIndexes")) {
                if (!Array.isArray(message.senderKeyIndexes))
                    return "senderKeyIndexes: array expected";
                for (var i = 0; i < message.senderKeyIndexes.length; ++i)
                    if (!$util.isInteger(message.senderKeyIndexes[i]))
                        return "senderKeyIndexes: integer[] expected";
            }
            if (message.recipientKeyHash != null && message.hasOwnProperty("recipientKeyHash"))
                if (!(message.recipientKeyHash && typeof message.recipientKeyHash.length === "number" || $util.isString(message.recipientKeyHash)))
                    return "recipientKeyHash: buffer expected";
            if (message.recipientTimestamp != null && message.hasOwnProperty("recipientTimestamp"))
                if (!$util.isInteger(message.recipientTimestamp) && !(message.recipientTimestamp && $util.isInteger(message.recipientTimestamp.low) && $util.isInteger(message.recipientTimestamp.high)))
                    return "recipientTimestamp: integer|Long expected";
            if (message.recipientKeyIndexes != null && message.hasOwnProperty("recipientKeyIndexes")) {
                if (!Array.isArray(message.recipientKeyIndexes))
                    return "recipientKeyIndexes: array expected";
                for (var i = 0; i < message.recipientKeyIndexes.length; ++i)
                    if (!$util.isInteger(message.recipientKeyIndexes[i]))
                        return "recipientKeyIndexes: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a DeviceListMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.DeviceListMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.DeviceListMetadata} DeviceListMetadata
         */
        DeviceListMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.DeviceListMetadata)
                return object;
            var message = new $root.proto.DeviceListMetadata();
            if (object.senderKeyHash != null)
                if (typeof object.senderKeyHash === "string")
                    $util.base64.decode(object.senderKeyHash, message.senderKeyHash = $util.newBuffer($util.base64.length(object.senderKeyHash)), 0);
                else if (object.senderKeyHash.length)
                    message.senderKeyHash = object.senderKeyHash;
            if (object.senderTimestamp != null)
                if ($util.Long)
                    (message.senderTimestamp = $util.Long.fromValue(object.senderTimestamp)).unsigned = true;
                else if (typeof object.senderTimestamp === "string")
                    message.senderTimestamp = parseInt(object.senderTimestamp, 10);
                else if (typeof object.senderTimestamp === "number")
                    message.senderTimestamp = object.senderTimestamp;
                else if (typeof object.senderTimestamp === "object")
                    message.senderTimestamp = new $util.LongBits(object.senderTimestamp.low >>> 0, object.senderTimestamp.high >>> 0).toNumber(true);
            if (object.senderKeyIndexes) {
                if (!Array.isArray(object.senderKeyIndexes))
                    throw TypeError(".proto.DeviceListMetadata.senderKeyIndexes: array expected");
                message.senderKeyIndexes = [];
                for (var i = 0; i < object.senderKeyIndexes.length; ++i)
                    message.senderKeyIndexes[i] = object.senderKeyIndexes[i] >>> 0;
            }
            if (object.recipientKeyHash != null)
                if (typeof object.recipientKeyHash === "string")
                    $util.base64.decode(object.recipientKeyHash, message.recipientKeyHash = $util.newBuffer($util.base64.length(object.recipientKeyHash)), 0);
                else if (object.recipientKeyHash.length)
                    message.recipientKeyHash = object.recipientKeyHash;
            if (object.recipientTimestamp != null)
                if ($util.Long)
                    (message.recipientTimestamp = $util.Long.fromValue(object.recipientTimestamp)).unsigned = true;
                else if (typeof object.recipientTimestamp === "string")
                    message.recipientTimestamp = parseInt(object.recipientTimestamp, 10);
                else if (typeof object.recipientTimestamp === "number")
                    message.recipientTimestamp = object.recipientTimestamp;
                else if (typeof object.recipientTimestamp === "object")
                    message.recipientTimestamp = new $util.LongBits(object.recipientTimestamp.low >>> 0, object.recipientTimestamp.high >>> 0).toNumber(true);
            if (object.recipientKeyIndexes) {
                if (!Array.isArray(object.recipientKeyIndexes))
                    throw TypeError(".proto.DeviceListMetadata.recipientKeyIndexes: array expected");
                message.recipientKeyIndexes = [];
                for (var i = 0; i < object.recipientKeyIndexes.length; ++i)
                    message.recipientKeyIndexes[i] = object.recipientKeyIndexes[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceListMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.DeviceListMetadata
         * @static
         * @param {proto.DeviceListMetadata} message DeviceListMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceListMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.senderKeyIndexes = [];
                object.recipientKeyIndexes = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.senderKeyHash = "";
                else {
                    object.senderKeyHash = [];
                    if (options.bytes !== Array)
                        object.senderKeyHash = $util.newBuffer(object.senderKeyHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.senderTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.senderTimestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.recipientKeyHash = "";
                else {
                    object.recipientKeyHash = [];
                    if (options.bytes !== Array)
                        object.recipientKeyHash = $util.newBuffer(object.recipientKeyHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.recipientTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.recipientTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.senderKeyHash != null && message.hasOwnProperty("senderKeyHash"))
                object.senderKeyHash = options.bytes === String ? $util.base64.encode(message.senderKeyHash, 0, message.senderKeyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderKeyHash) : message.senderKeyHash;
            if (message.senderTimestamp != null && message.hasOwnProperty("senderTimestamp"))
                if (typeof message.senderTimestamp === "number")
                    object.senderTimestamp = options.longs === String ? String(message.senderTimestamp) : message.senderTimestamp;
                else
                    object.senderTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.senderTimestamp) : options.longs === Number ? new $util.LongBits(message.senderTimestamp.low >>> 0, message.senderTimestamp.high >>> 0).toNumber(true) : message.senderTimestamp;
            if (message.senderKeyIndexes && message.senderKeyIndexes.length) {
                object.senderKeyIndexes = [];
                for (var j = 0; j < message.senderKeyIndexes.length; ++j)
                    object.senderKeyIndexes[j] = message.senderKeyIndexes[j];
            }
            if (message.recipientKeyHash != null && message.hasOwnProperty("recipientKeyHash"))
                object.recipientKeyHash = options.bytes === String ? $util.base64.encode(message.recipientKeyHash, 0, message.recipientKeyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipientKeyHash) : message.recipientKeyHash;
            if (message.recipientTimestamp != null && message.hasOwnProperty("recipientTimestamp"))
                if (typeof message.recipientTimestamp === "number")
                    object.recipientTimestamp = options.longs === String ? String(message.recipientTimestamp) : message.recipientTimestamp;
                else
                    object.recipientTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.recipientTimestamp) : options.longs === Number ? new $util.LongBits(message.recipientTimestamp.low >>> 0, message.recipientTimestamp.high >>> 0).toNumber(true) : message.recipientTimestamp;
            if (message.recipientKeyIndexes && message.recipientKeyIndexes.length) {
                object.recipientKeyIndexes = [];
                for (var j = 0; j < message.recipientKeyIndexes.length; ++j)
                    object.recipientKeyIndexes[j] = message.recipientKeyIndexes[j];
            }
            return object;
        };

        /**
         * Converts this DeviceListMetadata to JSON.
         * @function toJSON
         * @memberof proto.DeviceListMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceListMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceListMetadata;
    })();

    proto.DeviceProps = (function() {

        /**
         * Properties of a DeviceProps.
         * @memberof proto
         * @interface IDeviceProps
         * @property {string|null} [os] DeviceProps os
         * @property {proto.DeviceProps.IAppVersion|null} [version] DeviceProps version
         * @property {proto.DeviceProps.PlatformType|null} [platformType] DeviceProps platformType
         * @property {boolean|null} [requireFullSync] DeviceProps requireFullSync
         * @property {proto.DeviceProps.IHistorySyncConfig|null} [historySyncConfig] DeviceProps historySyncConfig
         */

        /**
         * Constructs a new DeviceProps.
         * @memberof proto
         * @classdesc Represents a DeviceProps.
         * @implements IDeviceProps
         * @constructor
         * @param {proto.IDeviceProps=} [properties] Properties to set
         */
        function DeviceProps(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceProps os.
         * @member {string} os
         * @memberof proto.DeviceProps
         * @instance
         */
        DeviceProps.prototype.os = "";

        /**
         * DeviceProps version.
         * @member {proto.DeviceProps.IAppVersion|null|undefined} version
         * @memberof proto.DeviceProps
         * @instance
         */
        DeviceProps.prototype.version = null;

        /**
         * DeviceProps platformType.
         * @member {proto.DeviceProps.PlatformType} platformType
         * @memberof proto.DeviceProps
         * @instance
         */
        DeviceProps.prototype.platformType = 0;

        /**
         * DeviceProps requireFullSync.
         * @member {boolean} requireFullSync
         * @memberof proto.DeviceProps
         * @instance
         */
        DeviceProps.prototype.requireFullSync = false;

        /**
         * DeviceProps historySyncConfig.
         * @member {proto.DeviceProps.IHistorySyncConfig|null|undefined} historySyncConfig
         * @memberof proto.DeviceProps
         * @instance
         */
        DeviceProps.prototype.historySyncConfig = null;

        /**
         * Creates a new DeviceProps instance using the specified properties.
         * @function create
         * @memberof proto.DeviceProps
         * @static
         * @param {proto.IDeviceProps=} [properties] Properties to set
         * @returns {proto.DeviceProps} DeviceProps instance
         */
        DeviceProps.create = function create(properties) {
            return new DeviceProps(properties);
        };

        /**
         * Encodes the specified DeviceProps message. Does not implicitly {@link proto.DeviceProps.verify|verify} messages.
         * @function encode
         * @memberof proto.DeviceProps
         * @static
         * @param {proto.IDeviceProps} message DeviceProps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceProps.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.os != null && Object.hasOwnProperty.call(message, "os"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.os);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                $root.proto.DeviceProps.AppVersion.encode(message.version, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.platformType != null && Object.hasOwnProperty.call(message, "platformType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.platformType);
            if (message.requireFullSync != null && Object.hasOwnProperty.call(message, "requireFullSync"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.requireFullSync);
            if (message.historySyncConfig != null && Object.hasOwnProperty.call(message, "historySyncConfig"))
                $root.proto.DeviceProps.HistorySyncConfig.encode(message.historySyncConfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeviceProps message, length delimited. Does not implicitly {@link proto.DeviceProps.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.DeviceProps
         * @static
         * @param {proto.IDeviceProps} message DeviceProps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceProps.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceProps message from the specified reader or buffer.
         * @function decode
         * @memberof proto.DeviceProps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.DeviceProps} DeviceProps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceProps.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.DeviceProps();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.os = reader.string();
                    break;
                case 2:
                    message.version = $root.proto.DeviceProps.AppVersion.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.platformType = reader.int32();
                    break;
                case 4:
                    message.requireFullSync = reader.bool();
                    break;
                case 5:
                    message.historySyncConfig = $root.proto.DeviceProps.HistorySyncConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceProps message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.DeviceProps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.DeviceProps} DeviceProps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceProps.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceProps message.
         * @function verify
         * @memberof proto.DeviceProps
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceProps.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.os != null && message.hasOwnProperty("os"))
                if (!$util.isString(message.os))
                    return "os: string expected";
            if (message.version != null && message.hasOwnProperty("version")) {
                var error = $root.proto.DeviceProps.AppVersion.verify(message.version);
                if (error)
                    return "version." + error;
            }
            if (message.platformType != null && message.hasOwnProperty("platformType"))
                switch (message.platformType) {
                default:
                    return "platformType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                    break;
                }
            if (message.requireFullSync != null && message.hasOwnProperty("requireFullSync"))
                if (typeof message.requireFullSync !== "boolean")
                    return "requireFullSync: boolean expected";
            if (message.historySyncConfig != null && message.hasOwnProperty("historySyncConfig")) {
                var error = $root.proto.DeviceProps.HistorySyncConfig.verify(message.historySyncConfig);
                if (error)
                    return "historySyncConfig." + error;
            }
            return null;
        };

        /**
         * Creates a DeviceProps message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.DeviceProps
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.DeviceProps} DeviceProps
         */
        DeviceProps.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.DeviceProps)
                return object;
            var message = new $root.proto.DeviceProps();
            if (object.os != null)
                message.os = String(object.os);
            if (object.version != null) {
                if (typeof object.version !== "object")
                    throw TypeError(".proto.DeviceProps.version: object expected");
                message.version = $root.proto.DeviceProps.AppVersion.fromObject(object.version);
            }
            switch (object.platformType) {
            case "UNKNOWN":
            case 0:
                message.platformType = 0;
                break;
            case "CHROME":
            case 1:
                message.platformType = 1;
                break;
            case "FIREFOX":
            case 2:
                message.platformType = 2;
                break;
            case "IE":
            case 3:
                message.platformType = 3;
                break;
            case "OPERA":
            case 4:
                message.platformType = 4;
                break;
            case "SAFARI":
            case 5:
                message.platformType = 5;
                break;
            case "EDGE":
            case 6:
                message.platformType = 6;
                break;
            case "DESKTOP":
            case 7:
                message.platformType = 7;
                break;
            case "IPAD":
            case 8:
                message.platformType = 8;
                break;
            case "ANDROID_TABLET":
            case 9:
                message.platformType = 9;
                break;
            case "OHANA":
            case 10:
                message.platformType = 10;
                break;
            case "ALOHA":
            case 11:
                message.platformType = 11;
                break;
            case "CATALINA":
            case 12:
                message.platformType = 12;
                break;
            case "TCL_TV":
            case 13:
                message.platformType = 13;
                break;
            }
            if (object.requireFullSync != null)
                message.requireFullSync = Boolean(object.requireFullSync);
            if (object.historySyncConfig != null) {
                if (typeof object.historySyncConfig !== "object")
                    throw TypeError(".proto.DeviceProps.historySyncConfig: object expected");
                message.historySyncConfig = $root.proto.DeviceProps.HistorySyncConfig.fromObject(object.historySyncConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceProps message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.DeviceProps
         * @static
         * @param {proto.DeviceProps} message DeviceProps
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceProps.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.os = "";
                object.version = null;
                object.platformType = options.enums === String ? "UNKNOWN" : 0;
                object.requireFullSync = false;
                object.historySyncConfig = null;
            }
            if (message.os != null && message.hasOwnProperty("os"))
                object.os = message.os;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = $root.proto.DeviceProps.AppVersion.toObject(message.version, options);
            if (message.platformType != null && message.hasOwnProperty("platformType"))
                object.platformType = options.enums === String ? $root.proto.DeviceProps.PlatformType[message.platformType] : message.platformType;
            if (message.requireFullSync != null && message.hasOwnProperty("requireFullSync"))
                object.requireFullSync = message.requireFullSync;
            if (message.historySyncConfig != null && message.hasOwnProperty("historySyncConfig"))
                object.historySyncConfig = $root.proto.DeviceProps.HistorySyncConfig.toObject(message.historySyncConfig, options);
            return object;
        };

        /**
         * Converts this DeviceProps to JSON.
         * @function toJSON
         * @memberof proto.DeviceProps
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceProps.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        DeviceProps.AppVersion = (function() {

            /**
             * Properties of an AppVersion.
             * @memberof proto.DeviceProps
             * @interface IAppVersion
             * @property {number|null} [primary] AppVersion primary
             * @property {number|null} [secondary] AppVersion secondary
             * @property {number|null} [tertiary] AppVersion tertiary
             * @property {number|null} [quaternary] AppVersion quaternary
             * @property {number|null} [quinary] AppVersion quinary
             */

            /**
             * Constructs a new AppVersion.
             * @memberof proto.DeviceProps
             * @classdesc Represents an AppVersion.
             * @implements IAppVersion
             * @constructor
             * @param {proto.DeviceProps.IAppVersion=} [properties] Properties to set
             */
            function AppVersion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppVersion primary.
             * @member {number} primary
             * @memberof proto.DeviceProps.AppVersion
             * @instance
             */
            AppVersion.prototype.primary = 0;

            /**
             * AppVersion secondary.
             * @member {number} secondary
             * @memberof proto.DeviceProps.AppVersion
             * @instance
             */
            AppVersion.prototype.secondary = 0;

            /**
             * AppVersion tertiary.
             * @member {number} tertiary
             * @memberof proto.DeviceProps.AppVersion
             * @instance
             */
            AppVersion.prototype.tertiary = 0;

            /**
             * AppVersion quaternary.
             * @member {number} quaternary
             * @memberof proto.DeviceProps.AppVersion
             * @instance
             */
            AppVersion.prototype.quaternary = 0;

            /**
             * AppVersion quinary.
             * @member {number} quinary
             * @memberof proto.DeviceProps.AppVersion
             * @instance
             */
            AppVersion.prototype.quinary = 0;

            /**
             * Creates a new AppVersion instance using the specified properties.
             * @function create
             * @memberof proto.DeviceProps.AppVersion
             * @static
             * @param {proto.DeviceProps.IAppVersion=} [properties] Properties to set
             * @returns {proto.DeviceProps.AppVersion} AppVersion instance
             */
            AppVersion.create = function create(properties) {
                return new AppVersion(properties);
            };

            /**
             * Encodes the specified AppVersion message. Does not implicitly {@link proto.DeviceProps.AppVersion.verify|verify} messages.
             * @function encode
             * @memberof proto.DeviceProps.AppVersion
             * @static
             * @param {proto.DeviceProps.IAppVersion} message AppVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppVersion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.primary);
                if (message.secondary != null && Object.hasOwnProperty.call(message, "secondary"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.secondary);
                if (message.tertiary != null && Object.hasOwnProperty.call(message, "tertiary"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tertiary);
                if (message.quaternary != null && Object.hasOwnProperty.call(message, "quaternary"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.quaternary);
                if (message.quinary != null && Object.hasOwnProperty.call(message, "quinary"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.quinary);
                return writer;
            };

            /**
             * Encodes the specified AppVersion message, length delimited. Does not implicitly {@link proto.DeviceProps.AppVersion.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.DeviceProps.AppVersion
             * @static
             * @param {proto.DeviceProps.IAppVersion} message AppVersion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppVersion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppVersion message from the specified reader or buffer.
             * @function decode
             * @memberof proto.DeviceProps.AppVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.DeviceProps.AppVersion} AppVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppVersion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.DeviceProps.AppVersion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.primary = reader.uint32();
                        break;
                    case 2:
                        message.secondary = reader.uint32();
                        break;
                    case 3:
                        message.tertiary = reader.uint32();
                        break;
                    case 4:
                        message.quaternary = reader.uint32();
                        break;
                    case 5:
                        message.quinary = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppVersion message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.DeviceProps.AppVersion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.DeviceProps.AppVersion} AppVersion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppVersion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppVersion message.
             * @function verify
             * @memberof proto.DeviceProps.AppVersion
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppVersion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.primary != null && message.hasOwnProperty("primary"))
                    if (!$util.isInteger(message.primary))
                        return "primary: integer expected";
                if (message.secondary != null && message.hasOwnProperty("secondary"))
                    if (!$util.isInteger(message.secondary))
                        return "secondary: integer expected";
                if (message.tertiary != null && message.hasOwnProperty("tertiary"))
                    if (!$util.isInteger(message.tertiary))
                        return "tertiary: integer expected";
                if (message.quaternary != null && message.hasOwnProperty("quaternary"))
                    if (!$util.isInteger(message.quaternary))
                        return "quaternary: integer expected";
                if (message.quinary != null && message.hasOwnProperty("quinary"))
                    if (!$util.isInteger(message.quinary))
                        return "quinary: integer expected";
                return null;
            };

            /**
             * Creates an AppVersion message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.DeviceProps.AppVersion
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.DeviceProps.AppVersion} AppVersion
             */
            AppVersion.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.DeviceProps.AppVersion)
                    return object;
                var message = new $root.proto.DeviceProps.AppVersion();
                if (object.primary != null)
                    message.primary = object.primary >>> 0;
                if (object.secondary != null)
                    message.secondary = object.secondary >>> 0;
                if (object.tertiary != null)
                    message.tertiary = object.tertiary >>> 0;
                if (object.quaternary != null)
                    message.quaternary = object.quaternary >>> 0;
                if (object.quinary != null)
                    message.quinary = object.quinary >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AppVersion message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.DeviceProps.AppVersion
             * @static
             * @param {proto.DeviceProps.AppVersion} message AppVersion
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppVersion.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.primary = 0;
                    object.secondary = 0;
                    object.tertiary = 0;
                    object.quaternary = 0;
                    object.quinary = 0;
                }
                if (message.primary != null && message.hasOwnProperty("primary"))
                    object.primary = message.primary;
                if (message.secondary != null && message.hasOwnProperty("secondary"))
                    object.secondary = message.secondary;
                if (message.tertiary != null && message.hasOwnProperty("tertiary"))
                    object.tertiary = message.tertiary;
                if (message.quaternary != null && message.hasOwnProperty("quaternary"))
                    object.quaternary = message.quaternary;
                if (message.quinary != null && message.hasOwnProperty("quinary"))
                    object.quinary = message.quinary;
                return object;
            };

            /**
             * Converts this AppVersion to JSON.
             * @function toJSON
             * @memberof proto.DeviceProps.AppVersion
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppVersion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppVersion;
        })();

        DeviceProps.HistorySyncConfig = (function() {

            /**
             * Properties of a HistorySyncConfig.
             * @memberof proto.DeviceProps
             * @interface IHistorySyncConfig
             * @property {number|null} [fullSyncDaysLimit] HistorySyncConfig fullSyncDaysLimit
             * @property {number|null} [fullSyncSizeMbLimit] HistorySyncConfig fullSyncSizeMbLimit
             * @property {number|null} [storageQuotaMb] HistorySyncConfig storageQuotaMb
             */

            /**
             * Constructs a new HistorySyncConfig.
             * @memberof proto.DeviceProps
             * @classdesc Represents a HistorySyncConfig.
             * @implements IHistorySyncConfig
             * @constructor
             * @param {proto.DeviceProps.IHistorySyncConfig=} [properties] Properties to set
             */
            function HistorySyncConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HistorySyncConfig fullSyncDaysLimit.
             * @member {number} fullSyncDaysLimit
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @instance
             */
            HistorySyncConfig.prototype.fullSyncDaysLimit = 0;

            /**
             * HistorySyncConfig fullSyncSizeMbLimit.
             * @member {number} fullSyncSizeMbLimit
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @instance
             */
            HistorySyncConfig.prototype.fullSyncSizeMbLimit = 0;

            /**
             * HistorySyncConfig storageQuotaMb.
             * @member {number} storageQuotaMb
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @instance
             */
            HistorySyncConfig.prototype.storageQuotaMb = 0;

            /**
             * Creates a new HistorySyncConfig instance using the specified properties.
             * @function create
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @static
             * @param {proto.DeviceProps.IHistorySyncConfig=} [properties] Properties to set
             * @returns {proto.DeviceProps.HistorySyncConfig} HistorySyncConfig instance
             */
            HistorySyncConfig.create = function create(properties) {
                return new HistorySyncConfig(properties);
            };

            /**
             * Encodes the specified HistorySyncConfig message. Does not implicitly {@link proto.DeviceProps.HistorySyncConfig.verify|verify} messages.
             * @function encode
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @static
             * @param {proto.DeviceProps.IHistorySyncConfig} message HistorySyncConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HistorySyncConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fullSyncDaysLimit != null && Object.hasOwnProperty.call(message, "fullSyncDaysLimit"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fullSyncDaysLimit);
                if (message.fullSyncSizeMbLimit != null && Object.hasOwnProperty.call(message, "fullSyncSizeMbLimit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fullSyncSizeMbLimit);
                if (message.storageQuotaMb != null && Object.hasOwnProperty.call(message, "storageQuotaMb"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.storageQuotaMb);
                return writer;
            };

            /**
             * Encodes the specified HistorySyncConfig message, length delimited. Does not implicitly {@link proto.DeviceProps.HistorySyncConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @static
             * @param {proto.DeviceProps.IHistorySyncConfig} message HistorySyncConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HistorySyncConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HistorySyncConfig message from the specified reader or buffer.
             * @function decode
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.DeviceProps.HistorySyncConfig} HistorySyncConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HistorySyncConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.DeviceProps.HistorySyncConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fullSyncDaysLimit = reader.uint32();
                        break;
                    case 2:
                        message.fullSyncSizeMbLimit = reader.uint32();
                        break;
                    case 3:
                        message.storageQuotaMb = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HistorySyncConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.DeviceProps.HistorySyncConfig} HistorySyncConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HistorySyncConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HistorySyncConfig message.
             * @function verify
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HistorySyncConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fullSyncDaysLimit != null && message.hasOwnProperty("fullSyncDaysLimit"))
                    if (!$util.isInteger(message.fullSyncDaysLimit))
                        return "fullSyncDaysLimit: integer expected";
                if (message.fullSyncSizeMbLimit != null && message.hasOwnProperty("fullSyncSizeMbLimit"))
                    if (!$util.isInteger(message.fullSyncSizeMbLimit))
                        return "fullSyncSizeMbLimit: integer expected";
                if (message.storageQuotaMb != null && message.hasOwnProperty("storageQuotaMb"))
                    if (!$util.isInteger(message.storageQuotaMb))
                        return "storageQuotaMb: integer expected";
                return null;
            };

            /**
             * Creates a HistorySyncConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.DeviceProps.HistorySyncConfig} HistorySyncConfig
             */
            HistorySyncConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.DeviceProps.HistorySyncConfig)
                    return object;
                var message = new $root.proto.DeviceProps.HistorySyncConfig();
                if (object.fullSyncDaysLimit != null)
                    message.fullSyncDaysLimit = object.fullSyncDaysLimit >>> 0;
                if (object.fullSyncSizeMbLimit != null)
                    message.fullSyncSizeMbLimit = object.fullSyncSizeMbLimit >>> 0;
                if (object.storageQuotaMb != null)
                    message.storageQuotaMb = object.storageQuotaMb >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a HistorySyncConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @static
             * @param {proto.DeviceProps.HistorySyncConfig} message HistorySyncConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HistorySyncConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fullSyncDaysLimit = 0;
                    object.fullSyncSizeMbLimit = 0;
                    object.storageQuotaMb = 0;
                }
                if (message.fullSyncDaysLimit != null && message.hasOwnProperty("fullSyncDaysLimit"))
                    object.fullSyncDaysLimit = message.fullSyncDaysLimit;
                if (message.fullSyncSizeMbLimit != null && message.hasOwnProperty("fullSyncSizeMbLimit"))
                    object.fullSyncSizeMbLimit = message.fullSyncSizeMbLimit;
                if (message.storageQuotaMb != null && message.hasOwnProperty("storageQuotaMb"))
                    object.storageQuotaMb = message.storageQuotaMb;
                return object;
            };

            /**
             * Converts this HistorySyncConfig to JSON.
             * @function toJSON
             * @memberof proto.DeviceProps.HistorySyncConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HistorySyncConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HistorySyncConfig;
        })();

        /**
         * PlatformType enum.
         * @name proto.DeviceProps.PlatformType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CHROME=1 CHROME value
         * @property {number} FIREFOX=2 FIREFOX value
         * @property {number} IE=3 IE value
         * @property {number} OPERA=4 OPERA value
         * @property {number} SAFARI=5 SAFARI value
         * @property {number} EDGE=6 EDGE value
         * @property {number} DESKTOP=7 DESKTOP value
         * @property {number} IPAD=8 IPAD value
         * @property {number} ANDROID_TABLET=9 ANDROID_TABLET value
         * @property {number} OHANA=10 OHANA value
         * @property {number} ALOHA=11 ALOHA value
         * @property {number} CATALINA=12 CATALINA value
         * @property {number} TCL_TV=13 TCL_TV value
         */
        DeviceProps.PlatformType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "CHROME"] = 1;
            values[valuesById[2] = "FIREFOX"] = 2;
            values[valuesById[3] = "IE"] = 3;
            values[valuesById[4] = "OPERA"] = 4;
            values[valuesById[5] = "SAFARI"] = 5;
            values[valuesById[6] = "EDGE"] = 6;
            values[valuesById[7] = "DESKTOP"] = 7;
            values[valuesById[8] = "IPAD"] = 8;
            values[valuesById[9] = "ANDROID_TABLET"] = 9;
            values[valuesById[10] = "OHANA"] = 10;
            values[valuesById[11] = "ALOHA"] = 11;
            values[valuesById[12] = "CATALINA"] = 12;
            values[valuesById[13] = "TCL_TV"] = 13;
            return values;
        })();

        return DeviceProps;
    })();

    proto.DisappearingMode = (function() {

        /**
         * Properties of a DisappearingMode.
         * @memberof proto
         * @interface IDisappearingMode
         * @property {proto.DisappearingMode.Initiator|null} [initiator] DisappearingMode initiator
         */

        /**
         * Constructs a new DisappearingMode.
         * @memberof proto
         * @classdesc Represents a DisappearingMode.
         * @implements IDisappearingMode
         * @constructor
         * @param {proto.IDisappearingMode=} [properties] Properties to set
         */
        function DisappearingMode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DisappearingMode initiator.
         * @member {proto.DisappearingMode.Initiator} initiator
         * @memberof proto.DisappearingMode
         * @instance
         */
        DisappearingMode.prototype.initiator = 0;

        /**
         * Creates a new DisappearingMode instance using the specified properties.
         * @function create
         * @memberof proto.DisappearingMode
         * @static
         * @param {proto.IDisappearingMode=} [properties] Properties to set
         * @returns {proto.DisappearingMode} DisappearingMode instance
         */
        DisappearingMode.create = function create(properties) {
            return new DisappearingMode(properties);
        };

        /**
         * Encodes the specified DisappearingMode message. Does not implicitly {@link proto.DisappearingMode.verify|verify} messages.
         * @function encode
         * @memberof proto.DisappearingMode
         * @static
         * @param {proto.IDisappearingMode} message DisappearingMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisappearingMode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.initiator != null && Object.hasOwnProperty.call(message, "initiator"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.initiator);
            return writer;
        };

        /**
         * Encodes the specified DisappearingMode message, length delimited. Does not implicitly {@link proto.DisappearingMode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.DisappearingMode
         * @static
         * @param {proto.IDisappearingMode} message DisappearingMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisappearingMode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisappearingMode message from the specified reader or buffer.
         * @function decode
         * @memberof proto.DisappearingMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.DisappearingMode} DisappearingMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisappearingMode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.DisappearingMode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.initiator = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisappearingMode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.DisappearingMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.DisappearingMode} DisappearingMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisappearingMode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisappearingMode message.
         * @function verify
         * @memberof proto.DisappearingMode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisappearingMode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                switch (message.initiator) {
                default:
                    return "initiator: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a DisappearingMode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.DisappearingMode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.DisappearingMode} DisappearingMode
         */
        DisappearingMode.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.DisappearingMode)
                return object;
            var message = new $root.proto.DisappearingMode();
            switch (object.initiator) {
            case "CHANGED_IN_CHAT":
            case 0:
                message.initiator = 0;
                break;
            case "INITIATED_BY_ME":
            case 1:
                message.initiator = 1;
                break;
            case "INITIATED_BY_OTHER":
            case 2:
                message.initiator = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DisappearingMode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.DisappearingMode
         * @static
         * @param {proto.DisappearingMode} message DisappearingMode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisappearingMode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.initiator = options.enums === String ? "CHANGED_IN_CHAT" : 0;
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                object.initiator = options.enums === String ? $root.proto.DisappearingMode.Initiator[message.initiator] : message.initiator;
            return object;
        };

        /**
         * Converts this DisappearingMode to JSON.
         * @function toJSON
         * @memberof proto.DisappearingMode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisappearingMode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Initiator enum.
         * @name proto.DisappearingMode.Initiator
         * @enum {number}
         * @property {number} CHANGED_IN_CHAT=0 CHANGED_IN_CHAT value
         * @property {number} INITIATED_BY_ME=1 INITIATED_BY_ME value
         * @property {number} INITIATED_BY_OTHER=2 INITIATED_BY_OTHER value
         */
        DisappearingMode.Initiator = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHANGED_IN_CHAT"] = 0;
            values[valuesById[1] = "INITIATED_BY_ME"] = 1;
            values[valuesById[2] = "INITIATED_BY_OTHER"] = 2;
            return values;
        })();

        return DisappearingMode;
    })();

    proto.EphemeralSetting = (function() {

        /**
         * Properties of an EphemeralSetting.
         * @memberof proto
         * @interface IEphemeralSetting
         * @property {number|null} [duration] EphemeralSetting duration
         * @property {number|Long|null} [timestamp] EphemeralSetting timestamp
         */

        /**
         * Constructs a new EphemeralSetting.
         * @memberof proto
         * @classdesc Represents an EphemeralSetting.
         * @implements IEphemeralSetting
         * @constructor
         * @param {proto.IEphemeralSetting=} [properties] Properties to set
         */
        function EphemeralSetting(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EphemeralSetting duration.
         * @member {number} duration
         * @memberof proto.EphemeralSetting
         * @instance
         */
        EphemeralSetting.prototype.duration = 0;

        /**
         * EphemeralSetting timestamp.
         * @member {number|Long} timestamp
         * @memberof proto.EphemeralSetting
         * @instance
         */
        EphemeralSetting.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EphemeralSetting instance using the specified properties.
         * @function create
         * @memberof proto.EphemeralSetting
         * @static
         * @param {proto.IEphemeralSetting=} [properties] Properties to set
         * @returns {proto.EphemeralSetting} EphemeralSetting instance
         */
        EphemeralSetting.create = function create(properties) {
            return new EphemeralSetting(properties);
        };

        /**
         * Encodes the specified EphemeralSetting message. Does not implicitly {@link proto.EphemeralSetting.verify|verify} messages.
         * @function encode
         * @memberof proto.EphemeralSetting
         * @static
         * @param {proto.IEphemeralSetting} message EphemeralSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EphemeralSetting.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 1, wireType 5 =*/13).sfixed32(message.duration);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 1 =*/17).sfixed64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified EphemeralSetting message, length delimited. Does not implicitly {@link proto.EphemeralSetting.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.EphemeralSetting
         * @static
         * @param {proto.IEphemeralSetting} message EphemeralSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EphemeralSetting.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EphemeralSetting message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EphemeralSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.EphemeralSetting} EphemeralSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EphemeralSetting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.EphemeralSetting();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.duration = reader.sfixed32();
                    break;
                case 2:
                    message.timestamp = reader.sfixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EphemeralSetting message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.EphemeralSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.EphemeralSetting} EphemeralSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EphemeralSetting.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EphemeralSetting message.
         * @function verify
         * @memberof proto.EphemeralSetting
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EphemeralSetting.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates an EphemeralSetting message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.EphemeralSetting
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.EphemeralSetting} EphemeralSetting
         */
        EphemeralSetting.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.EphemeralSetting)
                return object;
            var message = new $root.proto.EphemeralSetting();
            if (object.duration != null)
                message.duration = object.duration | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EphemeralSetting message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.EphemeralSetting
         * @static
         * @param {proto.EphemeralSetting} message EphemeralSetting
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EphemeralSetting.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.duration = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this EphemeralSetting to JSON.
         * @function toJSON
         * @memberof proto.EphemeralSetting
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EphemeralSetting.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EphemeralSetting;
    })();

    proto.ExitCode = (function() {

        /**
         * Properties of an ExitCode.
         * @memberof proto
         * @interface IExitCode
         * @property {number|Long|null} [code] ExitCode code
         * @property {string|null} [text] ExitCode text
         */

        /**
         * Constructs a new ExitCode.
         * @memberof proto
         * @classdesc Represents an ExitCode.
         * @implements IExitCode
         * @constructor
         * @param {proto.IExitCode=} [properties] Properties to set
         */
        function ExitCode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExitCode code.
         * @member {number|Long} code
         * @memberof proto.ExitCode
         * @instance
         */
        ExitCode.prototype.code = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ExitCode text.
         * @member {string} text
         * @memberof proto.ExitCode
         * @instance
         */
        ExitCode.prototype.text = "";

        /**
         * Creates a new ExitCode instance using the specified properties.
         * @function create
         * @memberof proto.ExitCode
         * @static
         * @param {proto.IExitCode=} [properties] Properties to set
         * @returns {proto.ExitCode} ExitCode instance
         */
        ExitCode.create = function create(properties) {
            return new ExitCode(properties);
        };

        /**
         * Encodes the specified ExitCode message. Does not implicitly {@link proto.ExitCode.verify|verify} messages.
         * @function encode
         * @memberof proto.ExitCode
         * @static
         * @param {proto.IExitCode} message ExitCode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExitCode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.code);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            return writer;
        };

        /**
         * Encodes the specified ExitCode message, length delimited. Does not implicitly {@link proto.ExitCode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ExitCode
         * @static
         * @param {proto.IExitCode} message ExitCode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExitCode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExitCode message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ExitCode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ExitCode} ExitCode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExitCode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ExitCode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint64();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExitCode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ExitCode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ExitCode} ExitCode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExitCode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExitCode message.
         * @function verify
         * @memberof proto.ExitCode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExitCode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code) && !(message.code && $util.isInteger(message.code.low) && $util.isInteger(message.code.high)))
                    return "code: integer|Long expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };

        /**
         * Creates an ExitCode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ExitCode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ExitCode} ExitCode
         */
        ExitCode.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ExitCode)
                return object;
            var message = new $root.proto.ExitCode();
            if (object.code != null)
                if ($util.Long)
                    (message.code = $util.Long.fromValue(object.code)).unsigned = true;
                else if (typeof object.code === "string")
                    message.code = parseInt(object.code, 10);
                else if (typeof object.code === "number")
                    message.code = object.code;
                else if (typeof object.code === "object")
                    message.code = new $util.LongBits(object.code.low >>> 0, object.code.high >>> 0).toNumber(true);
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };

        /**
         * Creates a plain object from an ExitCode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ExitCode
         * @static
         * @param {proto.ExitCode} message ExitCode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExitCode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.code = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.code = options.longs === String ? "0" : 0;
                object.text = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                if (typeof message.code === "number")
                    object.code = options.longs === String ? String(message.code) : message.code;
                else
                    object.code = options.longs === String ? $util.Long.prototype.toString.call(message.code) : options.longs === Number ? new $util.LongBits(message.code.low >>> 0, message.code.high >>> 0).toNumber(true) : message.code;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };

        /**
         * Converts this ExitCode to JSON.
         * @function toJSON
         * @memberof proto.ExitCode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExitCode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExitCode;
    })();

    proto.ExternalBlobReference = (function() {

        /**
         * Properties of an ExternalBlobReference.
         * @memberof proto
         * @interface IExternalBlobReference
         * @property {Uint8Array|null} [mediaKey] ExternalBlobReference mediaKey
         * @property {string|null} [directPath] ExternalBlobReference directPath
         * @property {string|null} [handle] ExternalBlobReference handle
         * @property {number|Long|null} [fileSizeBytes] ExternalBlobReference fileSizeBytes
         * @property {Uint8Array|null} [fileSha256] ExternalBlobReference fileSha256
         * @property {Uint8Array|null} [fileEncSha256] ExternalBlobReference fileEncSha256
         */

        /**
         * Constructs a new ExternalBlobReference.
         * @memberof proto
         * @classdesc Represents an ExternalBlobReference.
         * @implements IExternalBlobReference
         * @constructor
         * @param {proto.IExternalBlobReference=} [properties] Properties to set
         */
        function ExternalBlobReference(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExternalBlobReference mediaKey.
         * @member {Uint8Array} mediaKey
         * @memberof proto.ExternalBlobReference
         * @instance
         */
        ExternalBlobReference.prototype.mediaKey = $util.newBuffer([]);

        /**
         * ExternalBlobReference directPath.
         * @member {string} directPath
         * @memberof proto.ExternalBlobReference
         * @instance
         */
        ExternalBlobReference.prototype.directPath = "";

        /**
         * ExternalBlobReference handle.
         * @member {string} handle
         * @memberof proto.ExternalBlobReference
         * @instance
         */
        ExternalBlobReference.prototype.handle = "";

        /**
         * ExternalBlobReference fileSizeBytes.
         * @member {number|Long} fileSizeBytes
         * @memberof proto.ExternalBlobReference
         * @instance
         */
        ExternalBlobReference.prototype.fileSizeBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ExternalBlobReference fileSha256.
         * @member {Uint8Array} fileSha256
         * @memberof proto.ExternalBlobReference
         * @instance
         */
        ExternalBlobReference.prototype.fileSha256 = $util.newBuffer([]);

        /**
         * ExternalBlobReference fileEncSha256.
         * @member {Uint8Array} fileEncSha256
         * @memberof proto.ExternalBlobReference
         * @instance
         */
        ExternalBlobReference.prototype.fileEncSha256 = $util.newBuffer([]);

        /**
         * Creates a new ExternalBlobReference instance using the specified properties.
         * @function create
         * @memberof proto.ExternalBlobReference
         * @static
         * @param {proto.IExternalBlobReference=} [properties] Properties to set
         * @returns {proto.ExternalBlobReference} ExternalBlobReference instance
         */
        ExternalBlobReference.create = function create(properties) {
            return new ExternalBlobReference(properties);
        };

        /**
         * Encodes the specified ExternalBlobReference message. Does not implicitly {@link proto.ExternalBlobReference.verify|verify} messages.
         * @function encode
         * @memberof proto.ExternalBlobReference
         * @static
         * @param {proto.IExternalBlobReference} message ExternalBlobReference message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalBlobReference.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.mediaKey);
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.directPath);
            if (message.handle != null && Object.hasOwnProperty.call(message, "handle"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.handle);
            if (message.fileSizeBytes != null && Object.hasOwnProperty.call(message, "fileSizeBytes"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileSizeBytes);
            if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.fileSha256);
            if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.fileEncSha256);
            return writer;
        };

        /**
         * Encodes the specified ExternalBlobReference message, length delimited. Does not implicitly {@link proto.ExternalBlobReference.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ExternalBlobReference
         * @static
         * @param {proto.IExternalBlobReference} message ExternalBlobReference message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalBlobReference.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExternalBlobReference message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ExternalBlobReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ExternalBlobReference} ExternalBlobReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalBlobReference.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ExternalBlobReference();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mediaKey = reader.bytes();
                    break;
                case 2:
                    message.directPath = reader.string();
                    break;
                case 3:
                    message.handle = reader.string();
                    break;
                case 4:
                    message.fileSizeBytes = reader.uint64();
                    break;
                case 5:
                    message.fileSha256 = reader.bytes();
                    break;
                case 6:
                    message.fileEncSha256 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExternalBlobReference message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ExternalBlobReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ExternalBlobReference} ExternalBlobReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalBlobReference.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExternalBlobReference message.
         * @function verify
         * @memberof proto.ExternalBlobReference
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExternalBlobReference.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                    return "mediaKey: buffer expected";
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.handle != null && message.hasOwnProperty("handle"))
                if (!$util.isString(message.handle))
                    return "handle: string expected";
            if (message.fileSizeBytes != null && message.hasOwnProperty("fileSizeBytes"))
                if (!$util.isInteger(message.fileSizeBytes) && !(message.fileSizeBytes && $util.isInteger(message.fileSizeBytes.low) && $util.isInteger(message.fileSizeBytes.high)))
                    return "fileSizeBytes: integer|Long expected";
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                    return "fileSha256: buffer expected";
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                    return "fileEncSha256: buffer expected";
            return null;
        };

        /**
         * Creates an ExternalBlobReference message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ExternalBlobReference
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ExternalBlobReference} ExternalBlobReference
         */
        ExternalBlobReference.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ExternalBlobReference)
                return object;
            var message = new $root.proto.ExternalBlobReference();
            if (object.mediaKey != null)
                if (typeof object.mediaKey === "string")
                    $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                else if (object.mediaKey.length)
                    message.mediaKey = object.mediaKey;
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            if (object.handle != null)
                message.handle = String(object.handle);
            if (object.fileSizeBytes != null)
                if ($util.Long)
                    (message.fileSizeBytes = $util.Long.fromValue(object.fileSizeBytes)).unsigned = true;
                else if (typeof object.fileSizeBytes === "string")
                    message.fileSizeBytes = parseInt(object.fileSizeBytes, 10);
                else if (typeof object.fileSizeBytes === "number")
                    message.fileSizeBytes = object.fileSizeBytes;
                else if (typeof object.fileSizeBytes === "object")
                    message.fileSizeBytes = new $util.LongBits(object.fileSizeBytes.low >>> 0, object.fileSizeBytes.high >>> 0).toNumber(true);
            if (object.fileSha256 != null)
                if (typeof object.fileSha256 === "string")
                    $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                else if (object.fileSha256.length)
                    message.fileSha256 = object.fileSha256;
            if (object.fileEncSha256 != null)
                if (typeof object.fileEncSha256 === "string")
                    $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                else if (object.fileEncSha256.length)
                    message.fileEncSha256 = object.fileEncSha256;
            return message;
        };

        /**
         * Creates a plain object from an ExternalBlobReference message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ExternalBlobReference
         * @static
         * @param {proto.ExternalBlobReference} message ExternalBlobReference
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExternalBlobReference.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.mediaKey = "";
                else {
                    object.mediaKey = [];
                    if (options.bytes !== Array)
                        object.mediaKey = $util.newBuffer(object.mediaKey);
                }
                object.directPath = "";
                object.handle = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileSizeBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileSizeBytes = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.fileSha256 = "";
                else {
                    object.fileSha256 = [];
                    if (options.bytes !== Array)
                        object.fileSha256 = $util.newBuffer(object.fileSha256);
                }
                if (options.bytes === String)
                    object.fileEncSha256 = "";
                else {
                    object.fileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                }
            }
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.handle != null && message.hasOwnProperty("handle"))
                object.handle = message.handle;
            if (message.fileSizeBytes != null && message.hasOwnProperty("fileSizeBytes"))
                if (typeof message.fileSizeBytes === "number")
                    object.fileSizeBytes = options.longs === String ? String(message.fileSizeBytes) : message.fileSizeBytes;
                else
                    object.fileSizeBytes = options.longs === String ? $util.Long.prototype.toString.call(message.fileSizeBytes) : options.longs === Number ? new $util.LongBits(message.fileSizeBytes.low >>> 0, message.fileSizeBytes.high >>> 0).toNumber(true) : message.fileSizeBytes;
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
            return object;
        };

        /**
         * Converts this ExternalBlobReference to JSON.
         * @function toJSON
         * @memberof proto.ExternalBlobReference
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExternalBlobReference.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExternalBlobReference;
    })();

    proto.GlobalSettings = (function() {

        /**
         * Properties of a GlobalSettings.
         * @memberof proto
         * @interface IGlobalSettings
         * @property {proto.IWallpaperSettings|null} [lightThemeWallpaper] GlobalSettings lightThemeWallpaper
         * @property {proto.MediaVisibility|null} [mediaVisibility] GlobalSettings mediaVisibility
         * @property {proto.IWallpaperSettings|null} [darkThemeWallpaper] GlobalSettings darkThemeWallpaper
         * @property {proto.IAutoDownloadSettings|null} [autoDownloadWiFi] GlobalSettings autoDownloadWiFi
         * @property {proto.IAutoDownloadSettings|null} [autoDownloadCellular] GlobalSettings autoDownloadCellular
         * @property {proto.IAutoDownloadSettings|null} [autoDownloadRoaming] GlobalSettings autoDownloadRoaming
         * @property {boolean|null} [showIndividualNotificationsPreview] GlobalSettings showIndividualNotificationsPreview
         * @property {boolean|null} [showGroupNotificationsPreview] GlobalSettings showGroupNotificationsPreview
         * @property {number|null} [disappearingModeDuration] GlobalSettings disappearingModeDuration
         * @property {number|Long|null} [disappearingModeTimestamp] GlobalSettings disappearingModeTimestamp
         * @property {proto.IAvatarUserSettings|null} [avatarUserSettings] GlobalSettings avatarUserSettings
         */

        /**
         * Constructs a new GlobalSettings.
         * @memberof proto
         * @classdesc Represents a GlobalSettings.
         * @implements IGlobalSettings
         * @constructor
         * @param {proto.IGlobalSettings=} [properties] Properties to set
         */
        function GlobalSettings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GlobalSettings lightThemeWallpaper.
         * @member {proto.IWallpaperSettings|null|undefined} lightThemeWallpaper
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.lightThemeWallpaper = null;

        /**
         * GlobalSettings mediaVisibility.
         * @member {proto.MediaVisibility} mediaVisibility
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.mediaVisibility = 0;

        /**
         * GlobalSettings darkThemeWallpaper.
         * @member {proto.IWallpaperSettings|null|undefined} darkThemeWallpaper
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.darkThemeWallpaper = null;

        /**
         * GlobalSettings autoDownloadWiFi.
         * @member {proto.IAutoDownloadSettings|null|undefined} autoDownloadWiFi
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.autoDownloadWiFi = null;

        /**
         * GlobalSettings autoDownloadCellular.
         * @member {proto.IAutoDownloadSettings|null|undefined} autoDownloadCellular
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.autoDownloadCellular = null;

        /**
         * GlobalSettings autoDownloadRoaming.
         * @member {proto.IAutoDownloadSettings|null|undefined} autoDownloadRoaming
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.autoDownloadRoaming = null;

        /**
         * GlobalSettings showIndividualNotificationsPreview.
         * @member {boolean} showIndividualNotificationsPreview
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.showIndividualNotificationsPreview = false;

        /**
         * GlobalSettings showGroupNotificationsPreview.
         * @member {boolean} showGroupNotificationsPreview
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.showGroupNotificationsPreview = false;

        /**
         * GlobalSettings disappearingModeDuration.
         * @member {number} disappearingModeDuration
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.disappearingModeDuration = 0;

        /**
         * GlobalSettings disappearingModeTimestamp.
         * @member {number|Long} disappearingModeTimestamp
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.disappearingModeTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GlobalSettings avatarUserSettings.
         * @member {proto.IAvatarUserSettings|null|undefined} avatarUserSettings
         * @memberof proto.GlobalSettings
         * @instance
         */
        GlobalSettings.prototype.avatarUserSettings = null;

        /**
         * Creates a new GlobalSettings instance using the specified properties.
         * @function create
         * @memberof proto.GlobalSettings
         * @static
         * @param {proto.IGlobalSettings=} [properties] Properties to set
         * @returns {proto.GlobalSettings} GlobalSettings instance
         */
        GlobalSettings.create = function create(properties) {
            return new GlobalSettings(properties);
        };

        /**
         * Encodes the specified GlobalSettings message. Does not implicitly {@link proto.GlobalSettings.verify|verify} messages.
         * @function encode
         * @memberof proto.GlobalSettings
         * @static
         * @param {proto.IGlobalSettings} message GlobalSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GlobalSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lightThemeWallpaper != null && Object.hasOwnProperty.call(message, "lightThemeWallpaper"))
                $root.proto.WallpaperSettings.encode(message.lightThemeWallpaper, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mediaVisibility != null && Object.hasOwnProperty.call(message, "mediaVisibility"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mediaVisibility);
            if (message.darkThemeWallpaper != null && Object.hasOwnProperty.call(message, "darkThemeWallpaper"))
                $root.proto.WallpaperSettings.encode(message.darkThemeWallpaper, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.autoDownloadWiFi != null && Object.hasOwnProperty.call(message, "autoDownloadWiFi"))
                $root.proto.AutoDownloadSettings.encode(message.autoDownloadWiFi, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.autoDownloadCellular != null && Object.hasOwnProperty.call(message, "autoDownloadCellular"))
                $root.proto.AutoDownloadSettings.encode(message.autoDownloadCellular, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.autoDownloadRoaming != null && Object.hasOwnProperty.call(message, "autoDownloadRoaming"))
                $root.proto.AutoDownloadSettings.encode(message.autoDownloadRoaming, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.showIndividualNotificationsPreview != null && Object.hasOwnProperty.call(message, "showIndividualNotificationsPreview"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.showIndividualNotificationsPreview);
            if (message.showGroupNotificationsPreview != null && Object.hasOwnProperty.call(message, "showGroupNotificationsPreview"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.showGroupNotificationsPreview);
            if (message.disappearingModeDuration != null && Object.hasOwnProperty.call(message, "disappearingModeDuration"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.disappearingModeDuration);
            if (message.disappearingModeTimestamp != null && Object.hasOwnProperty.call(message, "disappearingModeTimestamp"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.disappearingModeTimestamp);
            if (message.avatarUserSettings != null && Object.hasOwnProperty.call(message, "avatarUserSettings"))
                $root.proto.AvatarUserSettings.encode(message.avatarUserSettings, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GlobalSettings message, length delimited. Does not implicitly {@link proto.GlobalSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.GlobalSettings
         * @static
         * @param {proto.IGlobalSettings} message GlobalSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GlobalSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GlobalSettings message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GlobalSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GlobalSettings} GlobalSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GlobalSettings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GlobalSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lightThemeWallpaper = $root.proto.WallpaperSettings.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.mediaVisibility = reader.int32();
                    break;
                case 3:
                    message.darkThemeWallpaper = $root.proto.WallpaperSettings.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.autoDownloadWiFi = $root.proto.AutoDownloadSettings.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.autoDownloadCellular = $root.proto.AutoDownloadSettings.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.autoDownloadRoaming = $root.proto.AutoDownloadSettings.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.showIndividualNotificationsPreview = reader.bool();
                    break;
                case 8:
                    message.showGroupNotificationsPreview = reader.bool();
                    break;
                case 9:
                    message.disappearingModeDuration = reader.int32();
                    break;
                case 10:
                    message.disappearingModeTimestamp = reader.int64();
                    break;
                case 11:
                    message.avatarUserSettings = $root.proto.AvatarUserSettings.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GlobalSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.GlobalSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.GlobalSettings} GlobalSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GlobalSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GlobalSettings message.
         * @function verify
         * @memberof proto.GlobalSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GlobalSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lightThemeWallpaper != null && message.hasOwnProperty("lightThemeWallpaper")) {
                var error = $root.proto.WallpaperSettings.verify(message.lightThemeWallpaper);
                if (error)
                    return "lightThemeWallpaper." + error;
            }
            if (message.mediaVisibility != null && message.hasOwnProperty("mediaVisibility"))
                switch (message.mediaVisibility) {
                default:
                    return "mediaVisibility: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.darkThemeWallpaper != null && message.hasOwnProperty("darkThemeWallpaper")) {
                var error = $root.proto.WallpaperSettings.verify(message.darkThemeWallpaper);
                if (error)
                    return "darkThemeWallpaper." + error;
            }
            if (message.autoDownloadWiFi != null && message.hasOwnProperty("autoDownloadWiFi")) {
                var error = $root.proto.AutoDownloadSettings.verify(message.autoDownloadWiFi);
                if (error)
                    return "autoDownloadWiFi." + error;
            }
            if (message.autoDownloadCellular != null && message.hasOwnProperty("autoDownloadCellular")) {
                var error = $root.proto.AutoDownloadSettings.verify(message.autoDownloadCellular);
                if (error)
                    return "autoDownloadCellular." + error;
            }
            if (message.autoDownloadRoaming != null && message.hasOwnProperty("autoDownloadRoaming")) {
                var error = $root.proto.AutoDownloadSettings.verify(message.autoDownloadRoaming);
                if (error)
                    return "autoDownloadRoaming." + error;
            }
            if (message.showIndividualNotificationsPreview != null && message.hasOwnProperty("showIndividualNotificationsPreview"))
                if (typeof message.showIndividualNotificationsPreview !== "boolean")
                    return "showIndividualNotificationsPreview: boolean expected";
            if (message.showGroupNotificationsPreview != null && message.hasOwnProperty("showGroupNotificationsPreview"))
                if (typeof message.showGroupNotificationsPreview !== "boolean")
                    return "showGroupNotificationsPreview: boolean expected";
            if (message.disappearingModeDuration != null && message.hasOwnProperty("disappearingModeDuration"))
                if (!$util.isInteger(message.disappearingModeDuration))
                    return "disappearingModeDuration: integer expected";
            if (message.disappearingModeTimestamp != null && message.hasOwnProperty("disappearingModeTimestamp"))
                if (!$util.isInteger(message.disappearingModeTimestamp) && !(message.disappearingModeTimestamp && $util.isInteger(message.disappearingModeTimestamp.low) && $util.isInteger(message.disappearingModeTimestamp.high)))
                    return "disappearingModeTimestamp: integer|Long expected";
            if (message.avatarUserSettings != null && message.hasOwnProperty("avatarUserSettings")) {
                var error = $root.proto.AvatarUserSettings.verify(message.avatarUserSettings);
                if (error)
                    return "avatarUserSettings." + error;
            }
            return null;
        };

        /**
         * Creates a GlobalSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.GlobalSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.GlobalSettings} GlobalSettings
         */
        GlobalSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.GlobalSettings)
                return object;
            var message = new $root.proto.GlobalSettings();
            if (object.lightThemeWallpaper != null) {
                if (typeof object.lightThemeWallpaper !== "object")
                    throw TypeError(".proto.GlobalSettings.lightThemeWallpaper: object expected");
                message.lightThemeWallpaper = $root.proto.WallpaperSettings.fromObject(object.lightThemeWallpaper);
            }
            switch (object.mediaVisibility) {
            case "DEFAULT":
            case 0:
                message.mediaVisibility = 0;
                break;
            case "OFF":
            case 1:
                message.mediaVisibility = 1;
                break;
            case "ON":
            case 2:
                message.mediaVisibility = 2;
                break;
            }
            if (object.darkThemeWallpaper != null) {
                if (typeof object.darkThemeWallpaper !== "object")
                    throw TypeError(".proto.GlobalSettings.darkThemeWallpaper: object expected");
                message.darkThemeWallpaper = $root.proto.WallpaperSettings.fromObject(object.darkThemeWallpaper);
            }
            if (object.autoDownloadWiFi != null) {
                if (typeof object.autoDownloadWiFi !== "object")
                    throw TypeError(".proto.GlobalSettings.autoDownloadWiFi: object expected");
                message.autoDownloadWiFi = $root.proto.AutoDownloadSettings.fromObject(object.autoDownloadWiFi);
            }
            if (object.autoDownloadCellular != null) {
                if (typeof object.autoDownloadCellular !== "object")
                    throw TypeError(".proto.GlobalSettings.autoDownloadCellular: object expected");
                message.autoDownloadCellular = $root.proto.AutoDownloadSettings.fromObject(object.autoDownloadCellular);
            }
            if (object.autoDownloadRoaming != null) {
                if (typeof object.autoDownloadRoaming !== "object")
                    throw TypeError(".proto.GlobalSettings.autoDownloadRoaming: object expected");
                message.autoDownloadRoaming = $root.proto.AutoDownloadSettings.fromObject(object.autoDownloadRoaming);
            }
            if (object.showIndividualNotificationsPreview != null)
                message.showIndividualNotificationsPreview = Boolean(object.showIndividualNotificationsPreview);
            if (object.showGroupNotificationsPreview != null)
                message.showGroupNotificationsPreview = Boolean(object.showGroupNotificationsPreview);
            if (object.disappearingModeDuration != null)
                message.disappearingModeDuration = object.disappearingModeDuration | 0;
            if (object.disappearingModeTimestamp != null)
                if ($util.Long)
                    (message.disappearingModeTimestamp = $util.Long.fromValue(object.disappearingModeTimestamp)).unsigned = false;
                else if (typeof object.disappearingModeTimestamp === "string")
                    message.disappearingModeTimestamp = parseInt(object.disappearingModeTimestamp, 10);
                else if (typeof object.disappearingModeTimestamp === "number")
                    message.disappearingModeTimestamp = object.disappearingModeTimestamp;
                else if (typeof object.disappearingModeTimestamp === "object")
                    message.disappearingModeTimestamp = new $util.LongBits(object.disappearingModeTimestamp.low >>> 0, object.disappearingModeTimestamp.high >>> 0).toNumber();
            if (object.avatarUserSettings != null) {
                if (typeof object.avatarUserSettings !== "object")
                    throw TypeError(".proto.GlobalSettings.avatarUserSettings: object expected");
                message.avatarUserSettings = $root.proto.AvatarUserSettings.fromObject(object.avatarUserSettings);
            }
            return message;
        };

        /**
         * Creates a plain object from a GlobalSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.GlobalSettings
         * @static
         * @param {proto.GlobalSettings} message GlobalSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GlobalSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lightThemeWallpaper = null;
                object.mediaVisibility = options.enums === String ? "DEFAULT" : 0;
                object.darkThemeWallpaper = null;
                object.autoDownloadWiFi = null;
                object.autoDownloadCellular = null;
                object.autoDownloadRoaming = null;
                object.showIndividualNotificationsPreview = false;
                object.showGroupNotificationsPreview = false;
                object.disappearingModeDuration = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.disappearingModeTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.disappearingModeTimestamp = options.longs === String ? "0" : 0;
                object.avatarUserSettings = null;
            }
            if (message.lightThemeWallpaper != null && message.hasOwnProperty("lightThemeWallpaper"))
                object.lightThemeWallpaper = $root.proto.WallpaperSettings.toObject(message.lightThemeWallpaper, options);
            if (message.mediaVisibility != null && message.hasOwnProperty("mediaVisibility"))
                object.mediaVisibility = options.enums === String ? $root.proto.MediaVisibility[message.mediaVisibility] : message.mediaVisibility;
            if (message.darkThemeWallpaper != null && message.hasOwnProperty("darkThemeWallpaper"))
                object.darkThemeWallpaper = $root.proto.WallpaperSettings.toObject(message.darkThemeWallpaper, options);
            if (message.autoDownloadWiFi != null && message.hasOwnProperty("autoDownloadWiFi"))
                object.autoDownloadWiFi = $root.proto.AutoDownloadSettings.toObject(message.autoDownloadWiFi, options);
            if (message.autoDownloadCellular != null && message.hasOwnProperty("autoDownloadCellular"))
                object.autoDownloadCellular = $root.proto.AutoDownloadSettings.toObject(message.autoDownloadCellular, options);
            if (message.autoDownloadRoaming != null && message.hasOwnProperty("autoDownloadRoaming"))
                object.autoDownloadRoaming = $root.proto.AutoDownloadSettings.toObject(message.autoDownloadRoaming, options);
            if (message.showIndividualNotificationsPreview != null && message.hasOwnProperty("showIndividualNotificationsPreview"))
                object.showIndividualNotificationsPreview = message.showIndividualNotificationsPreview;
            if (message.showGroupNotificationsPreview != null && message.hasOwnProperty("showGroupNotificationsPreview"))
                object.showGroupNotificationsPreview = message.showGroupNotificationsPreview;
            if (message.disappearingModeDuration != null && message.hasOwnProperty("disappearingModeDuration"))
                object.disappearingModeDuration = message.disappearingModeDuration;
            if (message.disappearingModeTimestamp != null && message.hasOwnProperty("disappearingModeTimestamp"))
                if (typeof message.disappearingModeTimestamp === "number")
                    object.disappearingModeTimestamp = options.longs === String ? String(message.disappearingModeTimestamp) : message.disappearingModeTimestamp;
                else
                    object.disappearingModeTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.disappearingModeTimestamp) : options.longs === Number ? new $util.LongBits(message.disappearingModeTimestamp.low >>> 0, message.disappearingModeTimestamp.high >>> 0).toNumber() : message.disappearingModeTimestamp;
            if (message.avatarUserSettings != null && message.hasOwnProperty("avatarUserSettings"))
                object.avatarUserSettings = $root.proto.AvatarUserSettings.toObject(message.avatarUserSettings, options);
            return object;
        };

        /**
         * Converts this GlobalSettings to JSON.
         * @function toJSON
         * @memberof proto.GlobalSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GlobalSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GlobalSettings;
    })();

    proto.GroupParticipant = (function() {

        /**
         * Properties of a GroupParticipant.
         * @memberof proto
         * @interface IGroupParticipant
         * @property {string} userJid GroupParticipant userJid
         * @property {proto.GroupParticipant.Rank|null} [rank] GroupParticipant rank
         */

        /**
         * Constructs a new GroupParticipant.
         * @memberof proto
         * @classdesc Represents a GroupParticipant.
         * @implements IGroupParticipant
         * @constructor
         * @param {proto.IGroupParticipant=} [properties] Properties to set
         */
        function GroupParticipant(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupParticipant userJid.
         * @member {string} userJid
         * @memberof proto.GroupParticipant
         * @instance
         */
        GroupParticipant.prototype.userJid = "";

        /**
         * GroupParticipant rank.
         * @member {proto.GroupParticipant.Rank} rank
         * @memberof proto.GroupParticipant
         * @instance
         */
        GroupParticipant.prototype.rank = 0;

        /**
         * Creates a new GroupParticipant instance using the specified properties.
         * @function create
         * @memberof proto.GroupParticipant
         * @static
         * @param {proto.IGroupParticipant=} [properties] Properties to set
         * @returns {proto.GroupParticipant} GroupParticipant instance
         */
        GroupParticipant.create = function create(properties) {
            return new GroupParticipant(properties);
        };

        /**
         * Encodes the specified GroupParticipant message. Does not implicitly {@link proto.GroupParticipant.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupParticipant
         * @static
         * @param {proto.IGroupParticipant} message GroupParticipant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupParticipant.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.userJid);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rank);
            return writer;
        };

        /**
         * Encodes the specified GroupParticipant message, length delimited. Does not implicitly {@link proto.GroupParticipant.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.GroupParticipant
         * @static
         * @param {proto.IGroupParticipant} message GroupParticipant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupParticipant.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupParticipant message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupParticipant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupParticipant} GroupParticipant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupParticipant.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupParticipant();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userJid = reader.string();
                    break;
                case 2:
                    message.rank = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userJid"))
                throw $util.ProtocolError("missing required 'userJid'", { instance: message });
            return message;
        };

        /**
         * Decodes a GroupParticipant message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.GroupParticipant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.GroupParticipant} GroupParticipant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupParticipant.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupParticipant message.
         * @function verify
         * @memberof proto.GroupParticipant
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupParticipant.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.userJid))
                return "userJid: string expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                switch (message.rank) {
                default:
                    return "rank: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a GroupParticipant message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.GroupParticipant
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.GroupParticipant} GroupParticipant
         */
        GroupParticipant.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.GroupParticipant)
                return object;
            var message = new $root.proto.GroupParticipant();
            if (object.userJid != null)
                message.userJid = String(object.userJid);
            switch (object.rank) {
            case "REGULAR":
            case 0:
                message.rank = 0;
                break;
            case "ADMIN":
            case 1:
                message.rank = 1;
                break;
            case "SUPERADMIN":
            case 2:
                message.rank = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupParticipant message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.GroupParticipant
         * @static
         * @param {proto.GroupParticipant} message GroupParticipant
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupParticipant.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.userJid = "";
                object.rank = options.enums === String ? "REGULAR" : 0;
            }
            if (message.userJid != null && message.hasOwnProperty("userJid"))
                object.userJid = message.userJid;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = options.enums === String ? $root.proto.GroupParticipant.Rank[message.rank] : message.rank;
            return object;
        };

        /**
         * Converts this GroupParticipant to JSON.
         * @function toJSON
         * @memberof proto.GroupParticipant
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupParticipant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Rank enum.
         * @name proto.GroupParticipant.Rank
         * @enum {number}
         * @property {number} REGULAR=0 REGULAR value
         * @property {number} ADMIN=1 ADMIN value
         * @property {number} SUPERADMIN=2 SUPERADMIN value
         */
        GroupParticipant.Rank = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "REGULAR"] = 0;
            values[valuesById[1] = "ADMIN"] = 1;
            values[valuesById[2] = "SUPERADMIN"] = 2;
            return values;
        })();

        return GroupParticipant;
    })();

    proto.HandshakeMessage = (function() {

        /**
         * Properties of a HandshakeMessage.
         * @memberof proto
         * @interface IHandshakeMessage
         * @property {proto.HandshakeMessage.IClientHello|null} [clientHello] HandshakeMessage clientHello
         * @property {proto.HandshakeMessage.IServerHello|null} [serverHello] HandshakeMessage serverHello
         * @property {proto.HandshakeMessage.IClientFinish|null} [clientFinish] HandshakeMessage clientFinish
         */

        /**
         * Constructs a new HandshakeMessage.
         * @memberof proto
         * @classdesc Represents a HandshakeMessage.
         * @implements IHandshakeMessage
         * @constructor
         * @param {proto.IHandshakeMessage=} [properties] Properties to set
         */
        function HandshakeMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HandshakeMessage clientHello.
         * @member {proto.HandshakeMessage.IClientHello|null|undefined} clientHello
         * @memberof proto.HandshakeMessage
         * @instance
         */
        HandshakeMessage.prototype.clientHello = null;

        /**
         * HandshakeMessage serverHello.
         * @member {proto.HandshakeMessage.IServerHello|null|undefined} serverHello
         * @memberof proto.HandshakeMessage
         * @instance
         */
        HandshakeMessage.prototype.serverHello = null;

        /**
         * HandshakeMessage clientFinish.
         * @member {proto.HandshakeMessage.IClientFinish|null|undefined} clientFinish
         * @memberof proto.HandshakeMessage
         * @instance
         */
        HandshakeMessage.prototype.clientFinish = null;

        /**
         * Creates a new HandshakeMessage instance using the specified properties.
         * @function create
         * @memberof proto.HandshakeMessage
         * @static
         * @param {proto.IHandshakeMessage=} [properties] Properties to set
         * @returns {proto.HandshakeMessage} HandshakeMessage instance
         */
        HandshakeMessage.create = function create(properties) {
            return new HandshakeMessage(properties);
        };

        /**
         * Encodes the specified HandshakeMessage message. Does not implicitly {@link proto.HandshakeMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.HandshakeMessage
         * @static
         * @param {proto.IHandshakeMessage} message HandshakeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HandshakeMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientHello != null && Object.hasOwnProperty.call(message, "clientHello"))
                $root.proto.HandshakeMessage.ClientHello.encode(message.clientHello, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverHello != null && Object.hasOwnProperty.call(message, "serverHello"))
                $root.proto.HandshakeMessage.ServerHello.encode(message.serverHello, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.clientFinish != null && Object.hasOwnProperty.call(message, "clientFinish"))
                $root.proto.HandshakeMessage.ClientFinish.encode(message.clientFinish, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HandshakeMessage message, length delimited. Does not implicitly {@link proto.HandshakeMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.HandshakeMessage
         * @static
         * @param {proto.IHandshakeMessage} message HandshakeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HandshakeMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HandshakeMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.HandshakeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.HandshakeMessage} HandshakeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HandshakeMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HandshakeMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.clientHello = $root.proto.HandshakeMessage.ClientHello.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverHello = $root.proto.HandshakeMessage.ServerHello.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.clientFinish = $root.proto.HandshakeMessage.ClientFinish.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HandshakeMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.HandshakeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.HandshakeMessage} HandshakeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HandshakeMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HandshakeMessage message.
         * @function verify
         * @memberof proto.HandshakeMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HandshakeMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientHello != null && message.hasOwnProperty("clientHello")) {
                var error = $root.proto.HandshakeMessage.ClientHello.verify(message.clientHello);
                if (error)
                    return "clientHello." + error;
            }
            if (message.serverHello != null && message.hasOwnProperty("serverHello")) {
                var error = $root.proto.HandshakeMessage.ServerHello.verify(message.serverHello);
                if (error)
                    return "serverHello." + error;
            }
            if (message.clientFinish != null && message.hasOwnProperty("clientFinish")) {
                var error = $root.proto.HandshakeMessage.ClientFinish.verify(message.clientFinish);
                if (error)
                    return "clientFinish." + error;
            }
            return null;
        };

        /**
         * Creates a HandshakeMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.HandshakeMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.HandshakeMessage} HandshakeMessage
         */
        HandshakeMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.HandshakeMessage)
                return object;
            var message = new $root.proto.HandshakeMessage();
            if (object.clientHello != null) {
                if (typeof object.clientHello !== "object")
                    throw TypeError(".proto.HandshakeMessage.clientHello: object expected");
                message.clientHello = $root.proto.HandshakeMessage.ClientHello.fromObject(object.clientHello);
            }
            if (object.serverHello != null) {
                if (typeof object.serverHello !== "object")
                    throw TypeError(".proto.HandshakeMessage.serverHello: object expected");
                message.serverHello = $root.proto.HandshakeMessage.ServerHello.fromObject(object.serverHello);
            }
            if (object.clientFinish != null) {
                if (typeof object.clientFinish !== "object")
                    throw TypeError(".proto.HandshakeMessage.clientFinish: object expected");
                message.clientFinish = $root.proto.HandshakeMessage.ClientFinish.fromObject(object.clientFinish);
            }
            return message;
        };

        /**
         * Creates a plain object from a HandshakeMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.HandshakeMessage
         * @static
         * @param {proto.HandshakeMessage} message HandshakeMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HandshakeMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.clientHello = null;
                object.serverHello = null;
                object.clientFinish = null;
            }
            if (message.clientHello != null && message.hasOwnProperty("clientHello"))
                object.clientHello = $root.proto.HandshakeMessage.ClientHello.toObject(message.clientHello, options);
            if (message.serverHello != null && message.hasOwnProperty("serverHello"))
                object.serverHello = $root.proto.HandshakeMessage.ServerHello.toObject(message.serverHello, options);
            if (message.clientFinish != null && message.hasOwnProperty("clientFinish"))
                object.clientFinish = $root.proto.HandshakeMessage.ClientFinish.toObject(message.clientFinish, options);
            return object;
        };

        /**
         * Converts this HandshakeMessage to JSON.
         * @function toJSON
         * @memberof proto.HandshakeMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HandshakeMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        HandshakeMessage.ClientFinish = (function() {

            /**
             * Properties of a ClientFinish.
             * @memberof proto.HandshakeMessage
             * @interface IClientFinish
             * @property {Uint8Array|null} ["static"] ClientFinish static
             * @property {Uint8Array|null} [payload] ClientFinish payload
             */

            /**
             * Constructs a new ClientFinish.
             * @memberof proto.HandshakeMessage
             * @classdesc Represents a ClientFinish.
             * @implements IClientFinish
             * @constructor
             * @param {proto.HandshakeMessage.IClientFinish=} [properties] Properties to set
             */
            function ClientFinish(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClientFinish static.
             * @member {Uint8Array} static
             * @memberof proto.HandshakeMessage.ClientFinish
             * @instance
             */
            ClientFinish.prototype["static"] = $util.newBuffer([]);

            /**
             * ClientFinish payload.
             * @member {Uint8Array} payload
             * @memberof proto.HandshakeMessage.ClientFinish
             * @instance
             */
            ClientFinish.prototype.payload = $util.newBuffer([]);

            /**
             * Creates a new ClientFinish instance using the specified properties.
             * @function create
             * @memberof proto.HandshakeMessage.ClientFinish
             * @static
             * @param {proto.HandshakeMessage.IClientFinish=} [properties] Properties to set
             * @returns {proto.HandshakeMessage.ClientFinish} ClientFinish instance
             */
            ClientFinish.create = function create(properties) {
                return new ClientFinish(properties);
            };

            /**
             * Encodes the specified ClientFinish message. Does not implicitly {@link proto.HandshakeMessage.ClientFinish.verify|verify} messages.
             * @function encode
             * @memberof proto.HandshakeMessage.ClientFinish
             * @static
             * @param {proto.HandshakeMessage.IClientFinish} message ClientFinish message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClientFinish.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message["static"] != null && Object.hasOwnProperty.call(message, "static"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message["static"]);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                return writer;
            };

            /**
             * Encodes the specified ClientFinish message, length delimited. Does not implicitly {@link proto.HandshakeMessage.ClientFinish.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.HandshakeMessage.ClientFinish
             * @static
             * @param {proto.HandshakeMessage.IClientFinish} message ClientFinish message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClientFinish.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClientFinish message from the specified reader or buffer.
             * @function decode
             * @memberof proto.HandshakeMessage.ClientFinish
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.HandshakeMessage.ClientFinish} ClientFinish
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClientFinish.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HandshakeMessage.ClientFinish();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message["static"] = reader.bytes();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClientFinish message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.HandshakeMessage.ClientFinish
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.HandshakeMessage.ClientFinish} ClientFinish
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClientFinish.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClientFinish message.
             * @function verify
             * @memberof proto.HandshakeMessage.ClientFinish
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClientFinish.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message["static"] != null && message.hasOwnProperty("static"))
                    if (!(message["static"] && typeof message["static"].length === "number" || $util.isString(message["static"])))
                        return "static: buffer expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };

            /**
             * Creates a ClientFinish message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.HandshakeMessage.ClientFinish
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.HandshakeMessage.ClientFinish} ClientFinish
             */
            ClientFinish.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.HandshakeMessage.ClientFinish)
                    return object;
                var message = new $root.proto.HandshakeMessage.ClientFinish();
                if (object["static"] != null)
                    if (typeof object["static"] === "string")
                        $util.base64.decode(object["static"], message["static"] = $util.newBuffer($util.base64.length(object["static"])), 0);
                    else if (object["static"].length)
                        message["static"] = object["static"];
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };

            /**
             * Creates a plain object from a ClientFinish message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.HandshakeMessage.ClientFinish
             * @static
             * @param {proto.HandshakeMessage.ClientFinish} message ClientFinish
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClientFinish.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object["static"] = "";
                    else {
                        object["static"] = [];
                        if (options.bytes !== Array)
                            object["static"] = $util.newBuffer(object["static"]);
                    }
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message["static"] != null && message.hasOwnProperty("static"))
                    object["static"] = options.bytes === String ? $util.base64.encode(message["static"], 0, message["static"].length) : options.bytes === Array ? Array.prototype.slice.call(message["static"]) : message["static"];
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };

            /**
             * Converts this ClientFinish to JSON.
             * @function toJSON
             * @memberof proto.HandshakeMessage.ClientFinish
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClientFinish.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ClientFinish;
        })();

        HandshakeMessage.ClientHello = (function() {

            /**
             * Properties of a ClientHello.
             * @memberof proto.HandshakeMessage
             * @interface IClientHello
             * @property {Uint8Array|null} [ephemeral] ClientHello ephemeral
             * @property {Uint8Array|null} ["static"] ClientHello static
             * @property {Uint8Array|null} [payload] ClientHello payload
             */

            /**
             * Constructs a new ClientHello.
             * @memberof proto.HandshakeMessage
             * @classdesc Represents a ClientHello.
             * @implements IClientHello
             * @constructor
             * @param {proto.HandshakeMessage.IClientHello=} [properties] Properties to set
             */
            function ClientHello(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClientHello ephemeral.
             * @member {Uint8Array} ephemeral
             * @memberof proto.HandshakeMessage.ClientHello
             * @instance
             */
            ClientHello.prototype.ephemeral = $util.newBuffer([]);

            /**
             * ClientHello static.
             * @member {Uint8Array} static
             * @memberof proto.HandshakeMessage.ClientHello
             * @instance
             */
            ClientHello.prototype["static"] = $util.newBuffer([]);

            /**
             * ClientHello payload.
             * @member {Uint8Array} payload
             * @memberof proto.HandshakeMessage.ClientHello
             * @instance
             */
            ClientHello.prototype.payload = $util.newBuffer([]);

            /**
             * Creates a new ClientHello instance using the specified properties.
             * @function create
             * @memberof proto.HandshakeMessage.ClientHello
             * @static
             * @param {proto.HandshakeMessage.IClientHello=} [properties] Properties to set
             * @returns {proto.HandshakeMessage.ClientHello} ClientHello instance
             */
            ClientHello.create = function create(properties) {
                return new ClientHello(properties);
            };

            /**
             * Encodes the specified ClientHello message. Does not implicitly {@link proto.HandshakeMessage.ClientHello.verify|verify} messages.
             * @function encode
             * @memberof proto.HandshakeMessage.ClientHello
             * @static
             * @param {proto.HandshakeMessage.IClientHello} message ClientHello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClientHello.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ephemeral != null && Object.hasOwnProperty.call(message, "ephemeral"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeral);
                if (message["static"] != null && Object.hasOwnProperty.call(message, "static"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["static"]);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                return writer;
            };

            /**
             * Encodes the specified ClientHello message, length delimited. Does not implicitly {@link proto.HandshakeMessage.ClientHello.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.HandshakeMessage.ClientHello
             * @static
             * @param {proto.HandshakeMessage.IClientHello} message ClientHello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClientHello.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClientHello message from the specified reader or buffer.
             * @function decode
             * @memberof proto.HandshakeMessage.ClientHello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.HandshakeMessage.ClientHello} ClientHello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClientHello.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HandshakeMessage.ClientHello();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ephemeral = reader.bytes();
                        break;
                    case 2:
                        message["static"] = reader.bytes();
                        break;
                    case 3:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClientHello message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.HandshakeMessage.ClientHello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.HandshakeMessage.ClientHello} ClientHello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClientHello.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClientHello message.
             * @function verify
             * @memberof proto.HandshakeMessage.ClientHello
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClientHello.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                    if (!(message.ephemeral && typeof message.ephemeral.length === "number" || $util.isString(message.ephemeral)))
                        return "ephemeral: buffer expected";
                if (message["static"] != null && message.hasOwnProperty("static"))
                    if (!(message["static"] && typeof message["static"].length === "number" || $util.isString(message["static"])))
                        return "static: buffer expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };

            /**
             * Creates a ClientHello message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.HandshakeMessage.ClientHello
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.HandshakeMessage.ClientHello} ClientHello
             */
            ClientHello.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.HandshakeMessage.ClientHello)
                    return object;
                var message = new $root.proto.HandshakeMessage.ClientHello();
                if (object.ephemeral != null)
                    if (typeof object.ephemeral === "string")
                        $util.base64.decode(object.ephemeral, message.ephemeral = $util.newBuffer($util.base64.length(object.ephemeral)), 0);
                    else if (object.ephemeral.length)
                        message.ephemeral = object.ephemeral;
                if (object["static"] != null)
                    if (typeof object["static"] === "string")
                        $util.base64.decode(object["static"], message["static"] = $util.newBuffer($util.base64.length(object["static"])), 0);
                    else if (object["static"].length)
                        message["static"] = object["static"];
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };

            /**
             * Creates a plain object from a ClientHello message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.HandshakeMessage.ClientHello
             * @static
             * @param {proto.HandshakeMessage.ClientHello} message ClientHello
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClientHello.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.ephemeral = "";
                    else {
                        object.ephemeral = [];
                        if (options.bytes !== Array)
                            object.ephemeral = $util.newBuffer(object.ephemeral);
                    }
                    if (options.bytes === String)
                        object["static"] = "";
                    else {
                        object["static"] = [];
                        if (options.bytes !== Array)
                            object["static"] = $util.newBuffer(object["static"]);
                    }
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                    object.ephemeral = options.bytes === String ? $util.base64.encode(message.ephemeral, 0, message.ephemeral.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeral) : message.ephemeral;
                if (message["static"] != null && message.hasOwnProperty("static"))
                    object["static"] = options.bytes === String ? $util.base64.encode(message["static"], 0, message["static"].length) : options.bytes === Array ? Array.prototype.slice.call(message["static"]) : message["static"];
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };

            /**
             * Converts this ClientHello to JSON.
             * @function toJSON
             * @memberof proto.HandshakeMessage.ClientHello
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClientHello.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ClientHello;
        })();

        HandshakeMessage.ServerHello = (function() {

            /**
             * Properties of a ServerHello.
             * @memberof proto.HandshakeMessage
             * @interface IServerHello
             * @property {Uint8Array|null} [ephemeral] ServerHello ephemeral
             * @property {Uint8Array|null} ["static"] ServerHello static
             * @property {Uint8Array|null} [payload] ServerHello payload
             */

            /**
             * Constructs a new ServerHello.
             * @memberof proto.HandshakeMessage
             * @classdesc Represents a ServerHello.
             * @implements IServerHello
             * @constructor
             * @param {proto.HandshakeMessage.IServerHello=} [properties] Properties to set
             */
            function ServerHello(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServerHello ephemeral.
             * @member {Uint8Array} ephemeral
             * @memberof proto.HandshakeMessage.ServerHello
             * @instance
             */
            ServerHello.prototype.ephemeral = $util.newBuffer([]);

            /**
             * ServerHello static.
             * @member {Uint8Array} static
             * @memberof proto.HandshakeMessage.ServerHello
             * @instance
             */
            ServerHello.prototype["static"] = $util.newBuffer([]);

            /**
             * ServerHello payload.
             * @member {Uint8Array} payload
             * @memberof proto.HandshakeMessage.ServerHello
             * @instance
             */
            ServerHello.prototype.payload = $util.newBuffer([]);

            /**
             * Creates a new ServerHello instance using the specified properties.
             * @function create
             * @memberof proto.HandshakeMessage.ServerHello
             * @static
             * @param {proto.HandshakeMessage.IServerHello=} [properties] Properties to set
             * @returns {proto.HandshakeMessage.ServerHello} ServerHello instance
             */
            ServerHello.create = function create(properties) {
                return new ServerHello(properties);
            };

            /**
             * Encodes the specified ServerHello message. Does not implicitly {@link proto.HandshakeMessage.ServerHello.verify|verify} messages.
             * @function encode
             * @memberof proto.HandshakeMessage.ServerHello
             * @static
             * @param {proto.HandshakeMessage.IServerHello} message ServerHello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerHello.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ephemeral != null && Object.hasOwnProperty.call(message, "ephemeral"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeral);
                if (message["static"] != null && Object.hasOwnProperty.call(message, "static"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["static"]);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                return writer;
            };

            /**
             * Encodes the specified ServerHello message, length delimited. Does not implicitly {@link proto.HandshakeMessage.ServerHello.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.HandshakeMessage.ServerHello
             * @static
             * @param {proto.HandshakeMessage.IServerHello} message ServerHello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerHello.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServerHello message from the specified reader or buffer.
             * @function decode
             * @memberof proto.HandshakeMessage.ServerHello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.HandshakeMessage.ServerHello} ServerHello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerHello.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HandshakeMessage.ServerHello();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ephemeral = reader.bytes();
                        break;
                    case 2:
                        message["static"] = reader.bytes();
                        break;
                    case 3:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServerHello message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.HandshakeMessage.ServerHello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.HandshakeMessage.ServerHello} ServerHello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerHello.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServerHello message.
             * @function verify
             * @memberof proto.HandshakeMessage.ServerHello
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServerHello.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                    if (!(message.ephemeral && typeof message.ephemeral.length === "number" || $util.isString(message.ephemeral)))
                        return "ephemeral: buffer expected";
                if (message["static"] != null && message.hasOwnProperty("static"))
                    if (!(message["static"] && typeof message["static"].length === "number" || $util.isString(message["static"])))
                        return "static: buffer expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };

            /**
             * Creates a ServerHello message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.HandshakeMessage.ServerHello
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.HandshakeMessage.ServerHello} ServerHello
             */
            ServerHello.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.HandshakeMessage.ServerHello)
                    return object;
                var message = new $root.proto.HandshakeMessage.ServerHello();
                if (object.ephemeral != null)
                    if (typeof object.ephemeral === "string")
                        $util.base64.decode(object.ephemeral, message.ephemeral = $util.newBuffer($util.base64.length(object.ephemeral)), 0);
                    else if (object.ephemeral.length)
                        message.ephemeral = object.ephemeral;
                if (object["static"] != null)
                    if (typeof object["static"] === "string")
                        $util.base64.decode(object["static"], message["static"] = $util.newBuffer($util.base64.length(object["static"])), 0);
                    else if (object["static"].length)
                        message["static"] = object["static"];
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };

            /**
             * Creates a plain object from a ServerHello message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.HandshakeMessage.ServerHello
             * @static
             * @param {proto.HandshakeMessage.ServerHello} message ServerHello
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServerHello.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.ephemeral = "";
                    else {
                        object.ephemeral = [];
                        if (options.bytes !== Array)
                            object.ephemeral = $util.newBuffer(object.ephemeral);
                    }
                    if (options.bytes === String)
                        object["static"] = "";
                    else {
                        object["static"] = [];
                        if (options.bytes !== Array)
                            object["static"] = $util.newBuffer(object["static"]);
                    }
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                    object.ephemeral = options.bytes === String ? $util.base64.encode(message.ephemeral, 0, message.ephemeral.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeral) : message.ephemeral;
                if (message["static"] != null && message.hasOwnProperty("static"))
                    object["static"] = options.bytes === String ? $util.base64.encode(message["static"], 0, message["static"].length) : options.bytes === Array ? Array.prototype.slice.call(message["static"]) : message["static"];
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };

            /**
             * Converts this ServerHello to JSON.
             * @function toJSON
             * @memberof proto.HandshakeMessage.ServerHello
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServerHello.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServerHello;
        })();

        return HandshakeMessage;
    })();

    proto.HistorySync = (function() {

        /**
         * Properties of a HistorySync.
         * @memberof proto
         * @interface IHistorySync
         * @property {proto.HistorySync.HistorySyncType} syncType HistorySync syncType
         * @property {Array.<proto.IConversation>|null} [conversations] HistorySync conversations
         * @property {Array.<proto.IWebMessageInfo>|null} [statusV3Messages] HistorySync statusV3Messages
         * @property {number|null} [chunkOrder] HistorySync chunkOrder
         * @property {number|null} [progress] HistorySync progress
         * @property {Array.<proto.IPushname>|null} [pushnames] HistorySync pushnames
         * @property {proto.IGlobalSettings|null} [globalSettings] HistorySync globalSettings
         * @property {Uint8Array|null} [threadIdUserSecret] HistorySync threadIdUserSecret
         * @property {number|null} [threadDsTimeframeOffset] HistorySync threadDsTimeframeOffset
         * @property {Array.<proto.IStickerMetadata>|null} [recentStickers] HistorySync recentStickers
         * @property {Array.<proto.IPastParticipants>|null} [pastParticipants] HistorySync pastParticipants
         */

        /**
         * Constructs a new HistorySync.
         * @memberof proto
         * @classdesc Represents a HistorySync.
         * @implements IHistorySync
         * @constructor
         * @param {proto.IHistorySync=} [properties] Properties to set
         */
        function HistorySync(properties) {
            this.conversations = [];
            this.statusV3Messages = [];
            this.pushnames = [];
            this.recentStickers = [];
            this.pastParticipants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HistorySync syncType.
         * @member {proto.HistorySync.HistorySyncType} syncType
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.syncType = 0;

        /**
         * HistorySync conversations.
         * @member {Array.<proto.IConversation>} conversations
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.conversations = $util.emptyArray;

        /**
         * HistorySync statusV3Messages.
         * @member {Array.<proto.IWebMessageInfo>} statusV3Messages
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.statusV3Messages = $util.emptyArray;

        /**
         * HistorySync chunkOrder.
         * @member {number} chunkOrder
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.chunkOrder = 0;

        /**
         * HistorySync progress.
         * @member {number} progress
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.progress = 0;

        /**
         * HistorySync pushnames.
         * @member {Array.<proto.IPushname>} pushnames
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.pushnames = $util.emptyArray;

        /**
         * HistorySync globalSettings.
         * @member {proto.IGlobalSettings|null|undefined} globalSettings
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.globalSettings = null;

        /**
         * HistorySync threadIdUserSecret.
         * @member {Uint8Array} threadIdUserSecret
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.threadIdUserSecret = $util.newBuffer([]);

        /**
         * HistorySync threadDsTimeframeOffset.
         * @member {number} threadDsTimeframeOffset
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.threadDsTimeframeOffset = 0;

        /**
         * HistorySync recentStickers.
         * @member {Array.<proto.IStickerMetadata>} recentStickers
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.recentStickers = $util.emptyArray;

        /**
         * HistorySync pastParticipants.
         * @member {Array.<proto.IPastParticipants>} pastParticipants
         * @memberof proto.HistorySync
         * @instance
         */
        HistorySync.prototype.pastParticipants = $util.emptyArray;

        /**
         * Creates a new HistorySync instance using the specified properties.
         * @function create
         * @memberof proto.HistorySync
         * @static
         * @param {proto.IHistorySync=} [properties] Properties to set
         * @returns {proto.HistorySync} HistorySync instance
         */
        HistorySync.create = function create(properties) {
            return new HistorySync(properties);
        };

        /**
         * Encodes the specified HistorySync message. Does not implicitly {@link proto.HistorySync.verify|verify} messages.
         * @function encode
         * @memberof proto.HistorySync
         * @static
         * @param {proto.IHistorySync} message HistorySync message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistorySync.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.syncType);
            if (message.conversations != null && message.conversations.length)
                for (var i = 0; i < message.conversations.length; ++i)
                    $root.proto.Conversation.encode(message.conversations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.statusV3Messages != null && message.statusV3Messages.length)
                for (var i = 0; i < message.statusV3Messages.length; ++i)
                    $root.proto.WebMessageInfo.encode(message.statusV3Messages[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.chunkOrder != null && Object.hasOwnProperty.call(message, "chunkOrder"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.chunkOrder);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.progress);
            if (message.pushnames != null && message.pushnames.length)
                for (var i = 0; i < message.pushnames.length; ++i)
                    $root.proto.Pushname.encode(message.pushnames[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.globalSettings != null && Object.hasOwnProperty.call(message, "globalSettings"))
                $root.proto.GlobalSettings.encode(message.globalSettings, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.threadIdUserSecret != null && Object.hasOwnProperty.call(message, "threadIdUserSecret"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.threadIdUserSecret);
            if (message.threadDsTimeframeOffset != null && Object.hasOwnProperty.call(message, "threadDsTimeframeOffset"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.threadDsTimeframeOffset);
            if (message.recentStickers != null && message.recentStickers.length)
                for (var i = 0; i < message.recentStickers.length; ++i)
                    $root.proto.StickerMetadata.encode(message.recentStickers[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.pastParticipants != null && message.pastParticipants.length)
                for (var i = 0; i < message.pastParticipants.length; ++i)
                    $root.proto.PastParticipants.encode(message.pastParticipants[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HistorySync message, length delimited. Does not implicitly {@link proto.HistorySync.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.HistorySync
         * @static
         * @param {proto.IHistorySync} message HistorySync message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistorySync.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HistorySync message from the specified reader or buffer.
         * @function decode
         * @memberof proto.HistorySync
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.HistorySync} HistorySync
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistorySync.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HistorySync();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.syncType = reader.int32();
                    break;
                case 2:
                    if (!(message.conversations && message.conversations.length))
                        message.conversations = [];
                    message.conversations.push($root.proto.Conversation.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.statusV3Messages && message.statusV3Messages.length))
                        message.statusV3Messages = [];
                    message.statusV3Messages.push($root.proto.WebMessageInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.chunkOrder = reader.uint32();
                    break;
                case 6:
                    message.progress = reader.uint32();
                    break;
                case 7:
                    if (!(message.pushnames && message.pushnames.length))
                        message.pushnames = [];
                    message.pushnames.push($root.proto.Pushname.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.globalSettings = $root.proto.GlobalSettings.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.threadIdUserSecret = reader.bytes();
                    break;
                case 10:
                    message.threadDsTimeframeOffset = reader.uint32();
                    break;
                case 11:
                    if (!(message.recentStickers && message.recentStickers.length))
                        message.recentStickers = [];
                    message.recentStickers.push($root.proto.StickerMetadata.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.pastParticipants && message.pastParticipants.length))
                        message.pastParticipants = [];
                    message.pastParticipants.push($root.proto.PastParticipants.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("syncType"))
                throw $util.ProtocolError("missing required 'syncType'", { instance: message });
            return message;
        };

        /**
         * Decodes a HistorySync message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.HistorySync
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.HistorySync} HistorySync
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistorySync.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HistorySync message.
         * @function verify
         * @memberof proto.HistorySync
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HistorySync.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.syncType) {
            default:
                return "syncType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
            if (message.conversations != null && message.hasOwnProperty("conversations")) {
                if (!Array.isArray(message.conversations))
                    return "conversations: array expected";
                for (var i = 0; i < message.conversations.length; ++i) {
                    var error = $root.proto.Conversation.verify(message.conversations[i]);
                    if (error)
                        return "conversations." + error;
                }
            }
            if (message.statusV3Messages != null && message.hasOwnProperty("statusV3Messages")) {
                if (!Array.isArray(message.statusV3Messages))
                    return "statusV3Messages: array expected";
                for (var i = 0; i < message.statusV3Messages.length; ++i) {
                    var error = $root.proto.WebMessageInfo.verify(message.statusV3Messages[i]);
                    if (error)
                        return "statusV3Messages." + error;
                }
            }
            if (message.chunkOrder != null && message.hasOwnProperty("chunkOrder"))
                if (!$util.isInteger(message.chunkOrder))
                    return "chunkOrder: integer expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            if (message.pushnames != null && message.hasOwnProperty("pushnames")) {
                if (!Array.isArray(message.pushnames))
                    return "pushnames: array expected";
                for (var i = 0; i < message.pushnames.length; ++i) {
                    var error = $root.proto.Pushname.verify(message.pushnames[i]);
                    if (error)
                        return "pushnames." + error;
                }
            }
            if (message.globalSettings != null && message.hasOwnProperty("globalSettings")) {
                var error = $root.proto.GlobalSettings.verify(message.globalSettings);
                if (error)
                    return "globalSettings." + error;
            }
            if (message.threadIdUserSecret != null && message.hasOwnProperty("threadIdUserSecret"))
                if (!(message.threadIdUserSecret && typeof message.threadIdUserSecret.length === "number" || $util.isString(message.threadIdUserSecret)))
                    return "threadIdUserSecret: buffer expected";
            if (message.threadDsTimeframeOffset != null && message.hasOwnProperty("threadDsTimeframeOffset"))
                if (!$util.isInteger(message.threadDsTimeframeOffset))
                    return "threadDsTimeframeOffset: integer expected";
            if (message.recentStickers != null && message.hasOwnProperty("recentStickers")) {
                if (!Array.isArray(message.recentStickers))
                    return "recentStickers: array expected";
                for (var i = 0; i < message.recentStickers.length; ++i) {
                    var error = $root.proto.StickerMetadata.verify(message.recentStickers[i]);
                    if (error)
                        return "recentStickers." + error;
                }
            }
            if (message.pastParticipants != null && message.hasOwnProperty("pastParticipants")) {
                if (!Array.isArray(message.pastParticipants))
                    return "pastParticipants: array expected";
                for (var i = 0; i < message.pastParticipants.length; ++i) {
                    var error = $root.proto.PastParticipants.verify(message.pastParticipants[i]);
                    if (error)
                        return "pastParticipants." + error;
                }
            }
            return null;
        };

        /**
         * Creates a HistorySync message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.HistorySync
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.HistorySync} HistorySync
         */
        HistorySync.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.HistorySync)
                return object;
            var message = new $root.proto.HistorySync();
            switch (object.syncType) {
            case "INITIAL_BOOTSTRAP":
            case 0:
                message.syncType = 0;
                break;
            case "INITIAL_STATUS_V3":
            case 1:
                message.syncType = 1;
                break;
            case "FULL":
            case 2:
                message.syncType = 2;
                break;
            case "RECENT":
            case 3:
                message.syncType = 3;
                break;
            case "PUSH_NAME":
            case 4:
                message.syncType = 4;
                break;
            case "NON_BLOCKING_DATA":
            case 5:
                message.syncType = 5;
                break;
            }
            if (object.conversations) {
                if (!Array.isArray(object.conversations))
                    throw TypeError(".proto.HistorySync.conversations: array expected");
                message.conversations = [];
                for (var i = 0; i < object.conversations.length; ++i) {
                    if (typeof object.conversations[i] !== "object")
                        throw TypeError(".proto.HistorySync.conversations: object expected");
                    message.conversations[i] = $root.proto.Conversation.fromObject(object.conversations[i]);
                }
            }
            if (object.statusV3Messages) {
                if (!Array.isArray(object.statusV3Messages))
                    throw TypeError(".proto.HistorySync.statusV3Messages: array expected");
                message.statusV3Messages = [];
                for (var i = 0; i < object.statusV3Messages.length; ++i) {
                    if (typeof object.statusV3Messages[i] !== "object")
                        throw TypeError(".proto.HistorySync.statusV3Messages: object expected");
                    message.statusV3Messages[i] = $root.proto.WebMessageInfo.fromObject(object.statusV3Messages[i]);
                }
            }
            if (object.chunkOrder != null)
                message.chunkOrder = object.chunkOrder >>> 0;
            if (object.progress != null)
                message.progress = object.progress >>> 0;
            if (object.pushnames) {
                if (!Array.isArray(object.pushnames))
                    throw TypeError(".proto.HistorySync.pushnames: array expected");
                message.pushnames = [];
                for (var i = 0; i < object.pushnames.length; ++i) {
                    if (typeof object.pushnames[i] !== "object")
                        throw TypeError(".proto.HistorySync.pushnames: object expected");
                    message.pushnames[i] = $root.proto.Pushname.fromObject(object.pushnames[i]);
                }
            }
            if (object.globalSettings != null) {
                if (typeof object.globalSettings !== "object")
                    throw TypeError(".proto.HistorySync.globalSettings: object expected");
                message.globalSettings = $root.proto.GlobalSettings.fromObject(object.globalSettings);
            }
            if (object.threadIdUserSecret != null)
                if (typeof object.threadIdUserSecret === "string")
                    $util.base64.decode(object.threadIdUserSecret, message.threadIdUserSecret = $util.newBuffer($util.base64.length(object.threadIdUserSecret)), 0);
                else if (object.threadIdUserSecret.length)
                    message.threadIdUserSecret = object.threadIdUserSecret;
            if (object.threadDsTimeframeOffset != null)
                message.threadDsTimeframeOffset = object.threadDsTimeframeOffset >>> 0;
            if (object.recentStickers) {
                if (!Array.isArray(object.recentStickers))
                    throw TypeError(".proto.HistorySync.recentStickers: array expected");
                message.recentStickers = [];
                for (var i = 0; i < object.recentStickers.length; ++i) {
                    if (typeof object.recentStickers[i] !== "object")
                        throw TypeError(".proto.HistorySync.recentStickers: object expected");
                    message.recentStickers[i] = $root.proto.StickerMetadata.fromObject(object.recentStickers[i]);
                }
            }
            if (object.pastParticipants) {
                if (!Array.isArray(object.pastParticipants))
                    throw TypeError(".proto.HistorySync.pastParticipants: array expected");
                message.pastParticipants = [];
                for (var i = 0; i < object.pastParticipants.length; ++i) {
                    if (typeof object.pastParticipants[i] !== "object")
                        throw TypeError(".proto.HistorySync.pastParticipants: object expected");
                    message.pastParticipants[i] = $root.proto.PastParticipants.fromObject(object.pastParticipants[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a HistorySync message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.HistorySync
         * @static
         * @param {proto.HistorySync} message HistorySync
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HistorySync.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.conversations = [];
                object.statusV3Messages = [];
                object.pushnames = [];
                object.recentStickers = [];
                object.pastParticipants = [];
            }
            if (options.defaults) {
                object.syncType = options.enums === String ? "INITIAL_BOOTSTRAP" : 0;
                object.chunkOrder = 0;
                object.progress = 0;
                object.globalSettings = null;
                if (options.bytes === String)
                    object.threadIdUserSecret = "";
                else {
                    object.threadIdUserSecret = [];
                    if (options.bytes !== Array)
                        object.threadIdUserSecret = $util.newBuffer(object.threadIdUserSecret);
                }
                object.threadDsTimeframeOffset = 0;
            }
            if (message.syncType != null && message.hasOwnProperty("syncType"))
                object.syncType = options.enums === String ? $root.proto.HistorySync.HistorySyncType[message.syncType] : message.syncType;
            if (message.conversations && message.conversations.length) {
                object.conversations = [];
                for (var j = 0; j < message.conversations.length; ++j)
                    object.conversations[j] = $root.proto.Conversation.toObject(message.conversations[j], options);
            }
            if (message.statusV3Messages && message.statusV3Messages.length) {
                object.statusV3Messages = [];
                for (var j = 0; j < message.statusV3Messages.length; ++j)
                    object.statusV3Messages[j] = $root.proto.WebMessageInfo.toObject(message.statusV3Messages[j], options);
            }
            if (message.chunkOrder != null && message.hasOwnProperty("chunkOrder"))
                object.chunkOrder = message.chunkOrder;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            if (message.pushnames && message.pushnames.length) {
                object.pushnames = [];
                for (var j = 0; j < message.pushnames.length; ++j)
                    object.pushnames[j] = $root.proto.Pushname.toObject(message.pushnames[j], options);
            }
            if (message.globalSettings != null && message.hasOwnProperty("globalSettings"))
                object.globalSettings = $root.proto.GlobalSettings.toObject(message.globalSettings, options);
            if (message.threadIdUserSecret != null && message.hasOwnProperty("threadIdUserSecret"))
                object.threadIdUserSecret = options.bytes === String ? $util.base64.encode(message.threadIdUserSecret, 0, message.threadIdUserSecret.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadIdUserSecret) : message.threadIdUserSecret;
            if (message.threadDsTimeframeOffset != null && message.hasOwnProperty("threadDsTimeframeOffset"))
                object.threadDsTimeframeOffset = message.threadDsTimeframeOffset;
            if (message.recentStickers && message.recentStickers.length) {
                object.recentStickers = [];
                for (var j = 0; j < message.recentStickers.length; ++j)
                    object.recentStickers[j] = $root.proto.StickerMetadata.toObject(message.recentStickers[j], options);
            }
            if (message.pastParticipants && message.pastParticipants.length) {
                object.pastParticipants = [];
                for (var j = 0; j < message.pastParticipants.length; ++j)
                    object.pastParticipants[j] = $root.proto.PastParticipants.toObject(message.pastParticipants[j], options);
            }
            return object;
        };

        /**
         * Converts this HistorySync to JSON.
         * @function toJSON
         * @memberof proto.HistorySync
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HistorySync.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * HistorySyncType enum.
         * @name proto.HistorySync.HistorySyncType
         * @enum {number}
         * @property {number} INITIAL_BOOTSTRAP=0 INITIAL_BOOTSTRAP value
         * @property {number} INITIAL_STATUS_V3=1 INITIAL_STATUS_V3 value
         * @property {number} FULL=2 FULL value
         * @property {number} RECENT=3 RECENT value
         * @property {number} PUSH_NAME=4 PUSH_NAME value
         * @property {number} NON_BLOCKING_DATA=5 NON_BLOCKING_DATA value
         */
        HistorySync.HistorySyncType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "INITIAL_BOOTSTRAP"] = 0;
            values[valuesById[1] = "INITIAL_STATUS_V3"] = 1;
            values[valuesById[2] = "FULL"] = 2;
            values[valuesById[3] = "RECENT"] = 3;
            values[valuesById[4] = "PUSH_NAME"] = 4;
            values[valuesById[5] = "NON_BLOCKING_DATA"] = 5;
            return values;
        })();

        return HistorySync;
    })();

    proto.HistorySyncMsg = (function() {

        /**
         * Properties of a HistorySyncMsg.
         * @memberof proto
         * @interface IHistorySyncMsg
         * @property {proto.IWebMessageInfo|null} [message] HistorySyncMsg message
         * @property {number|Long|null} [msgOrderId] HistorySyncMsg msgOrderId
         */

        /**
         * Constructs a new HistorySyncMsg.
         * @memberof proto
         * @classdesc Represents a HistorySyncMsg.
         * @implements IHistorySyncMsg
         * @constructor
         * @param {proto.IHistorySyncMsg=} [properties] Properties to set
         */
        function HistorySyncMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HistorySyncMsg message.
         * @member {proto.IWebMessageInfo|null|undefined} message
         * @memberof proto.HistorySyncMsg
         * @instance
         */
        HistorySyncMsg.prototype.message = null;

        /**
         * HistorySyncMsg msgOrderId.
         * @member {number|Long} msgOrderId
         * @memberof proto.HistorySyncMsg
         * @instance
         */
        HistorySyncMsg.prototype.msgOrderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new HistorySyncMsg instance using the specified properties.
         * @function create
         * @memberof proto.HistorySyncMsg
         * @static
         * @param {proto.IHistorySyncMsg=} [properties] Properties to set
         * @returns {proto.HistorySyncMsg} HistorySyncMsg instance
         */
        HistorySyncMsg.create = function create(properties) {
            return new HistorySyncMsg(properties);
        };

        /**
         * Encodes the specified HistorySyncMsg message. Does not implicitly {@link proto.HistorySyncMsg.verify|verify} messages.
         * @function encode
         * @memberof proto.HistorySyncMsg
         * @static
         * @param {proto.IHistorySyncMsg} message HistorySyncMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistorySyncMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                $root.proto.WebMessageInfo.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msgOrderId != null && Object.hasOwnProperty.call(message, "msgOrderId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.msgOrderId);
            return writer;
        };

        /**
         * Encodes the specified HistorySyncMsg message, length delimited. Does not implicitly {@link proto.HistorySyncMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.HistorySyncMsg
         * @static
         * @param {proto.IHistorySyncMsg} message HistorySyncMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistorySyncMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HistorySyncMsg message from the specified reader or buffer.
         * @function decode
         * @memberof proto.HistorySyncMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.HistorySyncMsg} HistorySyncMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistorySyncMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HistorySyncMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = $root.proto.WebMessageInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msgOrderId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HistorySyncMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.HistorySyncMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.HistorySyncMsg} HistorySyncMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistorySyncMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HistorySyncMsg message.
         * @function verify
         * @memberof proto.HistorySyncMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HistorySyncMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message")) {
                var error = $root.proto.WebMessageInfo.verify(message.message);
                if (error)
                    return "message." + error;
            }
            if (message.msgOrderId != null && message.hasOwnProperty("msgOrderId"))
                if (!$util.isInteger(message.msgOrderId) && !(message.msgOrderId && $util.isInteger(message.msgOrderId.low) && $util.isInteger(message.msgOrderId.high)))
                    return "msgOrderId: integer|Long expected";
            return null;
        };

        /**
         * Creates a HistorySyncMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.HistorySyncMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.HistorySyncMsg} HistorySyncMsg
         */
        HistorySyncMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.HistorySyncMsg)
                return object;
            var message = new $root.proto.HistorySyncMsg();
            if (object.message != null) {
                if (typeof object.message !== "object")
                    throw TypeError(".proto.HistorySyncMsg.message: object expected");
                message.message = $root.proto.WebMessageInfo.fromObject(object.message);
            }
            if (object.msgOrderId != null)
                if ($util.Long)
                    (message.msgOrderId = $util.Long.fromValue(object.msgOrderId)).unsigned = true;
                else if (typeof object.msgOrderId === "string")
                    message.msgOrderId = parseInt(object.msgOrderId, 10);
                else if (typeof object.msgOrderId === "number")
                    message.msgOrderId = object.msgOrderId;
                else if (typeof object.msgOrderId === "object")
                    message.msgOrderId = new $util.LongBits(object.msgOrderId.low >>> 0, object.msgOrderId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a HistorySyncMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.HistorySyncMsg
         * @static
         * @param {proto.HistorySyncMsg} message HistorySyncMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HistorySyncMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.message = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.msgOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgOrderId = options.longs === String ? "0" : 0;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = $root.proto.WebMessageInfo.toObject(message.message, options);
            if (message.msgOrderId != null && message.hasOwnProperty("msgOrderId"))
                if (typeof message.msgOrderId === "number")
                    object.msgOrderId = options.longs === String ? String(message.msgOrderId) : message.msgOrderId;
                else
                    object.msgOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.msgOrderId) : options.longs === Number ? new $util.LongBits(message.msgOrderId.low >>> 0, message.msgOrderId.high >>> 0).toNumber(true) : message.msgOrderId;
            return object;
        };

        /**
         * Converts this HistorySyncMsg to JSON.
         * @function toJSON
         * @memberof proto.HistorySyncMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HistorySyncMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HistorySyncMsg;
    })();

    proto.HydratedTemplateButton = (function() {

        /**
         * Properties of a HydratedTemplateButton.
         * @memberof proto
         * @interface IHydratedTemplateButton
         * @property {number|null} [index] HydratedTemplateButton index
         * @property {proto.HydratedTemplateButton.IHydratedQuickReplyButton|null} [quickReplyButton] HydratedTemplateButton quickReplyButton
         * @property {proto.HydratedTemplateButton.IHydratedURLButton|null} [urlButton] HydratedTemplateButton urlButton
         * @property {proto.HydratedTemplateButton.IHydratedCallButton|null} [callButton] HydratedTemplateButton callButton
         */

        /**
         * Constructs a new HydratedTemplateButton.
         * @memberof proto
         * @classdesc Represents a HydratedTemplateButton.
         * @implements IHydratedTemplateButton
         * @constructor
         * @param {proto.IHydratedTemplateButton=} [properties] Properties to set
         */
        function HydratedTemplateButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HydratedTemplateButton index.
         * @member {number} index
         * @memberof proto.HydratedTemplateButton
         * @instance
         */
        HydratedTemplateButton.prototype.index = 0;

        /**
         * HydratedTemplateButton quickReplyButton.
         * @member {proto.HydratedTemplateButton.IHydratedQuickReplyButton|null|undefined} quickReplyButton
         * @memberof proto.HydratedTemplateButton
         * @instance
         */
        HydratedTemplateButton.prototype.quickReplyButton = null;

        /**
         * HydratedTemplateButton urlButton.
         * @member {proto.HydratedTemplateButton.IHydratedURLButton|null|undefined} urlButton
         * @memberof proto.HydratedTemplateButton
         * @instance
         */
        HydratedTemplateButton.prototype.urlButton = null;

        /**
         * HydratedTemplateButton callButton.
         * @member {proto.HydratedTemplateButton.IHydratedCallButton|null|undefined} callButton
         * @memberof proto.HydratedTemplateButton
         * @instance
         */
        HydratedTemplateButton.prototype.callButton = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * HydratedTemplateButton hydratedButton.
         * @member {"quickReplyButton"|"urlButton"|"callButton"|undefined} hydratedButton
         * @memberof proto.HydratedTemplateButton
         * @instance
         */
        Object.defineProperty(HydratedTemplateButton.prototype, "hydratedButton", {
            get: $util.oneOfGetter($oneOfFields = ["quickReplyButton", "urlButton", "callButton"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new HydratedTemplateButton instance using the specified properties.
         * @function create
         * @memberof proto.HydratedTemplateButton
         * @static
         * @param {proto.IHydratedTemplateButton=} [properties] Properties to set
         * @returns {proto.HydratedTemplateButton} HydratedTemplateButton instance
         */
        HydratedTemplateButton.create = function create(properties) {
            return new HydratedTemplateButton(properties);
        };

        /**
         * Encodes the specified HydratedTemplateButton message. Does not implicitly {@link proto.HydratedTemplateButton.verify|verify} messages.
         * @function encode
         * @memberof proto.HydratedTemplateButton
         * @static
         * @param {proto.IHydratedTemplateButton} message HydratedTemplateButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedTemplateButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.quickReplyButton != null && Object.hasOwnProperty.call(message, "quickReplyButton"))
                $root.proto.HydratedTemplateButton.HydratedQuickReplyButton.encode(message.quickReplyButton, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.urlButton != null && Object.hasOwnProperty.call(message, "urlButton"))
                $root.proto.HydratedTemplateButton.HydratedURLButton.encode(message.urlButton, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.callButton != null && Object.hasOwnProperty.call(message, "callButton"))
                $root.proto.HydratedTemplateButton.HydratedCallButton.encode(message.callButton, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HydratedTemplateButton message, length delimited. Does not implicitly {@link proto.HydratedTemplateButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.HydratedTemplateButton
         * @static
         * @param {proto.IHydratedTemplateButton} message HydratedTemplateButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedTemplateButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HydratedTemplateButton message from the specified reader or buffer.
         * @function decode
         * @memberof proto.HydratedTemplateButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.HydratedTemplateButton} HydratedTemplateButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedTemplateButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HydratedTemplateButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.index = reader.uint32();
                    break;
                case 1:
                    message.quickReplyButton = $root.proto.HydratedTemplateButton.HydratedQuickReplyButton.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.urlButton = $root.proto.HydratedTemplateButton.HydratedURLButton.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.callButton = $root.proto.HydratedTemplateButton.HydratedCallButton.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HydratedTemplateButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.HydratedTemplateButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.HydratedTemplateButton} HydratedTemplateButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedTemplateButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HydratedTemplateButton message.
         * @function verify
         * @memberof proto.HydratedTemplateButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HydratedTemplateButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.quickReplyButton != null && message.hasOwnProperty("quickReplyButton")) {
                properties.hydratedButton = 1;
                {
                    var error = $root.proto.HydratedTemplateButton.HydratedQuickReplyButton.verify(message.quickReplyButton);
                    if (error)
                        return "quickReplyButton." + error;
                }
            }
            if (message.urlButton != null && message.hasOwnProperty("urlButton")) {
                if (properties.hydratedButton === 1)
                    return "hydratedButton: multiple values";
                properties.hydratedButton = 1;
                {
                    var error = $root.proto.HydratedTemplateButton.HydratedURLButton.verify(message.urlButton);
                    if (error)
                        return "urlButton." + error;
                }
            }
            if (message.callButton != null && message.hasOwnProperty("callButton")) {
                if (properties.hydratedButton === 1)
                    return "hydratedButton: multiple values";
                properties.hydratedButton = 1;
                {
                    var error = $root.proto.HydratedTemplateButton.HydratedCallButton.verify(message.callButton);
                    if (error)
                        return "callButton." + error;
                }
            }
            return null;
        };

        /**
         * Creates a HydratedTemplateButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.HydratedTemplateButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.HydratedTemplateButton} HydratedTemplateButton
         */
        HydratedTemplateButton.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.HydratedTemplateButton)
                return object;
            var message = new $root.proto.HydratedTemplateButton();
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.quickReplyButton != null) {
                if (typeof object.quickReplyButton !== "object")
                    throw TypeError(".proto.HydratedTemplateButton.quickReplyButton: object expected");
                message.quickReplyButton = $root.proto.HydratedTemplateButton.HydratedQuickReplyButton.fromObject(object.quickReplyButton);
            }
            if (object.urlButton != null) {
                if (typeof object.urlButton !== "object")
                    throw TypeError(".proto.HydratedTemplateButton.urlButton: object expected");
                message.urlButton = $root.proto.HydratedTemplateButton.HydratedURLButton.fromObject(object.urlButton);
            }
            if (object.callButton != null) {
                if (typeof object.callButton !== "object")
                    throw TypeError(".proto.HydratedTemplateButton.callButton: object expected");
                message.callButton = $root.proto.HydratedTemplateButton.HydratedCallButton.fromObject(object.callButton);
            }
            return message;
        };

        /**
         * Creates a plain object from a HydratedTemplateButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.HydratedTemplateButton
         * @static
         * @param {proto.HydratedTemplateButton} message HydratedTemplateButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HydratedTemplateButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = 0;
            if (message.quickReplyButton != null && message.hasOwnProperty("quickReplyButton")) {
                object.quickReplyButton = $root.proto.HydratedTemplateButton.HydratedQuickReplyButton.toObject(message.quickReplyButton, options);
                if (options.oneofs)
                    object.hydratedButton = "quickReplyButton";
            }
            if (message.urlButton != null && message.hasOwnProperty("urlButton")) {
                object.urlButton = $root.proto.HydratedTemplateButton.HydratedURLButton.toObject(message.urlButton, options);
                if (options.oneofs)
                    object.hydratedButton = "urlButton";
            }
            if (message.callButton != null && message.hasOwnProperty("callButton")) {
                object.callButton = $root.proto.HydratedTemplateButton.HydratedCallButton.toObject(message.callButton, options);
                if (options.oneofs)
                    object.hydratedButton = "callButton";
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HydratedTemplateButton to JSON.
         * @function toJSON
         * @memberof proto.HydratedTemplateButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HydratedTemplateButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        HydratedTemplateButton.HydratedCallButton = (function() {

            /**
             * Properties of a HydratedCallButton.
             * @memberof proto.HydratedTemplateButton
             * @interface IHydratedCallButton
             * @property {string|null} [displayText] HydratedCallButton displayText
             * @property {string|null} [phoneNumber] HydratedCallButton phoneNumber
             */

            /**
             * Constructs a new HydratedCallButton.
             * @memberof proto.HydratedTemplateButton
             * @classdesc Represents a HydratedCallButton.
             * @implements IHydratedCallButton
             * @constructor
             * @param {proto.HydratedTemplateButton.IHydratedCallButton=} [properties] Properties to set
             */
            function HydratedCallButton(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HydratedCallButton displayText.
             * @member {string} displayText
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @instance
             */
            HydratedCallButton.prototype.displayText = "";

            /**
             * HydratedCallButton phoneNumber.
             * @member {string} phoneNumber
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @instance
             */
            HydratedCallButton.prototype.phoneNumber = "";

            /**
             * Creates a new HydratedCallButton instance using the specified properties.
             * @function create
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedCallButton=} [properties] Properties to set
             * @returns {proto.HydratedTemplateButton.HydratedCallButton} HydratedCallButton instance
             */
            HydratedCallButton.create = function create(properties) {
                return new HydratedCallButton(properties);
            };

            /**
             * Encodes the specified HydratedCallButton message. Does not implicitly {@link proto.HydratedTemplateButton.HydratedCallButton.verify|verify} messages.
             * @function encode
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedCallButton} message HydratedCallButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HydratedCallButton.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayText);
                if (message.phoneNumber != null && Object.hasOwnProperty.call(message, "phoneNumber"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.phoneNumber);
                return writer;
            };

            /**
             * Encodes the specified HydratedCallButton message, length delimited. Does not implicitly {@link proto.HydratedTemplateButton.HydratedCallButton.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedCallButton} message HydratedCallButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HydratedCallButton.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HydratedCallButton message from the specified reader or buffer.
             * @function decode
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.HydratedTemplateButton.HydratedCallButton} HydratedCallButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HydratedCallButton.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HydratedTemplateButton.HydratedCallButton();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayText = reader.string();
                        break;
                    case 2:
                        message.phoneNumber = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HydratedCallButton message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.HydratedTemplateButton.HydratedCallButton} HydratedCallButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HydratedCallButton.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HydratedCallButton message.
             * @function verify
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HydratedCallButton.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    if (!$util.isString(message.displayText))
                        return "displayText: string expected";
                if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                    if (!$util.isString(message.phoneNumber))
                        return "phoneNumber: string expected";
                return null;
            };

            /**
             * Creates a HydratedCallButton message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.HydratedTemplateButton.HydratedCallButton} HydratedCallButton
             */
            HydratedCallButton.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.HydratedTemplateButton.HydratedCallButton)
                    return object;
                var message = new $root.proto.HydratedTemplateButton.HydratedCallButton();
                if (object.displayText != null)
                    message.displayText = String(object.displayText);
                if (object.phoneNumber != null)
                    message.phoneNumber = String(object.phoneNumber);
                return message;
            };

            /**
             * Creates a plain object from a HydratedCallButton message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @static
             * @param {proto.HydratedTemplateButton.HydratedCallButton} message HydratedCallButton
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HydratedCallButton.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayText = "";
                    object.phoneNumber = "";
                }
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    object.displayText = message.displayText;
                if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                    object.phoneNumber = message.phoneNumber;
                return object;
            };

            /**
             * Converts this HydratedCallButton to JSON.
             * @function toJSON
             * @memberof proto.HydratedTemplateButton.HydratedCallButton
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HydratedCallButton.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HydratedCallButton;
        })();

        HydratedTemplateButton.HydratedQuickReplyButton = (function() {

            /**
             * Properties of a HydratedQuickReplyButton.
             * @memberof proto.HydratedTemplateButton
             * @interface IHydratedQuickReplyButton
             * @property {string|null} [displayText] HydratedQuickReplyButton displayText
             * @property {string|null} [id] HydratedQuickReplyButton id
             */

            /**
             * Constructs a new HydratedQuickReplyButton.
             * @memberof proto.HydratedTemplateButton
             * @classdesc Represents a HydratedQuickReplyButton.
             * @implements IHydratedQuickReplyButton
             * @constructor
             * @param {proto.HydratedTemplateButton.IHydratedQuickReplyButton=} [properties] Properties to set
             */
            function HydratedQuickReplyButton(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HydratedQuickReplyButton displayText.
             * @member {string} displayText
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @instance
             */
            HydratedQuickReplyButton.prototype.displayText = "";

            /**
             * HydratedQuickReplyButton id.
             * @member {string} id
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @instance
             */
            HydratedQuickReplyButton.prototype.id = "";

            /**
             * Creates a new HydratedQuickReplyButton instance using the specified properties.
             * @function create
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedQuickReplyButton=} [properties] Properties to set
             * @returns {proto.HydratedTemplateButton.HydratedQuickReplyButton} HydratedQuickReplyButton instance
             */
            HydratedQuickReplyButton.create = function create(properties) {
                return new HydratedQuickReplyButton(properties);
            };

            /**
             * Encodes the specified HydratedQuickReplyButton message. Does not implicitly {@link proto.HydratedTemplateButton.HydratedQuickReplyButton.verify|verify} messages.
             * @function encode
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedQuickReplyButton} message HydratedQuickReplyButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HydratedQuickReplyButton.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayText);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified HydratedQuickReplyButton message, length delimited. Does not implicitly {@link proto.HydratedTemplateButton.HydratedQuickReplyButton.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedQuickReplyButton} message HydratedQuickReplyButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HydratedQuickReplyButton.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HydratedQuickReplyButton message from the specified reader or buffer.
             * @function decode
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.HydratedTemplateButton.HydratedQuickReplyButton} HydratedQuickReplyButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HydratedQuickReplyButton.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HydratedTemplateButton.HydratedQuickReplyButton();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayText = reader.string();
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HydratedQuickReplyButton message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.HydratedTemplateButton.HydratedQuickReplyButton} HydratedQuickReplyButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HydratedQuickReplyButton.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HydratedQuickReplyButton message.
             * @function verify
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HydratedQuickReplyButton.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    if (!$util.isString(message.displayText))
                        return "displayText: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a HydratedQuickReplyButton message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.HydratedTemplateButton.HydratedQuickReplyButton} HydratedQuickReplyButton
             */
            HydratedQuickReplyButton.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.HydratedTemplateButton.HydratedQuickReplyButton)
                    return object;
                var message = new $root.proto.HydratedTemplateButton.HydratedQuickReplyButton();
                if (object.displayText != null)
                    message.displayText = String(object.displayText);
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a HydratedQuickReplyButton message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @static
             * @param {proto.HydratedTemplateButton.HydratedQuickReplyButton} message HydratedQuickReplyButton
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HydratedQuickReplyButton.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayText = "";
                    object.id = "";
                }
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    object.displayText = message.displayText;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this HydratedQuickReplyButton to JSON.
             * @function toJSON
             * @memberof proto.HydratedTemplateButton.HydratedQuickReplyButton
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HydratedQuickReplyButton.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HydratedQuickReplyButton;
        })();

        HydratedTemplateButton.HydratedURLButton = (function() {

            /**
             * Properties of a HydratedURLButton.
             * @memberof proto.HydratedTemplateButton
             * @interface IHydratedURLButton
             * @property {string|null} [displayText] HydratedURLButton displayText
             * @property {string|null} [url] HydratedURLButton url
             */

            /**
             * Constructs a new HydratedURLButton.
             * @memberof proto.HydratedTemplateButton
             * @classdesc Represents a HydratedURLButton.
             * @implements IHydratedURLButton
             * @constructor
             * @param {proto.HydratedTemplateButton.IHydratedURLButton=} [properties] Properties to set
             */
            function HydratedURLButton(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HydratedURLButton displayText.
             * @member {string} displayText
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @instance
             */
            HydratedURLButton.prototype.displayText = "";

            /**
             * HydratedURLButton url.
             * @member {string} url
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @instance
             */
            HydratedURLButton.prototype.url = "";

            /**
             * Creates a new HydratedURLButton instance using the specified properties.
             * @function create
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedURLButton=} [properties] Properties to set
             * @returns {proto.HydratedTemplateButton.HydratedURLButton} HydratedURLButton instance
             */
            HydratedURLButton.create = function create(properties) {
                return new HydratedURLButton(properties);
            };

            /**
             * Encodes the specified HydratedURLButton message. Does not implicitly {@link proto.HydratedTemplateButton.HydratedURLButton.verify|verify} messages.
             * @function encode
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedURLButton} message HydratedURLButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HydratedURLButton.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayText);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified HydratedURLButton message, length delimited. Does not implicitly {@link proto.HydratedTemplateButton.HydratedURLButton.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @static
             * @param {proto.HydratedTemplateButton.IHydratedURLButton} message HydratedURLButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HydratedURLButton.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HydratedURLButton message from the specified reader or buffer.
             * @function decode
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.HydratedTemplateButton.HydratedURLButton} HydratedURLButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HydratedURLButton.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HydratedTemplateButton.HydratedURLButton();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayText = reader.string();
                        break;
                    case 2:
                        message.url = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HydratedURLButton message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.HydratedTemplateButton.HydratedURLButton} HydratedURLButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HydratedURLButton.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HydratedURLButton message.
             * @function verify
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HydratedURLButton.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    if (!$util.isString(message.displayText))
                        return "displayText: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a HydratedURLButton message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.HydratedTemplateButton.HydratedURLButton} HydratedURLButton
             */
            HydratedURLButton.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.HydratedTemplateButton.HydratedURLButton)
                    return object;
                var message = new $root.proto.HydratedTemplateButton.HydratedURLButton();
                if (object.displayText != null)
                    message.displayText = String(object.displayText);
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a HydratedURLButton message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @static
             * @param {proto.HydratedTemplateButton.HydratedURLButton} message HydratedURLButton
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HydratedURLButton.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayText = "";
                    object.url = "";
                }
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    object.displayText = message.displayText;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this HydratedURLButton to JSON.
             * @function toJSON
             * @memberof proto.HydratedTemplateButton.HydratedURLButton
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HydratedURLButton.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HydratedURLButton;
        })();

        return HydratedTemplateButton;
    })();

    proto.IdentityKeyPairStructure = (function() {

        /**
         * Properties of an IdentityKeyPairStructure.
         * @memberof proto
         * @interface IIdentityKeyPairStructure
         * @property {Uint8Array|null} [publicKey] IdentityKeyPairStructure publicKey
         * @property {Uint8Array|null} [privateKey] IdentityKeyPairStructure privateKey
         */

        /**
         * Constructs a new IdentityKeyPairStructure.
         * @memberof proto
         * @classdesc Represents an IdentityKeyPairStructure.
         * @implements IIdentityKeyPairStructure
         * @constructor
         * @param {proto.IIdentityKeyPairStructure=} [properties] Properties to set
         */
        function IdentityKeyPairStructure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKeyPairStructure publicKey.
         * @member {Uint8Array} publicKey
         * @memberof proto.IdentityKeyPairStructure
         * @instance
         */
        IdentityKeyPairStructure.prototype.publicKey = $util.newBuffer([]);

        /**
         * IdentityKeyPairStructure privateKey.
         * @member {Uint8Array} privateKey
         * @memberof proto.IdentityKeyPairStructure
         * @instance
         */
        IdentityKeyPairStructure.prototype.privateKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityKeyPairStructure instance using the specified properties.
         * @function create
         * @memberof proto.IdentityKeyPairStructure
         * @static
         * @param {proto.IIdentityKeyPairStructure=} [properties] Properties to set
         * @returns {proto.IdentityKeyPairStructure} IdentityKeyPairStructure instance
         */
        IdentityKeyPairStructure.create = function create(properties) {
            return new IdentityKeyPairStructure(properties);
        };

        /**
         * Encodes the specified IdentityKeyPairStructure message. Does not implicitly {@link proto.IdentityKeyPairStructure.verify|verify} messages.
         * @function encode
         * @memberof proto.IdentityKeyPairStructure
         * @static
         * @param {proto.IIdentityKeyPairStructure} message IdentityKeyPairStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyPairStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityKeyPairStructure message, length delimited. Does not implicitly {@link proto.IdentityKeyPairStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.IdentityKeyPairStructure
         * @static
         * @param {proto.IIdentityKeyPairStructure} message IdentityKeyPairStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyPairStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKeyPairStructure message from the specified reader or buffer.
         * @function decode
         * @memberof proto.IdentityKeyPairStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.IdentityKeyPairStructure} IdentityKeyPairStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyPairStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.IdentityKeyPairStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.privateKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKeyPairStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.IdentityKeyPairStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.IdentityKeyPairStructure} IdentityKeyPairStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyPairStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKeyPairStructure message.
         * @function verify
         * @memberof proto.IdentityKeyPairStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKeyPairStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityKeyPairStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.IdentityKeyPairStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.IdentityKeyPairStructure} IdentityKeyPairStructure
         */
        IdentityKeyPairStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.IdentityKeyPairStructure)
                return object;
            var message = new $root.proto.IdentityKeyPairStructure();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityKeyPairStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.IdentityKeyPairStructure
         * @static
         * @param {proto.IdentityKeyPairStructure} message IdentityKeyPairStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKeyPairStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            return object;
        };

        /**
         * Converts this IdentityKeyPairStructure to JSON.
         * @function toJSON
         * @memberof proto.IdentityKeyPairStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKeyPairStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKeyPairStructure;
    })();

    proto.InteractiveAnnotation = (function() {

        /**
         * Properties of an InteractiveAnnotation.
         * @memberof proto
         * @interface IInteractiveAnnotation
         * @property {Array.<proto.IPoint>|null} [polygonVertices] InteractiveAnnotation polygonVertices
         * @property {proto.ILocation|null} [location] InteractiveAnnotation location
         */

        /**
         * Constructs a new InteractiveAnnotation.
         * @memberof proto
         * @classdesc Represents an InteractiveAnnotation.
         * @implements IInteractiveAnnotation
         * @constructor
         * @param {proto.IInteractiveAnnotation=} [properties] Properties to set
         */
        function InteractiveAnnotation(properties) {
            this.polygonVertices = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InteractiveAnnotation polygonVertices.
         * @member {Array.<proto.IPoint>} polygonVertices
         * @memberof proto.InteractiveAnnotation
         * @instance
         */
        InteractiveAnnotation.prototype.polygonVertices = $util.emptyArray;

        /**
         * InteractiveAnnotation location.
         * @member {proto.ILocation|null|undefined} location
         * @memberof proto.InteractiveAnnotation
         * @instance
         */
        InteractiveAnnotation.prototype.location = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * InteractiveAnnotation action.
         * @member {"location"|undefined} action
         * @memberof proto.InteractiveAnnotation
         * @instance
         */
        Object.defineProperty(InteractiveAnnotation.prototype, "action", {
            get: $util.oneOfGetter($oneOfFields = ["location"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new InteractiveAnnotation instance using the specified properties.
         * @function create
         * @memberof proto.InteractiveAnnotation
         * @static
         * @param {proto.IInteractiveAnnotation=} [properties] Properties to set
         * @returns {proto.InteractiveAnnotation} InteractiveAnnotation instance
         */
        InteractiveAnnotation.create = function create(properties) {
            return new InteractiveAnnotation(properties);
        };

        /**
         * Encodes the specified InteractiveAnnotation message. Does not implicitly {@link proto.InteractiveAnnotation.verify|verify} messages.
         * @function encode
         * @memberof proto.InteractiveAnnotation
         * @static
         * @param {proto.IInteractiveAnnotation} message InteractiveAnnotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InteractiveAnnotation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.polygonVertices != null && message.polygonVertices.length)
                for (var i = 0; i < message.polygonVertices.length; ++i)
                    $root.proto.Point.encode(message.polygonVertices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                $root.proto.Location.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InteractiveAnnotation message, length delimited. Does not implicitly {@link proto.InteractiveAnnotation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.InteractiveAnnotation
         * @static
         * @param {proto.IInteractiveAnnotation} message InteractiveAnnotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InteractiveAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InteractiveAnnotation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InteractiveAnnotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InteractiveAnnotation} InteractiveAnnotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InteractiveAnnotation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InteractiveAnnotation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.polygonVertices && message.polygonVertices.length))
                        message.polygonVertices = [];
                    message.polygonVertices.push($root.proto.Point.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.location = $root.proto.Location.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InteractiveAnnotation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.InteractiveAnnotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.InteractiveAnnotation} InteractiveAnnotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InteractiveAnnotation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InteractiveAnnotation message.
         * @function verify
         * @memberof proto.InteractiveAnnotation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InteractiveAnnotation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.polygonVertices != null && message.hasOwnProperty("polygonVertices")) {
                if (!Array.isArray(message.polygonVertices))
                    return "polygonVertices: array expected";
                for (var i = 0; i < message.polygonVertices.length; ++i) {
                    var error = $root.proto.Point.verify(message.polygonVertices[i]);
                    if (error)
                        return "polygonVertices." + error;
                }
            }
            if (message.location != null && message.hasOwnProperty("location")) {
                properties.action = 1;
                {
                    var error = $root.proto.Location.verify(message.location);
                    if (error)
                        return "location." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InteractiveAnnotation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.InteractiveAnnotation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.InteractiveAnnotation} InteractiveAnnotation
         */
        InteractiveAnnotation.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.InteractiveAnnotation)
                return object;
            var message = new $root.proto.InteractiveAnnotation();
            if (object.polygonVertices) {
                if (!Array.isArray(object.polygonVertices))
                    throw TypeError(".proto.InteractiveAnnotation.polygonVertices: array expected");
                message.polygonVertices = [];
                for (var i = 0; i < object.polygonVertices.length; ++i) {
                    if (typeof object.polygonVertices[i] !== "object")
                        throw TypeError(".proto.InteractiveAnnotation.polygonVertices: object expected");
                    message.polygonVertices[i] = $root.proto.Point.fromObject(object.polygonVertices[i]);
                }
            }
            if (object.location != null) {
                if (typeof object.location !== "object")
                    throw TypeError(".proto.InteractiveAnnotation.location: object expected");
                message.location = $root.proto.Location.fromObject(object.location);
            }
            return message;
        };

        /**
         * Creates a plain object from an InteractiveAnnotation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.InteractiveAnnotation
         * @static
         * @param {proto.InteractiveAnnotation} message InteractiveAnnotation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InteractiveAnnotation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.polygonVertices = [];
            if (message.polygonVertices && message.polygonVertices.length) {
                object.polygonVertices = [];
                for (var j = 0; j < message.polygonVertices.length; ++j)
                    object.polygonVertices[j] = $root.proto.Point.toObject(message.polygonVertices[j], options);
            }
            if (message.location != null && message.hasOwnProperty("location")) {
                object.location = $root.proto.Location.toObject(message.location, options);
                if (options.oneofs)
                    object.action = "location";
            }
            return object;
        };

        /**
         * Converts this InteractiveAnnotation to JSON.
         * @function toJSON
         * @memberof proto.InteractiveAnnotation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InteractiveAnnotation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InteractiveAnnotation;
    })();

    proto.KeepInChat = (function() {

        /**
         * Properties of a KeepInChat.
         * @memberof proto
         * @interface IKeepInChat
         * @property {proto.KeepType|null} [keepType] KeepInChat keepType
         * @property {number|Long|null} [serverTimestamp] KeepInChat serverTimestamp
         * @property {proto.IMessageKey|null} [key] KeepInChat key
         * @property {string|null} [deviceJid] KeepInChat deviceJid
         * @property {number|Long|null} [clientTimestampMs] KeepInChat clientTimestampMs
         * @property {number|Long|null} [serverTimestampMs] KeepInChat serverTimestampMs
         */

        /**
         * Constructs a new KeepInChat.
         * @memberof proto
         * @classdesc Represents a KeepInChat.
         * @implements IKeepInChat
         * @constructor
         * @param {proto.IKeepInChat=} [properties] Properties to set
         */
        function KeepInChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeepInChat keepType.
         * @member {proto.KeepType} keepType
         * @memberof proto.KeepInChat
         * @instance
         */
        KeepInChat.prototype.keepType = 0;

        /**
         * KeepInChat serverTimestamp.
         * @member {number|Long} serverTimestamp
         * @memberof proto.KeepInChat
         * @instance
         */
        KeepInChat.prototype.serverTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * KeepInChat key.
         * @member {proto.IMessageKey|null|undefined} key
         * @memberof proto.KeepInChat
         * @instance
         */
        KeepInChat.prototype.key = null;

        /**
         * KeepInChat deviceJid.
         * @member {string} deviceJid
         * @memberof proto.KeepInChat
         * @instance
         */
        KeepInChat.prototype.deviceJid = "";

        /**
         * KeepInChat clientTimestampMs.
         * @member {number|Long} clientTimestampMs
         * @memberof proto.KeepInChat
         * @instance
         */
        KeepInChat.prototype.clientTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * KeepInChat serverTimestampMs.
         * @member {number|Long} serverTimestampMs
         * @memberof proto.KeepInChat
         * @instance
         */
        KeepInChat.prototype.serverTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new KeepInChat instance using the specified properties.
         * @function create
         * @memberof proto.KeepInChat
         * @static
         * @param {proto.IKeepInChat=} [properties] Properties to set
         * @returns {proto.KeepInChat} KeepInChat instance
         */
        KeepInChat.create = function create(properties) {
            return new KeepInChat(properties);
        };

        /**
         * Encodes the specified KeepInChat message. Does not implicitly {@link proto.KeepInChat.verify|verify} messages.
         * @function encode
         * @memberof proto.KeepInChat
         * @static
         * @param {proto.IKeepInChat} message KeepInChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeepInChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keepType != null && Object.hasOwnProperty.call(message, "keepType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.keepType);
            if (message.serverTimestamp != null && Object.hasOwnProperty.call(message, "serverTimestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.serverTimestamp);
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.deviceJid != null && Object.hasOwnProperty.call(message, "deviceJid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.deviceJid);
            if (message.clientTimestampMs != null && Object.hasOwnProperty.call(message, "clientTimestampMs"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.clientTimestampMs);
            if (message.serverTimestampMs != null && Object.hasOwnProperty.call(message, "serverTimestampMs"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.serverTimestampMs);
            return writer;
        };

        /**
         * Encodes the specified KeepInChat message, length delimited. Does not implicitly {@link proto.KeepInChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.KeepInChat
         * @static
         * @param {proto.IKeepInChat} message KeepInChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeepInChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeepInChat message from the specified reader or buffer.
         * @function decode
         * @memberof proto.KeepInChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.KeepInChat} KeepInChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeepInChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.KeepInChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keepType = reader.int32();
                    break;
                case 2:
                    message.serverTimestamp = reader.int64();
                    break;
                case 3:
                    message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.deviceJid = reader.string();
                    break;
                case 5:
                    message.clientTimestampMs = reader.int64();
                    break;
                case 6:
                    message.serverTimestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeepInChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.KeepInChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.KeepInChat} KeepInChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeepInChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeepInChat message.
         * @function verify
         * @memberof proto.KeepInChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeepInChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keepType != null && message.hasOwnProperty("keepType"))
                switch (message.keepType) {
                default:
                    return "keepType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                if (!$util.isInteger(message.serverTimestamp) && !(message.serverTimestamp && $util.isInteger(message.serverTimestamp.low) && $util.isInteger(message.serverTimestamp.high)))
                    return "serverTimestamp: integer|Long expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.proto.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.deviceJid != null && message.hasOwnProperty("deviceJid"))
                if (!$util.isString(message.deviceJid))
                    return "deviceJid: string expected";
            if (message.clientTimestampMs != null && message.hasOwnProperty("clientTimestampMs"))
                if (!$util.isInteger(message.clientTimestampMs) && !(message.clientTimestampMs && $util.isInteger(message.clientTimestampMs.low) && $util.isInteger(message.clientTimestampMs.high)))
                    return "clientTimestampMs: integer|Long expected";
            if (message.serverTimestampMs != null && message.hasOwnProperty("serverTimestampMs"))
                if (!$util.isInteger(message.serverTimestampMs) && !(message.serverTimestampMs && $util.isInteger(message.serverTimestampMs.low) && $util.isInteger(message.serverTimestampMs.high)))
                    return "serverTimestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a KeepInChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.KeepInChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.KeepInChat} KeepInChat
         */
        KeepInChat.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.KeepInChat)
                return object;
            var message = new $root.proto.KeepInChat();
            switch (object.keepType) {
            case "UNKNOWN":
            case 0:
                message.keepType = 0;
                break;
            case "KEEP_FOR_ALL":
            case 1:
                message.keepType = 1;
                break;
            case "UNDO_KEEP_FOR_ALL":
            case 2:
                message.keepType = 2;
                break;
            }
            if (object.serverTimestamp != null)
                if ($util.Long)
                    (message.serverTimestamp = $util.Long.fromValue(object.serverTimestamp)).unsigned = false;
                else if (typeof object.serverTimestamp === "string")
                    message.serverTimestamp = parseInt(object.serverTimestamp, 10);
                else if (typeof object.serverTimestamp === "number")
                    message.serverTimestamp = object.serverTimestamp;
                else if (typeof object.serverTimestamp === "object")
                    message.serverTimestamp = new $util.LongBits(object.serverTimestamp.low >>> 0, object.serverTimestamp.high >>> 0).toNumber();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".proto.KeepInChat.key: object expected");
                message.key = $root.proto.MessageKey.fromObject(object.key);
            }
            if (object.deviceJid != null)
                message.deviceJid = String(object.deviceJid);
            if (object.clientTimestampMs != null)
                if ($util.Long)
                    (message.clientTimestampMs = $util.Long.fromValue(object.clientTimestampMs)).unsigned = false;
                else if (typeof object.clientTimestampMs === "string")
                    message.clientTimestampMs = parseInt(object.clientTimestampMs, 10);
                else if (typeof object.clientTimestampMs === "number")
                    message.clientTimestampMs = object.clientTimestampMs;
                else if (typeof object.clientTimestampMs === "object")
                    message.clientTimestampMs = new $util.LongBits(object.clientTimestampMs.low >>> 0, object.clientTimestampMs.high >>> 0).toNumber();
            if (object.serverTimestampMs != null)
                if ($util.Long)
                    (message.serverTimestampMs = $util.Long.fromValue(object.serverTimestampMs)).unsigned = false;
                else if (typeof object.serverTimestampMs === "string")
                    message.serverTimestampMs = parseInt(object.serverTimestampMs, 10);
                else if (typeof object.serverTimestampMs === "number")
                    message.serverTimestampMs = object.serverTimestampMs;
                else if (typeof object.serverTimestampMs === "object")
                    message.serverTimestampMs = new $util.LongBits(object.serverTimestampMs.low >>> 0, object.serverTimestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a KeepInChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.KeepInChat
         * @static
         * @param {proto.KeepInChat} message KeepInChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeepInChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keepType = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.serverTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTimestamp = options.longs === String ? "0" : 0;
                object.key = null;
                object.deviceJid = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.clientTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTimestampMs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.serverTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTimestampMs = options.longs === String ? "0" : 0;
            }
            if (message.keepType != null && message.hasOwnProperty("keepType"))
                object.keepType = options.enums === String ? $root.proto.KeepType[message.keepType] : message.keepType;
            if (message.serverTimestamp != null && message.hasOwnProperty("serverTimestamp"))
                if (typeof message.serverTimestamp === "number")
                    object.serverTimestamp = options.longs === String ? String(message.serverTimestamp) : message.serverTimestamp;
                else
                    object.serverTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.serverTimestamp) : options.longs === Number ? new $util.LongBits(message.serverTimestamp.low >>> 0, message.serverTimestamp.high >>> 0).toNumber() : message.serverTimestamp;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.proto.MessageKey.toObject(message.key, options);
            if (message.deviceJid != null && message.hasOwnProperty("deviceJid"))
                object.deviceJid = message.deviceJid;
            if (message.clientTimestampMs != null && message.hasOwnProperty("clientTimestampMs"))
                if (typeof message.clientTimestampMs === "number")
                    object.clientTimestampMs = options.longs === String ? String(message.clientTimestampMs) : message.clientTimestampMs;
                else
                    object.clientTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.clientTimestampMs) : options.longs === Number ? new $util.LongBits(message.clientTimestampMs.low >>> 0, message.clientTimestampMs.high >>> 0).toNumber() : message.clientTimestampMs;
            if (message.serverTimestampMs != null && message.hasOwnProperty("serverTimestampMs"))
                if (typeof message.serverTimestampMs === "number")
                    object.serverTimestampMs = options.longs === String ? String(message.serverTimestampMs) : message.serverTimestampMs;
                else
                    object.serverTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.serverTimestampMs) : options.longs === Number ? new $util.LongBits(message.serverTimestampMs.low >>> 0, message.serverTimestampMs.high >>> 0).toNumber() : message.serverTimestampMs;
            return object;
        };

        /**
         * Converts this KeepInChat to JSON.
         * @function toJSON
         * @memberof proto.KeepInChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeepInChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeepInChat;
    })();

    /**
     * KeepType enum.
     * @name proto.KeepType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} KEEP_FOR_ALL=1 KEEP_FOR_ALL value
     * @property {number} UNDO_KEEP_FOR_ALL=2 UNDO_KEEP_FOR_ALL value
     */
    proto.KeepType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "KEEP_FOR_ALL"] = 1;
        values[valuesById[2] = "UNDO_KEEP_FOR_ALL"] = 2;
        return values;
    })();

    proto.KeyId = (function() {

        /**
         * Properties of a KeyId.
         * @memberof proto
         * @interface IKeyId
         * @property {Uint8Array|null} [id] KeyId id
         */

        /**
         * Constructs a new KeyId.
         * @memberof proto
         * @classdesc Represents a KeyId.
         * @implements IKeyId
         * @constructor
         * @param {proto.IKeyId=} [properties] Properties to set
         */
        function KeyId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyId id.
         * @member {Uint8Array} id
         * @memberof proto.KeyId
         * @instance
         */
        KeyId.prototype.id = $util.newBuffer([]);

        /**
         * Creates a new KeyId instance using the specified properties.
         * @function create
         * @memberof proto.KeyId
         * @static
         * @param {proto.IKeyId=} [properties] Properties to set
         * @returns {proto.KeyId} KeyId instance
         */
        KeyId.create = function create(properties) {
            return new KeyId(properties);
        };

        /**
         * Encodes the specified KeyId message. Does not implicitly {@link proto.KeyId.verify|verify} messages.
         * @function encode
         * @memberof proto.KeyId
         * @static
         * @param {proto.IKeyId} message KeyId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            return writer;
        };

        /**
         * Encodes the specified KeyId message, length delimited. Does not implicitly {@link proto.KeyId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.KeyId
         * @static
         * @param {proto.IKeyId} message KeyId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyId message from the specified reader or buffer.
         * @function decode
         * @memberof proto.KeyId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.KeyId} KeyId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.KeyId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.KeyId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.KeyId} KeyId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyId message.
         * @function verify
         * @memberof proto.KeyId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            return null;
        };

        /**
         * Creates a KeyId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.KeyId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.KeyId} KeyId
         */
        KeyId.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.KeyId)
                return object;
            var message = new $root.proto.KeyId();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            return message;
        };

        /**
         * Creates a plain object from a KeyId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.KeyId
         * @static
         * @param {proto.KeyId} message KeyId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            return object;
        };

        /**
         * Converts this KeyId to JSON.
         * @function toJSON
         * @memberof proto.KeyId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyId;
    })();

    proto.LocalizedName = (function() {

        /**
         * Properties of a LocalizedName.
         * @memberof proto
         * @interface ILocalizedName
         * @property {string|null} [lg] LocalizedName lg
         * @property {string|null} [lc] LocalizedName lc
         * @property {string|null} [verifiedName] LocalizedName verifiedName
         */

        /**
         * Constructs a new LocalizedName.
         * @memberof proto
         * @classdesc Represents a LocalizedName.
         * @implements ILocalizedName
         * @constructor
         * @param {proto.ILocalizedName=} [properties] Properties to set
         */
        function LocalizedName(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LocalizedName lg.
         * @member {string} lg
         * @memberof proto.LocalizedName
         * @instance
         */
        LocalizedName.prototype.lg = "";

        /**
         * LocalizedName lc.
         * @member {string} lc
         * @memberof proto.LocalizedName
         * @instance
         */
        LocalizedName.prototype.lc = "";

        /**
         * LocalizedName verifiedName.
         * @member {string} verifiedName
         * @memberof proto.LocalizedName
         * @instance
         */
        LocalizedName.prototype.verifiedName = "";

        /**
         * Creates a new LocalizedName instance using the specified properties.
         * @function create
         * @memberof proto.LocalizedName
         * @static
         * @param {proto.ILocalizedName=} [properties] Properties to set
         * @returns {proto.LocalizedName} LocalizedName instance
         */
        LocalizedName.create = function create(properties) {
            return new LocalizedName(properties);
        };

        /**
         * Encodes the specified LocalizedName message. Does not implicitly {@link proto.LocalizedName.verify|verify} messages.
         * @function encode
         * @memberof proto.LocalizedName
         * @static
         * @param {proto.ILocalizedName} message LocalizedName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocalizedName.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lg != null && Object.hasOwnProperty.call(message, "lg"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.lg);
            if (message.lc != null && Object.hasOwnProperty.call(message, "lc"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.lc);
            if (message.verifiedName != null && Object.hasOwnProperty.call(message, "verifiedName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.verifiedName);
            return writer;
        };

        /**
         * Encodes the specified LocalizedName message, length delimited. Does not implicitly {@link proto.LocalizedName.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.LocalizedName
         * @static
         * @param {proto.ILocalizedName} message LocalizedName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocalizedName.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LocalizedName message from the specified reader or buffer.
         * @function decode
         * @memberof proto.LocalizedName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.LocalizedName} LocalizedName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocalizedName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.LocalizedName();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lg = reader.string();
                    break;
                case 2:
                    message.lc = reader.string();
                    break;
                case 3:
                    message.verifiedName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LocalizedName message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.LocalizedName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.LocalizedName} LocalizedName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocalizedName.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LocalizedName message.
         * @function verify
         * @memberof proto.LocalizedName
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LocalizedName.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lg != null && message.hasOwnProperty("lg"))
                if (!$util.isString(message.lg))
                    return "lg: string expected";
            if (message.lc != null && message.hasOwnProperty("lc"))
                if (!$util.isString(message.lc))
                    return "lc: string expected";
            if (message.verifiedName != null && message.hasOwnProperty("verifiedName"))
                if (!$util.isString(message.verifiedName))
                    return "verifiedName: string expected";
            return null;
        };

        /**
         * Creates a LocalizedName message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.LocalizedName
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.LocalizedName} LocalizedName
         */
        LocalizedName.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.LocalizedName)
                return object;
            var message = new $root.proto.LocalizedName();
            if (object.lg != null)
                message.lg = String(object.lg);
            if (object.lc != null)
                message.lc = String(object.lc);
            if (object.verifiedName != null)
                message.verifiedName = String(object.verifiedName);
            return message;
        };

        /**
         * Creates a plain object from a LocalizedName message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.LocalizedName
         * @static
         * @param {proto.LocalizedName} message LocalizedName
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LocalizedName.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lg = "";
                object.lc = "";
                object.verifiedName = "";
            }
            if (message.lg != null && message.hasOwnProperty("lg"))
                object.lg = message.lg;
            if (message.lc != null && message.hasOwnProperty("lc"))
                object.lc = message.lc;
            if (message.verifiedName != null && message.hasOwnProperty("verifiedName"))
                object.verifiedName = message.verifiedName;
            return object;
        };

        /**
         * Converts this LocalizedName to JSON.
         * @function toJSON
         * @memberof proto.LocalizedName
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LocalizedName.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LocalizedName;
    })();

    proto.Location = (function() {

        /**
         * Properties of a Location.
         * @memberof proto
         * @interface ILocation
         * @property {number|null} [degreesLatitude] Location degreesLatitude
         * @property {number|null} [degreesLongitude] Location degreesLongitude
         * @property {string|null} [name] Location name
         */

        /**
         * Constructs a new Location.
         * @memberof proto
         * @classdesc Represents a Location.
         * @implements ILocation
         * @constructor
         * @param {proto.ILocation=} [properties] Properties to set
         */
        function Location(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Location degreesLatitude.
         * @member {number} degreesLatitude
         * @memberof proto.Location
         * @instance
         */
        Location.prototype.degreesLatitude = 0;

        /**
         * Location degreesLongitude.
         * @member {number} degreesLongitude
         * @memberof proto.Location
         * @instance
         */
        Location.prototype.degreesLongitude = 0;

        /**
         * Location name.
         * @member {string} name
         * @memberof proto.Location
         * @instance
         */
        Location.prototype.name = "";

        /**
         * Creates a new Location instance using the specified properties.
         * @function create
         * @memberof proto.Location
         * @static
         * @param {proto.ILocation=} [properties] Properties to set
         * @returns {proto.Location} Location instance
         */
        Location.create = function create(properties) {
            return new Location(properties);
        };

        /**
         * Encodes the specified Location message. Does not implicitly {@link proto.Location.verify|verify} messages.
         * @function encode
         * @memberof proto.Location
         * @static
         * @param {proto.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.degreesLatitude != null && Object.hasOwnProperty.call(message, "degreesLatitude"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.degreesLatitude);
            if (message.degreesLongitude != null && Object.hasOwnProperty.call(message, "degreesLongitude"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.degreesLongitude);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Location message, length delimited. Does not implicitly {@link proto.Location.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Location
         * @static
         * @param {proto.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Location message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Location();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.degreesLatitude = reader.double();
                    break;
                case 2:
                    message.degreesLongitude = reader.double();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Location message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Location message.
         * @function verify
         * @memberof proto.Location
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Location.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                if (typeof message.degreesLatitude !== "number")
                    return "degreesLatitude: number expected";
            if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                if (typeof message.degreesLongitude !== "number")
                    return "degreesLongitude: number expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Location message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Location
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Location} Location
         */
        Location.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Location)
                return object;
            var message = new $root.proto.Location();
            if (object.degreesLatitude != null)
                message.degreesLatitude = Number(object.degreesLatitude);
            if (object.degreesLongitude != null)
                message.degreesLongitude = Number(object.degreesLongitude);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Location message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Location
         * @static
         * @param {proto.Location} message Location
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Location.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.degreesLatitude = 0;
                object.degreesLongitude = 0;
                object.name = "";
            }
            if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                object.degreesLatitude = options.json && !isFinite(message.degreesLatitude) ? String(message.degreesLatitude) : message.degreesLatitude;
            if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                object.degreesLongitude = options.json && !isFinite(message.degreesLongitude) ? String(message.degreesLongitude) : message.degreesLongitude;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Location to JSON.
         * @function toJSON
         * @memberof proto.Location
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Location.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Location;
    })();

    proto.MediaData = (function() {

        /**
         * Properties of a MediaData.
         * @memberof proto
         * @interface IMediaData
         * @property {string|null} [localPath] MediaData localPath
         */

        /**
         * Constructs a new MediaData.
         * @memberof proto
         * @classdesc Represents a MediaData.
         * @implements IMediaData
         * @constructor
         * @param {proto.IMediaData=} [properties] Properties to set
         */
        function MediaData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaData localPath.
         * @member {string} localPath
         * @memberof proto.MediaData
         * @instance
         */
        MediaData.prototype.localPath = "";

        /**
         * Creates a new MediaData instance using the specified properties.
         * @function create
         * @memberof proto.MediaData
         * @static
         * @param {proto.IMediaData=} [properties] Properties to set
         * @returns {proto.MediaData} MediaData instance
         */
        MediaData.create = function create(properties) {
            return new MediaData(properties);
        };

        /**
         * Encodes the specified MediaData message. Does not implicitly {@link proto.MediaData.verify|verify} messages.
         * @function encode
         * @memberof proto.MediaData
         * @static
         * @param {proto.IMediaData} message MediaData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.localPath != null && Object.hasOwnProperty.call(message, "localPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.localPath);
            return writer;
        };

        /**
         * Encodes the specified MediaData message, length delimited. Does not implicitly {@link proto.MediaData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.MediaData
         * @static
         * @param {proto.IMediaData} message MediaData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MediaData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MediaData} MediaData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MediaData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.localPath = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.MediaData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.MediaData} MediaData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaData message.
         * @function verify
         * @memberof proto.MediaData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.localPath != null && message.hasOwnProperty("localPath"))
                if (!$util.isString(message.localPath))
                    return "localPath: string expected";
            return null;
        };

        /**
         * Creates a MediaData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.MediaData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.MediaData} MediaData
         */
        MediaData.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.MediaData)
                return object;
            var message = new $root.proto.MediaData();
            if (object.localPath != null)
                message.localPath = String(object.localPath);
            return message;
        };

        /**
         * Creates a plain object from a MediaData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.MediaData
         * @static
         * @param {proto.MediaData} message MediaData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.localPath = "";
            if (message.localPath != null && message.hasOwnProperty("localPath"))
                object.localPath = message.localPath;
            return object;
        };

        /**
         * Converts this MediaData to JSON.
         * @function toJSON
         * @memberof proto.MediaData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MediaData;
    })();

    proto.MediaRetryNotification = (function() {

        /**
         * Properties of a MediaRetryNotification.
         * @memberof proto
         * @interface IMediaRetryNotification
         * @property {string|null} [stanzaId] MediaRetryNotification stanzaId
         * @property {string|null} [directPath] MediaRetryNotification directPath
         * @property {proto.MediaRetryNotification.ResultType|null} [result] MediaRetryNotification result
         */

        /**
         * Constructs a new MediaRetryNotification.
         * @memberof proto
         * @classdesc Represents a MediaRetryNotification.
         * @implements IMediaRetryNotification
         * @constructor
         * @param {proto.IMediaRetryNotification=} [properties] Properties to set
         */
        function MediaRetryNotification(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaRetryNotification stanzaId.
         * @member {string} stanzaId
         * @memberof proto.MediaRetryNotification
         * @instance
         */
        MediaRetryNotification.prototype.stanzaId = "";

        /**
         * MediaRetryNotification directPath.
         * @member {string} directPath
         * @memberof proto.MediaRetryNotification
         * @instance
         */
        MediaRetryNotification.prototype.directPath = "";

        /**
         * MediaRetryNotification result.
         * @member {proto.MediaRetryNotification.ResultType} result
         * @memberof proto.MediaRetryNotification
         * @instance
         */
        MediaRetryNotification.prototype.result = 0;

        /**
         * Creates a new MediaRetryNotification instance using the specified properties.
         * @function create
         * @memberof proto.MediaRetryNotification
         * @static
         * @param {proto.IMediaRetryNotification=} [properties] Properties to set
         * @returns {proto.MediaRetryNotification} MediaRetryNotification instance
         */
        MediaRetryNotification.create = function create(properties) {
            return new MediaRetryNotification(properties);
        };

        /**
         * Encodes the specified MediaRetryNotification message. Does not implicitly {@link proto.MediaRetryNotification.verify|verify} messages.
         * @function encode
         * @memberof proto.MediaRetryNotification
         * @static
         * @param {proto.IMediaRetryNotification} message MediaRetryNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaRetryNotification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stanzaId != null && Object.hasOwnProperty.call(message, "stanzaId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stanzaId);
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.directPath);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified MediaRetryNotification message, length delimited. Does not implicitly {@link proto.MediaRetryNotification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.MediaRetryNotification
         * @static
         * @param {proto.IMediaRetryNotification} message MediaRetryNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaRetryNotification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaRetryNotification message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MediaRetryNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MediaRetryNotification} MediaRetryNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaRetryNotification.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MediaRetryNotification();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stanzaId = reader.string();
                    break;
                case 2:
                    message.directPath = reader.string();
                    break;
                case 3:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaRetryNotification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.MediaRetryNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.MediaRetryNotification} MediaRetryNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaRetryNotification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaRetryNotification message.
         * @function verify
         * @memberof proto.MediaRetryNotification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaRetryNotification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                if (!$util.isString(message.stanzaId))
                    return "stanzaId: string expected";
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a MediaRetryNotification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.MediaRetryNotification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.MediaRetryNotification} MediaRetryNotification
         */
        MediaRetryNotification.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.MediaRetryNotification)
                return object;
            var message = new $root.proto.MediaRetryNotification();
            if (object.stanzaId != null)
                message.stanzaId = String(object.stanzaId);
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            switch (object.result) {
            case "GENERAL_ERROR":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "NOT_FOUND":
            case 2:
                message.result = 2;
                break;
            case "DECRYPTION_ERROR":
            case 3:
                message.result = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MediaRetryNotification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.MediaRetryNotification
         * @static
         * @param {proto.MediaRetryNotification} message MediaRetryNotification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaRetryNotification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.stanzaId = "";
                object.directPath = "";
                object.result = options.enums === String ? "GENERAL_ERROR" : 0;
            }
            if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                object.stanzaId = message.stanzaId;
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.proto.MediaRetryNotification.ResultType[message.result] : message.result;
            return object;
        };

        /**
         * Converts this MediaRetryNotification to JSON.
         * @function toJSON
         * @memberof proto.MediaRetryNotification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaRetryNotification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ResultType enum.
         * @name proto.MediaRetryNotification.ResultType
         * @enum {number}
         * @property {number} GENERAL_ERROR=0 GENERAL_ERROR value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} NOT_FOUND=2 NOT_FOUND value
         * @property {number} DECRYPTION_ERROR=3 DECRYPTION_ERROR value
         */
        MediaRetryNotification.ResultType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GENERAL_ERROR"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "NOT_FOUND"] = 2;
            values[valuesById[3] = "DECRYPTION_ERROR"] = 3;
            return values;
        })();

        return MediaRetryNotification;
    })();

    /**
     * MediaVisibility enum.
     * @name proto.MediaVisibility
     * @enum {number}
     * @property {number} DEFAULT=0 DEFAULT value
     * @property {number} OFF=1 OFF value
     * @property {number} ON=2 ON value
     */
    proto.MediaVisibility = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT"] = 0;
        values[valuesById[1] = "OFF"] = 1;
        values[valuesById[2] = "ON"] = 2;
        return values;
    })();

    proto.Message = (function() {

        /**
         * Properties of a Message.
         * @memberof proto
         * @interface IMessage
         * @property {string|null} [conversation] Message conversation
         * @property {proto.Message.ISenderKeyDistributionMessage|null} [senderKeyDistributionMessage] Message senderKeyDistributionMessage
         * @property {proto.Message.IImageMessage|null} [imageMessage] Message imageMessage
         * @property {proto.Message.IContactMessage|null} [contactMessage] Message contactMessage
         * @property {proto.Message.ILocationMessage|null} [locationMessage] Message locationMessage
         * @property {proto.Message.IExtendedTextMessage|null} [extendedTextMessage] Message extendedTextMessage
         * @property {proto.Message.IDocumentMessage|null} [documentMessage] Message documentMessage
         * @property {proto.Message.IAudioMessage|null} [audioMessage] Message audioMessage
         * @property {proto.Message.IVideoMessage|null} [videoMessage] Message videoMessage
         * @property {proto.Message.ICall|null} [call] Message call
         * @property {proto.Message.IChat|null} [chat] Message chat
         * @property {proto.Message.IProtocolMessage|null} [protocolMessage] Message protocolMessage
         * @property {proto.Message.IContactsArrayMessage|null} [contactsArrayMessage] Message contactsArrayMessage
         * @property {proto.Message.IHighlyStructuredMessage|null} [highlyStructuredMessage] Message highlyStructuredMessage
         * @property {proto.Message.ISenderKeyDistributionMessage|null} [fastRatchetKeySenderKeyDistributionMessage] Message fastRatchetKeySenderKeyDistributionMessage
         * @property {proto.Message.ISendPaymentMessage|null} [sendPaymentMessage] Message sendPaymentMessage
         * @property {proto.Message.ILiveLocationMessage|null} [liveLocationMessage] Message liveLocationMessage
         * @property {proto.Message.IRequestPaymentMessage|null} [requestPaymentMessage] Message requestPaymentMessage
         * @property {proto.Message.IDeclinePaymentRequestMessage|null} [declinePaymentRequestMessage] Message declinePaymentRequestMessage
         * @property {proto.Message.ICancelPaymentRequestMessage|null} [cancelPaymentRequestMessage] Message cancelPaymentRequestMessage
         * @property {proto.Message.ITemplateMessage|null} [templateMessage] Message templateMessage
         * @property {proto.Message.IStickerMessage|null} [stickerMessage] Message stickerMessage
         * @property {proto.Message.IGroupInviteMessage|null} [groupInviteMessage] Message groupInviteMessage
         * @property {proto.Message.ITemplateButtonReplyMessage|null} [templateButtonReplyMessage] Message templateButtonReplyMessage
         * @property {proto.Message.IProductMessage|null} [productMessage] Message productMessage
         * @property {proto.Message.IDeviceSentMessage|null} [deviceSentMessage] Message deviceSentMessage
         * @property {proto.IMessageContextInfo|null} [messageContextInfo] Message messageContextInfo
         * @property {proto.Message.IListMessage|null} [listMessage] Message listMessage
         * @property {proto.Message.IFutureProofMessage|null} [viewOnceMessage] Message viewOnceMessage
         * @property {proto.Message.IOrderMessage|null} [orderMessage] Message orderMessage
         * @property {proto.Message.IListResponseMessage|null} [listResponseMessage] Message listResponseMessage
         * @property {proto.Message.IFutureProofMessage|null} [ephemeralMessage] Message ephemeralMessage
         * @property {proto.Message.IInvoiceMessage|null} [invoiceMessage] Message invoiceMessage
         * @property {proto.Message.IButtonsMessage|null} [buttonsMessage] Message buttonsMessage
         * @property {proto.Message.IButtonsResponseMessage|null} [buttonsResponseMessage] Message buttonsResponseMessage
         * @property {proto.Message.IPaymentInviteMessage|null} [paymentInviteMessage] Message paymentInviteMessage
         * @property {proto.Message.IInteractiveMessage|null} [interactiveMessage] Message interactiveMessage
         * @property {proto.Message.IReactionMessage|null} [reactionMessage] Message reactionMessage
         * @property {proto.Message.IStickerSyncRMRMessage|null} [stickerSyncRmrMessage] Message stickerSyncRmrMessage
         * @property {proto.Message.IInteractiveResponseMessage|null} [interactiveResponseMessage] Message interactiveResponseMessage
         * @property {proto.Message.IPollCreationMessage|null} [pollCreationMessage] Message pollCreationMessage
         * @property {proto.Message.IPollUpdateMessage|null} [pollUpdateMessage] Message pollUpdateMessage
         * @property {proto.Message.IKeepInChatMessage|null} [keepInChatMessage] Message keepInChatMessage
         * @property {proto.Message.IFutureProofMessage|null} [documentWithCaptionMessage] Message documentWithCaptionMessage
         * @property {proto.Message.IRequestPhoneNumberMessage|null} [requestPhoneNumberMessage] Message requestPhoneNumberMessage
         * @property {proto.Message.IFutureProofMessage|null} [viewOnceMessageV2] Message viewOnceMessageV2
         * @property {proto.Message.IEncReactionMessage|null} [encReactionMessage] Message encReactionMessage
         * @property {proto.Message.IFutureProofMessage|null} [editedMessage] Message editedMessage
         * @property {proto.Message.IFutureProofMessage|null} [viewOnceMessageV2Extension] Message viewOnceMessageV2Extension
         */

        /**
         * Constructs a new Message.
         * @memberof proto
         * @classdesc Represents a Message.
         * @implements IMessage
         * @constructor
         * @param {proto.IMessage=} [properties] Properties to set
         */
        function Message(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Message conversation.
         * @member {string} conversation
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.conversation = "";

        /**
         * Message senderKeyDistributionMessage.
         * @member {proto.Message.ISenderKeyDistributionMessage|null|undefined} senderKeyDistributionMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.senderKeyDistributionMessage = null;

        /**
         * Message imageMessage.
         * @member {proto.Message.IImageMessage|null|undefined} imageMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.imageMessage = null;

        /**
         * Message contactMessage.
         * @member {proto.Message.IContactMessage|null|undefined} contactMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.contactMessage = null;

        /**
         * Message locationMessage.
         * @member {proto.Message.ILocationMessage|null|undefined} locationMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.locationMessage = null;

        /**
         * Message extendedTextMessage.
         * @member {proto.Message.IExtendedTextMessage|null|undefined} extendedTextMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.extendedTextMessage = null;

        /**
         * Message documentMessage.
         * @member {proto.Message.IDocumentMessage|null|undefined} documentMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.documentMessage = null;

        /**
         * Message audioMessage.
         * @member {proto.Message.IAudioMessage|null|undefined} audioMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.audioMessage = null;

        /**
         * Message videoMessage.
         * @member {proto.Message.IVideoMessage|null|undefined} videoMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.videoMessage = null;

        /**
         * Message call.
         * @member {proto.Message.ICall|null|undefined} call
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.call = null;

        /**
         * Message chat.
         * @member {proto.Message.IChat|null|undefined} chat
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.chat = null;

        /**
         * Message protocolMessage.
         * @member {proto.Message.IProtocolMessage|null|undefined} protocolMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.protocolMessage = null;

        /**
         * Message contactsArrayMessage.
         * @member {proto.Message.IContactsArrayMessage|null|undefined} contactsArrayMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.contactsArrayMessage = null;

        /**
         * Message highlyStructuredMessage.
         * @member {proto.Message.IHighlyStructuredMessage|null|undefined} highlyStructuredMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.highlyStructuredMessage = null;

        /**
         * Message fastRatchetKeySenderKeyDistributionMessage.
         * @member {proto.Message.ISenderKeyDistributionMessage|null|undefined} fastRatchetKeySenderKeyDistributionMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.fastRatchetKeySenderKeyDistributionMessage = null;

        /**
         * Message sendPaymentMessage.
         * @member {proto.Message.ISendPaymentMessage|null|undefined} sendPaymentMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.sendPaymentMessage = null;

        /**
         * Message liveLocationMessage.
         * @member {proto.Message.ILiveLocationMessage|null|undefined} liveLocationMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.liveLocationMessage = null;

        /**
         * Message requestPaymentMessage.
         * @member {proto.Message.IRequestPaymentMessage|null|undefined} requestPaymentMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.requestPaymentMessage = null;

        /**
         * Message declinePaymentRequestMessage.
         * @member {proto.Message.IDeclinePaymentRequestMessage|null|undefined} declinePaymentRequestMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.declinePaymentRequestMessage = null;

        /**
         * Message cancelPaymentRequestMessage.
         * @member {proto.Message.ICancelPaymentRequestMessage|null|undefined} cancelPaymentRequestMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.cancelPaymentRequestMessage = null;

        /**
         * Message templateMessage.
         * @member {proto.Message.ITemplateMessage|null|undefined} templateMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.templateMessage = null;

        /**
         * Message stickerMessage.
         * @member {proto.Message.IStickerMessage|null|undefined} stickerMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.stickerMessage = null;

        /**
         * Message groupInviteMessage.
         * @member {proto.Message.IGroupInviteMessage|null|undefined} groupInviteMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.groupInviteMessage = null;

        /**
         * Message templateButtonReplyMessage.
         * @member {proto.Message.ITemplateButtonReplyMessage|null|undefined} templateButtonReplyMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.templateButtonReplyMessage = null;

        /**
         * Message productMessage.
         * @member {proto.Message.IProductMessage|null|undefined} productMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.productMessage = null;

        /**
         * Message deviceSentMessage.
         * @member {proto.Message.IDeviceSentMessage|null|undefined} deviceSentMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.deviceSentMessage = null;

        /**
         * Message messageContextInfo.
         * @member {proto.IMessageContextInfo|null|undefined} messageContextInfo
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.messageContextInfo = null;

        /**
         * Message listMessage.
         * @member {proto.Message.IListMessage|null|undefined} listMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.listMessage = null;

        /**
         * Message viewOnceMessage.
         * @member {proto.Message.IFutureProofMessage|null|undefined} viewOnceMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.viewOnceMessage = null;

        /**
         * Message orderMessage.
         * @member {proto.Message.IOrderMessage|null|undefined} orderMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.orderMessage = null;

        /**
         * Message listResponseMessage.
         * @member {proto.Message.IListResponseMessage|null|undefined} listResponseMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.listResponseMessage = null;

        /**
         * Message ephemeralMessage.
         * @member {proto.Message.IFutureProofMessage|null|undefined} ephemeralMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.ephemeralMessage = null;

        /**
         * Message invoiceMessage.
         * @member {proto.Message.IInvoiceMessage|null|undefined} invoiceMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.invoiceMessage = null;

        /**
         * Message buttonsMessage.
         * @member {proto.Message.IButtonsMessage|null|undefined} buttonsMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.buttonsMessage = null;

        /**
         * Message buttonsResponseMessage.
         * @member {proto.Message.IButtonsResponseMessage|null|undefined} buttonsResponseMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.buttonsResponseMessage = null;

        /**
         * Message paymentInviteMessage.
         * @member {proto.Message.IPaymentInviteMessage|null|undefined} paymentInviteMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.paymentInviteMessage = null;

        /**
         * Message interactiveMessage.
         * @member {proto.Message.IInteractiveMessage|null|undefined} interactiveMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.interactiveMessage = null;

        /**
         * Message reactionMessage.
         * @member {proto.Message.IReactionMessage|null|undefined} reactionMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.reactionMessage = null;

        /**
         * Message stickerSyncRmrMessage.
         * @member {proto.Message.IStickerSyncRMRMessage|null|undefined} stickerSyncRmrMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.stickerSyncRmrMessage = null;

        /**
         * Message interactiveResponseMessage.
         * @member {proto.Message.IInteractiveResponseMessage|null|undefined} interactiveResponseMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.interactiveResponseMessage = null;

        /**
         * Message pollCreationMessage.
         * @member {proto.Message.IPollCreationMessage|null|undefined} pollCreationMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.pollCreationMessage = null;

        /**
         * Message pollUpdateMessage.
         * @member {proto.Message.IPollUpdateMessage|null|undefined} pollUpdateMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.pollUpdateMessage = null;

        /**
         * Message keepInChatMessage.
         * @member {proto.Message.IKeepInChatMessage|null|undefined} keepInChatMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.keepInChatMessage = null;

        /**
         * Message documentWithCaptionMessage.
         * @member {proto.Message.IFutureProofMessage|null|undefined} documentWithCaptionMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.documentWithCaptionMessage = null;

        /**
         * Message requestPhoneNumberMessage.
         * @member {proto.Message.IRequestPhoneNumberMessage|null|undefined} requestPhoneNumberMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.requestPhoneNumberMessage = null;

        /**
         * Message viewOnceMessageV2.
         * @member {proto.Message.IFutureProofMessage|null|undefined} viewOnceMessageV2
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.viewOnceMessageV2 = null;

        /**
         * Message encReactionMessage.
         * @member {proto.Message.IEncReactionMessage|null|undefined} encReactionMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.encReactionMessage = null;

        /**
         * Message editedMessage.
         * @member {proto.Message.IFutureProofMessage|null|undefined} editedMessage
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.editedMessage = null;

        /**
         * Message viewOnceMessageV2Extension.
         * @member {proto.Message.IFutureProofMessage|null|undefined} viewOnceMessageV2Extension
         * @memberof proto.Message
         * @instance
         */
        Message.prototype.viewOnceMessageV2Extension = null;

        /**
         * Creates a new Message instance using the specified properties.
         * @function create
         * @memberof proto.Message
         * @static
         * @param {proto.IMessage=} [properties] Properties to set
         * @returns {proto.Message} Message instance
         */
        Message.create = function create(properties) {
            return new Message(properties);
        };

        /**
         * Encodes the specified Message message. Does not implicitly {@link proto.Message.verify|verify} messages.
         * @function encode
         * @memberof proto.Message
         * @static
         * @param {proto.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.conversation != null && Object.hasOwnProperty.call(message, "conversation"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.conversation);
            if (message.senderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "senderKeyDistributionMessage"))
                $root.proto.Message.SenderKeyDistributionMessage.encode(message.senderKeyDistributionMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.imageMessage != null && Object.hasOwnProperty.call(message, "imageMessage"))
                $root.proto.Message.ImageMessage.encode(message.imageMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.contactMessage != null && Object.hasOwnProperty.call(message, "contactMessage"))
                $root.proto.Message.ContactMessage.encode(message.contactMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.locationMessage != null && Object.hasOwnProperty.call(message, "locationMessage"))
                $root.proto.Message.LocationMessage.encode(message.locationMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.extendedTextMessage != null && Object.hasOwnProperty.call(message, "extendedTextMessage"))
                $root.proto.Message.ExtendedTextMessage.encode(message.extendedTextMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.documentMessage != null && Object.hasOwnProperty.call(message, "documentMessage"))
                $root.proto.Message.DocumentMessage.encode(message.documentMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.audioMessage != null && Object.hasOwnProperty.call(message, "audioMessage"))
                $root.proto.Message.AudioMessage.encode(message.audioMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.videoMessage != null && Object.hasOwnProperty.call(message, "videoMessage"))
                $root.proto.Message.VideoMessage.encode(message.videoMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.call != null && Object.hasOwnProperty.call(message, "call"))
                $root.proto.Message.Call.encode(message.call, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.chat != null && Object.hasOwnProperty.call(message, "chat"))
                $root.proto.Message.Chat.encode(message.chat, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.protocolMessage != null && Object.hasOwnProperty.call(message, "protocolMessage"))
                $root.proto.Message.ProtocolMessage.encode(message.protocolMessage, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.contactsArrayMessage != null && Object.hasOwnProperty.call(message, "contactsArrayMessage"))
                $root.proto.Message.ContactsArrayMessage.encode(message.contactsArrayMessage, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.highlyStructuredMessage != null && Object.hasOwnProperty.call(message, "highlyStructuredMessage"))
                $root.proto.Message.HighlyStructuredMessage.encode(message.highlyStructuredMessage, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.fastRatchetKeySenderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "fastRatchetKeySenderKeyDistributionMessage"))
                $root.proto.Message.SenderKeyDistributionMessage.encode(message.fastRatchetKeySenderKeyDistributionMessage, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.sendPaymentMessage != null && Object.hasOwnProperty.call(message, "sendPaymentMessage"))
                $root.proto.Message.SendPaymentMessage.encode(message.sendPaymentMessage, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.liveLocationMessage != null && Object.hasOwnProperty.call(message, "liveLocationMessage"))
                $root.proto.Message.LiveLocationMessage.encode(message.liveLocationMessage, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.requestPaymentMessage != null && Object.hasOwnProperty.call(message, "requestPaymentMessage"))
                $root.proto.Message.RequestPaymentMessage.encode(message.requestPaymentMessage, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.declinePaymentRequestMessage != null && Object.hasOwnProperty.call(message, "declinePaymentRequestMessage"))
                $root.proto.Message.DeclinePaymentRequestMessage.encode(message.declinePaymentRequestMessage, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.cancelPaymentRequestMessage != null && Object.hasOwnProperty.call(message, "cancelPaymentRequestMessage"))
                $root.proto.Message.CancelPaymentRequestMessage.encode(message.cancelPaymentRequestMessage, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.templateMessage != null && Object.hasOwnProperty.call(message, "templateMessage"))
                $root.proto.Message.TemplateMessage.encode(message.templateMessage, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.stickerMessage != null && Object.hasOwnProperty.call(message, "stickerMessage"))
                $root.proto.Message.StickerMessage.encode(message.stickerMessage, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.groupInviteMessage != null && Object.hasOwnProperty.call(message, "groupInviteMessage"))
                $root.proto.Message.GroupInviteMessage.encode(message.groupInviteMessage, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.templateButtonReplyMessage != null && Object.hasOwnProperty.call(message, "templateButtonReplyMessage"))
                $root.proto.Message.TemplateButtonReplyMessage.encode(message.templateButtonReplyMessage, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.productMessage != null && Object.hasOwnProperty.call(message, "productMessage"))
                $root.proto.Message.ProductMessage.encode(message.productMessage, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.deviceSentMessage != null && Object.hasOwnProperty.call(message, "deviceSentMessage"))
                $root.proto.Message.DeviceSentMessage.encode(message.deviceSentMessage, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.messageContextInfo != null && Object.hasOwnProperty.call(message, "messageContextInfo"))
                $root.proto.MessageContextInfo.encode(message.messageContextInfo, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.listMessage != null && Object.hasOwnProperty.call(message, "listMessage"))
                $root.proto.Message.ListMessage.encode(message.listMessage, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            if (message.viewOnceMessage != null && Object.hasOwnProperty.call(message, "viewOnceMessage"))
                $root.proto.Message.FutureProofMessage.encode(message.viewOnceMessage, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.orderMessage != null && Object.hasOwnProperty.call(message, "orderMessage"))
                $root.proto.Message.OrderMessage.encode(message.orderMessage, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.listResponseMessage != null && Object.hasOwnProperty.call(message, "listResponseMessage"))
                $root.proto.Message.ListResponseMessage.encode(message.listResponseMessage, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
            if (message.ephemeralMessage != null && Object.hasOwnProperty.call(message, "ephemeralMessage"))
                $root.proto.Message.FutureProofMessage.encode(message.ephemeralMessage, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
            if (message.invoiceMessage != null && Object.hasOwnProperty.call(message, "invoiceMessage"))
                $root.proto.Message.InvoiceMessage.encode(message.invoiceMessage, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
            if (message.buttonsMessage != null && Object.hasOwnProperty.call(message, "buttonsMessage"))
                $root.proto.Message.ButtonsMessage.encode(message.buttonsMessage, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            if (message.buttonsResponseMessage != null && Object.hasOwnProperty.call(message, "buttonsResponseMessage"))
                $root.proto.Message.ButtonsResponseMessage.encode(message.buttonsResponseMessage, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
            if (message.paymentInviteMessage != null && Object.hasOwnProperty.call(message, "paymentInviteMessage"))
                $root.proto.Message.PaymentInviteMessage.encode(message.paymentInviteMessage, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            if (message.interactiveMessage != null && Object.hasOwnProperty.call(message, "interactiveMessage"))
                $root.proto.Message.InteractiveMessage.encode(message.interactiveMessage, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.reactionMessage != null && Object.hasOwnProperty.call(message, "reactionMessage"))
                $root.proto.Message.ReactionMessage.encode(message.reactionMessage, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
            if (message.stickerSyncRmrMessage != null && Object.hasOwnProperty.call(message, "stickerSyncRmrMessage"))
                $root.proto.Message.StickerSyncRMRMessage.encode(message.stickerSyncRmrMessage, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
            if (message.interactiveResponseMessage != null && Object.hasOwnProperty.call(message, "interactiveResponseMessage"))
                $root.proto.Message.InteractiveResponseMessage.encode(message.interactiveResponseMessage, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
            if (message.pollCreationMessage != null && Object.hasOwnProperty.call(message, "pollCreationMessage"))
                $root.proto.Message.PollCreationMessage.encode(message.pollCreationMessage, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
            if (message.pollUpdateMessage != null && Object.hasOwnProperty.call(message, "pollUpdateMessage"))
                $root.proto.Message.PollUpdateMessage.encode(message.pollUpdateMessage, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
            if (message.keepInChatMessage != null && Object.hasOwnProperty.call(message, "keepInChatMessage"))
                $root.proto.Message.KeepInChatMessage.encode(message.keepInChatMessage, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            if (message.documentWithCaptionMessage != null && Object.hasOwnProperty.call(message, "documentWithCaptionMessage"))
                $root.proto.Message.FutureProofMessage.encode(message.documentWithCaptionMessage, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
            if (message.requestPhoneNumberMessage != null && Object.hasOwnProperty.call(message, "requestPhoneNumberMessage"))
                $root.proto.Message.RequestPhoneNumberMessage.encode(message.requestPhoneNumberMessage, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
            if (message.viewOnceMessageV2 != null && Object.hasOwnProperty.call(message, "viewOnceMessageV2"))
                $root.proto.Message.FutureProofMessage.encode(message.viewOnceMessageV2, writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
            if (message.encReactionMessage != null && Object.hasOwnProperty.call(message, "encReactionMessage"))
                $root.proto.Message.EncReactionMessage.encode(message.encReactionMessage, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
            if (message.editedMessage != null && Object.hasOwnProperty.call(message, "editedMessage"))
                $root.proto.Message.FutureProofMessage.encode(message.editedMessage, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
            if (message.viewOnceMessageV2Extension != null && Object.hasOwnProperty.call(message, "viewOnceMessageV2Extension"))
                $root.proto.Message.FutureProofMessage.encode(message.viewOnceMessageV2Extension, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Message message, length delimited. Does not implicitly {@link proto.Message.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Message
         * @static
         * @param {proto.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.conversation = reader.string();
                    break;
                case 2:
                    message.senderKeyDistributionMessage = $root.proto.Message.SenderKeyDistributionMessage.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.imageMessage = $root.proto.Message.ImageMessage.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.contactMessage = $root.proto.Message.ContactMessage.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.locationMessage = $root.proto.Message.LocationMessage.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.extendedTextMessage = $root.proto.Message.ExtendedTextMessage.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.documentMessage = $root.proto.Message.DocumentMessage.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.audioMessage = $root.proto.Message.AudioMessage.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.videoMessage = $root.proto.Message.VideoMessage.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.call = $root.proto.Message.Call.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.chat = $root.proto.Message.Chat.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.protocolMessage = $root.proto.Message.ProtocolMessage.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.contactsArrayMessage = $root.proto.Message.ContactsArrayMessage.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.highlyStructuredMessage = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.fastRatchetKeySenderKeyDistributionMessage = $root.proto.Message.SenderKeyDistributionMessage.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.sendPaymentMessage = $root.proto.Message.SendPaymentMessage.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.liveLocationMessage = $root.proto.Message.LiveLocationMessage.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.requestPaymentMessage = $root.proto.Message.RequestPaymentMessage.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.declinePaymentRequestMessage = $root.proto.Message.DeclinePaymentRequestMessage.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.cancelPaymentRequestMessage = $root.proto.Message.CancelPaymentRequestMessage.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.templateMessage = $root.proto.Message.TemplateMessage.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.stickerMessage = $root.proto.Message.StickerMessage.decode(reader, reader.uint32());
                    break;
                case 28:
                    message.groupInviteMessage = $root.proto.Message.GroupInviteMessage.decode(reader, reader.uint32());
                    break;
                case 29:
                    message.templateButtonReplyMessage = $root.proto.Message.TemplateButtonReplyMessage.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.productMessage = $root.proto.Message.ProductMessage.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.deviceSentMessage = $root.proto.Message.DeviceSentMessage.decode(reader, reader.uint32());
                    break;
                case 35:
                    message.messageContextInfo = $root.proto.MessageContextInfo.decode(reader, reader.uint32());
                    break;
                case 36:
                    message.listMessage = $root.proto.Message.ListMessage.decode(reader, reader.uint32());
                    break;
                case 37:
                    message.viewOnceMessage = $root.proto.Message.FutureProofMessage.decode(reader, reader.uint32());
                    break;
                case 38:
                    message.orderMessage = $root.proto.Message.OrderMessage.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.listResponseMessage = $root.proto.Message.ListResponseMessage.decode(reader, reader.uint32());
                    break;
                case 40:
                    message.ephemeralMessage = $root.proto.Message.FutureProofMessage.decode(reader, reader.uint32());
                    break;
                case 41:
                    message.invoiceMessage = $root.proto.Message.InvoiceMessage.decode(reader, reader.uint32());
                    break;
                case 42:
                    message.buttonsMessage = $root.proto.Message.ButtonsMessage.decode(reader, reader.uint32());
                    break;
                case 43:
                    message.buttonsResponseMessage = $root.proto.Message.ButtonsResponseMessage.decode(reader, reader.uint32());
                    break;
                case 44:
                    message.paymentInviteMessage = $root.proto.Message.PaymentInviteMessage.decode(reader, reader.uint32());
                    break;
                case 45:
                    message.interactiveMessage = $root.proto.Message.InteractiveMessage.decode(reader, reader.uint32());
                    break;
                case 46:
                    message.reactionMessage = $root.proto.Message.ReactionMessage.decode(reader, reader.uint32());
                    break;
                case 47:
                    message.stickerSyncRmrMessage = $root.proto.Message.StickerSyncRMRMessage.decode(reader, reader.uint32());
                    break;
                case 48:
                    message.interactiveResponseMessage = $root.proto.Message.InteractiveResponseMessage.decode(reader, reader.uint32());
                    break;
                case 49:
                    message.pollCreationMessage = $root.proto.Message.PollCreationMessage.decode(reader, reader.uint32());
                    break;
                case 50:
                    message.pollUpdateMessage = $root.proto.Message.PollUpdateMessage.decode(reader, reader.uint32());
                    break;
                case 51:
                    message.keepInChatMessage = $root.proto.Message.KeepInChatMessage.decode(reader, reader.uint32());
                    break;
                case 53:
                    message.documentWithCaptionMessage = $root.proto.Message.FutureProofMessage.decode(reader, reader.uint32());
                    break;
                case 54:
                    message.requestPhoneNumberMessage = $root.proto.Message.RequestPhoneNumberMessage.decode(reader, reader.uint32());
                    break;
                case 55:
                    message.viewOnceMessageV2 = $root.proto.Message.FutureProofMessage.decode(reader, reader.uint32());
                    break;
                case 56:
                    message.encReactionMessage = $root.proto.Message.EncReactionMessage.decode(reader, reader.uint32());
                    break;
                case 58:
                    message.editedMessage = $root.proto.Message.FutureProofMessage.decode(reader, reader.uint32());
                    break;
                case 59:
                    message.viewOnceMessageV2Extension = $root.proto.Message.FutureProofMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Message message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Message message.
         * @function verify
         * @memberof proto.Message
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Message.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.conversation != null && message.hasOwnProperty("conversation"))
                if (!$util.isString(message.conversation))
                    return "conversation: string expected";
            if (message.senderKeyDistributionMessage != null && message.hasOwnProperty("senderKeyDistributionMessage")) {
                var error = $root.proto.Message.SenderKeyDistributionMessage.verify(message.senderKeyDistributionMessage);
                if (error)
                    return "senderKeyDistributionMessage." + error;
            }
            if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                var error = $root.proto.Message.ImageMessage.verify(message.imageMessage);
                if (error)
                    return "imageMessage." + error;
            }
            if (message.contactMessage != null && message.hasOwnProperty("contactMessage")) {
                var error = $root.proto.Message.ContactMessage.verify(message.contactMessage);
                if (error)
                    return "contactMessage." + error;
            }
            if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                var error = $root.proto.Message.LocationMessage.verify(message.locationMessage);
                if (error)
                    return "locationMessage." + error;
            }
            if (message.extendedTextMessage != null && message.hasOwnProperty("extendedTextMessage")) {
                var error = $root.proto.Message.ExtendedTextMessage.verify(message.extendedTextMessage);
                if (error)
                    return "extendedTextMessage." + error;
            }
            if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                var error = $root.proto.Message.DocumentMessage.verify(message.documentMessage);
                if (error)
                    return "documentMessage." + error;
            }
            if (message.audioMessage != null && message.hasOwnProperty("audioMessage")) {
                var error = $root.proto.Message.AudioMessage.verify(message.audioMessage);
                if (error)
                    return "audioMessage." + error;
            }
            if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                var error = $root.proto.Message.VideoMessage.verify(message.videoMessage);
                if (error)
                    return "videoMessage." + error;
            }
            if (message.call != null && message.hasOwnProperty("call")) {
                var error = $root.proto.Message.Call.verify(message.call);
                if (error)
                    return "call." + error;
            }
            if (message.chat != null && message.hasOwnProperty("chat")) {
                var error = $root.proto.Message.Chat.verify(message.chat);
                if (error)
                    return "chat." + error;
            }
            if (message.protocolMessage != null && message.hasOwnProperty("protocolMessage")) {
                var error = $root.proto.Message.ProtocolMessage.verify(message.protocolMessage);
                if (error)
                    return "protocolMessage." + error;
            }
            if (message.contactsArrayMessage != null && message.hasOwnProperty("contactsArrayMessage")) {
                var error = $root.proto.Message.ContactsArrayMessage.verify(message.contactsArrayMessage);
                if (error)
                    return "contactsArrayMessage." + error;
            }
            if (message.highlyStructuredMessage != null && message.hasOwnProperty("highlyStructuredMessage")) {
                var error = $root.proto.Message.HighlyStructuredMessage.verify(message.highlyStructuredMessage);
                if (error)
                    return "highlyStructuredMessage." + error;
            }
            if (message.fastRatchetKeySenderKeyDistributionMessage != null && message.hasOwnProperty("fastRatchetKeySenderKeyDistributionMessage")) {
                var error = $root.proto.Message.SenderKeyDistributionMessage.verify(message.fastRatchetKeySenderKeyDistributionMessage);
                if (error)
                    return "fastRatchetKeySenderKeyDistributionMessage." + error;
            }
            if (message.sendPaymentMessage != null && message.hasOwnProperty("sendPaymentMessage")) {
                var error = $root.proto.Message.SendPaymentMessage.verify(message.sendPaymentMessage);
                if (error)
                    return "sendPaymentMessage." + error;
            }
            if (message.liveLocationMessage != null && message.hasOwnProperty("liveLocationMessage")) {
                var error = $root.proto.Message.LiveLocationMessage.verify(message.liveLocationMessage);
                if (error)
                    return "liveLocationMessage." + error;
            }
            if (message.requestPaymentMessage != null && message.hasOwnProperty("requestPaymentMessage")) {
                var error = $root.proto.Message.RequestPaymentMessage.verify(message.requestPaymentMessage);
                if (error)
                    return "requestPaymentMessage." + error;
            }
            if (message.declinePaymentRequestMessage != null && message.hasOwnProperty("declinePaymentRequestMessage")) {
                var error = $root.proto.Message.DeclinePaymentRequestMessage.verify(message.declinePaymentRequestMessage);
                if (error)
                    return "declinePaymentRequestMessage." + error;
            }
            if (message.cancelPaymentRequestMessage != null && message.hasOwnProperty("cancelPaymentRequestMessage")) {
                var error = $root.proto.Message.CancelPaymentRequestMessage.verify(message.cancelPaymentRequestMessage);
                if (error)
                    return "cancelPaymentRequestMessage." + error;
            }
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage")) {
                var error = $root.proto.Message.TemplateMessage.verify(message.templateMessage);
                if (error)
                    return "templateMessage." + error;
            }
            if (message.stickerMessage != null && message.hasOwnProperty("stickerMessage")) {
                var error = $root.proto.Message.StickerMessage.verify(message.stickerMessage);
                if (error)
                    return "stickerMessage." + error;
            }
            if (message.groupInviteMessage != null && message.hasOwnProperty("groupInviteMessage")) {
                var error = $root.proto.Message.GroupInviteMessage.verify(message.groupInviteMessage);
                if (error)
                    return "groupInviteMessage." + error;
            }
            if (message.templateButtonReplyMessage != null && message.hasOwnProperty("templateButtonReplyMessage")) {
                var error = $root.proto.Message.TemplateButtonReplyMessage.verify(message.templateButtonReplyMessage);
                if (error)
                    return "templateButtonReplyMessage." + error;
            }
            if (message.productMessage != null && message.hasOwnProperty("productMessage")) {
                var error = $root.proto.Message.ProductMessage.verify(message.productMessage);
                if (error)
                    return "productMessage." + error;
            }
            if (message.deviceSentMessage != null && message.hasOwnProperty("deviceSentMessage")) {
                var error = $root.proto.Message.DeviceSentMessage.verify(message.deviceSentMessage);
                if (error)
                    return "deviceSentMessage." + error;
            }
            if (message.messageContextInfo != null && message.hasOwnProperty("messageContextInfo")) {
                var error = $root.proto.MessageContextInfo.verify(message.messageContextInfo);
                if (error)
                    return "messageContextInfo." + error;
            }
            if (message.listMessage != null && message.hasOwnProperty("listMessage")) {
                var error = $root.proto.Message.ListMessage.verify(message.listMessage);
                if (error)
                    return "listMessage." + error;
            }
            if (message.viewOnceMessage != null && message.hasOwnProperty("viewOnceMessage")) {
                var error = $root.proto.Message.FutureProofMessage.verify(message.viewOnceMessage);
                if (error)
                    return "viewOnceMessage." + error;
            }
            if (message.orderMessage != null && message.hasOwnProperty("orderMessage")) {
                var error = $root.proto.Message.OrderMessage.verify(message.orderMessage);
                if (error)
                    return "orderMessage." + error;
            }
            if (message.listResponseMessage != null && message.hasOwnProperty("listResponseMessage")) {
                var error = $root.proto.Message.ListResponseMessage.verify(message.listResponseMessage);
                if (error)
                    return "listResponseMessage." + error;
            }
            if (message.ephemeralMessage != null && message.hasOwnProperty("ephemeralMessage")) {
                var error = $root.proto.Message.FutureProofMessage.verify(message.ephemeralMessage);
                if (error)
                    return "ephemeralMessage." + error;
            }
            if (message.invoiceMessage != null && message.hasOwnProperty("invoiceMessage")) {
                var error = $root.proto.Message.InvoiceMessage.verify(message.invoiceMessage);
                if (error)
                    return "invoiceMessage." + error;
            }
            if (message.buttonsMessage != null && message.hasOwnProperty("buttonsMessage")) {
                var error = $root.proto.Message.ButtonsMessage.verify(message.buttonsMessage);
                if (error)
                    return "buttonsMessage." + error;
            }
            if (message.buttonsResponseMessage != null && message.hasOwnProperty("buttonsResponseMessage")) {
                var error = $root.proto.Message.ButtonsResponseMessage.verify(message.buttonsResponseMessage);
                if (error)
                    return "buttonsResponseMessage." + error;
            }
            if (message.paymentInviteMessage != null && message.hasOwnProperty("paymentInviteMessage")) {
                var error = $root.proto.Message.PaymentInviteMessage.verify(message.paymentInviteMessage);
                if (error)
                    return "paymentInviteMessage." + error;
            }
            if (message.interactiveMessage != null && message.hasOwnProperty("interactiveMessage")) {
                var error = $root.proto.Message.InteractiveMessage.verify(message.interactiveMessage);
                if (error)
                    return "interactiveMessage." + error;
            }
            if (message.reactionMessage != null && message.hasOwnProperty("reactionMessage")) {
                var error = $root.proto.Message.ReactionMessage.verify(message.reactionMessage);
                if (error)
                    return "reactionMessage." + error;
            }
            if (message.stickerSyncRmrMessage != null && message.hasOwnProperty("stickerSyncRmrMessage")) {
                var error = $root.proto.Message.StickerSyncRMRMessage.verify(message.stickerSyncRmrMessage);
                if (error)
                    return "stickerSyncRmrMessage." + error;
            }
            if (message.interactiveResponseMessage != null && message.hasOwnProperty("interactiveResponseMessage")) {
                var error = $root.proto.Message.InteractiveResponseMessage.verify(message.interactiveResponseMessage);
                if (error)
                    return "interactiveResponseMessage." + error;
            }
            if (message.pollCreationMessage != null && message.hasOwnProperty("pollCreationMessage")) {
                var error = $root.proto.Message.PollCreationMessage.verify(message.pollCreationMessage);
                if (error)
                    return "pollCreationMessage." + error;
            }
            if (message.pollUpdateMessage != null && message.hasOwnProperty("pollUpdateMessage")) {
                var error = $root.proto.Message.PollUpdateMessage.verify(message.pollUpdateMessage);
                if (error)
                    return "pollUpdateMessage." + error;
            }
            if (message.keepInChatMessage != null && message.hasOwnProperty("keepInChatMessage")) {
                var error = $root.proto.Message.KeepInChatMessage.verify(message.keepInChatMessage);
                if (error)
                    return "keepInChatMessage." + error;
            }
            if (message.documentWithCaptionMessage != null && message.hasOwnProperty("documentWithCaptionMessage")) {
                var error = $root.proto.Message.FutureProofMessage.verify(message.documentWithCaptionMessage);
                if (error)
                    return "documentWithCaptionMessage." + error;
            }
            if (message.requestPhoneNumberMessage != null && message.hasOwnProperty("requestPhoneNumberMessage")) {
                var error = $root.proto.Message.RequestPhoneNumberMessage.verify(message.requestPhoneNumberMessage);
                if (error)
                    return "requestPhoneNumberMessage." + error;
            }
            if (message.viewOnceMessageV2 != null && message.hasOwnProperty("viewOnceMessageV2")) {
                var error = $root.proto.Message.FutureProofMessage.verify(message.viewOnceMessageV2);
                if (error)
                    return "viewOnceMessageV2." + error;
            }
            if (message.encReactionMessage != null && message.hasOwnProperty("encReactionMessage")) {
                var error = $root.proto.Message.EncReactionMessage.verify(message.encReactionMessage);
                if (error)
                    return "encReactionMessage." + error;
            }
            if (message.editedMessage != null && message.hasOwnProperty("editedMessage")) {
                var error = $root.proto.Message.FutureProofMessage.verify(message.editedMessage);
                if (error)
                    return "editedMessage." + error;
            }
            if (message.viewOnceMessageV2Extension != null && message.hasOwnProperty("viewOnceMessageV2Extension")) {
                var error = $root.proto.Message.FutureProofMessage.verify(message.viewOnceMessageV2Extension);
                if (error)
                    return "viewOnceMessageV2Extension." + error;
            }
            return null;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Message
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Message} Message
         */
        Message.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Message)
                return object;
            var message = new $root.proto.Message();
            if (object.conversation != null)
                message.conversation = String(object.conversation);
            if (object.senderKeyDistributionMessage != null) {
                if (typeof object.senderKeyDistributionMessage !== "object")
                    throw TypeError(".proto.Message.senderKeyDistributionMessage: object expected");
                message.senderKeyDistributionMessage = $root.proto.Message.SenderKeyDistributionMessage.fromObject(object.senderKeyDistributionMessage);
            }
            if (object.imageMessage != null) {
                if (typeof object.imageMessage !== "object")
                    throw TypeError(".proto.Message.imageMessage: object expected");
                message.imageMessage = $root.proto.Message.ImageMessage.fromObject(object.imageMessage);
            }
            if (object.contactMessage != null) {
                if (typeof object.contactMessage !== "object")
                    throw TypeError(".proto.Message.contactMessage: object expected");
                message.contactMessage = $root.proto.Message.ContactMessage.fromObject(object.contactMessage);
            }
            if (object.locationMessage != null) {
                if (typeof object.locationMessage !== "object")
                    throw TypeError(".proto.Message.locationMessage: object expected");
                message.locationMessage = $root.proto.Message.LocationMessage.fromObject(object.locationMessage);
            }
            if (object.extendedTextMessage != null) {
                if (typeof object.extendedTextMessage !== "object")
                    throw TypeError(".proto.Message.extendedTextMessage: object expected");
                message.extendedTextMessage = $root.proto.Message.ExtendedTextMessage.fromObject(object.extendedTextMessage);
            }
            if (object.documentMessage != null) {
                if (typeof object.documentMessage !== "object")
                    throw TypeError(".proto.Message.documentMessage: object expected");
                message.documentMessage = $root.proto.Message.DocumentMessage.fromObject(object.documentMessage);
            }
            if (object.audioMessage != null) {
                if (typeof object.audioMessage !== "object")
                    throw TypeError(".proto.Message.audioMessage: object expected");
                message.audioMessage = $root.proto.Message.AudioMessage.fromObject(object.audioMessage);
            }
            if (object.videoMessage != null) {
                if (typeof object.videoMessage !== "object")
                    throw TypeError(".proto.Message.videoMessage: object expected");
                message.videoMessage = $root.proto.Message.VideoMessage.fromObject(object.videoMessage);
            }
            if (object.call != null) {
                if (typeof object.call !== "object")
                    throw TypeError(".proto.Message.call: object expected");
                message.call = $root.proto.Message.Call.fromObject(object.call);
            }
            if (object.chat != null) {
                if (typeof object.chat !== "object")
                    throw TypeError(".proto.Message.chat: object expected");
                message.chat = $root.proto.Message.Chat.fromObject(object.chat);
            }
            if (object.protocolMessage != null) {
                if (typeof object.protocolMessage !== "object")
                    throw TypeError(".proto.Message.protocolMessage: object expected");
                message.protocolMessage = $root.proto.Message.ProtocolMessage.fromObject(object.protocolMessage);
            }
            if (object.contactsArrayMessage != null) {
                if (typeof object.contactsArrayMessage !== "object")
                    throw TypeError(".proto.Message.contactsArrayMessage: object expected");
                message.contactsArrayMessage = $root.proto.Message.ContactsArrayMessage.fromObject(object.contactsArrayMessage);
            }
            if (object.highlyStructuredMessage != null) {
                if (typeof object.highlyStructuredMessage !== "object")
                    throw TypeError(".proto.Message.highlyStructuredMessage: object expected");
                message.highlyStructuredMessage = $root.proto.Message.HighlyStructuredMessage.fromObject(object.highlyStructuredMessage);
            }
            if (object.fastRatchetKeySenderKeyDistributionMessage != null) {
                if (typeof object.fastRatchetKeySenderKeyDistributionMessage !== "object")
                    throw TypeError(".proto.Message.fastRatchetKeySenderKeyDistributionMessage: object expected");
                message.fastRatchetKeySenderKeyDistributionMessage = $root.proto.Message.SenderKeyDistributionMessage.fromObject(object.fastRatchetKeySenderKeyDistributionMessage);
            }
            if (object.sendPaymentMessage != null) {
                if (typeof object.sendPaymentMessage !== "object")
                    throw TypeError(".proto.Message.sendPaymentMessage: object expected");
                message.sendPaymentMessage = $root.proto.Message.SendPaymentMessage.fromObject(object.sendPaymentMessage);
            }
            if (object.liveLocationMessage != null) {
                if (typeof object.liveLocationMessage !== "object")
                    throw TypeError(".proto.Message.liveLocationMessage: object expected");
                message.liveLocationMessage = $root.proto.Message.LiveLocationMessage.fromObject(object.liveLocationMessage);
            }
            if (object.requestPaymentMessage != null) {
                if (typeof object.requestPaymentMessage !== "object")
                    throw TypeError(".proto.Message.requestPaymentMessage: object expected");
                message.requestPaymentMessage = $root.proto.Message.RequestPaymentMessage.fromObject(object.requestPaymentMessage);
            }
            if (object.declinePaymentRequestMessage != null) {
                if (typeof object.declinePaymentRequestMessage !== "object")
                    throw TypeError(".proto.Message.declinePaymentRequestMessage: object expected");
                message.declinePaymentRequestMessage = $root.proto.Message.DeclinePaymentRequestMessage.fromObject(object.declinePaymentRequestMessage);
            }
            if (object.cancelPaymentRequestMessage != null) {
                if (typeof object.cancelPaymentRequestMessage !== "object")
                    throw TypeError(".proto.Message.cancelPaymentRequestMessage: object expected");
                message.cancelPaymentRequestMessage = $root.proto.Message.CancelPaymentRequestMessage.fromObject(object.cancelPaymentRequestMessage);
            }
            if (object.templateMessage != null) {
                if (typeof object.templateMessage !== "object")
                    throw TypeError(".proto.Message.templateMessage: object expected");
                message.templateMessage = $root.proto.Message.TemplateMessage.fromObject(object.templateMessage);
            }
            if (object.stickerMessage != null) {
                if (typeof object.stickerMessage !== "object")
                    throw TypeError(".proto.Message.stickerMessage: object expected");
                message.stickerMessage = $root.proto.Message.StickerMessage.fromObject(object.stickerMessage);
            }
            if (object.groupInviteMessage != null) {
                if (typeof object.groupInviteMessage !== "object")
                    throw TypeError(".proto.Message.groupInviteMessage: object expected");
                message.groupInviteMessage = $root.proto.Message.GroupInviteMessage.fromObject(object.groupInviteMessage);
            }
            if (object.templateButtonReplyMessage != null) {
                if (typeof object.templateButtonReplyMessage !== "object")
                    throw TypeError(".proto.Message.templateButtonReplyMessage: object expected");
                message.templateButtonReplyMessage = $root.proto.Message.TemplateButtonReplyMessage.fromObject(object.templateButtonReplyMessage);
            }
            if (object.productMessage != null) {
                if (typeof object.productMessage !== "object")
                    throw TypeError(".proto.Message.productMessage: object expected");
                message.productMessage = $root.proto.Message.ProductMessage.fromObject(object.productMessage);
            }
            if (object.deviceSentMessage != null) {
                if (typeof object.deviceSentMessage !== "object")
                    throw TypeError(".proto.Message.deviceSentMessage: object expected");
                message.deviceSentMessage = $root.proto.Message.DeviceSentMessage.fromObject(object.deviceSentMessage);
            }
            if (object.messageContextInfo != null) {
                if (typeof object.messageContextInfo !== "object")
                    throw TypeError(".proto.Message.messageContextInfo: object expected");
                message.messageContextInfo = $root.proto.MessageContextInfo.fromObject(object.messageContextInfo);
            }
            if (object.listMessage != null) {
                if (typeof object.listMessage !== "object")
                    throw TypeError(".proto.Message.listMessage: object expected");
                message.listMessage = $root.proto.Message.ListMessage.fromObject(object.listMessage);
            }
            if (object.viewOnceMessage != null) {
                if (typeof object.viewOnceMessage !== "object")
                    throw TypeError(".proto.Message.viewOnceMessage: object expected");
                message.viewOnceMessage = $root.proto.Message.FutureProofMessage.fromObject(object.viewOnceMessage);
            }
            if (object.orderMessage != null) {
                if (typeof object.orderMessage !== "object")
                    throw TypeError(".proto.Message.orderMessage: object expected");
                message.orderMessage = $root.proto.Message.OrderMessage.fromObject(object.orderMessage);
            }
            if (object.listResponseMessage != null) {
                if (typeof object.listResponseMessage !== "object")
                    throw TypeError(".proto.Message.listResponseMessage: object expected");
                message.listResponseMessage = $root.proto.Message.ListResponseMessage.fromObject(object.listResponseMessage);
            }
            if (object.ephemeralMessage != null) {
                if (typeof object.ephemeralMessage !== "object")
                    throw TypeError(".proto.Message.ephemeralMessage: object expected");
                message.ephemeralMessage = $root.proto.Message.FutureProofMessage.fromObject(object.ephemeralMessage);
            }
            if (object.invoiceMessage != null) {
                if (typeof object.invoiceMessage !== "object")
                    throw TypeError(".proto.Message.invoiceMessage: object expected");
                message.invoiceMessage = $root.proto.Message.InvoiceMessage.fromObject(object.invoiceMessage);
            }
            if (object.buttonsMessage != null) {
                if (typeof object.buttonsMessage !== "object")
                    throw TypeError(".proto.Message.buttonsMessage: object expected");
                message.buttonsMessage = $root.proto.Message.ButtonsMessage.fromObject(object.buttonsMessage);
            }
            if (object.buttonsResponseMessage != null) {
                if (typeof object.buttonsResponseMessage !== "object")
                    throw TypeError(".proto.Message.buttonsResponseMessage: object expected");
                message.buttonsResponseMessage = $root.proto.Message.ButtonsResponseMessage.fromObject(object.buttonsResponseMessage);
            }
            if (object.paymentInviteMessage != null) {
                if (typeof object.paymentInviteMessage !== "object")
                    throw TypeError(".proto.Message.paymentInviteMessage: object expected");
                message.paymentInviteMessage = $root.proto.Message.PaymentInviteMessage.fromObject(object.paymentInviteMessage);
            }
            if (object.interactiveMessage != null) {
                if (typeof object.interactiveMessage !== "object")
                    throw TypeError(".proto.Message.interactiveMessage: object expected");
                message.interactiveMessage = $root.proto.Message.InteractiveMessage.fromObject(object.interactiveMessage);
            }
            if (object.reactionMessage != null) {
                if (typeof object.reactionMessage !== "object")
                    throw TypeError(".proto.Message.reactionMessage: object expected");
                message.reactionMessage = $root.proto.Message.ReactionMessage.fromObject(object.reactionMessage);
            }
            if (object.stickerSyncRmrMessage != null) {
                if (typeof object.stickerSyncRmrMessage !== "object")
                    throw TypeError(".proto.Message.stickerSyncRmrMessage: object expected");
                message.stickerSyncRmrMessage = $root.proto.Message.StickerSyncRMRMessage.fromObject(object.stickerSyncRmrMessage);
            }
            if (object.interactiveResponseMessage != null) {
                if (typeof object.interactiveResponseMessage !== "object")
                    throw TypeError(".proto.Message.interactiveResponseMessage: object expected");
                message.interactiveResponseMessage = $root.proto.Message.InteractiveResponseMessage.fromObject(object.interactiveResponseMessage);
            }
            if (object.pollCreationMessage != null) {
                if (typeof object.pollCreationMessage !== "object")
                    throw TypeError(".proto.Message.pollCreationMessage: object expected");
                message.pollCreationMessage = $root.proto.Message.PollCreationMessage.fromObject(object.pollCreationMessage);
            }
            if (object.pollUpdateMessage != null) {
                if (typeof object.pollUpdateMessage !== "object")
                    throw TypeError(".proto.Message.pollUpdateMessage: object expected");
                message.pollUpdateMessage = $root.proto.Message.PollUpdateMessage.fromObject(object.pollUpdateMessage);
            }
            if (object.keepInChatMessage != null) {
                if (typeof object.keepInChatMessage !== "object")
                    throw TypeError(".proto.Message.keepInChatMessage: object expected");
                message.keepInChatMessage = $root.proto.Message.KeepInChatMessage.fromObject(object.keepInChatMessage);
            }
            if (object.documentWithCaptionMessage != null) {
                if (typeof object.documentWithCaptionMessage !== "object")
                    throw TypeError(".proto.Message.documentWithCaptionMessage: object expected");
                message.documentWithCaptionMessage = $root.proto.Message.FutureProofMessage.fromObject(object.documentWithCaptionMessage);
            }
            if (object.requestPhoneNumberMessage != null) {
                if (typeof object.requestPhoneNumberMessage !== "object")
                    throw TypeError(".proto.Message.requestPhoneNumberMessage: object expected");
                message.requestPhoneNumberMessage = $root.proto.Message.RequestPhoneNumberMessage.fromObject(object.requestPhoneNumberMessage);
            }
            if (object.viewOnceMessageV2 != null) {
                if (typeof object.viewOnceMessageV2 !== "object")
                    throw TypeError(".proto.Message.viewOnceMessageV2: object expected");
                message.viewOnceMessageV2 = $root.proto.Message.FutureProofMessage.fromObject(object.viewOnceMessageV2);
            }
            if (object.encReactionMessage != null) {
                if (typeof object.encReactionMessage !== "object")
                    throw TypeError(".proto.Message.encReactionMessage: object expected");
                message.encReactionMessage = $root.proto.Message.EncReactionMessage.fromObject(object.encReactionMessage);
            }
            if (object.editedMessage != null) {
                if (typeof object.editedMessage !== "object")
                    throw TypeError(".proto.Message.editedMessage: object expected");
                message.editedMessage = $root.proto.Message.FutureProofMessage.fromObject(object.editedMessage);
            }
            if (object.viewOnceMessageV2Extension != null) {
                if (typeof object.viewOnceMessageV2Extension !== "object")
                    throw TypeError(".proto.Message.viewOnceMessageV2Extension: object expected");
                message.viewOnceMessageV2Extension = $root.proto.Message.FutureProofMessage.fromObject(object.viewOnceMessageV2Extension);
            }
            return message;
        };

        /**
         * Creates a plain object from a Message message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Message
         * @static
         * @param {proto.Message} message Message
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.conversation = "";
                object.senderKeyDistributionMessage = null;
                object.imageMessage = null;
                object.contactMessage = null;
                object.locationMessage = null;
                object.extendedTextMessage = null;
                object.documentMessage = null;
                object.audioMessage = null;
                object.videoMessage = null;
                object.call = null;
                object.chat = null;
                object.protocolMessage = null;
                object.contactsArrayMessage = null;
                object.highlyStructuredMessage = null;
                object.fastRatchetKeySenderKeyDistributionMessage = null;
                object.sendPaymentMessage = null;
                object.liveLocationMessage = null;
                object.requestPaymentMessage = null;
                object.declinePaymentRequestMessage = null;
                object.cancelPaymentRequestMessage = null;
                object.templateMessage = null;
                object.stickerMessage = null;
                object.groupInviteMessage = null;
                object.templateButtonReplyMessage = null;
                object.productMessage = null;
                object.deviceSentMessage = null;
                object.messageContextInfo = null;
                object.listMessage = null;
                object.viewOnceMessage = null;
                object.orderMessage = null;
                object.listResponseMessage = null;
                object.ephemeralMessage = null;
                object.invoiceMessage = null;
                object.buttonsMessage = null;
                object.buttonsResponseMessage = null;
                object.paymentInviteMessage = null;
                object.interactiveMessage = null;
                object.reactionMessage = null;
                object.stickerSyncRmrMessage = null;
                object.interactiveResponseMessage = null;
                object.pollCreationMessage = null;
                object.pollUpdateMessage = null;
                object.keepInChatMessage = null;
                object.documentWithCaptionMessage = null;
                object.requestPhoneNumberMessage = null;
                object.viewOnceMessageV2 = null;
                object.encReactionMessage = null;
                object.editedMessage = null;
                object.viewOnceMessageV2Extension = null;
            }
            if (message.conversation != null && message.hasOwnProperty("conversation"))
                object.conversation = message.conversation;
            if (message.senderKeyDistributionMessage != null && message.hasOwnProperty("senderKeyDistributionMessage"))
                object.senderKeyDistributionMessage = $root.proto.Message.SenderKeyDistributionMessage.toObject(message.senderKeyDistributionMessage, options);
            if (message.imageMessage != null && message.hasOwnProperty("imageMessage"))
                object.imageMessage = $root.proto.Message.ImageMessage.toObject(message.imageMessage, options);
            if (message.contactMessage != null && message.hasOwnProperty("contactMessage"))
                object.contactMessage = $root.proto.Message.ContactMessage.toObject(message.contactMessage, options);
            if (message.locationMessage != null && message.hasOwnProperty("locationMessage"))
                object.locationMessage = $root.proto.Message.LocationMessage.toObject(message.locationMessage, options);
            if (message.extendedTextMessage != null && message.hasOwnProperty("extendedTextMessage"))
                object.extendedTextMessage = $root.proto.Message.ExtendedTextMessage.toObject(message.extendedTextMessage, options);
            if (message.documentMessage != null && message.hasOwnProperty("documentMessage"))
                object.documentMessage = $root.proto.Message.DocumentMessage.toObject(message.documentMessage, options);
            if (message.audioMessage != null && message.hasOwnProperty("audioMessage"))
                object.audioMessage = $root.proto.Message.AudioMessage.toObject(message.audioMessage, options);
            if (message.videoMessage != null && message.hasOwnProperty("videoMessage"))
                object.videoMessage = $root.proto.Message.VideoMessage.toObject(message.videoMessage, options);
            if (message.call != null && message.hasOwnProperty("call"))
                object.call = $root.proto.Message.Call.toObject(message.call, options);
            if (message.chat != null && message.hasOwnProperty("chat"))
                object.chat = $root.proto.Message.Chat.toObject(message.chat, options);
            if (message.protocolMessage != null && message.hasOwnProperty("protocolMessage"))
                object.protocolMessage = $root.proto.Message.ProtocolMessage.toObject(message.protocolMessage, options);
            if (message.contactsArrayMessage != null && message.hasOwnProperty("contactsArrayMessage"))
                object.contactsArrayMessage = $root.proto.Message.ContactsArrayMessage.toObject(message.contactsArrayMessage, options);
            if (message.highlyStructuredMessage != null && message.hasOwnProperty("highlyStructuredMessage"))
                object.highlyStructuredMessage = $root.proto.Message.HighlyStructuredMessage.toObject(message.highlyStructuredMessage, options);
            if (message.fastRatchetKeySenderKeyDistributionMessage != null && message.hasOwnProperty("fastRatchetKeySenderKeyDistributionMessage"))
                object.fastRatchetKeySenderKeyDistributionMessage = $root.proto.Message.SenderKeyDistributionMessage.toObject(message.fastRatchetKeySenderKeyDistributionMessage, options);
            if (message.sendPaymentMessage != null && message.hasOwnProperty("sendPaymentMessage"))
                object.sendPaymentMessage = $root.proto.Message.SendPaymentMessage.toObject(message.sendPaymentMessage, options);
            if (message.liveLocationMessage != null && message.hasOwnProperty("liveLocationMessage"))
                object.liveLocationMessage = $root.proto.Message.LiveLocationMessage.toObject(message.liveLocationMessage, options);
            if (message.requestPaymentMessage != null && message.hasOwnProperty("requestPaymentMessage"))
                object.requestPaymentMessage = $root.proto.Message.RequestPaymentMessage.toObject(message.requestPaymentMessage, options);
            if (message.declinePaymentRequestMessage != null && message.hasOwnProperty("declinePaymentRequestMessage"))
                object.declinePaymentRequestMessage = $root.proto.Message.DeclinePaymentRequestMessage.toObject(message.declinePaymentRequestMessage, options);
            if (message.cancelPaymentRequestMessage != null && message.hasOwnProperty("cancelPaymentRequestMessage"))
                object.cancelPaymentRequestMessage = $root.proto.Message.CancelPaymentRequestMessage.toObject(message.cancelPaymentRequestMessage, options);
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage"))
                object.templateMessage = $root.proto.Message.TemplateMessage.toObject(message.templateMessage, options);
            if (message.stickerMessage != null && message.hasOwnProperty("stickerMessage"))
                object.stickerMessage = $root.proto.Message.StickerMessage.toObject(message.stickerMessage, options);
            if (message.groupInviteMessage != null && message.hasOwnProperty("groupInviteMessage"))
                object.groupInviteMessage = $root.proto.Message.GroupInviteMessage.toObject(message.groupInviteMessage, options);
            if (message.templateButtonReplyMessage != null && message.hasOwnProperty("templateButtonReplyMessage"))
                object.templateButtonReplyMessage = $root.proto.Message.TemplateButtonReplyMessage.toObject(message.templateButtonReplyMessage, options);
            if (message.productMessage != null && message.hasOwnProperty("productMessage"))
                object.productMessage = $root.proto.Message.ProductMessage.toObject(message.productMessage, options);
            if (message.deviceSentMessage != null && message.hasOwnProperty("deviceSentMessage"))
                object.deviceSentMessage = $root.proto.Message.DeviceSentMessage.toObject(message.deviceSentMessage, options);
            if (message.messageContextInfo != null && message.hasOwnProperty("messageContextInfo"))
                object.messageContextInfo = $root.proto.MessageContextInfo.toObject(message.messageContextInfo, options);
            if (message.listMessage != null && message.hasOwnProperty("listMessage"))
                object.listMessage = $root.proto.Message.ListMessage.toObject(message.listMessage, options);
            if (message.viewOnceMessage != null && message.hasOwnProperty("viewOnceMessage"))
                object.viewOnceMessage = $root.proto.Message.FutureProofMessage.toObject(message.viewOnceMessage, options);
            if (message.orderMessage != null && message.hasOwnProperty("orderMessage"))
                object.orderMessage = $root.proto.Message.OrderMessage.toObject(message.orderMessage, options);
            if (message.listResponseMessage != null && message.hasOwnProperty("listResponseMessage"))
                object.listResponseMessage = $root.proto.Message.ListResponseMessage.toObject(message.listResponseMessage, options);
            if (message.ephemeralMessage != null && message.hasOwnProperty("ephemeralMessage"))
                object.ephemeralMessage = $root.proto.Message.FutureProofMessage.toObject(message.ephemeralMessage, options);
            if (message.invoiceMessage != null && message.hasOwnProperty("invoiceMessage"))
                object.invoiceMessage = $root.proto.Message.InvoiceMessage.toObject(message.invoiceMessage, options);
            if (message.buttonsMessage != null && message.hasOwnProperty("buttonsMessage"))
                object.buttonsMessage = $root.proto.Message.ButtonsMessage.toObject(message.buttonsMessage, options);
            if (message.buttonsResponseMessage != null && message.hasOwnProperty("buttonsResponseMessage"))
                object.buttonsResponseMessage = $root.proto.Message.ButtonsResponseMessage.toObject(message.buttonsResponseMessage, options);
            if (message.paymentInviteMessage != null && message.hasOwnProperty("paymentInviteMessage"))
                object.paymentInviteMessage = $root.proto.Message.PaymentInviteMessage.toObject(message.paymentInviteMessage, options);
            if (message.interactiveMessage != null && message.hasOwnProperty("interactiveMessage"))
                object.interactiveMessage = $root.proto.Message.InteractiveMessage.toObject(message.interactiveMessage, options);
            if (message.reactionMessage != null && message.hasOwnProperty("reactionMessage"))
                object.reactionMessage = $root.proto.Message.ReactionMessage.toObject(message.reactionMessage, options);
            if (message.stickerSyncRmrMessage != null && message.hasOwnProperty("stickerSyncRmrMessage"))
                object.stickerSyncRmrMessage = $root.proto.Message.StickerSyncRMRMessage.toObject(message.stickerSyncRmrMessage, options);
            if (message.interactiveResponseMessage != null && message.hasOwnProperty("interactiveResponseMessage"))
                object.interactiveResponseMessage = $root.proto.Message.InteractiveResponseMessage.toObject(message.interactiveResponseMessage, options);
            if (message.pollCreationMessage != null && message.hasOwnProperty("pollCreationMessage"))
                object.pollCreationMessage = $root.proto.Message.PollCreationMessage.toObject(message.pollCreationMessage, options);
            if (message.pollUpdateMessage != null && message.hasOwnProperty("pollUpdateMessage"))
                object.pollUpdateMessage = $root.proto.Message.PollUpdateMessage.toObject(message.pollUpdateMessage, options);
            if (message.keepInChatMessage != null && message.hasOwnProperty("keepInChatMessage"))
                object.keepInChatMessage = $root.proto.Message.KeepInChatMessage.toObject(message.keepInChatMessage, options);
            if (message.documentWithCaptionMessage != null && message.hasOwnProperty("documentWithCaptionMessage"))
                object.documentWithCaptionMessage = $root.proto.Message.FutureProofMessage.toObject(message.documentWithCaptionMessage, options);
            if (message.requestPhoneNumberMessage != null && message.hasOwnProperty("requestPhoneNumberMessage"))
                object.requestPhoneNumberMessage = $root.proto.Message.RequestPhoneNumberMessage.toObject(message.requestPhoneNumberMessage, options);
            if (message.viewOnceMessageV2 != null && message.hasOwnProperty("viewOnceMessageV2"))
                object.viewOnceMessageV2 = $root.proto.Message.FutureProofMessage.toObject(message.viewOnceMessageV2, options);
            if (message.encReactionMessage != null && message.hasOwnProperty("encReactionMessage"))
                object.encReactionMessage = $root.proto.Message.EncReactionMessage.toObject(message.encReactionMessage, options);
            if (message.editedMessage != null && message.hasOwnProperty("editedMessage"))
                object.editedMessage = $root.proto.Message.FutureProofMessage.toObject(message.editedMessage, options);
            if (message.viewOnceMessageV2Extension != null && message.hasOwnProperty("viewOnceMessageV2Extension"))
                object.viewOnceMessageV2Extension = $root.proto.Message.FutureProofMessage.toObject(message.viewOnceMessageV2Extension, options);
            return object;
        };

        /**
         * Converts this Message to JSON.
         * @function toJSON
         * @memberof proto.Message
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Message.AppStateFatalExceptionNotification = (function() {

            /**
             * Properties of an AppStateFatalExceptionNotification.
             * @memberof proto.Message
             * @interface IAppStateFatalExceptionNotification
             * @property {Array.<string>|null} [collectionNames] AppStateFatalExceptionNotification collectionNames
             * @property {number|Long|null} [timestamp] AppStateFatalExceptionNotification timestamp
             */

            /**
             * Constructs a new AppStateFatalExceptionNotification.
             * @memberof proto.Message
             * @classdesc Represents an AppStateFatalExceptionNotification.
             * @implements IAppStateFatalExceptionNotification
             * @constructor
             * @param {proto.Message.IAppStateFatalExceptionNotification=} [properties] Properties to set
             */
            function AppStateFatalExceptionNotification(properties) {
                this.collectionNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppStateFatalExceptionNotification collectionNames.
             * @member {Array.<string>} collectionNames
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @instance
             */
            AppStateFatalExceptionNotification.prototype.collectionNames = $util.emptyArray;

            /**
             * AppStateFatalExceptionNotification timestamp.
             * @member {number|Long} timestamp
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @instance
             */
            AppStateFatalExceptionNotification.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AppStateFatalExceptionNotification instance using the specified properties.
             * @function create
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @static
             * @param {proto.Message.IAppStateFatalExceptionNotification=} [properties] Properties to set
             * @returns {proto.Message.AppStateFatalExceptionNotification} AppStateFatalExceptionNotification instance
             */
            AppStateFatalExceptionNotification.create = function create(properties) {
                return new AppStateFatalExceptionNotification(properties);
            };

            /**
             * Encodes the specified AppStateFatalExceptionNotification message. Does not implicitly {@link proto.Message.AppStateFatalExceptionNotification.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @static
             * @param {proto.Message.IAppStateFatalExceptionNotification} message AppStateFatalExceptionNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateFatalExceptionNotification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collectionNames != null && message.collectionNames.length)
                    for (var i = 0; i < message.collectionNames.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.collectionNames[i]);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified AppStateFatalExceptionNotification message, length delimited. Does not implicitly {@link proto.Message.AppStateFatalExceptionNotification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @static
             * @param {proto.Message.IAppStateFatalExceptionNotification} message AppStateFatalExceptionNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateFatalExceptionNotification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppStateFatalExceptionNotification message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.AppStateFatalExceptionNotification} AppStateFatalExceptionNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateFatalExceptionNotification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.AppStateFatalExceptionNotification();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.collectionNames && message.collectionNames.length))
                            message.collectionNames = [];
                        message.collectionNames.push(reader.string());
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppStateFatalExceptionNotification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.AppStateFatalExceptionNotification} AppStateFatalExceptionNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateFatalExceptionNotification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppStateFatalExceptionNotification message.
             * @function verify
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppStateFatalExceptionNotification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collectionNames != null && message.hasOwnProperty("collectionNames")) {
                    if (!Array.isArray(message.collectionNames))
                        return "collectionNames: array expected";
                    for (var i = 0; i < message.collectionNames.length; ++i)
                        if (!$util.isString(message.collectionNames[i]))
                            return "collectionNames: string[] expected";
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates an AppStateFatalExceptionNotification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.AppStateFatalExceptionNotification} AppStateFatalExceptionNotification
             */
            AppStateFatalExceptionNotification.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.AppStateFatalExceptionNotification)
                    return object;
                var message = new $root.proto.Message.AppStateFatalExceptionNotification();
                if (object.collectionNames) {
                    if (!Array.isArray(object.collectionNames))
                        throw TypeError(".proto.Message.AppStateFatalExceptionNotification.collectionNames: array expected");
                    message.collectionNames = [];
                    for (var i = 0; i < object.collectionNames.length; ++i)
                        message.collectionNames[i] = String(object.collectionNames[i]);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an AppStateFatalExceptionNotification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @static
             * @param {proto.Message.AppStateFatalExceptionNotification} message AppStateFatalExceptionNotification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppStateFatalExceptionNotification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collectionNames = [];
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                if (message.collectionNames && message.collectionNames.length) {
                    object.collectionNames = [];
                    for (var j = 0; j < message.collectionNames.length; ++j)
                        object.collectionNames[j] = message.collectionNames[j];
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this AppStateFatalExceptionNotification to JSON.
             * @function toJSON
             * @memberof proto.Message.AppStateFatalExceptionNotification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppStateFatalExceptionNotification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppStateFatalExceptionNotification;
        })();

        Message.AppStateSyncKey = (function() {

            /**
             * Properties of an AppStateSyncKey.
             * @memberof proto.Message
             * @interface IAppStateSyncKey
             * @property {proto.Message.IAppStateSyncKeyId|null} [keyId] AppStateSyncKey keyId
             * @property {proto.Message.IAppStateSyncKeyData|null} [keyData] AppStateSyncKey keyData
             */

            /**
             * Constructs a new AppStateSyncKey.
             * @memberof proto.Message
             * @classdesc Represents an AppStateSyncKey.
             * @implements IAppStateSyncKey
             * @constructor
             * @param {proto.Message.IAppStateSyncKey=} [properties] Properties to set
             */
            function AppStateSyncKey(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppStateSyncKey keyId.
             * @member {proto.Message.IAppStateSyncKeyId|null|undefined} keyId
             * @memberof proto.Message.AppStateSyncKey
             * @instance
             */
            AppStateSyncKey.prototype.keyId = null;

            /**
             * AppStateSyncKey keyData.
             * @member {proto.Message.IAppStateSyncKeyData|null|undefined} keyData
             * @memberof proto.Message.AppStateSyncKey
             * @instance
             */
            AppStateSyncKey.prototype.keyData = null;

            /**
             * Creates a new AppStateSyncKey instance using the specified properties.
             * @function create
             * @memberof proto.Message.AppStateSyncKey
             * @static
             * @param {proto.Message.IAppStateSyncKey=} [properties] Properties to set
             * @returns {proto.Message.AppStateSyncKey} AppStateSyncKey instance
             */
            AppStateSyncKey.create = function create(properties) {
                return new AppStateSyncKey(properties);
            };

            /**
             * Encodes the specified AppStateSyncKey message. Does not implicitly {@link proto.Message.AppStateSyncKey.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.AppStateSyncKey
             * @static
             * @param {proto.Message.IAppStateSyncKey} message AppStateSyncKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKey.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyId != null && Object.hasOwnProperty.call(message, "keyId"))
                    $root.proto.Message.AppStateSyncKeyId.encode(message.keyId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.keyData != null && Object.hasOwnProperty.call(message, "keyData"))
                    $root.proto.Message.AppStateSyncKeyData.encode(message.keyData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AppStateSyncKey message, length delimited. Does not implicitly {@link proto.Message.AppStateSyncKey.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.AppStateSyncKey
             * @static
             * @param {proto.Message.IAppStateSyncKey} message AppStateSyncKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKey.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppStateSyncKey message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.AppStateSyncKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.AppStateSyncKey} AppStateSyncKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKey.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.AppStateSyncKey();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyId = $root.proto.Message.AppStateSyncKeyId.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.keyData = $root.proto.Message.AppStateSyncKeyData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppStateSyncKey message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.AppStateSyncKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.AppStateSyncKey} AppStateSyncKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKey.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppStateSyncKey message.
             * @function verify
             * @memberof proto.Message.AppStateSyncKey
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppStateSyncKey.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyId != null && message.hasOwnProperty("keyId")) {
                    var error = $root.proto.Message.AppStateSyncKeyId.verify(message.keyId);
                    if (error)
                        return "keyId." + error;
                }
                if (message.keyData != null && message.hasOwnProperty("keyData")) {
                    var error = $root.proto.Message.AppStateSyncKeyData.verify(message.keyData);
                    if (error)
                        return "keyData." + error;
                }
                return null;
            };

            /**
             * Creates an AppStateSyncKey message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.AppStateSyncKey
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.AppStateSyncKey} AppStateSyncKey
             */
            AppStateSyncKey.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.AppStateSyncKey)
                    return object;
                var message = new $root.proto.Message.AppStateSyncKey();
                if (object.keyId != null) {
                    if (typeof object.keyId !== "object")
                        throw TypeError(".proto.Message.AppStateSyncKey.keyId: object expected");
                    message.keyId = $root.proto.Message.AppStateSyncKeyId.fromObject(object.keyId);
                }
                if (object.keyData != null) {
                    if (typeof object.keyData !== "object")
                        throw TypeError(".proto.Message.AppStateSyncKey.keyData: object expected");
                    message.keyData = $root.proto.Message.AppStateSyncKeyData.fromObject(object.keyData);
                }
                return message;
            };

            /**
             * Creates a plain object from an AppStateSyncKey message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.AppStateSyncKey
             * @static
             * @param {proto.Message.AppStateSyncKey} message AppStateSyncKey
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppStateSyncKey.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.keyId = null;
                    object.keyData = null;
                }
                if (message.keyId != null && message.hasOwnProperty("keyId"))
                    object.keyId = $root.proto.Message.AppStateSyncKeyId.toObject(message.keyId, options);
                if (message.keyData != null && message.hasOwnProperty("keyData"))
                    object.keyData = $root.proto.Message.AppStateSyncKeyData.toObject(message.keyData, options);
                return object;
            };

            /**
             * Converts this AppStateSyncKey to JSON.
             * @function toJSON
             * @memberof proto.Message.AppStateSyncKey
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppStateSyncKey.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppStateSyncKey;
        })();

        Message.AppStateSyncKeyData = (function() {

            /**
             * Properties of an AppStateSyncKeyData.
             * @memberof proto.Message
             * @interface IAppStateSyncKeyData
             * @property {Uint8Array|null} [keyData] AppStateSyncKeyData keyData
             * @property {proto.Message.IAppStateSyncKeyFingerprint|null} [fingerprint] AppStateSyncKeyData fingerprint
             * @property {number|Long|null} [timestamp] AppStateSyncKeyData timestamp
             */

            /**
             * Constructs a new AppStateSyncKeyData.
             * @memberof proto.Message
             * @classdesc Represents an AppStateSyncKeyData.
             * @implements IAppStateSyncKeyData
             * @constructor
             * @param {proto.Message.IAppStateSyncKeyData=} [properties] Properties to set
             */
            function AppStateSyncKeyData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppStateSyncKeyData keyData.
             * @member {Uint8Array} keyData
             * @memberof proto.Message.AppStateSyncKeyData
             * @instance
             */
            AppStateSyncKeyData.prototype.keyData = $util.newBuffer([]);

            /**
             * AppStateSyncKeyData fingerprint.
             * @member {proto.Message.IAppStateSyncKeyFingerprint|null|undefined} fingerprint
             * @memberof proto.Message.AppStateSyncKeyData
             * @instance
             */
            AppStateSyncKeyData.prototype.fingerprint = null;

            /**
             * AppStateSyncKeyData timestamp.
             * @member {number|Long} timestamp
             * @memberof proto.Message.AppStateSyncKeyData
             * @instance
             */
            AppStateSyncKeyData.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AppStateSyncKeyData instance using the specified properties.
             * @function create
             * @memberof proto.Message.AppStateSyncKeyData
             * @static
             * @param {proto.Message.IAppStateSyncKeyData=} [properties] Properties to set
             * @returns {proto.Message.AppStateSyncKeyData} AppStateSyncKeyData instance
             */
            AppStateSyncKeyData.create = function create(properties) {
                return new AppStateSyncKeyData(properties);
            };

            /**
             * Encodes the specified AppStateSyncKeyData message. Does not implicitly {@link proto.Message.AppStateSyncKeyData.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.AppStateSyncKeyData
             * @static
             * @param {proto.Message.IAppStateSyncKeyData} message AppStateSyncKeyData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyData != null && Object.hasOwnProperty.call(message, "keyData"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keyData);
                if (message.fingerprint != null && Object.hasOwnProperty.call(message, "fingerprint"))
                    $root.proto.Message.AppStateSyncKeyFingerprint.encode(message.fingerprint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified AppStateSyncKeyData message, length delimited. Does not implicitly {@link proto.Message.AppStateSyncKeyData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.AppStateSyncKeyData
             * @static
             * @param {proto.Message.IAppStateSyncKeyData} message AppStateSyncKeyData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppStateSyncKeyData message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.AppStateSyncKeyData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.AppStateSyncKeyData} AppStateSyncKeyData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.AppStateSyncKeyData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyData = reader.bytes();
                        break;
                    case 2:
                        message.fingerprint = $root.proto.Message.AppStateSyncKeyFingerprint.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppStateSyncKeyData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.AppStateSyncKeyData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.AppStateSyncKeyData} AppStateSyncKeyData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppStateSyncKeyData message.
             * @function verify
             * @memberof proto.Message.AppStateSyncKeyData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppStateSyncKeyData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyData != null && message.hasOwnProperty("keyData"))
                    if (!(message.keyData && typeof message.keyData.length === "number" || $util.isString(message.keyData)))
                        return "keyData: buffer expected";
                if (message.fingerprint != null && message.hasOwnProperty("fingerprint")) {
                    var error = $root.proto.Message.AppStateSyncKeyFingerprint.verify(message.fingerprint);
                    if (error)
                        return "fingerprint." + error;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates an AppStateSyncKeyData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.AppStateSyncKeyData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.AppStateSyncKeyData} AppStateSyncKeyData
             */
            AppStateSyncKeyData.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.AppStateSyncKeyData)
                    return object;
                var message = new $root.proto.Message.AppStateSyncKeyData();
                if (object.keyData != null)
                    if (typeof object.keyData === "string")
                        $util.base64.decode(object.keyData, message.keyData = $util.newBuffer($util.base64.length(object.keyData)), 0);
                    else if (object.keyData.length)
                        message.keyData = object.keyData;
                if (object.fingerprint != null) {
                    if (typeof object.fingerprint !== "object")
                        throw TypeError(".proto.Message.AppStateSyncKeyData.fingerprint: object expected");
                    message.fingerprint = $root.proto.Message.AppStateSyncKeyFingerprint.fromObject(object.fingerprint);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an AppStateSyncKeyData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.AppStateSyncKeyData
             * @static
             * @param {proto.Message.AppStateSyncKeyData} message AppStateSyncKeyData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppStateSyncKeyData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.keyData = "";
                    else {
                        object.keyData = [];
                        if (options.bytes !== Array)
                            object.keyData = $util.newBuffer(object.keyData);
                    }
                    object.fingerprint = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.keyData != null && message.hasOwnProperty("keyData"))
                    object.keyData = options.bytes === String ? $util.base64.encode(message.keyData, 0, message.keyData.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyData) : message.keyData;
                if (message.fingerprint != null && message.hasOwnProperty("fingerprint"))
                    object.fingerprint = $root.proto.Message.AppStateSyncKeyFingerprint.toObject(message.fingerprint, options);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this AppStateSyncKeyData to JSON.
             * @function toJSON
             * @memberof proto.Message.AppStateSyncKeyData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppStateSyncKeyData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppStateSyncKeyData;
        })();

        Message.AppStateSyncKeyFingerprint = (function() {

            /**
             * Properties of an AppStateSyncKeyFingerprint.
             * @memberof proto.Message
             * @interface IAppStateSyncKeyFingerprint
             * @property {number|null} [rawId] AppStateSyncKeyFingerprint rawId
             * @property {number|null} [currentIndex] AppStateSyncKeyFingerprint currentIndex
             * @property {Array.<number>|null} [deviceIndexes] AppStateSyncKeyFingerprint deviceIndexes
             */

            /**
             * Constructs a new AppStateSyncKeyFingerprint.
             * @memberof proto.Message
             * @classdesc Represents an AppStateSyncKeyFingerprint.
             * @implements IAppStateSyncKeyFingerprint
             * @constructor
             * @param {proto.Message.IAppStateSyncKeyFingerprint=} [properties] Properties to set
             */
            function AppStateSyncKeyFingerprint(properties) {
                this.deviceIndexes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppStateSyncKeyFingerprint rawId.
             * @member {number} rawId
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @instance
             */
            AppStateSyncKeyFingerprint.prototype.rawId = 0;

            /**
             * AppStateSyncKeyFingerprint currentIndex.
             * @member {number} currentIndex
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @instance
             */
            AppStateSyncKeyFingerprint.prototype.currentIndex = 0;

            /**
             * AppStateSyncKeyFingerprint deviceIndexes.
             * @member {Array.<number>} deviceIndexes
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @instance
             */
            AppStateSyncKeyFingerprint.prototype.deviceIndexes = $util.emptyArray;

            /**
             * Creates a new AppStateSyncKeyFingerprint instance using the specified properties.
             * @function create
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @static
             * @param {proto.Message.IAppStateSyncKeyFingerprint=} [properties] Properties to set
             * @returns {proto.Message.AppStateSyncKeyFingerprint} AppStateSyncKeyFingerprint instance
             */
            AppStateSyncKeyFingerprint.create = function create(properties) {
                return new AppStateSyncKeyFingerprint(properties);
            };

            /**
             * Encodes the specified AppStateSyncKeyFingerprint message. Does not implicitly {@link proto.Message.AppStateSyncKeyFingerprint.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @static
             * @param {proto.Message.IAppStateSyncKeyFingerprint} message AppStateSyncKeyFingerprint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyFingerprint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rawId != null && Object.hasOwnProperty.call(message, "rawId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rawId);
                if (message.currentIndex != null && Object.hasOwnProperty.call(message, "currentIndex"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.currentIndex);
                if (message.deviceIndexes != null && message.deviceIndexes.length) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork();
                    for (var i = 0; i < message.deviceIndexes.length; ++i)
                        writer.uint32(message.deviceIndexes[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified AppStateSyncKeyFingerprint message, length delimited. Does not implicitly {@link proto.Message.AppStateSyncKeyFingerprint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @static
             * @param {proto.Message.IAppStateSyncKeyFingerprint} message AppStateSyncKeyFingerprint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyFingerprint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppStateSyncKeyFingerprint message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.AppStateSyncKeyFingerprint} AppStateSyncKeyFingerprint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyFingerprint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.AppStateSyncKeyFingerprint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rawId = reader.uint32();
                        break;
                    case 2:
                        message.currentIndex = reader.uint32();
                        break;
                    case 3:
                        if (!(message.deviceIndexes && message.deviceIndexes.length))
                            message.deviceIndexes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.deviceIndexes.push(reader.uint32());
                        } else
                            message.deviceIndexes.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppStateSyncKeyFingerprint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.AppStateSyncKeyFingerprint} AppStateSyncKeyFingerprint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyFingerprint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppStateSyncKeyFingerprint message.
             * @function verify
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppStateSyncKeyFingerprint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rawId != null && message.hasOwnProperty("rawId"))
                    if (!$util.isInteger(message.rawId))
                        return "rawId: integer expected";
                if (message.currentIndex != null && message.hasOwnProperty("currentIndex"))
                    if (!$util.isInteger(message.currentIndex))
                        return "currentIndex: integer expected";
                if (message.deviceIndexes != null && message.hasOwnProperty("deviceIndexes")) {
                    if (!Array.isArray(message.deviceIndexes))
                        return "deviceIndexes: array expected";
                    for (var i = 0; i < message.deviceIndexes.length; ++i)
                        if (!$util.isInteger(message.deviceIndexes[i]))
                            return "deviceIndexes: integer[] expected";
                }
                return null;
            };

            /**
             * Creates an AppStateSyncKeyFingerprint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.AppStateSyncKeyFingerprint} AppStateSyncKeyFingerprint
             */
            AppStateSyncKeyFingerprint.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.AppStateSyncKeyFingerprint)
                    return object;
                var message = new $root.proto.Message.AppStateSyncKeyFingerprint();
                if (object.rawId != null)
                    message.rawId = object.rawId >>> 0;
                if (object.currentIndex != null)
                    message.currentIndex = object.currentIndex >>> 0;
                if (object.deviceIndexes) {
                    if (!Array.isArray(object.deviceIndexes))
                        throw TypeError(".proto.Message.AppStateSyncKeyFingerprint.deviceIndexes: array expected");
                    message.deviceIndexes = [];
                    for (var i = 0; i < object.deviceIndexes.length; ++i)
                        message.deviceIndexes[i] = object.deviceIndexes[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from an AppStateSyncKeyFingerprint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @static
             * @param {proto.Message.AppStateSyncKeyFingerprint} message AppStateSyncKeyFingerprint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppStateSyncKeyFingerprint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.deviceIndexes = [];
                if (options.defaults) {
                    object.rawId = 0;
                    object.currentIndex = 0;
                }
                if (message.rawId != null && message.hasOwnProperty("rawId"))
                    object.rawId = message.rawId;
                if (message.currentIndex != null && message.hasOwnProperty("currentIndex"))
                    object.currentIndex = message.currentIndex;
                if (message.deviceIndexes && message.deviceIndexes.length) {
                    object.deviceIndexes = [];
                    for (var j = 0; j < message.deviceIndexes.length; ++j)
                        object.deviceIndexes[j] = message.deviceIndexes[j];
                }
                return object;
            };

            /**
             * Converts this AppStateSyncKeyFingerprint to JSON.
             * @function toJSON
             * @memberof proto.Message.AppStateSyncKeyFingerprint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppStateSyncKeyFingerprint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppStateSyncKeyFingerprint;
        })();

        Message.AppStateSyncKeyId = (function() {

            /**
             * Properties of an AppStateSyncKeyId.
             * @memberof proto.Message
             * @interface IAppStateSyncKeyId
             * @property {Uint8Array|null} [keyId] AppStateSyncKeyId keyId
             */

            /**
             * Constructs a new AppStateSyncKeyId.
             * @memberof proto.Message
             * @classdesc Represents an AppStateSyncKeyId.
             * @implements IAppStateSyncKeyId
             * @constructor
             * @param {proto.Message.IAppStateSyncKeyId=} [properties] Properties to set
             */
            function AppStateSyncKeyId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppStateSyncKeyId keyId.
             * @member {Uint8Array} keyId
             * @memberof proto.Message.AppStateSyncKeyId
             * @instance
             */
            AppStateSyncKeyId.prototype.keyId = $util.newBuffer([]);

            /**
             * Creates a new AppStateSyncKeyId instance using the specified properties.
             * @function create
             * @memberof proto.Message.AppStateSyncKeyId
             * @static
             * @param {proto.Message.IAppStateSyncKeyId=} [properties] Properties to set
             * @returns {proto.Message.AppStateSyncKeyId} AppStateSyncKeyId instance
             */
            AppStateSyncKeyId.create = function create(properties) {
                return new AppStateSyncKeyId(properties);
            };

            /**
             * Encodes the specified AppStateSyncKeyId message. Does not implicitly {@link proto.Message.AppStateSyncKeyId.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.AppStateSyncKeyId
             * @static
             * @param {proto.Message.IAppStateSyncKeyId} message AppStateSyncKeyId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyId != null && Object.hasOwnProperty.call(message, "keyId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keyId);
                return writer;
            };

            /**
             * Encodes the specified AppStateSyncKeyId message, length delimited. Does not implicitly {@link proto.Message.AppStateSyncKeyId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.AppStateSyncKeyId
             * @static
             * @param {proto.Message.IAppStateSyncKeyId} message AppStateSyncKeyId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppStateSyncKeyId message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.AppStateSyncKeyId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.AppStateSyncKeyId} AppStateSyncKeyId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.AppStateSyncKeyId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyId = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppStateSyncKeyId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.AppStateSyncKeyId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.AppStateSyncKeyId} AppStateSyncKeyId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppStateSyncKeyId message.
             * @function verify
             * @memberof proto.Message.AppStateSyncKeyId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppStateSyncKeyId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyId != null && message.hasOwnProperty("keyId"))
                    if (!(message.keyId && typeof message.keyId.length === "number" || $util.isString(message.keyId)))
                        return "keyId: buffer expected";
                return null;
            };

            /**
             * Creates an AppStateSyncKeyId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.AppStateSyncKeyId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.AppStateSyncKeyId} AppStateSyncKeyId
             */
            AppStateSyncKeyId.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.AppStateSyncKeyId)
                    return object;
                var message = new $root.proto.Message.AppStateSyncKeyId();
                if (object.keyId != null)
                    if (typeof object.keyId === "string")
                        $util.base64.decode(object.keyId, message.keyId = $util.newBuffer($util.base64.length(object.keyId)), 0);
                    else if (object.keyId.length)
                        message.keyId = object.keyId;
                return message;
            };

            /**
             * Creates a plain object from an AppStateSyncKeyId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.AppStateSyncKeyId
             * @static
             * @param {proto.Message.AppStateSyncKeyId} message AppStateSyncKeyId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppStateSyncKeyId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.keyId = "";
                    else {
                        object.keyId = [];
                        if (options.bytes !== Array)
                            object.keyId = $util.newBuffer(object.keyId);
                    }
                if (message.keyId != null && message.hasOwnProperty("keyId"))
                    object.keyId = options.bytes === String ? $util.base64.encode(message.keyId, 0, message.keyId.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyId) : message.keyId;
                return object;
            };

            /**
             * Converts this AppStateSyncKeyId to JSON.
             * @function toJSON
             * @memberof proto.Message.AppStateSyncKeyId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppStateSyncKeyId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppStateSyncKeyId;
        })();

        Message.AppStateSyncKeyRequest = (function() {

            /**
             * Properties of an AppStateSyncKeyRequest.
             * @memberof proto.Message
             * @interface IAppStateSyncKeyRequest
             * @property {Array.<proto.Message.IAppStateSyncKeyId>|null} [keyIds] AppStateSyncKeyRequest keyIds
             */

            /**
             * Constructs a new AppStateSyncKeyRequest.
             * @memberof proto.Message
             * @classdesc Represents an AppStateSyncKeyRequest.
             * @implements IAppStateSyncKeyRequest
             * @constructor
             * @param {proto.Message.IAppStateSyncKeyRequest=} [properties] Properties to set
             */
            function AppStateSyncKeyRequest(properties) {
                this.keyIds = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppStateSyncKeyRequest keyIds.
             * @member {Array.<proto.Message.IAppStateSyncKeyId>} keyIds
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @instance
             */
            AppStateSyncKeyRequest.prototype.keyIds = $util.emptyArray;

            /**
             * Creates a new AppStateSyncKeyRequest instance using the specified properties.
             * @function create
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @static
             * @param {proto.Message.IAppStateSyncKeyRequest=} [properties] Properties to set
             * @returns {proto.Message.AppStateSyncKeyRequest} AppStateSyncKeyRequest instance
             */
            AppStateSyncKeyRequest.create = function create(properties) {
                return new AppStateSyncKeyRequest(properties);
            };

            /**
             * Encodes the specified AppStateSyncKeyRequest message. Does not implicitly {@link proto.Message.AppStateSyncKeyRequest.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @static
             * @param {proto.Message.IAppStateSyncKeyRequest} message AppStateSyncKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyIds != null && message.keyIds.length)
                    for (var i = 0; i < message.keyIds.length; ++i)
                        $root.proto.Message.AppStateSyncKeyId.encode(message.keyIds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AppStateSyncKeyRequest message, length delimited. Does not implicitly {@link proto.Message.AppStateSyncKeyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @static
             * @param {proto.Message.IAppStateSyncKeyRequest} message AppStateSyncKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppStateSyncKeyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.AppStateSyncKeyRequest} AppStateSyncKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.AppStateSyncKeyRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.keyIds && message.keyIds.length))
                            message.keyIds = [];
                        message.keyIds.push($root.proto.Message.AppStateSyncKeyId.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppStateSyncKeyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.AppStateSyncKeyRequest} AppStateSyncKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppStateSyncKeyRequest message.
             * @function verify
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppStateSyncKeyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyIds != null && message.hasOwnProperty("keyIds")) {
                    if (!Array.isArray(message.keyIds))
                        return "keyIds: array expected";
                    for (var i = 0; i < message.keyIds.length; ++i) {
                        var error = $root.proto.Message.AppStateSyncKeyId.verify(message.keyIds[i]);
                        if (error)
                            return "keyIds." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an AppStateSyncKeyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.AppStateSyncKeyRequest} AppStateSyncKeyRequest
             */
            AppStateSyncKeyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.AppStateSyncKeyRequest)
                    return object;
                var message = new $root.proto.Message.AppStateSyncKeyRequest();
                if (object.keyIds) {
                    if (!Array.isArray(object.keyIds))
                        throw TypeError(".proto.Message.AppStateSyncKeyRequest.keyIds: array expected");
                    message.keyIds = [];
                    for (var i = 0; i < object.keyIds.length; ++i) {
                        if (typeof object.keyIds[i] !== "object")
                            throw TypeError(".proto.Message.AppStateSyncKeyRequest.keyIds: object expected");
                        message.keyIds[i] = $root.proto.Message.AppStateSyncKeyId.fromObject(object.keyIds[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an AppStateSyncKeyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @static
             * @param {proto.Message.AppStateSyncKeyRequest} message AppStateSyncKeyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppStateSyncKeyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.keyIds = [];
                if (message.keyIds && message.keyIds.length) {
                    object.keyIds = [];
                    for (var j = 0; j < message.keyIds.length; ++j)
                        object.keyIds[j] = $root.proto.Message.AppStateSyncKeyId.toObject(message.keyIds[j], options);
                }
                return object;
            };

            /**
             * Converts this AppStateSyncKeyRequest to JSON.
             * @function toJSON
             * @memberof proto.Message.AppStateSyncKeyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppStateSyncKeyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppStateSyncKeyRequest;
        })();

        Message.AppStateSyncKeyShare = (function() {

            /**
             * Properties of an AppStateSyncKeyShare.
             * @memberof proto.Message
             * @interface IAppStateSyncKeyShare
             * @property {Array.<proto.Message.IAppStateSyncKey>|null} [keys] AppStateSyncKeyShare keys
             */

            /**
             * Constructs a new AppStateSyncKeyShare.
             * @memberof proto.Message
             * @classdesc Represents an AppStateSyncKeyShare.
             * @implements IAppStateSyncKeyShare
             * @constructor
             * @param {proto.Message.IAppStateSyncKeyShare=} [properties] Properties to set
             */
            function AppStateSyncKeyShare(properties) {
                this.keys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppStateSyncKeyShare keys.
             * @member {Array.<proto.Message.IAppStateSyncKey>} keys
             * @memberof proto.Message.AppStateSyncKeyShare
             * @instance
             */
            AppStateSyncKeyShare.prototype.keys = $util.emptyArray;

            /**
             * Creates a new AppStateSyncKeyShare instance using the specified properties.
             * @function create
             * @memberof proto.Message.AppStateSyncKeyShare
             * @static
             * @param {proto.Message.IAppStateSyncKeyShare=} [properties] Properties to set
             * @returns {proto.Message.AppStateSyncKeyShare} AppStateSyncKeyShare instance
             */
            AppStateSyncKeyShare.create = function create(properties) {
                return new AppStateSyncKeyShare(properties);
            };

            /**
             * Encodes the specified AppStateSyncKeyShare message. Does not implicitly {@link proto.Message.AppStateSyncKeyShare.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.AppStateSyncKeyShare
             * @static
             * @param {proto.Message.IAppStateSyncKeyShare} message AppStateSyncKeyShare message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyShare.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keys != null && message.keys.length)
                    for (var i = 0; i < message.keys.length; ++i)
                        $root.proto.Message.AppStateSyncKey.encode(message.keys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AppStateSyncKeyShare message, length delimited. Does not implicitly {@link proto.Message.AppStateSyncKeyShare.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.AppStateSyncKeyShare
             * @static
             * @param {proto.Message.IAppStateSyncKeyShare} message AppStateSyncKeyShare message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppStateSyncKeyShare.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppStateSyncKeyShare message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.AppStateSyncKeyShare
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.AppStateSyncKeyShare} AppStateSyncKeyShare
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyShare.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.AppStateSyncKeyShare();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.proto.Message.AppStateSyncKey.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppStateSyncKeyShare message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.AppStateSyncKeyShare
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.AppStateSyncKeyShare} AppStateSyncKeyShare
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppStateSyncKeyShare.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppStateSyncKeyShare message.
             * @function verify
             * @memberof proto.Message.AppStateSyncKeyShare
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppStateSyncKeyShare.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    if (!Array.isArray(message.keys))
                        return "keys: array expected";
                    for (var i = 0; i < message.keys.length; ++i) {
                        var error = $root.proto.Message.AppStateSyncKey.verify(message.keys[i]);
                        if (error)
                            return "keys." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an AppStateSyncKeyShare message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.AppStateSyncKeyShare
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.AppStateSyncKeyShare} AppStateSyncKeyShare
             */
            AppStateSyncKeyShare.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.AppStateSyncKeyShare)
                    return object;
                var message = new $root.proto.Message.AppStateSyncKeyShare();
                if (object.keys) {
                    if (!Array.isArray(object.keys))
                        throw TypeError(".proto.Message.AppStateSyncKeyShare.keys: array expected");
                    message.keys = [];
                    for (var i = 0; i < object.keys.length; ++i) {
                        if (typeof object.keys[i] !== "object")
                            throw TypeError(".proto.Message.AppStateSyncKeyShare.keys: object expected");
                        message.keys[i] = $root.proto.Message.AppStateSyncKey.fromObject(object.keys[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an AppStateSyncKeyShare message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.AppStateSyncKeyShare
             * @static
             * @param {proto.Message.AppStateSyncKeyShare} message AppStateSyncKeyShare
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppStateSyncKeyShare.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.keys = [];
                if (message.keys && message.keys.length) {
                    object.keys = [];
                    for (var j = 0; j < message.keys.length; ++j)
                        object.keys[j] = $root.proto.Message.AppStateSyncKey.toObject(message.keys[j], options);
                }
                return object;
            };

            /**
             * Converts this AppStateSyncKeyShare to JSON.
             * @function toJSON
             * @memberof proto.Message.AppStateSyncKeyShare
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppStateSyncKeyShare.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppStateSyncKeyShare;
        })();

        Message.AudioMessage = (function() {

            /**
             * Properties of an AudioMessage.
             * @memberof proto.Message
             * @interface IAudioMessage
             * @property {string|null} [url] AudioMessage url
             * @property {string|null} [mimetype] AudioMessage mimetype
             * @property {Uint8Array|null} [fileSha256] AudioMessage fileSha256
             * @property {number|Long|null} [fileLength] AudioMessage fileLength
             * @property {number|null} [seconds] AudioMessage seconds
             * @property {boolean|null} [ptt] AudioMessage ptt
             * @property {Uint8Array|null} [mediaKey] AudioMessage mediaKey
             * @property {Uint8Array|null} [fileEncSha256] AudioMessage fileEncSha256
             * @property {string|null} [directPath] AudioMessage directPath
             * @property {number|Long|null} [mediaKeyTimestamp] AudioMessage mediaKeyTimestamp
             * @property {proto.IContextInfo|null} [contextInfo] AudioMessage contextInfo
             * @property {Uint8Array|null} [streamingSidecar] AudioMessage streamingSidecar
             * @property {Uint8Array|null} [waveform] AudioMessage waveform
             * @property {number|null} [backgroundArgb] AudioMessage backgroundArgb
             */

            /**
             * Constructs a new AudioMessage.
             * @memberof proto.Message
             * @classdesc Represents an AudioMessage.
             * @implements IAudioMessage
             * @constructor
             * @param {proto.Message.IAudioMessage=} [properties] Properties to set
             */
            function AudioMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AudioMessage url.
             * @member {string} url
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.url = "";

            /**
             * AudioMessage mimetype.
             * @member {string} mimetype
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.mimetype = "";

            /**
             * AudioMessage fileSha256.
             * @member {Uint8Array} fileSha256
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.fileSha256 = $util.newBuffer([]);

            /**
             * AudioMessage fileLength.
             * @member {number|Long} fileLength
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * AudioMessage seconds.
             * @member {number} seconds
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.seconds = 0;

            /**
             * AudioMessage ptt.
             * @member {boolean} ptt
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.ptt = false;

            /**
             * AudioMessage mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.mediaKey = $util.newBuffer([]);

            /**
             * AudioMessage fileEncSha256.
             * @member {Uint8Array} fileEncSha256
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.fileEncSha256 = $util.newBuffer([]);

            /**
             * AudioMessage directPath.
             * @member {string} directPath
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.directPath = "";

            /**
             * AudioMessage mediaKeyTimestamp.
             * @member {number|Long} mediaKeyTimestamp
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AudioMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.contextInfo = null;

            /**
             * AudioMessage streamingSidecar.
             * @member {Uint8Array} streamingSidecar
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.streamingSidecar = $util.newBuffer([]);

            /**
             * AudioMessage waveform.
             * @member {Uint8Array} waveform
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.waveform = $util.newBuffer([]);

            /**
             * AudioMessage backgroundArgb.
             * @member {number} backgroundArgb
             * @memberof proto.Message.AudioMessage
             * @instance
             */
            AudioMessage.prototype.backgroundArgb = 0;

            /**
             * Creates a new AudioMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.AudioMessage
             * @static
             * @param {proto.Message.IAudioMessage=} [properties] Properties to set
             * @returns {proto.Message.AudioMessage} AudioMessage instance
             */
            AudioMessage.create = function create(properties) {
                return new AudioMessage(properties);
            };

            /**
             * Encodes the specified AudioMessage message. Does not implicitly {@link proto.Message.AudioMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.AudioMessage
             * @static
             * @param {proto.Message.IAudioMessage} message AudioMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AudioMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimetype);
                if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileSha256);
                if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileLength);
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.seconds);
                if (message.ptt != null && Object.hasOwnProperty.call(message, "ptt"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ptt);
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.mediaKey);
                if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.fileEncSha256);
                if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.directPath);
                if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.mediaKeyTimestamp);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.streamingSidecar != null && Object.hasOwnProperty.call(message, "streamingSidecar"))
                    writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.streamingSidecar);
                if (message.waveform != null && Object.hasOwnProperty.call(message, "waveform"))
                    writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.waveform);
                if (message.backgroundArgb != null && Object.hasOwnProperty.call(message, "backgroundArgb"))
                    writer.uint32(/* id 20, wireType 5 =*/165).fixed32(message.backgroundArgb);
                return writer;
            };

            /**
             * Encodes the specified AudioMessage message, length delimited. Does not implicitly {@link proto.Message.AudioMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.AudioMessage
             * @static
             * @param {proto.Message.IAudioMessage} message AudioMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AudioMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AudioMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.AudioMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.AudioMessage} AudioMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AudioMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.AudioMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        message.mimetype = reader.string();
                        break;
                    case 3:
                        message.fileSha256 = reader.bytes();
                        break;
                    case 4:
                        message.fileLength = reader.uint64();
                        break;
                    case 5:
                        message.seconds = reader.uint32();
                        break;
                    case 6:
                        message.ptt = reader.bool();
                        break;
                    case 7:
                        message.mediaKey = reader.bytes();
                        break;
                    case 8:
                        message.fileEncSha256 = reader.bytes();
                        break;
                    case 9:
                        message.directPath = reader.string();
                        break;
                    case 10:
                        message.mediaKeyTimestamp = reader.int64();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.streamingSidecar = reader.bytes();
                        break;
                    case 19:
                        message.waveform = reader.bytes();
                        break;
                    case 20:
                        message.backgroundArgb = reader.fixed32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AudioMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.AudioMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.AudioMessage} AudioMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AudioMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AudioMessage message.
             * @function verify
             * @memberof proto.Message.AudioMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AudioMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    if (!$util.isString(message.mimetype))
                        return "mimetype: string expected";
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                        return "fileSha256: buffer expected";
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                        return "fileLength: integer|Long expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds))
                        return "seconds: integer expected";
                if (message.ptt != null && message.hasOwnProperty("ptt"))
                    if (typeof message.ptt !== "boolean")
                        return "ptt: boolean expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                        return "fileEncSha256: buffer expected";
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    if (!$util.isString(message.directPath))
                        return "directPath: string expected";
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                        return "mediaKeyTimestamp: integer|Long expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.streamingSidecar != null && message.hasOwnProperty("streamingSidecar"))
                    if (!(message.streamingSidecar && typeof message.streamingSidecar.length === "number" || $util.isString(message.streamingSidecar)))
                        return "streamingSidecar: buffer expected";
                if (message.waveform != null && message.hasOwnProperty("waveform"))
                    if (!(message.waveform && typeof message.waveform.length === "number" || $util.isString(message.waveform)))
                        return "waveform: buffer expected";
                if (message.backgroundArgb != null && message.hasOwnProperty("backgroundArgb"))
                    if (!$util.isInteger(message.backgroundArgb))
                        return "backgroundArgb: integer expected";
                return null;
            };

            /**
             * Creates an AudioMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.AudioMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.AudioMessage} AudioMessage
             */
            AudioMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.AudioMessage)
                    return object;
                var message = new $root.proto.Message.AudioMessage();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.mimetype != null)
                    message.mimetype = String(object.mimetype);
                if (object.fileSha256 != null)
                    if (typeof object.fileSha256 === "string")
                        $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                    else if (object.fileSha256.length)
                        message.fileSha256 = object.fileSha256;
                if (object.fileLength != null)
                    if ($util.Long)
                        (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                    else if (typeof object.fileLength === "string")
                        message.fileLength = parseInt(object.fileLength, 10);
                    else if (typeof object.fileLength === "number")
                        message.fileLength = object.fileLength;
                    else if (typeof object.fileLength === "object")
                        message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
                if (object.seconds != null)
                    message.seconds = object.seconds >>> 0;
                if (object.ptt != null)
                    message.ptt = Boolean(object.ptt);
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.fileEncSha256 != null)
                    if (typeof object.fileEncSha256 === "string")
                        $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                    else if (object.fileEncSha256.length)
                        message.fileEncSha256 = object.fileEncSha256;
                if (object.directPath != null)
                    message.directPath = String(object.directPath);
                if (object.mediaKeyTimestamp != null)
                    if ($util.Long)
                        (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                    else if (typeof object.mediaKeyTimestamp === "string")
                        message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                    else if (typeof object.mediaKeyTimestamp === "number")
                        message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                    else if (typeof object.mediaKeyTimestamp === "object")
                        message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.AudioMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.streamingSidecar != null)
                    if (typeof object.streamingSidecar === "string")
                        $util.base64.decode(object.streamingSidecar, message.streamingSidecar = $util.newBuffer($util.base64.length(object.streamingSidecar)), 0);
                    else if (object.streamingSidecar.length)
                        message.streamingSidecar = object.streamingSidecar;
                if (object.waveform != null)
                    if (typeof object.waveform === "string")
                        $util.base64.decode(object.waveform, message.waveform = $util.newBuffer($util.base64.length(object.waveform)), 0);
                    else if (object.waveform.length)
                        message.waveform = object.waveform;
                if (object.backgroundArgb != null)
                    message.backgroundArgb = object.backgroundArgb >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AudioMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.AudioMessage
             * @static
             * @param {proto.Message.AudioMessage} message AudioMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AudioMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.url = "";
                    object.mimetype = "";
                    if (options.bytes === String)
                        object.fileSha256 = "";
                    else {
                        object.fileSha256 = [];
                        if (options.bytes !== Array)
                            object.fileSha256 = $util.newBuffer(object.fileSha256);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileLength = options.longs === String ? "0" : 0;
                    object.seconds = 0;
                    object.ptt = false;
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    if (options.bytes === String)
                        object.fileEncSha256 = "";
                    else {
                        object.fileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                    }
                    object.directPath = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                    object.contextInfo = null;
                    if (options.bytes === String)
                        object.streamingSidecar = "";
                    else {
                        object.streamingSidecar = [];
                        if (options.bytes !== Array)
                            object.streamingSidecar = $util.newBuffer(object.streamingSidecar);
                    }
                    if (options.bytes === String)
                        object.waveform = "";
                    else {
                        object.waveform = [];
                        if (options.bytes !== Array)
                            object.waveform = $util.newBuffer(object.waveform);
                    }
                    object.backgroundArgb = 0;
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    object.mimetype = message.mimetype;
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (typeof message.fileLength === "number")
                        object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                    else
                        object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    object.seconds = message.seconds;
                if (message.ptt != null && message.hasOwnProperty("ptt"))
                    object.ptt = message.ptt;
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    object.directPath = message.directPath;
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (typeof message.mediaKeyTimestamp === "number")
                        object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                    else
                        object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.streamingSidecar != null && message.hasOwnProperty("streamingSidecar"))
                    object.streamingSidecar = options.bytes === String ? $util.base64.encode(message.streamingSidecar, 0, message.streamingSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.streamingSidecar) : message.streamingSidecar;
                if (message.waveform != null && message.hasOwnProperty("waveform"))
                    object.waveform = options.bytes === String ? $util.base64.encode(message.waveform, 0, message.waveform.length) : options.bytes === Array ? Array.prototype.slice.call(message.waveform) : message.waveform;
                if (message.backgroundArgb != null && message.hasOwnProperty("backgroundArgb"))
                    object.backgroundArgb = message.backgroundArgb;
                return object;
            };

            /**
             * Converts this AudioMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.AudioMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AudioMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AudioMessage;
        })();

        Message.ButtonsMessage = (function() {

            /**
             * Properties of a ButtonsMessage.
             * @memberof proto.Message
             * @interface IButtonsMessage
             * @property {string|null} [contentText] ButtonsMessage contentText
             * @property {string|null} [footerText] ButtonsMessage footerText
             * @property {proto.IContextInfo|null} [contextInfo] ButtonsMessage contextInfo
             * @property {Array.<proto.Message.ButtonsMessage.IButton>|null} [buttons] ButtonsMessage buttons
             * @property {proto.Message.ButtonsMessage.HeaderType|null} [headerType] ButtonsMessage headerType
             * @property {string|null} [text] ButtonsMessage text
             * @property {proto.Message.IDocumentMessage|null} [documentMessage] ButtonsMessage documentMessage
             * @property {proto.Message.IImageMessage|null} [imageMessage] ButtonsMessage imageMessage
             * @property {proto.Message.IVideoMessage|null} [videoMessage] ButtonsMessage videoMessage
             * @property {proto.Message.ILocationMessage|null} [locationMessage] ButtonsMessage locationMessage
             */

            /**
             * Constructs a new ButtonsMessage.
             * @memberof proto.Message
             * @classdesc Represents a ButtonsMessage.
             * @implements IButtonsMessage
             * @constructor
             * @param {proto.Message.IButtonsMessage=} [properties] Properties to set
             */
            function ButtonsMessage(properties) {
                this.buttons = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonsMessage contentText.
             * @member {string} contentText
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.contentText = "";

            /**
             * ButtonsMessage footerText.
             * @member {string} footerText
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.footerText = "";

            /**
             * ButtonsMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.contextInfo = null;

            /**
             * ButtonsMessage buttons.
             * @member {Array.<proto.Message.ButtonsMessage.IButton>} buttons
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.buttons = $util.emptyArray;

            /**
             * ButtonsMessage headerType.
             * @member {proto.Message.ButtonsMessage.HeaderType} headerType
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.headerType = 0;

            /**
             * ButtonsMessage text.
             * @member {string|null|undefined} text
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.text = null;

            /**
             * ButtonsMessage documentMessage.
             * @member {proto.Message.IDocumentMessage|null|undefined} documentMessage
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.documentMessage = null;

            /**
             * ButtonsMessage imageMessage.
             * @member {proto.Message.IImageMessage|null|undefined} imageMessage
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.imageMessage = null;

            /**
             * ButtonsMessage videoMessage.
             * @member {proto.Message.IVideoMessage|null|undefined} videoMessage
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.videoMessage = null;

            /**
             * ButtonsMessage locationMessage.
             * @member {proto.Message.ILocationMessage|null|undefined} locationMessage
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            ButtonsMessage.prototype.locationMessage = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ButtonsMessage header.
             * @member {"text"|"documentMessage"|"imageMessage"|"videoMessage"|"locationMessage"|undefined} header
             * @memberof proto.Message.ButtonsMessage
             * @instance
             */
            Object.defineProperty(ButtonsMessage.prototype, "header", {
                get: $util.oneOfGetter($oneOfFields = ["text", "documentMessage", "imageMessage", "videoMessage", "locationMessage"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ButtonsMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ButtonsMessage
             * @static
             * @param {proto.Message.IButtonsMessage=} [properties] Properties to set
             * @returns {proto.Message.ButtonsMessage} ButtonsMessage instance
             */
            ButtonsMessage.create = function create(properties) {
                return new ButtonsMessage(properties);
            };

            /**
             * Encodes the specified ButtonsMessage message. Does not implicitly {@link proto.Message.ButtonsMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ButtonsMessage
             * @static
             * @param {proto.Message.IButtonsMessage} message ButtonsMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonsMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                if (message.documentMessage != null && Object.hasOwnProperty.call(message, "documentMessage"))
                    $root.proto.Message.DocumentMessage.encode(message.documentMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.imageMessage != null && Object.hasOwnProperty.call(message, "imageMessage"))
                    $root.proto.Message.ImageMessage.encode(message.imageMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.videoMessage != null && Object.hasOwnProperty.call(message, "videoMessage"))
                    $root.proto.Message.VideoMessage.encode(message.videoMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.locationMessage != null && Object.hasOwnProperty.call(message, "locationMessage"))
                    $root.proto.Message.LocationMessage.encode(message.locationMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.contentText != null && Object.hasOwnProperty.call(message, "contentText"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.contentText);
                if (message.footerText != null && Object.hasOwnProperty.call(message, "footerText"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.footerText);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.buttons != null && message.buttons.length)
                    for (var i = 0; i < message.buttons.length; ++i)
                        $root.proto.Message.ButtonsMessage.Button.encode(message.buttons[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.headerType != null && Object.hasOwnProperty.call(message, "headerType"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.headerType);
                return writer;
            };

            /**
             * Encodes the specified ButtonsMessage message, length delimited. Does not implicitly {@link proto.Message.ButtonsMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ButtonsMessage
             * @static
             * @param {proto.Message.IButtonsMessage} message ButtonsMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonsMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonsMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ButtonsMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ButtonsMessage} ButtonsMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonsMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ButtonsMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 6:
                        message.contentText = reader.string();
                        break;
                    case 7:
                        message.footerText = reader.string();
                        break;
                    case 8:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.buttons && message.buttons.length))
                            message.buttons = [];
                        message.buttons.push($root.proto.Message.ButtonsMessage.Button.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        message.headerType = reader.int32();
                        break;
                    case 1:
                        message.text = reader.string();
                        break;
                    case 2:
                        message.documentMessage = $root.proto.Message.DocumentMessage.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.imageMessage = $root.proto.Message.ImageMessage.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.videoMessage = $root.proto.Message.VideoMessage.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.locationMessage = $root.proto.Message.LocationMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonsMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ButtonsMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ButtonsMessage} ButtonsMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonsMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonsMessage message.
             * @function verify
             * @memberof proto.Message.ButtonsMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonsMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.contentText != null && message.hasOwnProperty("contentText"))
                    if (!$util.isString(message.contentText))
                        return "contentText: string expected";
                if (message.footerText != null && message.hasOwnProperty("footerText"))
                    if (!$util.isString(message.footerText))
                        return "footerText: string expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.buttons != null && message.hasOwnProperty("buttons")) {
                    if (!Array.isArray(message.buttons))
                        return "buttons: array expected";
                    for (var i = 0; i < message.buttons.length; ++i) {
                        var error = $root.proto.Message.ButtonsMessage.Button.verify(message.buttons[i]);
                        if (error)
                            return "buttons." + error;
                    }
                }
                if (message.headerType != null && message.hasOwnProperty("headerType"))
                    switch (message.headerType) {
                    default:
                        return "headerType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.text != null && message.hasOwnProperty("text")) {
                    properties.header = 1;
                    if (!$util.isString(message.text))
                        return "text: string expected";
                }
                if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                    if (properties.header === 1)
                        return "header: multiple values";
                    properties.header = 1;
                    {
                        var error = $root.proto.Message.DocumentMessage.verify(message.documentMessage);
                        if (error)
                            return "documentMessage." + error;
                    }
                }
                if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                    if (properties.header === 1)
                        return "header: multiple values";
                    properties.header = 1;
                    {
                        var error = $root.proto.Message.ImageMessage.verify(message.imageMessage);
                        if (error)
                            return "imageMessage." + error;
                    }
                }
                if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                    if (properties.header === 1)
                        return "header: multiple values";
                    properties.header = 1;
                    {
                        var error = $root.proto.Message.VideoMessage.verify(message.videoMessage);
                        if (error)
                            return "videoMessage." + error;
                    }
                }
                if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                    if (properties.header === 1)
                        return "header: multiple values";
                    properties.header = 1;
                    {
                        var error = $root.proto.Message.LocationMessage.verify(message.locationMessage);
                        if (error)
                            return "locationMessage." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ButtonsMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ButtonsMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ButtonsMessage} ButtonsMessage
             */
            ButtonsMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ButtonsMessage)
                    return object;
                var message = new $root.proto.Message.ButtonsMessage();
                if (object.contentText != null)
                    message.contentText = String(object.contentText);
                if (object.footerText != null)
                    message.footerText = String(object.footerText);
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ButtonsMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.buttons) {
                    if (!Array.isArray(object.buttons))
                        throw TypeError(".proto.Message.ButtonsMessage.buttons: array expected");
                    message.buttons = [];
                    for (var i = 0; i < object.buttons.length; ++i) {
                        if (typeof object.buttons[i] !== "object")
                            throw TypeError(".proto.Message.ButtonsMessage.buttons: object expected");
                        message.buttons[i] = $root.proto.Message.ButtonsMessage.Button.fromObject(object.buttons[i]);
                    }
                }
                switch (object.headerType) {
                case "UNKNOWN":
                case 0:
                    message.headerType = 0;
                    break;
                case "EMPTY":
                case 1:
                    message.headerType = 1;
                    break;
                case "TEXT":
                case 2:
                    message.headerType = 2;
                    break;
                case "DOCUMENT":
                case 3:
                    message.headerType = 3;
                    break;
                case "IMAGE":
                case 4:
                    message.headerType = 4;
                    break;
                case "VIDEO":
                case 5:
                    message.headerType = 5;
                    break;
                case "LOCATION":
                case 6:
                    message.headerType = 6;
                    break;
                }
                if (object.text != null)
                    message.text = String(object.text);
                if (object.documentMessage != null) {
                    if (typeof object.documentMessage !== "object")
                        throw TypeError(".proto.Message.ButtonsMessage.documentMessage: object expected");
                    message.documentMessage = $root.proto.Message.DocumentMessage.fromObject(object.documentMessage);
                }
                if (object.imageMessage != null) {
                    if (typeof object.imageMessage !== "object")
                        throw TypeError(".proto.Message.ButtonsMessage.imageMessage: object expected");
                    message.imageMessage = $root.proto.Message.ImageMessage.fromObject(object.imageMessage);
                }
                if (object.videoMessage != null) {
                    if (typeof object.videoMessage !== "object")
                        throw TypeError(".proto.Message.ButtonsMessage.videoMessage: object expected");
                    message.videoMessage = $root.proto.Message.VideoMessage.fromObject(object.videoMessage);
                }
                if (object.locationMessage != null) {
                    if (typeof object.locationMessage !== "object")
                        throw TypeError(".proto.Message.ButtonsMessage.locationMessage: object expected");
                    message.locationMessage = $root.proto.Message.LocationMessage.fromObject(object.locationMessage);
                }
                return message;
            };

            /**
             * Creates a plain object from a ButtonsMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ButtonsMessage
             * @static
             * @param {proto.Message.ButtonsMessage} message ButtonsMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonsMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.buttons = [];
                if (options.defaults) {
                    object.contentText = "";
                    object.footerText = "";
                    object.contextInfo = null;
                    object.headerType = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.text != null && message.hasOwnProperty("text")) {
                    object.text = message.text;
                    if (options.oneofs)
                        object.header = "text";
                }
                if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                    object.documentMessage = $root.proto.Message.DocumentMessage.toObject(message.documentMessage, options);
                    if (options.oneofs)
                        object.header = "documentMessage";
                }
                if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                    object.imageMessage = $root.proto.Message.ImageMessage.toObject(message.imageMessage, options);
                    if (options.oneofs)
                        object.header = "imageMessage";
                }
                if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                    object.videoMessage = $root.proto.Message.VideoMessage.toObject(message.videoMessage, options);
                    if (options.oneofs)
                        object.header = "videoMessage";
                }
                if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                    object.locationMessage = $root.proto.Message.LocationMessage.toObject(message.locationMessage, options);
                    if (options.oneofs)
                        object.header = "locationMessage";
                }
                if (message.contentText != null && message.hasOwnProperty("contentText"))
                    object.contentText = message.contentText;
                if (message.footerText != null && message.hasOwnProperty("footerText"))
                    object.footerText = message.footerText;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.buttons && message.buttons.length) {
                    object.buttons = [];
                    for (var j = 0; j < message.buttons.length; ++j)
                        object.buttons[j] = $root.proto.Message.ButtonsMessage.Button.toObject(message.buttons[j], options);
                }
                if (message.headerType != null && message.hasOwnProperty("headerType"))
                    object.headerType = options.enums === String ? $root.proto.Message.ButtonsMessage.HeaderType[message.headerType] : message.headerType;
                return object;
            };

            /**
             * Converts this ButtonsMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ButtonsMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonsMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ButtonsMessage.Button = (function() {

                /**
                 * Properties of a Button.
                 * @memberof proto.Message.ButtonsMessage
                 * @interface IButton
                 * @property {string|null} [buttonId] Button buttonId
                 * @property {proto.Message.ButtonsMessage.Button.IButtonText|null} [buttonText] Button buttonText
                 * @property {proto.Message.ButtonsMessage.Button.Type|null} [type] Button type
                 * @property {proto.Message.ButtonsMessage.Button.INativeFlowInfo|null} [nativeFlowInfo] Button nativeFlowInfo
                 */

                /**
                 * Constructs a new Button.
                 * @memberof proto.Message.ButtonsMessage
                 * @classdesc Represents a Button.
                 * @implements IButton
                 * @constructor
                 * @param {proto.Message.ButtonsMessage.IButton=} [properties] Properties to set
                 */
                function Button(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Button buttonId.
                 * @member {string} buttonId
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @instance
                 */
                Button.prototype.buttonId = "";

                /**
                 * Button buttonText.
                 * @member {proto.Message.ButtonsMessage.Button.IButtonText|null|undefined} buttonText
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @instance
                 */
                Button.prototype.buttonText = null;

                /**
                 * Button type.
                 * @member {proto.Message.ButtonsMessage.Button.Type} type
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @instance
                 */
                Button.prototype.type = 0;

                /**
                 * Button nativeFlowInfo.
                 * @member {proto.Message.ButtonsMessage.Button.INativeFlowInfo|null|undefined} nativeFlowInfo
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @instance
                 */
                Button.prototype.nativeFlowInfo = null;

                /**
                 * Creates a new Button instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @static
                 * @param {proto.Message.ButtonsMessage.IButton=} [properties] Properties to set
                 * @returns {proto.Message.ButtonsMessage.Button} Button instance
                 */
                Button.create = function create(properties) {
                    return new Button(properties);
                };

                /**
                 * Encodes the specified Button message. Does not implicitly {@link proto.Message.ButtonsMessage.Button.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @static
                 * @param {proto.Message.ButtonsMessage.IButton} message Button message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Button.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.buttonId != null && Object.hasOwnProperty.call(message, "buttonId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.buttonId);
                    if (message.buttonText != null && Object.hasOwnProperty.call(message, "buttonText"))
                        $root.proto.Message.ButtonsMessage.Button.ButtonText.encode(message.buttonText, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                    if (message.nativeFlowInfo != null && Object.hasOwnProperty.call(message, "nativeFlowInfo"))
                        $root.proto.Message.ButtonsMessage.Button.NativeFlowInfo.encode(message.nativeFlowInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Button message, length delimited. Does not implicitly {@link proto.Message.ButtonsMessage.Button.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @static
                 * @param {proto.Message.ButtonsMessage.IButton} message Button message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Button.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Button message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ButtonsMessage.Button} Button
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Button.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ButtonsMessage.Button();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.buttonId = reader.string();
                            break;
                        case 2:
                            message.buttonText = $root.proto.Message.ButtonsMessage.Button.ButtonText.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.type = reader.int32();
                            break;
                        case 4:
                            message.nativeFlowInfo = $root.proto.Message.ButtonsMessage.Button.NativeFlowInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Button message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ButtonsMessage.Button} Button
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Button.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Button message.
                 * @function verify
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Button.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.buttonId != null && message.hasOwnProperty("buttonId"))
                        if (!$util.isString(message.buttonId))
                            return "buttonId: string expected";
                    if (message.buttonText != null && message.hasOwnProperty("buttonText")) {
                        var error = $root.proto.Message.ButtonsMessage.Button.ButtonText.verify(message.buttonText);
                        if (error)
                            return "buttonText." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.nativeFlowInfo != null && message.hasOwnProperty("nativeFlowInfo")) {
                        var error = $root.proto.Message.ButtonsMessage.Button.NativeFlowInfo.verify(message.nativeFlowInfo);
                        if (error)
                            return "nativeFlowInfo." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Button message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ButtonsMessage.Button} Button
                 */
                Button.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ButtonsMessage.Button)
                        return object;
                    var message = new $root.proto.Message.ButtonsMessage.Button();
                    if (object.buttonId != null)
                        message.buttonId = String(object.buttonId);
                    if (object.buttonText != null) {
                        if (typeof object.buttonText !== "object")
                            throw TypeError(".proto.Message.ButtonsMessage.Button.buttonText: object expected");
                        message.buttonText = $root.proto.Message.ButtonsMessage.Button.ButtonText.fromObject(object.buttonText);
                    }
                    switch (object.type) {
                    case "UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "RESPONSE":
                    case 1:
                        message.type = 1;
                        break;
                    case "NATIVE_FLOW":
                    case 2:
                        message.type = 2;
                        break;
                    }
                    if (object.nativeFlowInfo != null) {
                        if (typeof object.nativeFlowInfo !== "object")
                            throw TypeError(".proto.Message.ButtonsMessage.Button.nativeFlowInfo: object expected");
                        message.nativeFlowInfo = $root.proto.Message.ButtonsMessage.Button.NativeFlowInfo.fromObject(object.nativeFlowInfo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Button message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @static
                 * @param {proto.Message.ButtonsMessage.Button} message Button
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Button.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.buttonId = "";
                        object.buttonText = null;
                        object.type = options.enums === String ? "UNKNOWN" : 0;
                        object.nativeFlowInfo = null;
                    }
                    if (message.buttonId != null && message.hasOwnProperty("buttonId"))
                        object.buttonId = message.buttonId;
                    if (message.buttonText != null && message.hasOwnProperty("buttonText"))
                        object.buttonText = $root.proto.Message.ButtonsMessage.Button.ButtonText.toObject(message.buttonText, options);
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.proto.Message.ButtonsMessage.Button.Type[message.type] : message.type;
                    if (message.nativeFlowInfo != null && message.hasOwnProperty("nativeFlowInfo"))
                        object.nativeFlowInfo = $root.proto.Message.ButtonsMessage.Button.NativeFlowInfo.toObject(message.nativeFlowInfo, options);
                    return object;
                };

                /**
                 * Converts this Button to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ButtonsMessage.Button
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Button.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Button.ButtonText = (function() {

                    /**
                     * Properties of a ButtonText.
                     * @memberof proto.Message.ButtonsMessage.Button
                     * @interface IButtonText
                     * @property {string|null} [displayText] ButtonText displayText
                     */

                    /**
                     * Constructs a new ButtonText.
                     * @memberof proto.Message.ButtonsMessage.Button
                     * @classdesc Represents a ButtonText.
                     * @implements IButtonText
                     * @constructor
                     * @param {proto.Message.ButtonsMessage.Button.IButtonText=} [properties] Properties to set
                     */
                    function ButtonText(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ButtonText displayText.
                     * @member {string} displayText
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @instance
                     */
                    ButtonText.prototype.displayText = "";

                    /**
                     * Creates a new ButtonText instance using the specified properties.
                     * @function create
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @static
                     * @param {proto.Message.ButtonsMessage.Button.IButtonText=} [properties] Properties to set
                     * @returns {proto.Message.ButtonsMessage.Button.ButtonText} ButtonText instance
                     */
                    ButtonText.create = function create(properties) {
                        return new ButtonText(properties);
                    };

                    /**
                     * Encodes the specified ButtonText message. Does not implicitly {@link proto.Message.ButtonsMessage.Button.ButtonText.verify|verify} messages.
                     * @function encode
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @static
                     * @param {proto.Message.ButtonsMessage.Button.IButtonText} message ButtonText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ButtonText.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayText);
                        return writer;
                    };

                    /**
                     * Encodes the specified ButtonText message, length delimited. Does not implicitly {@link proto.Message.ButtonsMessage.Button.ButtonText.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @static
                     * @param {proto.Message.ButtonsMessage.Button.IButtonText} message ButtonText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ButtonText.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ButtonText message from the specified reader or buffer.
                     * @function decode
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {proto.Message.ButtonsMessage.Button.ButtonText} ButtonText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ButtonText.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ButtonsMessage.Button.ButtonText();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.displayText = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ButtonText message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {proto.Message.ButtonsMessage.Button.ButtonText} ButtonText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ButtonText.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ButtonText message.
                     * @function verify
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ButtonText.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.displayText != null && message.hasOwnProperty("displayText"))
                            if (!$util.isString(message.displayText))
                                return "displayText: string expected";
                        return null;
                    };

                    /**
                     * Creates a ButtonText message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {proto.Message.ButtonsMessage.Button.ButtonText} ButtonText
                     */
                    ButtonText.fromObject = function fromObject(object) {
                        if (object instanceof $root.proto.Message.ButtonsMessage.Button.ButtonText)
                            return object;
                        var message = new $root.proto.Message.ButtonsMessage.Button.ButtonText();
                        if (object.displayText != null)
                            message.displayText = String(object.displayText);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ButtonText message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @static
                     * @param {proto.Message.ButtonsMessage.Button.ButtonText} message ButtonText
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ButtonText.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.displayText = "";
                        if (message.displayText != null && message.hasOwnProperty("displayText"))
                            object.displayText = message.displayText;
                        return object;
                    };

                    /**
                     * Converts this ButtonText to JSON.
                     * @function toJSON
                     * @memberof proto.Message.ButtonsMessage.Button.ButtonText
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ButtonText.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ButtonText;
                })();

                Button.NativeFlowInfo = (function() {

                    /**
                     * Properties of a NativeFlowInfo.
                     * @memberof proto.Message.ButtonsMessage.Button
                     * @interface INativeFlowInfo
                     * @property {string|null} [name] NativeFlowInfo name
                     * @property {string|null} [paramsJson] NativeFlowInfo paramsJson
                     */

                    /**
                     * Constructs a new NativeFlowInfo.
                     * @memberof proto.Message.ButtonsMessage.Button
                     * @classdesc Represents a NativeFlowInfo.
                     * @implements INativeFlowInfo
                     * @constructor
                     * @param {proto.Message.ButtonsMessage.Button.INativeFlowInfo=} [properties] Properties to set
                     */
                    function NativeFlowInfo(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * NativeFlowInfo name.
                     * @member {string} name
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @instance
                     */
                    NativeFlowInfo.prototype.name = "";

                    /**
                     * NativeFlowInfo paramsJson.
                     * @member {string} paramsJson
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @instance
                     */
                    NativeFlowInfo.prototype.paramsJson = "";

                    /**
                     * Creates a new NativeFlowInfo instance using the specified properties.
                     * @function create
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @static
                     * @param {proto.Message.ButtonsMessage.Button.INativeFlowInfo=} [properties] Properties to set
                     * @returns {proto.Message.ButtonsMessage.Button.NativeFlowInfo} NativeFlowInfo instance
                     */
                    NativeFlowInfo.create = function create(properties) {
                        return new NativeFlowInfo(properties);
                    };

                    /**
                     * Encodes the specified NativeFlowInfo message. Does not implicitly {@link proto.Message.ButtonsMessage.Button.NativeFlowInfo.verify|verify} messages.
                     * @function encode
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @static
                     * @param {proto.Message.ButtonsMessage.Button.INativeFlowInfo} message NativeFlowInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NativeFlowInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.paramsJson != null && Object.hasOwnProperty.call(message, "paramsJson"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.paramsJson);
                        return writer;
                    };

                    /**
                     * Encodes the specified NativeFlowInfo message, length delimited. Does not implicitly {@link proto.Message.ButtonsMessage.Button.NativeFlowInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @static
                     * @param {proto.Message.ButtonsMessage.Button.INativeFlowInfo} message NativeFlowInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NativeFlowInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a NativeFlowInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {proto.Message.ButtonsMessage.Button.NativeFlowInfo} NativeFlowInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NativeFlowInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ButtonsMessage.Button.NativeFlowInfo();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.paramsJson = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a NativeFlowInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {proto.Message.ButtonsMessage.Button.NativeFlowInfo} NativeFlowInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NativeFlowInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a NativeFlowInfo message.
                     * @function verify
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NativeFlowInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.paramsJson != null && message.hasOwnProperty("paramsJson"))
                            if (!$util.isString(message.paramsJson))
                                return "paramsJson: string expected";
                        return null;
                    };

                    /**
                     * Creates a NativeFlowInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {proto.Message.ButtonsMessage.Button.NativeFlowInfo} NativeFlowInfo
                     */
                    NativeFlowInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.proto.Message.ButtonsMessage.Button.NativeFlowInfo)
                            return object;
                        var message = new $root.proto.Message.ButtonsMessage.Button.NativeFlowInfo();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.paramsJson != null)
                            message.paramsJson = String(object.paramsJson);
                        return message;
                    };

                    /**
                     * Creates a plain object from a NativeFlowInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @static
                     * @param {proto.Message.ButtonsMessage.Button.NativeFlowInfo} message NativeFlowInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NativeFlowInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.paramsJson = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.paramsJson != null && message.hasOwnProperty("paramsJson"))
                            object.paramsJson = message.paramsJson;
                        return object;
                    };

                    /**
                     * Converts this NativeFlowInfo to JSON.
                     * @function toJSON
                     * @memberof proto.Message.ButtonsMessage.Button.NativeFlowInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NativeFlowInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return NativeFlowInfo;
                })();

                /**
                 * Type enum.
                 * @name proto.Message.ButtonsMessage.Button.Type
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} RESPONSE=1 RESPONSE value
                 * @property {number} NATIVE_FLOW=2 NATIVE_FLOW value
                 */
                Button.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "RESPONSE"] = 1;
                    values[valuesById[2] = "NATIVE_FLOW"] = 2;
                    return values;
                })();

                return Button;
            })();

            /**
             * HeaderType enum.
             * @name proto.Message.ButtonsMessage.HeaderType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} EMPTY=1 EMPTY value
             * @property {number} TEXT=2 TEXT value
             * @property {number} DOCUMENT=3 DOCUMENT value
             * @property {number} IMAGE=4 IMAGE value
             * @property {number} VIDEO=5 VIDEO value
             * @property {number} LOCATION=6 LOCATION value
             */
            ButtonsMessage.HeaderType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "EMPTY"] = 1;
                values[valuesById[2] = "TEXT"] = 2;
                values[valuesById[3] = "DOCUMENT"] = 3;
                values[valuesById[4] = "IMAGE"] = 4;
                values[valuesById[5] = "VIDEO"] = 5;
                values[valuesById[6] = "LOCATION"] = 6;
                return values;
            })();

            return ButtonsMessage;
        })();

        Message.ButtonsResponseMessage = (function() {

            /**
             * Properties of a ButtonsResponseMessage.
             * @memberof proto.Message
             * @interface IButtonsResponseMessage
             * @property {string|null} [selectedButtonId] ButtonsResponseMessage selectedButtonId
             * @property {proto.IContextInfo|null} [contextInfo] ButtonsResponseMessage contextInfo
             * @property {proto.Message.ButtonsResponseMessage.Type|null} [type] ButtonsResponseMessage type
             * @property {string|null} [selectedDisplayText] ButtonsResponseMessage selectedDisplayText
             */

            /**
             * Constructs a new ButtonsResponseMessage.
             * @memberof proto.Message
             * @classdesc Represents a ButtonsResponseMessage.
             * @implements IButtonsResponseMessage
             * @constructor
             * @param {proto.Message.IButtonsResponseMessage=} [properties] Properties to set
             */
            function ButtonsResponseMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonsResponseMessage selectedButtonId.
             * @member {string} selectedButtonId
             * @memberof proto.Message.ButtonsResponseMessage
             * @instance
             */
            ButtonsResponseMessage.prototype.selectedButtonId = "";

            /**
             * ButtonsResponseMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ButtonsResponseMessage
             * @instance
             */
            ButtonsResponseMessage.prototype.contextInfo = null;

            /**
             * ButtonsResponseMessage type.
             * @member {proto.Message.ButtonsResponseMessage.Type} type
             * @memberof proto.Message.ButtonsResponseMessage
             * @instance
             */
            ButtonsResponseMessage.prototype.type = 0;

            /**
             * ButtonsResponseMessage selectedDisplayText.
             * @member {string|null|undefined} selectedDisplayText
             * @memberof proto.Message.ButtonsResponseMessage
             * @instance
             */
            ButtonsResponseMessage.prototype.selectedDisplayText = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ButtonsResponseMessage response.
             * @member {"selectedDisplayText"|undefined} response
             * @memberof proto.Message.ButtonsResponseMessage
             * @instance
             */
            Object.defineProperty(ButtonsResponseMessage.prototype, "response", {
                get: $util.oneOfGetter($oneOfFields = ["selectedDisplayText"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ButtonsResponseMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ButtonsResponseMessage
             * @static
             * @param {proto.Message.IButtonsResponseMessage=} [properties] Properties to set
             * @returns {proto.Message.ButtonsResponseMessage} ButtonsResponseMessage instance
             */
            ButtonsResponseMessage.create = function create(properties) {
                return new ButtonsResponseMessage(properties);
            };

            /**
             * Encodes the specified ButtonsResponseMessage message. Does not implicitly {@link proto.Message.ButtonsResponseMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ButtonsResponseMessage
             * @static
             * @param {proto.Message.IButtonsResponseMessage} message ButtonsResponseMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonsResponseMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selectedButtonId != null && Object.hasOwnProperty.call(message, "selectedButtonId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selectedButtonId);
                if (message.selectedDisplayText != null && Object.hasOwnProperty.call(message, "selectedDisplayText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.selectedDisplayText);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified ButtonsResponseMessage message, length delimited. Does not implicitly {@link proto.Message.ButtonsResponseMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ButtonsResponseMessage
             * @static
             * @param {proto.Message.IButtonsResponseMessage} message ButtonsResponseMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonsResponseMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonsResponseMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ButtonsResponseMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ButtonsResponseMessage} ButtonsResponseMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonsResponseMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ButtonsResponseMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.selectedButtonId = reader.string();
                        break;
                    case 3:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.selectedDisplayText = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonsResponseMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ButtonsResponseMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ButtonsResponseMessage} ButtonsResponseMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonsResponseMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonsResponseMessage message.
             * @function verify
             * @memberof proto.Message.ButtonsResponseMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonsResponseMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.selectedButtonId != null && message.hasOwnProperty("selectedButtonId"))
                    if (!$util.isString(message.selectedButtonId))
                        return "selectedButtonId: string expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.selectedDisplayText != null && message.hasOwnProperty("selectedDisplayText")) {
                    properties.response = 1;
                    if (!$util.isString(message.selectedDisplayText))
                        return "selectedDisplayText: string expected";
                }
                return null;
            };

            /**
             * Creates a ButtonsResponseMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ButtonsResponseMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ButtonsResponseMessage} ButtonsResponseMessage
             */
            ButtonsResponseMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ButtonsResponseMessage)
                    return object;
                var message = new $root.proto.Message.ButtonsResponseMessage();
                if (object.selectedButtonId != null)
                    message.selectedButtonId = String(object.selectedButtonId);
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ButtonsResponseMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "DISPLAY_TEXT":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.selectedDisplayText != null)
                    message.selectedDisplayText = String(object.selectedDisplayText);
                return message;
            };

            /**
             * Creates a plain object from a ButtonsResponseMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ButtonsResponseMessage
             * @static
             * @param {proto.Message.ButtonsResponseMessage} message ButtonsResponseMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonsResponseMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.selectedButtonId = "";
                    object.contextInfo = null;
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.selectedButtonId != null && message.hasOwnProperty("selectedButtonId"))
                    object.selectedButtonId = message.selectedButtonId;
                if (message.selectedDisplayText != null && message.hasOwnProperty("selectedDisplayText")) {
                    object.selectedDisplayText = message.selectedDisplayText;
                    if (options.oneofs)
                        object.response = "selectedDisplayText";
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.proto.Message.ButtonsResponseMessage.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this ButtonsResponseMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ButtonsResponseMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonsResponseMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name proto.Message.ButtonsResponseMessage.Type
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} DISPLAY_TEXT=1 DISPLAY_TEXT value
             */
            ButtonsResponseMessage.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "DISPLAY_TEXT"] = 1;
                return values;
            })();

            return ButtonsResponseMessage;
        })();

        Message.Call = (function() {

            /**
             * Properties of a Call.
             * @memberof proto.Message
             * @interface ICall
             * @property {Uint8Array|null} [callKey] Call callKey
             * @property {string|null} [conversionSource] Call conversionSource
             * @property {Uint8Array|null} [conversionData] Call conversionData
             * @property {number|null} [conversionDelaySeconds] Call conversionDelaySeconds
             */

            /**
             * Constructs a new Call.
             * @memberof proto.Message
             * @classdesc Represents a Call.
             * @implements ICall
             * @constructor
             * @param {proto.Message.ICall=} [properties] Properties to set
             */
            function Call(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Call callKey.
             * @member {Uint8Array} callKey
             * @memberof proto.Message.Call
             * @instance
             */
            Call.prototype.callKey = $util.newBuffer([]);

            /**
             * Call conversionSource.
             * @member {string} conversionSource
             * @memberof proto.Message.Call
             * @instance
             */
            Call.prototype.conversionSource = "";

            /**
             * Call conversionData.
             * @member {Uint8Array} conversionData
             * @memberof proto.Message.Call
             * @instance
             */
            Call.prototype.conversionData = $util.newBuffer([]);

            /**
             * Call conversionDelaySeconds.
             * @member {number} conversionDelaySeconds
             * @memberof proto.Message.Call
             * @instance
             */
            Call.prototype.conversionDelaySeconds = 0;

            /**
             * Creates a new Call instance using the specified properties.
             * @function create
             * @memberof proto.Message.Call
             * @static
             * @param {proto.Message.ICall=} [properties] Properties to set
             * @returns {proto.Message.Call} Call instance
             */
            Call.create = function create(properties) {
                return new Call(properties);
            };

            /**
             * Encodes the specified Call message. Does not implicitly {@link proto.Message.Call.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.Call
             * @static
             * @param {proto.Message.ICall} message Call message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Call.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callKey != null && Object.hasOwnProperty.call(message, "callKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.callKey);
                if (message.conversionSource != null && Object.hasOwnProperty.call(message, "conversionSource"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.conversionSource);
                if (message.conversionData != null && Object.hasOwnProperty.call(message, "conversionData"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.conversionData);
                if (message.conversionDelaySeconds != null && Object.hasOwnProperty.call(message, "conversionDelaySeconds"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.conversionDelaySeconds);
                return writer;
            };

            /**
             * Encodes the specified Call message, length delimited. Does not implicitly {@link proto.Message.Call.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.Call
             * @static
             * @param {proto.Message.ICall} message Call message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Call.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Call message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.Call
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.Call} Call
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Call.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.Call();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.callKey = reader.bytes();
                        break;
                    case 2:
                        message.conversionSource = reader.string();
                        break;
                    case 3:
                        message.conversionData = reader.bytes();
                        break;
                    case 4:
                        message.conversionDelaySeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Call message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.Call
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.Call} Call
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Call.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Call message.
             * @function verify
             * @memberof proto.Message.Call
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Call.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callKey != null && message.hasOwnProperty("callKey"))
                    if (!(message.callKey && typeof message.callKey.length === "number" || $util.isString(message.callKey)))
                        return "callKey: buffer expected";
                if (message.conversionSource != null && message.hasOwnProperty("conversionSource"))
                    if (!$util.isString(message.conversionSource))
                        return "conversionSource: string expected";
                if (message.conversionData != null && message.hasOwnProperty("conversionData"))
                    if (!(message.conversionData && typeof message.conversionData.length === "number" || $util.isString(message.conversionData)))
                        return "conversionData: buffer expected";
                if (message.conversionDelaySeconds != null && message.hasOwnProperty("conversionDelaySeconds"))
                    if (!$util.isInteger(message.conversionDelaySeconds))
                        return "conversionDelaySeconds: integer expected";
                return null;
            };

            /**
             * Creates a Call message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.Call
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.Call} Call
             */
            Call.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.Call)
                    return object;
                var message = new $root.proto.Message.Call();
                if (object.callKey != null)
                    if (typeof object.callKey === "string")
                        $util.base64.decode(object.callKey, message.callKey = $util.newBuffer($util.base64.length(object.callKey)), 0);
                    else if (object.callKey.length)
                        message.callKey = object.callKey;
                if (object.conversionSource != null)
                    message.conversionSource = String(object.conversionSource);
                if (object.conversionData != null)
                    if (typeof object.conversionData === "string")
                        $util.base64.decode(object.conversionData, message.conversionData = $util.newBuffer($util.base64.length(object.conversionData)), 0);
                    else if (object.conversionData.length)
                        message.conversionData = object.conversionData;
                if (object.conversionDelaySeconds != null)
                    message.conversionDelaySeconds = object.conversionDelaySeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Call message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.Call
             * @static
             * @param {proto.Message.Call} message Call
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Call.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.callKey = "";
                    else {
                        object.callKey = [];
                        if (options.bytes !== Array)
                            object.callKey = $util.newBuffer(object.callKey);
                    }
                    object.conversionSource = "";
                    if (options.bytes === String)
                        object.conversionData = "";
                    else {
                        object.conversionData = [];
                        if (options.bytes !== Array)
                            object.conversionData = $util.newBuffer(object.conversionData);
                    }
                    object.conversionDelaySeconds = 0;
                }
                if (message.callKey != null && message.hasOwnProperty("callKey"))
                    object.callKey = options.bytes === String ? $util.base64.encode(message.callKey, 0, message.callKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.callKey) : message.callKey;
                if (message.conversionSource != null && message.hasOwnProperty("conversionSource"))
                    object.conversionSource = message.conversionSource;
                if (message.conversionData != null && message.hasOwnProperty("conversionData"))
                    object.conversionData = options.bytes === String ? $util.base64.encode(message.conversionData, 0, message.conversionData.length) : options.bytes === Array ? Array.prototype.slice.call(message.conversionData) : message.conversionData;
                if (message.conversionDelaySeconds != null && message.hasOwnProperty("conversionDelaySeconds"))
                    object.conversionDelaySeconds = message.conversionDelaySeconds;
                return object;
            };

            /**
             * Converts this Call to JSON.
             * @function toJSON
             * @memberof proto.Message.Call
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Call.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Call;
        })();

        Message.CancelPaymentRequestMessage = (function() {

            /**
             * Properties of a CancelPaymentRequestMessage.
             * @memberof proto.Message
             * @interface ICancelPaymentRequestMessage
             * @property {proto.IMessageKey|null} [key] CancelPaymentRequestMessage key
             */

            /**
             * Constructs a new CancelPaymentRequestMessage.
             * @memberof proto.Message
             * @classdesc Represents a CancelPaymentRequestMessage.
             * @implements ICancelPaymentRequestMessage
             * @constructor
             * @param {proto.Message.ICancelPaymentRequestMessage=} [properties] Properties to set
             */
            function CancelPaymentRequestMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CancelPaymentRequestMessage key.
             * @member {proto.IMessageKey|null|undefined} key
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @instance
             */
            CancelPaymentRequestMessage.prototype.key = null;

            /**
             * Creates a new CancelPaymentRequestMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @static
             * @param {proto.Message.ICancelPaymentRequestMessage=} [properties] Properties to set
             * @returns {proto.Message.CancelPaymentRequestMessage} CancelPaymentRequestMessage instance
             */
            CancelPaymentRequestMessage.create = function create(properties) {
                return new CancelPaymentRequestMessage(properties);
            };

            /**
             * Encodes the specified CancelPaymentRequestMessage message. Does not implicitly {@link proto.Message.CancelPaymentRequestMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @static
             * @param {proto.Message.ICancelPaymentRequestMessage} message CancelPaymentRequestMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelPaymentRequestMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CancelPaymentRequestMessage message, length delimited. Does not implicitly {@link proto.Message.CancelPaymentRequestMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @static
             * @param {proto.Message.ICancelPaymentRequestMessage} message CancelPaymentRequestMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelPaymentRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CancelPaymentRequestMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.CancelPaymentRequestMessage} CancelPaymentRequestMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelPaymentRequestMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.CancelPaymentRequestMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CancelPaymentRequestMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.CancelPaymentRequestMessage} CancelPaymentRequestMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelPaymentRequestMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CancelPaymentRequestMessage message.
             * @function verify
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CancelPaymentRequestMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key")) {
                    var error = $root.proto.MessageKey.verify(message.key);
                    if (error)
                        return "key." + error;
                }
                return null;
            };

            /**
             * Creates a CancelPaymentRequestMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.CancelPaymentRequestMessage} CancelPaymentRequestMessage
             */
            CancelPaymentRequestMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.CancelPaymentRequestMessage)
                    return object;
                var message = new $root.proto.Message.CancelPaymentRequestMessage();
                if (object.key != null) {
                    if (typeof object.key !== "object")
                        throw TypeError(".proto.Message.CancelPaymentRequestMessage.key: object expected");
                    message.key = $root.proto.MessageKey.fromObject(object.key);
                }
                return message;
            };

            /**
             * Creates a plain object from a CancelPaymentRequestMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @static
             * @param {proto.Message.CancelPaymentRequestMessage} message CancelPaymentRequestMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CancelPaymentRequestMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.key = null;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = $root.proto.MessageKey.toObject(message.key, options);
                return object;
            };

            /**
             * Converts this CancelPaymentRequestMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.CancelPaymentRequestMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CancelPaymentRequestMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CancelPaymentRequestMessage;
        })();

        Message.Chat = (function() {

            /**
             * Properties of a Chat.
             * @memberof proto.Message
             * @interface IChat
             * @property {string|null} [displayName] Chat displayName
             * @property {string|null} [id] Chat id
             */

            /**
             * Constructs a new Chat.
             * @memberof proto.Message
             * @classdesc Represents a Chat.
             * @implements IChat
             * @constructor
             * @param {proto.Message.IChat=} [properties] Properties to set
             */
            function Chat(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Chat displayName.
             * @member {string} displayName
             * @memberof proto.Message.Chat
             * @instance
             */
            Chat.prototype.displayName = "";

            /**
             * Chat id.
             * @member {string} id
             * @memberof proto.Message.Chat
             * @instance
             */
            Chat.prototype.id = "";

            /**
             * Creates a new Chat instance using the specified properties.
             * @function create
             * @memberof proto.Message.Chat
             * @static
             * @param {proto.Message.IChat=} [properties] Properties to set
             * @returns {proto.Message.Chat} Chat instance
             */
            Chat.create = function create(properties) {
                return new Chat(properties);
            };

            /**
             * Encodes the specified Chat message. Does not implicitly {@link proto.Message.Chat.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.Chat
             * @static
             * @param {proto.Message.IChat} message Chat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chat.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified Chat message, length delimited. Does not implicitly {@link proto.Message.Chat.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.Chat
             * @static
             * @param {proto.Message.IChat} message Chat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chat.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Chat message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.Chat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.Chat} Chat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chat.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.Chat();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayName = reader.string();
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Chat message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.Chat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.Chat} Chat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chat.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Chat message.
             * @function verify
             * @memberof proto.Message.Chat
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Chat.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a Chat message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.Chat
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.Chat} Chat
             */
            Chat.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.Chat)
                    return object;
                var message = new $root.proto.Message.Chat();
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a Chat message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.Chat
             * @static
             * @param {proto.Message.Chat} message Chat
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Chat.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayName = "";
                    object.id = "";
                }
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this Chat to JSON.
             * @function toJSON
             * @memberof proto.Message.Chat
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Chat.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Chat;
        })();

        Message.ContactMessage = (function() {

            /**
             * Properties of a ContactMessage.
             * @memberof proto.Message
             * @interface IContactMessage
             * @property {string|null} [displayName] ContactMessage displayName
             * @property {string|null} [vcard] ContactMessage vcard
             * @property {proto.IContextInfo|null} [contextInfo] ContactMessage contextInfo
             */

            /**
             * Constructs a new ContactMessage.
             * @memberof proto.Message
             * @classdesc Represents a ContactMessage.
             * @implements IContactMessage
             * @constructor
             * @param {proto.Message.IContactMessage=} [properties] Properties to set
             */
            function ContactMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContactMessage displayName.
             * @member {string} displayName
             * @memberof proto.Message.ContactMessage
             * @instance
             */
            ContactMessage.prototype.displayName = "";

            /**
             * ContactMessage vcard.
             * @member {string} vcard
             * @memberof proto.Message.ContactMessage
             * @instance
             */
            ContactMessage.prototype.vcard = "";

            /**
             * ContactMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ContactMessage
             * @instance
             */
            ContactMessage.prototype.contextInfo = null;

            /**
             * Creates a new ContactMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ContactMessage
             * @static
             * @param {proto.Message.IContactMessage=} [properties] Properties to set
             * @returns {proto.Message.ContactMessage} ContactMessage instance
             */
            ContactMessage.create = function create(properties) {
                return new ContactMessage(properties);
            };

            /**
             * Encodes the specified ContactMessage message. Does not implicitly {@link proto.Message.ContactMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ContactMessage
             * @static
             * @param {proto.Message.IContactMessage} message ContactMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
                if (message.vcard != null && Object.hasOwnProperty.call(message, "vcard"))
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.vcard);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ContactMessage message, length delimited. Does not implicitly {@link proto.Message.ContactMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ContactMessage
             * @static
             * @param {proto.Message.IContactMessage} message ContactMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContactMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ContactMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ContactMessage} ContactMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ContactMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayName = reader.string();
                        break;
                    case 16:
                        message.vcard = reader.string();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContactMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ContactMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ContactMessage} ContactMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContactMessage message.
             * @function verify
             * @memberof proto.Message.ContactMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContactMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.vcard != null && message.hasOwnProperty("vcard"))
                    if (!$util.isString(message.vcard))
                        return "vcard: string expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates a ContactMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ContactMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ContactMessage} ContactMessage
             */
            ContactMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ContactMessage)
                    return object;
                var message = new $root.proto.Message.ContactMessage();
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.vcard != null)
                    message.vcard = String(object.vcard);
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ContactMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a ContactMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ContactMessage
             * @static
             * @param {proto.Message.ContactMessage} message ContactMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContactMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayName = "";
                    object.vcard = "";
                    object.contextInfo = null;
                }
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.vcard != null && message.hasOwnProperty("vcard"))
                    object.vcard = message.vcard;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this ContactMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ContactMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContactMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ContactMessage;
        })();

        Message.ContactsArrayMessage = (function() {

            /**
             * Properties of a ContactsArrayMessage.
             * @memberof proto.Message
             * @interface IContactsArrayMessage
             * @property {string|null} [displayName] ContactsArrayMessage displayName
             * @property {Array.<proto.Message.IContactMessage>|null} [contacts] ContactsArrayMessage contacts
             * @property {proto.IContextInfo|null} [contextInfo] ContactsArrayMessage contextInfo
             */

            /**
             * Constructs a new ContactsArrayMessage.
             * @memberof proto.Message
             * @classdesc Represents a ContactsArrayMessage.
             * @implements IContactsArrayMessage
             * @constructor
             * @param {proto.Message.IContactsArrayMessage=} [properties] Properties to set
             */
            function ContactsArrayMessage(properties) {
                this.contacts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContactsArrayMessage displayName.
             * @member {string} displayName
             * @memberof proto.Message.ContactsArrayMessage
             * @instance
             */
            ContactsArrayMessage.prototype.displayName = "";

            /**
             * ContactsArrayMessage contacts.
             * @member {Array.<proto.Message.IContactMessage>} contacts
             * @memberof proto.Message.ContactsArrayMessage
             * @instance
             */
            ContactsArrayMessage.prototype.contacts = $util.emptyArray;

            /**
             * ContactsArrayMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ContactsArrayMessage
             * @instance
             */
            ContactsArrayMessage.prototype.contextInfo = null;

            /**
             * Creates a new ContactsArrayMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ContactsArrayMessage
             * @static
             * @param {proto.Message.IContactsArrayMessage=} [properties] Properties to set
             * @returns {proto.Message.ContactsArrayMessage} ContactsArrayMessage instance
             */
            ContactsArrayMessage.create = function create(properties) {
                return new ContactsArrayMessage(properties);
            };

            /**
             * Encodes the specified ContactsArrayMessage message. Does not implicitly {@link proto.Message.ContactsArrayMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ContactsArrayMessage
             * @static
             * @param {proto.Message.IContactsArrayMessage} message ContactsArrayMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactsArrayMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
                if (message.contacts != null && message.contacts.length)
                    for (var i = 0; i < message.contacts.length; ++i)
                        $root.proto.Message.ContactMessage.encode(message.contacts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ContactsArrayMessage message, length delimited. Does not implicitly {@link proto.Message.ContactsArrayMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ContactsArrayMessage
             * @static
             * @param {proto.Message.IContactsArrayMessage} message ContactsArrayMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactsArrayMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContactsArrayMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ContactsArrayMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ContactsArrayMessage} ContactsArrayMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactsArrayMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ContactsArrayMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayName = reader.string();
                        break;
                    case 2:
                        if (!(message.contacts && message.contacts.length))
                            message.contacts = [];
                        message.contacts.push($root.proto.Message.ContactMessage.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContactsArrayMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ContactsArrayMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ContactsArrayMessage} ContactsArrayMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactsArrayMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContactsArrayMessage message.
             * @function verify
             * @memberof proto.Message.ContactsArrayMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContactsArrayMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.contacts != null && message.hasOwnProperty("contacts")) {
                    if (!Array.isArray(message.contacts))
                        return "contacts: array expected";
                    for (var i = 0; i < message.contacts.length; ++i) {
                        var error = $root.proto.Message.ContactMessage.verify(message.contacts[i]);
                        if (error)
                            return "contacts." + error;
                    }
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates a ContactsArrayMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ContactsArrayMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ContactsArrayMessage} ContactsArrayMessage
             */
            ContactsArrayMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ContactsArrayMessage)
                    return object;
                var message = new $root.proto.Message.ContactsArrayMessage();
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.contacts) {
                    if (!Array.isArray(object.contacts))
                        throw TypeError(".proto.Message.ContactsArrayMessage.contacts: array expected");
                    message.contacts = [];
                    for (var i = 0; i < object.contacts.length; ++i) {
                        if (typeof object.contacts[i] !== "object")
                            throw TypeError(".proto.Message.ContactsArrayMessage.contacts: object expected");
                        message.contacts[i] = $root.proto.Message.ContactMessage.fromObject(object.contacts[i]);
                    }
                }
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ContactsArrayMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a ContactsArrayMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ContactsArrayMessage
             * @static
             * @param {proto.Message.ContactsArrayMessage} message ContactsArrayMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContactsArrayMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.contacts = [];
                if (options.defaults) {
                    object.displayName = "";
                    object.contextInfo = null;
                }
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.contacts && message.contacts.length) {
                    object.contacts = [];
                    for (var j = 0; j < message.contacts.length; ++j)
                        object.contacts[j] = $root.proto.Message.ContactMessage.toObject(message.contacts[j], options);
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this ContactsArrayMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ContactsArrayMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContactsArrayMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ContactsArrayMessage;
        })();

        Message.DeclinePaymentRequestMessage = (function() {

            /**
             * Properties of a DeclinePaymentRequestMessage.
             * @memberof proto.Message
             * @interface IDeclinePaymentRequestMessage
             * @property {proto.IMessageKey|null} [key] DeclinePaymentRequestMessage key
             */

            /**
             * Constructs a new DeclinePaymentRequestMessage.
             * @memberof proto.Message
             * @classdesc Represents a DeclinePaymentRequestMessage.
             * @implements IDeclinePaymentRequestMessage
             * @constructor
             * @param {proto.Message.IDeclinePaymentRequestMessage=} [properties] Properties to set
             */
            function DeclinePaymentRequestMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeclinePaymentRequestMessage key.
             * @member {proto.IMessageKey|null|undefined} key
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @instance
             */
            DeclinePaymentRequestMessage.prototype.key = null;

            /**
             * Creates a new DeclinePaymentRequestMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @static
             * @param {proto.Message.IDeclinePaymentRequestMessage=} [properties] Properties to set
             * @returns {proto.Message.DeclinePaymentRequestMessage} DeclinePaymentRequestMessage instance
             */
            DeclinePaymentRequestMessage.create = function create(properties) {
                return new DeclinePaymentRequestMessage(properties);
            };

            /**
             * Encodes the specified DeclinePaymentRequestMessage message. Does not implicitly {@link proto.Message.DeclinePaymentRequestMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @static
             * @param {proto.Message.IDeclinePaymentRequestMessage} message DeclinePaymentRequestMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeclinePaymentRequestMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeclinePaymentRequestMessage message, length delimited. Does not implicitly {@link proto.Message.DeclinePaymentRequestMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @static
             * @param {proto.Message.IDeclinePaymentRequestMessage} message DeclinePaymentRequestMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeclinePaymentRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeclinePaymentRequestMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.DeclinePaymentRequestMessage} DeclinePaymentRequestMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeclinePaymentRequestMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.DeclinePaymentRequestMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeclinePaymentRequestMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.DeclinePaymentRequestMessage} DeclinePaymentRequestMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeclinePaymentRequestMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeclinePaymentRequestMessage message.
             * @function verify
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeclinePaymentRequestMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key")) {
                    var error = $root.proto.MessageKey.verify(message.key);
                    if (error)
                        return "key." + error;
                }
                return null;
            };

            /**
             * Creates a DeclinePaymentRequestMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.DeclinePaymentRequestMessage} DeclinePaymentRequestMessage
             */
            DeclinePaymentRequestMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.DeclinePaymentRequestMessage)
                    return object;
                var message = new $root.proto.Message.DeclinePaymentRequestMessage();
                if (object.key != null) {
                    if (typeof object.key !== "object")
                        throw TypeError(".proto.Message.DeclinePaymentRequestMessage.key: object expected");
                    message.key = $root.proto.MessageKey.fromObject(object.key);
                }
                return message;
            };

            /**
             * Creates a plain object from a DeclinePaymentRequestMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @static
             * @param {proto.Message.DeclinePaymentRequestMessage} message DeclinePaymentRequestMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeclinePaymentRequestMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.key = null;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = $root.proto.MessageKey.toObject(message.key, options);
                return object;
            };

            /**
             * Converts this DeclinePaymentRequestMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.DeclinePaymentRequestMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeclinePaymentRequestMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeclinePaymentRequestMessage;
        })();

        Message.DeviceSentMessage = (function() {

            /**
             * Properties of a DeviceSentMessage.
             * @memberof proto.Message
             * @interface IDeviceSentMessage
             * @property {string|null} [destinationJid] DeviceSentMessage destinationJid
             * @property {proto.IMessage|null} [message] DeviceSentMessage message
             * @property {string|null} [phash] DeviceSentMessage phash
             */

            /**
             * Constructs a new DeviceSentMessage.
             * @memberof proto.Message
             * @classdesc Represents a DeviceSentMessage.
             * @implements IDeviceSentMessage
             * @constructor
             * @param {proto.Message.IDeviceSentMessage=} [properties] Properties to set
             */
            function DeviceSentMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeviceSentMessage destinationJid.
             * @member {string} destinationJid
             * @memberof proto.Message.DeviceSentMessage
             * @instance
             */
            DeviceSentMessage.prototype.destinationJid = "";

            /**
             * DeviceSentMessage message.
             * @member {proto.IMessage|null|undefined} message
             * @memberof proto.Message.DeviceSentMessage
             * @instance
             */
            DeviceSentMessage.prototype.message = null;

            /**
             * DeviceSentMessage phash.
             * @member {string} phash
             * @memberof proto.Message.DeviceSentMessage
             * @instance
             */
            DeviceSentMessage.prototype.phash = "";

            /**
             * Creates a new DeviceSentMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.DeviceSentMessage
             * @static
             * @param {proto.Message.IDeviceSentMessage=} [properties] Properties to set
             * @returns {proto.Message.DeviceSentMessage} DeviceSentMessage instance
             */
            DeviceSentMessage.create = function create(properties) {
                return new DeviceSentMessage(properties);
            };

            /**
             * Encodes the specified DeviceSentMessage message. Does not implicitly {@link proto.Message.DeviceSentMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.DeviceSentMessage
             * @static
             * @param {proto.Message.IDeviceSentMessage} message DeviceSentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceSentMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destinationJid != null && Object.hasOwnProperty.call(message, "destinationJid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.destinationJid);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.proto.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.phash != null && Object.hasOwnProperty.call(message, "phash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.phash);
                return writer;
            };

            /**
             * Encodes the specified DeviceSentMessage message, length delimited. Does not implicitly {@link proto.Message.DeviceSentMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.DeviceSentMessage
             * @static
             * @param {proto.Message.IDeviceSentMessage} message DeviceSentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceSentMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeviceSentMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.DeviceSentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.DeviceSentMessage} DeviceSentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceSentMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.DeviceSentMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.destinationJid = reader.string();
                        break;
                    case 2:
                        message.message = $root.proto.Message.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.phash = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeviceSentMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.DeviceSentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.DeviceSentMessage} DeviceSentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceSentMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeviceSentMessage message.
             * @function verify
             * @memberof proto.Message.DeviceSentMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeviceSentMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destinationJid != null && message.hasOwnProperty("destinationJid"))
                    if (!$util.isString(message.destinationJid))
                        return "destinationJid: string expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    var error = $root.proto.Message.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                if (message.phash != null && message.hasOwnProperty("phash"))
                    if (!$util.isString(message.phash))
                        return "phash: string expected";
                return null;
            };

            /**
             * Creates a DeviceSentMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.DeviceSentMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.DeviceSentMessage} DeviceSentMessage
             */
            DeviceSentMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.DeviceSentMessage)
                    return object;
                var message = new $root.proto.Message.DeviceSentMessage();
                if (object.destinationJid != null)
                    message.destinationJid = String(object.destinationJid);
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".proto.Message.DeviceSentMessage.message: object expected");
                    message.message = $root.proto.Message.fromObject(object.message);
                }
                if (object.phash != null)
                    message.phash = String(object.phash);
                return message;
            };

            /**
             * Creates a plain object from a DeviceSentMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.DeviceSentMessage
             * @static
             * @param {proto.Message.DeviceSentMessage} message DeviceSentMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeviceSentMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.destinationJid = "";
                    object.message = null;
                    object.phash = "";
                }
                if (message.destinationJid != null && message.hasOwnProperty("destinationJid"))
                    object.destinationJid = message.destinationJid;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.proto.Message.toObject(message.message, options);
                if (message.phash != null && message.hasOwnProperty("phash"))
                    object.phash = message.phash;
                return object;
            };

            /**
             * Converts this DeviceSentMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.DeviceSentMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeviceSentMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeviceSentMessage;
        })();

        Message.DocumentMessage = (function() {

            /**
             * Properties of a DocumentMessage.
             * @memberof proto.Message
             * @interface IDocumentMessage
             * @property {string|null} [url] DocumentMessage url
             * @property {string|null} [mimetype] DocumentMessage mimetype
             * @property {string|null} [title] DocumentMessage title
             * @property {Uint8Array|null} [fileSha256] DocumentMessage fileSha256
             * @property {number|Long|null} [fileLength] DocumentMessage fileLength
             * @property {number|null} [pageCount] DocumentMessage pageCount
             * @property {Uint8Array|null} [mediaKey] DocumentMessage mediaKey
             * @property {string|null} [fileName] DocumentMessage fileName
             * @property {Uint8Array|null} [fileEncSha256] DocumentMessage fileEncSha256
             * @property {string|null} [directPath] DocumentMessage directPath
             * @property {number|Long|null} [mediaKeyTimestamp] DocumentMessage mediaKeyTimestamp
             * @property {boolean|null} [contactVcard] DocumentMessage contactVcard
             * @property {string|null} [thumbnailDirectPath] DocumentMessage thumbnailDirectPath
             * @property {Uint8Array|null} [thumbnailSha256] DocumentMessage thumbnailSha256
             * @property {Uint8Array|null} [thumbnailEncSha256] DocumentMessage thumbnailEncSha256
             * @property {Uint8Array|null} [jpegThumbnail] DocumentMessage jpegThumbnail
             * @property {proto.IContextInfo|null} [contextInfo] DocumentMessage contextInfo
             * @property {number|null} [thumbnailHeight] DocumentMessage thumbnailHeight
             * @property {number|null} [thumbnailWidth] DocumentMessage thumbnailWidth
             * @property {string|null} [caption] DocumentMessage caption
             */

            /**
             * Constructs a new DocumentMessage.
             * @memberof proto.Message
             * @classdesc Represents a DocumentMessage.
             * @implements IDocumentMessage
             * @constructor
             * @param {proto.Message.IDocumentMessage=} [properties] Properties to set
             */
            function DocumentMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DocumentMessage url.
             * @member {string} url
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.url = "";

            /**
             * DocumentMessage mimetype.
             * @member {string} mimetype
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.mimetype = "";

            /**
             * DocumentMessage title.
             * @member {string} title
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.title = "";

            /**
             * DocumentMessage fileSha256.
             * @member {Uint8Array} fileSha256
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.fileSha256 = $util.newBuffer([]);

            /**
             * DocumentMessage fileLength.
             * @member {number|Long} fileLength
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DocumentMessage pageCount.
             * @member {number} pageCount
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.pageCount = 0;

            /**
             * DocumentMessage mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.mediaKey = $util.newBuffer([]);

            /**
             * DocumentMessage fileName.
             * @member {string} fileName
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.fileName = "";

            /**
             * DocumentMessage fileEncSha256.
             * @member {Uint8Array} fileEncSha256
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.fileEncSha256 = $util.newBuffer([]);

            /**
             * DocumentMessage directPath.
             * @member {string} directPath
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.directPath = "";

            /**
             * DocumentMessage mediaKeyTimestamp.
             * @member {number|Long} mediaKeyTimestamp
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DocumentMessage contactVcard.
             * @member {boolean} contactVcard
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.contactVcard = false;

            /**
             * DocumentMessage thumbnailDirectPath.
             * @member {string} thumbnailDirectPath
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.thumbnailDirectPath = "";

            /**
             * DocumentMessage thumbnailSha256.
             * @member {Uint8Array} thumbnailSha256
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.thumbnailSha256 = $util.newBuffer([]);

            /**
             * DocumentMessage thumbnailEncSha256.
             * @member {Uint8Array} thumbnailEncSha256
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.thumbnailEncSha256 = $util.newBuffer([]);

            /**
             * DocumentMessage jpegThumbnail.
             * @member {Uint8Array} jpegThumbnail
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.jpegThumbnail = $util.newBuffer([]);

            /**
             * DocumentMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.contextInfo = null;

            /**
             * DocumentMessage thumbnailHeight.
             * @member {number} thumbnailHeight
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.thumbnailHeight = 0;

            /**
             * DocumentMessage thumbnailWidth.
             * @member {number} thumbnailWidth
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.thumbnailWidth = 0;

            /**
             * DocumentMessage caption.
             * @member {string} caption
             * @memberof proto.Message.DocumentMessage
             * @instance
             */
            DocumentMessage.prototype.caption = "";

            /**
             * Creates a new DocumentMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.DocumentMessage
             * @static
             * @param {proto.Message.IDocumentMessage=} [properties] Properties to set
             * @returns {proto.Message.DocumentMessage} DocumentMessage instance
             */
            DocumentMessage.create = function create(properties) {
                return new DocumentMessage(properties);
            };

            /**
             * Encodes the specified DocumentMessage message. Does not implicitly {@link proto.Message.DocumentMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.DocumentMessage
             * @static
             * @param {proto.Message.IDocumentMessage} message DocumentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DocumentMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimetype);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fileSha256);
                if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.fileLength);
                if (message.pageCount != null && Object.hasOwnProperty.call(message, "pageCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.pageCount);
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.mediaKey);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.fileName);
                if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.fileEncSha256);
                if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.directPath);
                if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int64(message.mediaKeyTimestamp);
                if (message.contactVcard != null && Object.hasOwnProperty.call(message, "contactVcard"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.contactVcard);
                if (message.thumbnailDirectPath != null && Object.hasOwnProperty.call(message, "thumbnailDirectPath"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.thumbnailDirectPath);
                if (message.thumbnailSha256 != null && Object.hasOwnProperty.call(message, "thumbnailSha256"))
                    writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.thumbnailSha256);
                if (message.thumbnailEncSha256 != null && Object.hasOwnProperty.call(message, "thumbnailEncSha256"))
                    writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.thumbnailEncSha256);
                if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.thumbnailHeight != null && Object.hasOwnProperty.call(message, "thumbnailHeight"))
                    writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.thumbnailHeight);
                if (message.thumbnailWidth != null && Object.hasOwnProperty.call(message, "thumbnailWidth"))
                    writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.thumbnailWidth);
                if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                    writer.uint32(/* id 20, wireType 2 =*/162).string(message.caption);
                return writer;
            };

            /**
             * Encodes the specified DocumentMessage message, length delimited. Does not implicitly {@link proto.Message.DocumentMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.DocumentMessage
             * @static
             * @param {proto.Message.IDocumentMessage} message DocumentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DocumentMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DocumentMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.DocumentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.DocumentMessage} DocumentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DocumentMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.DocumentMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        message.mimetype = reader.string();
                        break;
                    case 3:
                        message.title = reader.string();
                        break;
                    case 4:
                        message.fileSha256 = reader.bytes();
                        break;
                    case 5:
                        message.fileLength = reader.uint64();
                        break;
                    case 6:
                        message.pageCount = reader.uint32();
                        break;
                    case 7:
                        message.mediaKey = reader.bytes();
                        break;
                    case 8:
                        message.fileName = reader.string();
                        break;
                    case 9:
                        message.fileEncSha256 = reader.bytes();
                        break;
                    case 10:
                        message.directPath = reader.string();
                        break;
                    case 11:
                        message.mediaKeyTimestamp = reader.int64();
                        break;
                    case 12:
                        message.contactVcard = reader.bool();
                        break;
                    case 13:
                        message.thumbnailDirectPath = reader.string();
                        break;
                    case 14:
                        message.thumbnailSha256 = reader.bytes();
                        break;
                    case 15:
                        message.thumbnailEncSha256 = reader.bytes();
                        break;
                    case 16:
                        message.jpegThumbnail = reader.bytes();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.thumbnailHeight = reader.uint32();
                        break;
                    case 19:
                        message.thumbnailWidth = reader.uint32();
                        break;
                    case 20:
                        message.caption = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DocumentMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.DocumentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.DocumentMessage} DocumentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DocumentMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DocumentMessage message.
             * @function verify
             * @memberof proto.Message.DocumentMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DocumentMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    if (!$util.isString(message.mimetype))
                        return "mimetype: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                        return "fileSha256: buffer expected";
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                        return "fileLength: integer|Long expected";
                if (message.pageCount != null && message.hasOwnProperty("pageCount"))
                    if (!$util.isInteger(message.pageCount))
                        return "pageCount: integer expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                        return "fileEncSha256: buffer expected";
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    if (!$util.isString(message.directPath))
                        return "directPath: string expected";
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                        return "mediaKeyTimestamp: integer|Long expected";
                if (message.contactVcard != null && message.hasOwnProperty("contactVcard"))
                    if (typeof message.contactVcard !== "boolean")
                        return "contactVcard: boolean expected";
                if (message.thumbnailDirectPath != null && message.hasOwnProperty("thumbnailDirectPath"))
                    if (!$util.isString(message.thumbnailDirectPath))
                        return "thumbnailDirectPath: string expected";
                if (message.thumbnailSha256 != null && message.hasOwnProperty("thumbnailSha256"))
                    if (!(message.thumbnailSha256 && typeof message.thumbnailSha256.length === "number" || $util.isString(message.thumbnailSha256)))
                        return "thumbnailSha256: buffer expected";
                if (message.thumbnailEncSha256 != null && message.hasOwnProperty("thumbnailEncSha256"))
                    if (!(message.thumbnailEncSha256 && typeof message.thumbnailEncSha256.length === "number" || $util.isString(message.thumbnailEncSha256)))
                        return "thumbnailEncSha256: buffer expected";
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                        return "jpegThumbnail: buffer expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                    if (!$util.isInteger(message.thumbnailHeight))
                        return "thumbnailHeight: integer expected";
                if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                    if (!$util.isInteger(message.thumbnailWidth))
                        return "thumbnailWidth: integer expected";
                if (message.caption != null && message.hasOwnProperty("caption"))
                    if (!$util.isString(message.caption))
                        return "caption: string expected";
                return null;
            };

            /**
             * Creates a DocumentMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.DocumentMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.DocumentMessage} DocumentMessage
             */
            DocumentMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.DocumentMessage)
                    return object;
                var message = new $root.proto.Message.DocumentMessage();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.mimetype != null)
                    message.mimetype = String(object.mimetype);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.fileSha256 != null)
                    if (typeof object.fileSha256 === "string")
                        $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                    else if (object.fileSha256.length)
                        message.fileSha256 = object.fileSha256;
                if (object.fileLength != null)
                    if ($util.Long)
                        (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                    else if (typeof object.fileLength === "string")
                        message.fileLength = parseInt(object.fileLength, 10);
                    else if (typeof object.fileLength === "number")
                        message.fileLength = object.fileLength;
                    else if (typeof object.fileLength === "object")
                        message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
                if (object.pageCount != null)
                    message.pageCount = object.pageCount >>> 0;
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.fileEncSha256 != null)
                    if (typeof object.fileEncSha256 === "string")
                        $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                    else if (object.fileEncSha256.length)
                        message.fileEncSha256 = object.fileEncSha256;
                if (object.directPath != null)
                    message.directPath = String(object.directPath);
                if (object.mediaKeyTimestamp != null)
                    if ($util.Long)
                        (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                    else if (typeof object.mediaKeyTimestamp === "string")
                        message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                    else if (typeof object.mediaKeyTimestamp === "number")
                        message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                    else if (typeof object.mediaKeyTimestamp === "object")
                        message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
                if (object.contactVcard != null)
                    message.contactVcard = Boolean(object.contactVcard);
                if (object.thumbnailDirectPath != null)
                    message.thumbnailDirectPath = String(object.thumbnailDirectPath);
                if (object.thumbnailSha256 != null)
                    if (typeof object.thumbnailSha256 === "string")
                        $util.base64.decode(object.thumbnailSha256, message.thumbnailSha256 = $util.newBuffer($util.base64.length(object.thumbnailSha256)), 0);
                    else if (object.thumbnailSha256.length)
                        message.thumbnailSha256 = object.thumbnailSha256;
                if (object.thumbnailEncSha256 != null)
                    if (typeof object.thumbnailEncSha256 === "string")
                        $util.base64.decode(object.thumbnailEncSha256, message.thumbnailEncSha256 = $util.newBuffer($util.base64.length(object.thumbnailEncSha256)), 0);
                    else if (object.thumbnailEncSha256.length)
                        message.thumbnailEncSha256 = object.thumbnailEncSha256;
                if (object.jpegThumbnail != null)
                    if (typeof object.jpegThumbnail === "string")
                        $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                    else if (object.jpegThumbnail.length)
                        message.jpegThumbnail = object.jpegThumbnail;
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.DocumentMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.thumbnailHeight != null)
                    message.thumbnailHeight = object.thumbnailHeight >>> 0;
                if (object.thumbnailWidth != null)
                    message.thumbnailWidth = object.thumbnailWidth >>> 0;
                if (object.caption != null)
                    message.caption = String(object.caption);
                return message;
            };

            /**
             * Creates a plain object from a DocumentMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.DocumentMessage
             * @static
             * @param {proto.Message.DocumentMessage} message DocumentMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DocumentMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.url = "";
                    object.mimetype = "";
                    object.title = "";
                    if (options.bytes === String)
                        object.fileSha256 = "";
                    else {
                        object.fileSha256 = [];
                        if (options.bytes !== Array)
                            object.fileSha256 = $util.newBuffer(object.fileSha256);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileLength = options.longs === String ? "0" : 0;
                    object.pageCount = 0;
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    object.fileName = "";
                    if (options.bytes === String)
                        object.fileEncSha256 = "";
                    else {
                        object.fileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                    }
                    object.directPath = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                    object.contactVcard = false;
                    object.thumbnailDirectPath = "";
                    if (options.bytes === String)
                        object.thumbnailSha256 = "";
                    else {
                        object.thumbnailSha256 = [];
                        if (options.bytes !== Array)
                            object.thumbnailSha256 = $util.newBuffer(object.thumbnailSha256);
                    }
                    if (options.bytes === String)
                        object.thumbnailEncSha256 = "";
                    else {
                        object.thumbnailEncSha256 = [];
                        if (options.bytes !== Array)
                            object.thumbnailEncSha256 = $util.newBuffer(object.thumbnailEncSha256);
                    }
                    if (options.bytes === String)
                        object.jpegThumbnail = "";
                    else {
                        object.jpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                    }
                    object.contextInfo = null;
                    object.thumbnailHeight = 0;
                    object.thumbnailWidth = 0;
                    object.caption = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    object.mimetype = message.mimetype;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (typeof message.fileLength === "number")
                        object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                    else
                        object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
                if (message.pageCount != null && message.hasOwnProperty("pageCount"))
                    object.pageCount = message.pageCount;
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    object.directPath = message.directPath;
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (typeof message.mediaKeyTimestamp === "number")
                        object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                    else
                        object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
                if (message.contactVcard != null && message.hasOwnProperty("contactVcard"))
                    object.contactVcard = message.contactVcard;
                if (message.thumbnailDirectPath != null && message.hasOwnProperty("thumbnailDirectPath"))
                    object.thumbnailDirectPath = message.thumbnailDirectPath;
                if (message.thumbnailSha256 != null && message.hasOwnProperty("thumbnailSha256"))
                    object.thumbnailSha256 = options.bytes === String ? $util.base64.encode(message.thumbnailSha256, 0, message.thumbnailSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnailSha256) : message.thumbnailSha256;
                if (message.thumbnailEncSha256 != null && message.hasOwnProperty("thumbnailEncSha256"))
                    object.thumbnailEncSha256 = options.bytes === String ? $util.base64.encode(message.thumbnailEncSha256, 0, message.thumbnailEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnailEncSha256) : message.thumbnailEncSha256;
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                    object.thumbnailHeight = message.thumbnailHeight;
                if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                    object.thumbnailWidth = message.thumbnailWidth;
                if (message.caption != null && message.hasOwnProperty("caption"))
                    object.caption = message.caption;
                return object;
            };

            /**
             * Converts this DocumentMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.DocumentMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DocumentMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DocumentMessage;
        })();

        Message.EncReactionMessage = (function() {

            /**
             * Properties of an EncReactionMessage.
             * @memberof proto.Message
             * @interface IEncReactionMessage
             * @property {proto.IMessageKey|null} [targetMessageKey] EncReactionMessage targetMessageKey
             * @property {Uint8Array|null} [encPayload] EncReactionMessage encPayload
             * @property {Uint8Array|null} [encIv] EncReactionMessage encIv
             */

            /**
             * Constructs a new EncReactionMessage.
             * @memberof proto.Message
             * @classdesc Represents an EncReactionMessage.
             * @implements IEncReactionMessage
             * @constructor
             * @param {proto.Message.IEncReactionMessage=} [properties] Properties to set
             */
            function EncReactionMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EncReactionMessage targetMessageKey.
             * @member {proto.IMessageKey|null|undefined} targetMessageKey
             * @memberof proto.Message.EncReactionMessage
             * @instance
             */
            EncReactionMessage.prototype.targetMessageKey = null;

            /**
             * EncReactionMessage encPayload.
             * @member {Uint8Array} encPayload
             * @memberof proto.Message.EncReactionMessage
             * @instance
             */
            EncReactionMessage.prototype.encPayload = $util.newBuffer([]);

            /**
             * EncReactionMessage encIv.
             * @member {Uint8Array} encIv
             * @memberof proto.Message.EncReactionMessage
             * @instance
             */
            EncReactionMessage.prototype.encIv = $util.newBuffer([]);

            /**
             * Creates a new EncReactionMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.EncReactionMessage
             * @static
             * @param {proto.Message.IEncReactionMessage=} [properties] Properties to set
             * @returns {proto.Message.EncReactionMessage} EncReactionMessage instance
             */
            EncReactionMessage.create = function create(properties) {
                return new EncReactionMessage(properties);
            };

            /**
             * Encodes the specified EncReactionMessage message. Does not implicitly {@link proto.Message.EncReactionMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.EncReactionMessage
             * @static
             * @param {proto.Message.IEncReactionMessage} message EncReactionMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncReactionMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetMessageKey != null && Object.hasOwnProperty.call(message, "targetMessageKey"))
                    $root.proto.MessageKey.encode(message.targetMessageKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encPayload);
                if (message.encIv != null && Object.hasOwnProperty.call(message, "encIv"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encIv);
                return writer;
            };

            /**
             * Encodes the specified EncReactionMessage message, length delimited. Does not implicitly {@link proto.Message.EncReactionMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.EncReactionMessage
             * @static
             * @param {proto.Message.IEncReactionMessage} message EncReactionMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncReactionMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EncReactionMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.EncReactionMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.EncReactionMessage} EncReactionMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncReactionMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.EncReactionMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.targetMessageKey = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.encPayload = reader.bytes();
                        break;
                    case 3:
                        message.encIv = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EncReactionMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.EncReactionMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.EncReactionMessage} EncReactionMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncReactionMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EncReactionMessage message.
             * @function verify
             * @memberof proto.Message.EncReactionMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EncReactionMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetMessageKey != null && message.hasOwnProperty("targetMessageKey")) {
                    var error = $root.proto.MessageKey.verify(message.targetMessageKey);
                    if (error)
                        return "targetMessageKey." + error;
                }
                if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                    if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                        return "encPayload: buffer expected";
                if (message.encIv != null && message.hasOwnProperty("encIv"))
                    if (!(message.encIv && typeof message.encIv.length === "number" || $util.isString(message.encIv)))
                        return "encIv: buffer expected";
                return null;
            };

            /**
             * Creates an EncReactionMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.EncReactionMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.EncReactionMessage} EncReactionMessage
             */
            EncReactionMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.EncReactionMessage)
                    return object;
                var message = new $root.proto.Message.EncReactionMessage();
                if (object.targetMessageKey != null) {
                    if (typeof object.targetMessageKey !== "object")
                        throw TypeError(".proto.Message.EncReactionMessage.targetMessageKey: object expected");
                    message.targetMessageKey = $root.proto.MessageKey.fromObject(object.targetMessageKey);
                }
                if (object.encPayload != null)
                    if (typeof object.encPayload === "string")
                        $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                    else if (object.encPayload.length)
                        message.encPayload = object.encPayload;
                if (object.encIv != null)
                    if (typeof object.encIv === "string")
                        $util.base64.decode(object.encIv, message.encIv = $util.newBuffer($util.base64.length(object.encIv)), 0);
                    else if (object.encIv.length)
                        message.encIv = object.encIv;
                return message;
            };

            /**
             * Creates a plain object from an EncReactionMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.EncReactionMessage
             * @static
             * @param {proto.Message.EncReactionMessage} message EncReactionMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EncReactionMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.targetMessageKey = null;
                    if (options.bytes === String)
                        object.encPayload = "";
                    else {
                        object.encPayload = [];
                        if (options.bytes !== Array)
                            object.encPayload = $util.newBuffer(object.encPayload);
                    }
                    if (options.bytes === String)
                        object.encIv = "";
                    else {
                        object.encIv = [];
                        if (options.bytes !== Array)
                            object.encIv = $util.newBuffer(object.encIv);
                    }
                }
                if (message.targetMessageKey != null && message.hasOwnProperty("targetMessageKey"))
                    object.targetMessageKey = $root.proto.MessageKey.toObject(message.targetMessageKey, options);
                if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                    object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
                if (message.encIv != null && message.hasOwnProperty("encIv"))
                    object.encIv = options.bytes === String ? $util.base64.encode(message.encIv, 0, message.encIv.length) : options.bytes === Array ? Array.prototype.slice.call(message.encIv) : message.encIv;
                return object;
            };

            /**
             * Converts this EncReactionMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.EncReactionMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EncReactionMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EncReactionMessage;
        })();

        Message.ExtendedTextMessage = (function() {

            /**
             * Properties of an ExtendedTextMessage.
             * @memberof proto.Message
             * @interface IExtendedTextMessage
             * @property {string|null} [text] ExtendedTextMessage text
             * @property {string|null} [matchedText] ExtendedTextMessage matchedText
             * @property {string|null} [canonicalUrl] ExtendedTextMessage canonicalUrl
             * @property {string|null} [description] ExtendedTextMessage description
             * @property {string|null} [title] ExtendedTextMessage title
             * @property {number|null} [textArgb] ExtendedTextMessage textArgb
             * @property {number|null} [backgroundArgb] ExtendedTextMessage backgroundArgb
             * @property {proto.Message.ExtendedTextMessage.FontType|null} [font] ExtendedTextMessage font
             * @property {proto.Message.ExtendedTextMessage.PreviewType|null} [previewType] ExtendedTextMessage previewType
             * @property {Uint8Array|null} [jpegThumbnail] ExtendedTextMessage jpegThumbnail
             * @property {proto.IContextInfo|null} [contextInfo] ExtendedTextMessage contextInfo
             * @property {boolean|null} [doNotPlayInline] ExtendedTextMessage doNotPlayInline
             * @property {string|null} [thumbnailDirectPath] ExtendedTextMessage thumbnailDirectPath
             * @property {Uint8Array|null} [thumbnailSha256] ExtendedTextMessage thumbnailSha256
             * @property {Uint8Array|null} [thumbnailEncSha256] ExtendedTextMessage thumbnailEncSha256
             * @property {Uint8Array|null} [mediaKey] ExtendedTextMessage mediaKey
             * @property {number|Long|null} [mediaKeyTimestamp] ExtendedTextMessage mediaKeyTimestamp
             * @property {number|null} [thumbnailHeight] ExtendedTextMessage thumbnailHeight
             * @property {number|null} [thumbnailWidth] ExtendedTextMessage thumbnailWidth
             * @property {proto.Message.ExtendedTextMessage.InviteLinkGroupType|null} [inviteLinkGroupType] ExtendedTextMessage inviteLinkGroupType
             * @property {string|null} [inviteLinkParentGroupSubjectV2] ExtendedTextMessage inviteLinkParentGroupSubjectV2
             * @property {Uint8Array|null} [inviteLinkParentGroupThumbnailV2] ExtendedTextMessage inviteLinkParentGroupThumbnailV2
             * @property {proto.Message.ExtendedTextMessage.InviteLinkGroupType|null} [inviteLinkGroupTypeV2] ExtendedTextMessage inviteLinkGroupTypeV2
             * @property {boolean|null} [viewOnce] ExtendedTextMessage viewOnce
             */

            /**
             * Constructs a new ExtendedTextMessage.
             * @memberof proto.Message
             * @classdesc Represents an ExtendedTextMessage.
             * @implements IExtendedTextMessage
             * @constructor
             * @param {proto.Message.IExtendedTextMessage=} [properties] Properties to set
             */
            function ExtendedTextMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtendedTextMessage text.
             * @member {string} text
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.text = "";

            /**
             * ExtendedTextMessage matchedText.
             * @member {string} matchedText
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.matchedText = "";

            /**
             * ExtendedTextMessage canonicalUrl.
             * @member {string} canonicalUrl
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.canonicalUrl = "";

            /**
             * ExtendedTextMessage description.
             * @member {string} description
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.description = "";

            /**
             * ExtendedTextMessage title.
             * @member {string} title
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.title = "";

            /**
             * ExtendedTextMessage textArgb.
             * @member {number} textArgb
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.textArgb = 0;

            /**
             * ExtendedTextMessage backgroundArgb.
             * @member {number} backgroundArgb
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.backgroundArgb = 0;

            /**
             * ExtendedTextMessage font.
             * @member {proto.Message.ExtendedTextMessage.FontType} font
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.font = 0;

            /**
             * ExtendedTextMessage previewType.
             * @member {proto.Message.ExtendedTextMessage.PreviewType} previewType
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.previewType = 0;

            /**
             * ExtendedTextMessage jpegThumbnail.
             * @member {Uint8Array} jpegThumbnail
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.jpegThumbnail = $util.newBuffer([]);

            /**
             * ExtendedTextMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.contextInfo = null;

            /**
             * ExtendedTextMessage doNotPlayInline.
             * @member {boolean} doNotPlayInline
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.doNotPlayInline = false;

            /**
             * ExtendedTextMessage thumbnailDirectPath.
             * @member {string} thumbnailDirectPath
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.thumbnailDirectPath = "";

            /**
             * ExtendedTextMessage thumbnailSha256.
             * @member {Uint8Array} thumbnailSha256
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.thumbnailSha256 = $util.newBuffer([]);

            /**
             * ExtendedTextMessage thumbnailEncSha256.
             * @member {Uint8Array} thumbnailEncSha256
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.thumbnailEncSha256 = $util.newBuffer([]);

            /**
             * ExtendedTextMessage mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.mediaKey = $util.newBuffer([]);

            /**
             * ExtendedTextMessage mediaKeyTimestamp.
             * @member {number|Long} mediaKeyTimestamp
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ExtendedTextMessage thumbnailHeight.
             * @member {number} thumbnailHeight
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.thumbnailHeight = 0;

            /**
             * ExtendedTextMessage thumbnailWidth.
             * @member {number} thumbnailWidth
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.thumbnailWidth = 0;

            /**
             * ExtendedTextMessage inviteLinkGroupType.
             * @member {proto.Message.ExtendedTextMessage.InviteLinkGroupType} inviteLinkGroupType
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.inviteLinkGroupType = 0;

            /**
             * ExtendedTextMessage inviteLinkParentGroupSubjectV2.
             * @member {string} inviteLinkParentGroupSubjectV2
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.inviteLinkParentGroupSubjectV2 = "";

            /**
             * ExtendedTextMessage inviteLinkParentGroupThumbnailV2.
             * @member {Uint8Array} inviteLinkParentGroupThumbnailV2
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.inviteLinkParentGroupThumbnailV2 = $util.newBuffer([]);

            /**
             * ExtendedTextMessage inviteLinkGroupTypeV2.
             * @member {proto.Message.ExtendedTextMessage.InviteLinkGroupType} inviteLinkGroupTypeV2
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.inviteLinkGroupTypeV2 = 0;

            /**
             * ExtendedTextMessage viewOnce.
             * @member {boolean} viewOnce
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             */
            ExtendedTextMessage.prototype.viewOnce = false;

            /**
             * Creates a new ExtendedTextMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ExtendedTextMessage
             * @static
             * @param {proto.Message.IExtendedTextMessage=} [properties] Properties to set
             * @returns {proto.Message.ExtendedTextMessage} ExtendedTextMessage instance
             */
            ExtendedTextMessage.create = function create(properties) {
                return new ExtendedTextMessage(properties);
            };

            /**
             * Encodes the specified ExtendedTextMessage message. Does not implicitly {@link proto.Message.ExtendedTextMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ExtendedTextMessage
             * @static
             * @param {proto.Message.IExtendedTextMessage} message ExtendedTextMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtendedTextMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                if (message.matchedText != null && Object.hasOwnProperty.call(message, "matchedText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.matchedText);
                if (message.canonicalUrl != null && Object.hasOwnProperty.call(message, "canonicalUrl"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.canonicalUrl);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.title);
                if (message.textArgb != null && Object.hasOwnProperty.call(message, "textArgb"))
                    writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.textArgb);
                if (message.backgroundArgb != null && Object.hasOwnProperty.call(message, "backgroundArgb"))
                    writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.backgroundArgb);
                if (message.font != null && Object.hasOwnProperty.call(message, "font"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.font);
                if (message.previewType != null && Object.hasOwnProperty.call(message, "previewType"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.previewType);
                if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.doNotPlayInline != null && Object.hasOwnProperty.call(message, "doNotPlayInline"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.doNotPlayInline);
                if (message.thumbnailDirectPath != null && Object.hasOwnProperty.call(message, "thumbnailDirectPath"))
                    writer.uint32(/* id 19, wireType 2 =*/154).string(message.thumbnailDirectPath);
                if (message.thumbnailSha256 != null && Object.hasOwnProperty.call(message, "thumbnailSha256"))
                    writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.thumbnailSha256);
                if (message.thumbnailEncSha256 != null && Object.hasOwnProperty.call(message, "thumbnailEncSha256"))
                    writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.thumbnailEncSha256);
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 22, wireType 2 =*/178).bytes(message.mediaKey);
                if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                    writer.uint32(/* id 23, wireType 0 =*/184).int64(message.mediaKeyTimestamp);
                if (message.thumbnailHeight != null && Object.hasOwnProperty.call(message, "thumbnailHeight"))
                    writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.thumbnailHeight);
                if (message.thumbnailWidth != null && Object.hasOwnProperty.call(message, "thumbnailWidth"))
                    writer.uint32(/* id 25, wireType 0 =*/200).uint32(message.thumbnailWidth);
                if (message.inviteLinkGroupType != null && Object.hasOwnProperty.call(message, "inviteLinkGroupType"))
                    writer.uint32(/* id 26, wireType 0 =*/208).int32(message.inviteLinkGroupType);
                if (message.inviteLinkParentGroupSubjectV2 != null && Object.hasOwnProperty.call(message, "inviteLinkParentGroupSubjectV2"))
                    writer.uint32(/* id 27, wireType 2 =*/218).string(message.inviteLinkParentGroupSubjectV2);
                if (message.inviteLinkParentGroupThumbnailV2 != null && Object.hasOwnProperty.call(message, "inviteLinkParentGroupThumbnailV2"))
                    writer.uint32(/* id 28, wireType 2 =*/226).bytes(message.inviteLinkParentGroupThumbnailV2);
                if (message.inviteLinkGroupTypeV2 != null && Object.hasOwnProperty.call(message, "inviteLinkGroupTypeV2"))
                    writer.uint32(/* id 29, wireType 0 =*/232).int32(message.inviteLinkGroupTypeV2);
                if (message.viewOnce != null && Object.hasOwnProperty.call(message, "viewOnce"))
                    writer.uint32(/* id 30, wireType 0 =*/240).bool(message.viewOnce);
                return writer;
            };

            /**
             * Encodes the specified ExtendedTextMessage message, length delimited. Does not implicitly {@link proto.Message.ExtendedTextMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ExtendedTextMessage
             * @static
             * @param {proto.Message.IExtendedTextMessage} message ExtendedTextMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtendedTextMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtendedTextMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ExtendedTextMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ExtendedTextMessage} ExtendedTextMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtendedTextMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ExtendedTextMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.text = reader.string();
                        break;
                    case 2:
                        message.matchedText = reader.string();
                        break;
                    case 4:
                        message.canonicalUrl = reader.string();
                        break;
                    case 5:
                        message.description = reader.string();
                        break;
                    case 6:
                        message.title = reader.string();
                        break;
                    case 7:
                        message.textArgb = reader.fixed32();
                        break;
                    case 8:
                        message.backgroundArgb = reader.fixed32();
                        break;
                    case 9:
                        message.font = reader.int32();
                        break;
                    case 10:
                        message.previewType = reader.int32();
                        break;
                    case 16:
                        message.jpegThumbnail = reader.bytes();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.doNotPlayInline = reader.bool();
                        break;
                    case 19:
                        message.thumbnailDirectPath = reader.string();
                        break;
                    case 20:
                        message.thumbnailSha256 = reader.bytes();
                        break;
                    case 21:
                        message.thumbnailEncSha256 = reader.bytes();
                        break;
                    case 22:
                        message.mediaKey = reader.bytes();
                        break;
                    case 23:
                        message.mediaKeyTimestamp = reader.int64();
                        break;
                    case 24:
                        message.thumbnailHeight = reader.uint32();
                        break;
                    case 25:
                        message.thumbnailWidth = reader.uint32();
                        break;
                    case 26:
                        message.inviteLinkGroupType = reader.int32();
                        break;
                    case 27:
                        message.inviteLinkParentGroupSubjectV2 = reader.string();
                        break;
                    case 28:
                        message.inviteLinkParentGroupThumbnailV2 = reader.bytes();
                        break;
                    case 29:
                        message.inviteLinkGroupTypeV2 = reader.int32();
                        break;
                    case 30:
                        message.viewOnce = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtendedTextMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ExtendedTextMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ExtendedTextMessage} ExtendedTextMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtendedTextMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtendedTextMessage message.
             * @function verify
             * @memberof proto.Message.ExtendedTextMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtendedTextMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                if (message.matchedText != null && message.hasOwnProperty("matchedText"))
                    if (!$util.isString(message.matchedText))
                        return "matchedText: string expected";
                if (message.canonicalUrl != null && message.hasOwnProperty("canonicalUrl"))
                    if (!$util.isString(message.canonicalUrl))
                        return "canonicalUrl: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.textArgb != null && message.hasOwnProperty("textArgb"))
                    if (!$util.isInteger(message.textArgb))
                        return "textArgb: integer expected";
                if (message.backgroundArgb != null && message.hasOwnProperty("backgroundArgb"))
                    if (!$util.isInteger(message.backgroundArgb))
                        return "backgroundArgb: integer expected";
                if (message.font != null && message.hasOwnProperty("font"))
                    switch (message.font) {
                    default:
                        return "font: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.previewType != null && message.hasOwnProperty("previewType"))
                    switch (message.previewType) {
                    default:
                        return "previewType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                        return "jpegThumbnail: buffer expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.doNotPlayInline != null && message.hasOwnProperty("doNotPlayInline"))
                    if (typeof message.doNotPlayInline !== "boolean")
                        return "doNotPlayInline: boolean expected";
                if (message.thumbnailDirectPath != null && message.hasOwnProperty("thumbnailDirectPath"))
                    if (!$util.isString(message.thumbnailDirectPath))
                        return "thumbnailDirectPath: string expected";
                if (message.thumbnailSha256 != null && message.hasOwnProperty("thumbnailSha256"))
                    if (!(message.thumbnailSha256 && typeof message.thumbnailSha256.length === "number" || $util.isString(message.thumbnailSha256)))
                        return "thumbnailSha256: buffer expected";
                if (message.thumbnailEncSha256 != null && message.hasOwnProperty("thumbnailEncSha256"))
                    if (!(message.thumbnailEncSha256 && typeof message.thumbnailEncSha256.length === "number" || $util.isString(message.thumbnailEncSha256)))
                        return "thumbnailEncSha256: buffer expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                        return "mediaKeyTimestamp: integer|Long expected";
                if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                    if (!$util.isInteger(message.thumbnailHeight))
                        return "thumbnailHeight: integer expected";
                if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                    if (!$util.isInteger(message.thumbnailWidth))
                        return "thumbnailWidth: integer expected";
                if (message.inviteLinkGroupType != null && message.hasOwnProperty("inviteLinkGroupType"))
                    switch (message.inviteLinkGroupType) {
                    default:
                        return "inviteLinkGroupType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.inviteLinkParentGroupSubjectV2 != null && message.hasOwnProperty("inviteLinkParentGroupSubjectV2"))
                    if (!$util.isString(message.inviteLinkParentGroupSubjectV2))
                        return "inviteLinkParentGroupSubjectV2: string expected";
                if (message.inviteLinkParentGroupThumbnailV2 != null && message.hasOwnProperty("inviteLinkParentGroupThumbnailV2"))
                    if (!(message.inviteLinkParentGroupThumbnailV2 && typeof message.inviteLinkParentGroupThumbnailV2.length === "number" || $util.isString(message.inviteLinkParentGroupThumbnailV2)))
                        return "inviteLinkParentGroupThumbnailV2: buffer expected";
                if (message.inviteLinkGroupTypeV2 != null && message.hasOwnProperty("inviteLinkGroupTypeV2"))
                    switch (message.inviteLinkGroupTypeV2) {
                    default:
                        return "inviteLinkGroupTypeV2: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.viewOnce != null && message.hasOwnProperty("viewOnce"))
                    if (typeof message.viewOnce !== "boolean")
                        return "viewOnce: boolean expected";
                return null;
            };

            /**
             * Creates an ExtendedTextMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ExtendedTextMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ExtendedTextMessage} ExtendedTextMessage
             */
            ExtendedTextMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ExtendedTextMessage)
                    return object;
                var message = new $root.proto.Message.ExtendedTextMessage();
                if (object.text != null)
                    message.text = String(object.text);
                if (object.matchedText != null)
                    message.matchedText = String(object.matchedText);
                if (object.canonicalUrl != null)
                    message.canonicalUrl = String(object.canonicalUrl);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.textArgb != null)
                    message.textArgb = object.textArgb >>> 0;
                if (object.backgroundArgb != null)
                    message.backgroundArgb = object.backgroundArgb >>> 0;
                switch (object.font) {
                case "SANS_SERIF":
                case 0:
                    message.font = 0;
                    break;
                case "SERIF":
                case 1:
                    message.font = 1;
                    break;
                case "NORICAN_REGULAR":
                case 2:
                    message.font = 2;
                    break;
                case "BRYNDAN_WRITE":
                case 3:
                    message.font = 3;
                    break;
                case "BEBASNEUE_REGULAR":
                case 4:
                    message.font = 4;
                    break;
                case "OSWALD_HEAVY":
                case 5:
                    message.font = 5;
                    break;
                }
                switch (object.previewType) {
                case "NONE":
                case 0:
                    message.previewType = 0;
                    break;
                case "VIDEO":
                case 1:
                    message.previewType = 1;
                    break;
                }
                if (object.jpegThumbnail != null)
                    if (typeof object.jpegThumbnail === "string")
                        $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                    else if (object.jpegThumbnail.length)
                        message.jpegThumbnail = object.jpegThumbnail;
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ExtendedTextMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.doNotPlayInline != null)
                    message.doNotPlayInline = Boolean(object.doNotPlayInline);
                if (object.thumbnailDirectPath != null)
                    message.thumbnailDirectPath = String(object.thumbnailDirectPath);
                if (object.thumbnailSha256 != null)
                    if (typeof object.thumbnailSha256 === "string")
                        $util.base64.decode(object.thumbnailSha256, message.thumbnailSha256 = $util.newBuffer($util.base64.length(object.thumbnailSha256)), 0);
                    else if (object.thumbnailSha256.length)
                        message.thumbnailSha256 = object.thumbnailSha256;
                if (object.thumbnailEncSha256 != null)
                    if (typeof object.thumbnailEncSha256 === "string")
                        $util.base64.decode(object.thumbnailEncSha256, message.thumbnailEncSha256 = $util.newBuffer($util.base64.length(object.thumbnailEncSha256)), 0);
                    else if (object.thumbnailEncSha256.length)
                        message.thumbnailEncSha256 = object.thumbnailEncSha256;
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.mediaKeyTimestamp != null)
                    if ($util.Long)
                        (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                    else if (typeof object.mediaKeyTimestamp === "string")
                        message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                    else if (typeof object.mediaKeyTimestamp === "number")
                        message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                    else if (typeof object.mediaKeyTimestamp === "object")
                        message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
                if (object.thumbnailHeight != null)
                    message.thumbnailHeight = object.thumbnailHeight >>> 0;
                if (object.thumbnailWidth != null)
                    message.thumbnailWidth = object.thumbnailWidth >>> 0;
                switch (object.inviteLinkGroupType) {
                case "DEFAULT":
                case 0:
                    message.inviteLinkGroupType = 0;
                    break;
                case "PARENT":
                case 1:
                    message.inviteLinkGroupType = 1;
                    break;
                case "SUB":
                case 2:
                    message.inviteLinkGroupType = 2;
                    break;
                case "DEFAULT_SUB":
                case 3:
                    message.inviteLinkGroupType = 3;
                    break;
                }
                if (object.inviteLinkParentGroupSubjectV2 != null)
                    message.inviteLinkParentGroupSubjectV2 = String(object.inviteLinkParentGroupSubjectV2);
                if (object.inviteLinkParentGroupThumbnailV2 != null)
                    if (typeof object.inviteLinkParentGroupThumbnailV2 === "string")
                        $util.base64.decode(object.inviteLinkParentGroupThumbnailV2, message.inviteLinkParentGroupThumbnailV2 = $util.newBuffer($util.base64.length(object.inviteLinkParentGroupThumbnailV2)), 0);
                    else if (object.inviteLinkParentGroupThumbnailV2.length)
                        message.inviteLinkParentGroupThumbnailV2 = object.inviteLinkParentGroupThumbnailV2;
                switch (object.inviteLinkGroupTypeV2) {
                case "DEFAULT":
                case 0:
                    message.inviteLinkGroupTypeV2 = 0;
                    break;
                case "PARENT":
                case 1:
                    message.inviteLinkGroupTypeV2 = 1;
                    break;
                case "SUB":
                case 2:
                    message.inviteLinkGroupTypeV2 = 2;
                    break;
                case "DEFAULT_SUB":
                case 3:
                    message.inviteLinkGroupTypeV2 = 3;
                    break;
                }
                if (object.viewOnce != null)
                    message.viewOnce = Boolean(object.viewOnce);
                return message;
            };

            /**
             * Creates a plain object from an ExtendedTextMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ExtendedTextMessage
             * @static
             * @param {proto.Message.ExtendedTextMessage} message ExtendedTextMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtendedTextMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.text = "";
                    object.matchedText = "";
                    object.canonicalUrl = "";
                    object.description = "";
                    object.title = "";
                    object.textArgb = 0;
                    object.backgroundArgb = 0;
                    object.font = options.enums === String ? "SANS_SERIF" : 0;
                    object.previewType = options.enums === String ? "NONE" : 0;
                    if (options.bytes === String)
                        object.jpegThumbnail = "";
                    else {
                        object.jpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                    }
                    object.contextInfo = null;
                    object.doNotPlayInline = false;
                    object.thumbnailDirectPath = "";
                    if (options.bytes === String)
                        object.thumbnailSha256 = "";
                    else {
                        object.thumbnailSha256 = [];
                        if (options.bytes !== Array)
                            object.thumbnailSha256 = $util.newBuffer(object.thumbnailSha256);
                    }
                    if (options.bytes === String)
                        object.thumbnailEncSha256 = "";
                    else {
                        object.thumbnailEncSha256 = [];
                        if (options.bytes !== Array)
                            object.thumbnailEncSha256 = $util.newBuffer(object.thumbnailEncSha256);
                    }
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                    object.thumbnailHeight = 0;
                    object.thumbnailWidth = 0;
                    object.inviteLinkGroupType = options.enums === String ? "DEFAULT" : 0;
                    object.inviteLinkParentGroupSubjectV2 = "";
                    if (options.bytes === String)
                        object.inviteLinkParentGroupThumbnailV2 = "";
                    else {
                        object.inviteLinkParentGroupThumbnailV2 = [];
                        if (options.bytes !== Array)
                            object.inviteLinkParentGroupThumbnailV2 = $util.newBuffer(object.inviteLinkParentGroupThumbnailV2);
                    }
                    object.inviteLinkGroupTypeV2 = options.enums === String ? "DEFAULT" : 0;
                    object.viewOnce = false;
                }
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                if (message.matchedText != null && message.hasOwnProperty("matchedText"))
                    object.matchedText = message.matchedText;
                if (message.canonicalUrl != null && message.hasOwnProperty("canonicalUrl"))
                    object.canonicalUrl = message.canonicalUrl;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.textArgb != null && message.hasOwnProperty("textArgb"))
                    object.textArgb = message.textArgb;
                if (message.backgroundArgb != null && message.hasOwnProperty("backgroundArgb"))
                    object.backgroundArgb = message.backgroundArgb;
                if (message.font != null && message.hasOwnProperty("font"))
                    object.font = options.enums === String ? $root.proto.Message.ExtendedTextMessage.FontType[message.font] : message.font;
                if (message.previewType != null && message.hasOwnProperty("previewType"))
                    object.previewType = options.enums === String ? $root.proto.Message.ExtendedTextMessage.PreviewType[message.previewType] : message.previewType;
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.doNotPlayInline != null && message.hasOwnProperty("doNotPlayInline"))
                    object.doNotPlayInline = message.doNotPlayInline;
                if (message.thumbnailDirectPath != null && message.hasOwnProperty("thumbnailDirectPath"))
                    object.thumbnailDirectPath = message.thumbnailDirectPath;
                if (message.thumbnailSha256 != null && message.hasOwnProperty("thumbnailSha256"))
                    object.thumbnailSha256 = options.bytes === String ? $util.base64.encode(message.thumbnailSha256, 0, message.thumbnailSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnailSha256) : message.thumbnailSha256;
                if (message.thumbnailEncSha256 != null && message.hasOwnProperty("thumbnailEncSha256"))
                    object.thumbnailEncSha256 = options.bytes === String ? $util.base64.encode(message.thumbnailEncSha256, 0, message.thumbnailEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnailEncSha256) : message.thumbnailEncSha256;
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (typeof message.mediaKeyTimestamp === "number")
                        object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                    else
                        object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
                if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                    object.thumbnailHeight = message.thumbnailHeight;
                if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                    object.thumbnailWidth = message.thumbnailWidth;
                if (message.inviteLinkGroupType != null && message.hasOwnProperty("inviteLinkGroupType"))
                    object.inviteLinkGroupType = options.enums === String ? $root.proto.Message.ExtendedTextMessage.InviteLinkGroupType[message.inviteLinkGroupType] : message.inviteLinkGroupType;
                if (message.inviteLinkParentGroupSubjectV2 != null && message.hasOwnProperty("inviteLinkParentGroupSubjectV2"))
                    object.inviteLinkParentGroupSubjectV2 = message.inviteLinkParentGroupSubjectV2;
                if (message.inviteLinkParentGroupThumbnailV2 != null && message.hasOwnProperty("inviteLinkParentGroupThumbnailV2"))
                    object.inviteLinkParentGroupThumbnailV2 = options.bytes === String ? $util.base64.encode(message.inviteLinkParentGroupThumbnailV2, 0, message.inviteLinkParentGroupThumbnailV2.length) : options.bytes === Array ? Array.prototype.slice.call(message.inviteLinkParentGroupThumbnailV2) : message.inviteLinkParentGroupThumbnailV2;
                if (message.inviteLinkGroupTypeV2 != null && message.hasOwnProperty("inviteLinkGroupTypeV2"))
                    object.inviteLinkGroupTypeV2 = options.enums === String ? $root.proto.Message.ExtendedTextMessage.InviteLinkGroupType[message.inviteLinkGroupTypeV2] : message.inviteLinkGroupTypeV2;
                if (message.viewOnce != null && message.hasOwnProperty("viewOnce"))
                    object.viewOnce = message.viewOnce;
                return object;
            };

            /**
             * Converts this ExtendedTextMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ExtendedTextMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtendedTextMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * FontType enum.
             * @name proto.Message.ExtendedTextMessage.FontType
             * @enum {number}
             * @property {number} SANS_SERIF=0 SANS_SERIF value
             * @property {number} SERIF=1 SERIF value
             * @property {number} NORICAN_REGULAR=2 NORICAN_REGULAR value
             * @property {number} BRYNDAN_WRITE=3 BRYNDAN_WRITE value
             * @property {number} BEBASNEUE_REGULAR=4 BEBASNEUE_REGULAR value
             * @property {number} OSWALD_HEAVY=5 OSWALD_HEAVY value
             */
            ExtendedTextMessage.FontType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SANS_SERIF"] = 0;
                values[valuesById[1] = "SERIF"] = 1;
                values[valuesById[2] = "NORICAN_REGULAR"] = 2;
                values[valuesById[3] = "BRYNDAN_WRITE"] = 3;
                values[valuesById[4] = "BEBASNEUE_REGULAR"] = 4;
                values[valuesById[5] = "OSWALD_HEAVY"] = 5;
                return values;
            })();

            /**
             * InviteLinkGroupType enum.
             * @name proto.Message.ExtendedTextMessage.InviteLinkGroupType
             * @enum {number}
             * @property {number} DEFAULT=0 DEFAULT value
             * @property {number} PARENT=1 PARENT value
             * @property {number} SUB=2 SUB value
             * @property {number} DEFAULT_SUB=3 DEFAULT_SUB value
             */
            ExtendedTextMessage.InviteLinkGroupType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "PARENT"] = 1;
                values[valuesById[2] = "SUB"] = 2;
                values[valuesById[3] = "DEFAULT_SUB"] = 3;
                return values;
            })();

            /**
             * PreviewType enum.
             * @name proto.Message.ExtendedTextMessage.PreviewType
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} VIDEO=1 VIDEO value
             */
            ExtendedTextMessage.PreviewType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "VIDEO"] = 1;
                return values;
            })();

            return ExtendedTextMessage;
        })();

        Message.FutureProofMessage = (function() {

            /**
             * Properties of a FutureProofMessage.
             * @memberof proto.Message
             * @interface IFutureProofMessage
             * @property {proto.IMessage|null} [message] FutureProofMessage message
             */

            /**
             * Constructs a new FutureProofMessage.
             * @memberof proto.Message
             * @classdesc Represents a FutureProofMessage.
             * @implements IFutureProofMessage
             * @constructor
             * @param {proto.Message.IFutureProofMessage=} [properties] Properties to set
             */
            function FutureProofMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FutureProofMessage message.
             * @member {proto.IMessage|null|undefined} message
             * @memberof proto.Message.FutureProofMessage
             * @instance
             */
            FutureProofMessage.prototype.message = null;

            /**
             * Creates a new FutureProofMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.FutureProofMessage
             * @static
             * @param {proto.Message.IFutureProofMessage=} [properties] Properties to set
             * @returns {proto.Message.FutureProofMessage} FutureProofMessage instance
             */
            FutureProofMessage.create = function create(properties) {
                return new FutureProofMessage(properties);
            };

            /**
             * Encodes the specified FutureProofMessage message. Does not implicitly {@link proto.Message.FutureProofMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.FutureProofMessage
             * @static
             * @param {proto.Message.IFutureProofMessage} message FutureProofMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FutureProofMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.proto.Message.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FutureProofMessage message, length delimited. Does not implicitly {@link proto.Message.FutureProofMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.FutureProofMessage
             * @static
             * @param {proto.Message.IFutureProofMessage} message FutureProofMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FutureProofMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FutureProofMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.FutureProofMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.FutureProofMessage} FutureProofMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FutureProofMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.FutureProofMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.message = $root.proto.Message.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FutureProofMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.FutureProofMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.FutureProofMessage} FutureProofMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FutureProofMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FutureProofMessage message.
             * @function verify
             * @memberof proto.Message.FutureProofMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FutureProofMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    var error = $root.proto.Message.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                return null;
            };

            /**
             * Creates a FutureProofMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.FutureProofMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.FutureProofMessage} FutureProofMessage
             */
            FutureProofMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.FutureProofMessage)
                    return object;
                var message = new $root.proto.Message.FutureProofMessage();
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".proto.Message.FutureProofMessage.message: object expected");
                    message.message = $root.proto.Message.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a FutureProofMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.FutureProofMessage
             * @static
             * @param {proto.Message.FutureProofMessage} message FutureProofMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FutureProofMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.message = null;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.proto.Message.toObject(message.message, options);
                return object;
            };

            /**
             * Converts this FutureProofMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.FutureProofMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FutureProofMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FutureProofMessage;
        })();

        Message.GroupInviteMessage = (function() {

            /**
             * Properties of a GroupInviteMessage.
             * @memberof proto.Message
             * @interface IGroupInviteMessage
             * @property {string|null} [groupJid] GroupInviteMessage groupJid
             * @property {string|null} [inviteCode] GroupInviteMessage inviteCode
             * @property {number|Long|null} [inviteExpiration] GroupInviteMessage inviteExpiration
             * @property {string|null} [groupName] GroupInviteMessage groupName
             * @property {Uint8Array|null} [jpegThumbnail] GroupInviteMessage jpegThumbnail
             * @property {string|null} [caption] GroupInviteMessage caption
             * @property {proto.IContextInfo|null} [contextInfo] GroupInviteMessage contextInfo
             * @property {proto.Message.GroupInviteMessage.GroupType|null} [groupType] GroupInviteMessage groupType
             */

            /**
             * Constructs a new GroupInviteMessage.
             * @memberof proto.Message
             * @classdesc Represents a GroupInviteMessage.
             * @implements IGroupInviteMessage
             * @constructor
             * @param {proto.Message.IGroupInviteMessage=} [properties] Properties to set
             */
            function GroupInviteMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupInviteMessage groupJid.
             * @member {string} groupJid
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             */
            GroupInviteMessage.prototype.groupJid = "";

            /**
             * GroupInviteMessage inviteCode.
             * @member {string} inviteCode
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             */
            GroupInviteMessage.prototype.inviteCode = "";

            /**
             * GroupInviteMessage inviteExpiration.
             * @member {number|Long} inviteExpiration
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             */
            GroupInviteMessage.prototype.inviteExpiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupInviteMessage groupName.
             * @member {string} groupName
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             */
            GroupInviteMessage.prototype.groupName = "";

            /**
             * GroupInviteMessage jpegThumbnail.
             * @member {Uint8Array} jpegThumbnail
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             */
            GroupInviteMessage.prototype.jpegThumbnail = $util.newBuffer([]);

            /**
             * GroupInviteMessage caption.
             * @member {string} caption
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             */
            GroupInviteMessage.prototype.caption = "";

            /**
             * GroupInviteMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             */
            GroupInviteMessage.prototype.contextInfo = null;

            /**
             * GroupInviteMessage groupType.
             * @member {proto.Message.GroupInviteMessage.GroupType} groupType
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             */
            GroupInviteMessage.prototype.groupType = 0;

            /**
             * Creates a new GroupInviteMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.GroupInviteMessage
             * @static
             * @param {proto.Message.IGroupInviteMessage=} [properties] Properties to set
             * @returns {proto.Message.GroupInviteMessage} GroupInviteMessage instance
             */
            GroupInviteMessage.create = function create(properties) {
                return new GroupInviteMessage(properties);
            };

            /**
             * Encodes the specified GroupInviteMessage message. Does not implicitly {@link proto.Message.GroupInviteMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.GroupInviteMessage
             * @static
             * @param {proto.Message.IGroupInviteMessage} message GroupInviteMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInviteMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupJid != null && Object.hasOwnProperty.call(message, "groupJid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupJid);
                if (message.inviteCode != null && Object.hasOwnProperty.call(message, "inviteCode"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviteCode);
                if (message.inviteExpiration != null && Object.hasOwnProperty.call(message, "inviteExpiration"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.inviteExpiration);
                if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.groupName);
                if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.jpegThumbnail);
                if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.caption);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.groupType != null && Object.hasOwnProperty.call(message, "groupType"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.groupType);
                return writer;
            };

            /**
             * Encodes the specified GroupInviteMessage message, length delimited. Does not implicitly {@link proto.Message.GroupInviteMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.GroupInviteMessage
             * @static
             * @param {proto.Message.IGroupInviteMessage} message GroupInviteMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInviteMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupInviteMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.GroupInviteMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.GroupInviteMessage} GroupInviteMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInviteMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.GroupInviteMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.groupJid = reader.string();
                        break;
                    case 2:
                        message.inviteCode = reader.string();
                        break;
                    case 3:
                        message.inviteExpiration = reader.int64();
                        break;
                    case 4:
                        message.groupName = reader.string();
                        break;
                    case 5:
                        message.jpegThumbnail = reader.bytes();
                        break;
                    case 6:
                        message.caption = reader.string();
                        break;
                    case 7:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.groupType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupInviteMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.GroupInviteMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.GroupInviteMessage} GroupInviteMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInviteMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupInviteMessage message.
             * @function verify
             * @memberof proto.Message.GroupInviteMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupInviteMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupJid != null && message.hasOwnProperty("groupJid"))
                    if (!$util.isString(message.groupJid))
                        return "groupJid: string expected";
                if (message.inviteCode != null && message.hasOwnProperty("inviteCode"))
                    if (!$util.isString(message.inviteCode))
                        return "inviteCode: string expected";
                if (message.inviteExpiration != null && message.hasOwnProperty("inviteExpiration"))
                    if (!$util.isInteger(message.inviteExpiration) && !(message.inviteExpiration && $util.isInteger(message.inviteExpiration.low) && $util.isInteger(message.inviteExpiration.high)))
                        return "inviteExpiration: integer|Long expected";
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    if (!$util.isString(message.groupName))
                        return "groupName: string expected";
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                        return "jpegThumbnail: buffer expected";
                if (message.caption != null && message.hasOwnProperty("caption"))
                    if (!$util.isString(message.caption))
                        return "caption: string expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.groupType != null && message.hasOwnProperty("groupType"))
                    switch (message.groupType) {
                    default:
                        return "groupType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupInviteMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.GroupInviteMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.GroupInviteMessage} GroupInviteMessage
             */
            GroupInviteMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.GroupInviteMessage)
                    return object;
                var message = new $root.proto.Message.GroupInviteMessage();
                if (object.groupJid != null)
                    message.groupJid = String(object.groupJid);
                if (object.inviteCode != null)
                    message.inviteCode = String(object.inviteCode);
                if (object.inviteExpiration != null)
                    if ($util.Long)
                        (message.inviteExpiration = $util.Long.fromValue(object.inviteExpiration)).unsigned = false;
                    else if (typeof object.inviteExpiration === "string")
                        message.inviteExpiration = parseInt(object.inviteExpiration, 10);
                    else if (typeof object.inviteExpiration === "number")
                        message.inviteExpiration = object.inviteExpiration;
                    else if (typeof object.inviteExpiration === "object")
                        message.inviteExpiration = new $util.LongBits(object.inviteExpiration.low >>> 0, object.inviteExpiration.high >>> 0).toNumber();
                if (object.groupName != null)
                    message.groupName = String(object.groupName);
                if (object.jpegThumbnail != null)
                    if (typeof object.jpegThumbnail === "string")
                        $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                    else if (object.jpegThumbnail.length)
                        message.jpegThumbnail = object.jpegThumbnail;
                if (object.caption != null)
                    message.caption = String(object.caption);
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.GroupInviteMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                switch (object.groupType) {
                case "DEFAULT":
                case 0:
                    message.groupType = 0;
                    break;
                case "PARENT":
                case 1:
                    message.groupType = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupInviteMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.GroupInviteMessage
             * @static
             * @param {proto.Message.GroupInviteMessage} message GroupInviteMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupInviteMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.groupJid = "";
                    object.inviteCode = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.inviteExpiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inviteExpiration = options.longs === String ? "0" : 0;
                    object.groupName = "";
                    if (options.bytes === String)
                        object.jpegThumbnail = "";
                    else {
                        object.jpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                    }
                    object.caption = "";
                    object.contextInfo = null;
                    object.groupType = options.enums === String ? "DEFAULT" : 0;
                }
                if (message.groupJid != null && message.hasOwnProperty("groupJid"))
                    object.groupJid = message.groupJid;
                if (message.inviteCode != null && message.hasOwnProperty("inviteCode"))
                    object.inviteCode = message.inviteCode;
                if (message.inviteExpiration != null && message.hasOwnProperty("inviteExpiration"))
                    if (typeof message.inviteExpiration === "number")
                        object.inviteExpiration = options.longs === String ? String(message.inviteExpiration) : message.inviteExpiration;
                    else
                        object.inviteExpiration = options.longs === String ? $util.Long.prototype.toString.call(message.inviteExpiration) : options.longs === Number ? new $util.LongBits(message.inviteExpiration.low >>> 0, message.inviteExpiration.high >>> 0).toNumber() : message.inviteExpiration;
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    object.groupName = message.groupName;
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                if (message.caption != null && message.hasOwnProperty("caption"))
                    object.caption = message.caption;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.groupType != null && message.hasOwnProperty("groupType"))
                    object.groupType = options.enums === String ? $root.proto.Message.GroupInviteMessage.GroupType[message.groupType] : message.groupType;
                return object;
            };

            /**
             * Converts this GroupInviteMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.GroupInviteMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupInviteMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * GroupType enum.
             * @name proto.Message.GroupInviteMessage.GroupType
             * @enum {number}
             * @property {number} DEFAULT=0 DEFAULT value
             * @property {number} PARENT=1 PARENT value
             */
            GroupInviteMessage.GroupType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "PARENT"] = 1;
                return values;
            })();

            return GroupInviteMessage;
        })();

        Message.HighlyStructuredMessage = (function() {

            /**
             * Properties of a HighlyStructuredMessage.
             * @memberof proto.Message
             * @interface IHighlyStructuredMessage
             * @property {string|null} [namespace] HighlyStructuredMessage namespace
             * @property {string|null} [elementName] HighlyStructuredMessage elementName
             * @property {Array.<string>|null} [params] HighlyStructuredMessage params
             * @property {string|null} [fallbackLg] HighlyStructuredMessage fallbackLg
             * @property {string|null} [fallbackLc] HighlyStructuredMessage fallbackLc
             * @property {Array.<proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter>|null} [localizableParams] HighlyStructuredMessage localizableParams
             * @property {string|null} [deterministicLg] HighlyStructuredMessage deterministicLg
             * @property {string|null} [deterministicLc] HighlyStructuredMessage deterministicLc
             * @property {proto.Message.ITemplateMessage|null} [hydratedHsm] HighlyStructuredMessage hydratedHsm
             */

            /**
             * Constructs a new HighlyStructuredMessage.
             * @memberof proto.Message
             * @classdesc Represents a HighlyStructuredMessage.
             * @implements IHighlyStructuredMessage
             * @constructor
             * @param {proto.Message.IHighlyStructuredMessage=} [properties] Properties to set
             */
            function HighlyStructuredMessage(properties) {
                this.params = [];
                this.localizableParams = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HighlyStructuredMessage namespace.
             * @member {string} namespace
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.namespace = "";

            /**
             * HighlyStructuredMessage elementName.
             * @member {string} elementName
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.elementName = "";

            /**
             * HighlyStructuredMessage params.
             * @member {Array.<string>} params
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.params = $util.emptyArray;

            /**
             * HighlyStructuredMessage fallbackLg.
             * @member {string} fallbackLg
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.fallbackLg = "";

            /**
             * HighlyStructuredMessage fallbackLc.
             * @member {string} fallbackLc
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.fallbackLc = "";

            /**
             * HighlyStructuredMessage localizableParams.
             * @member {Array.<proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter>} localizableParams
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.localizableParams = $util.emptyArray;

            /**
             * HighlyStructuredMessage deterministicLg.
             * @member {string} deterministicLg
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.deterministicLg = "";

            /**
             * HighlyStructuredMessage deterministicLc.
             * @member {string} deterministicLc
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.deterministicLc = "";

            /**
             * HighlyStructuredMessage hydratedHsm.
             * @member {proto.Message.ITemplateMessage|null|undefined} hydratedHsm
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             */
            HighlyStructuredMessage.prototype.hydratedHsm = null;

            /**
             * Creates a new HighlyStructuredMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.HighlyStructuredMessage
             * @static
             * @param {proto.Message.IHighlyStructuredMessage=} [properties] Properties to set
             * @returns {proto.Message.HighlyStructuredMessage} HighlyStructuredMessage instance
             */
            HighlyStructuredMessage.create = function create(properties) {
                return new HighlyStructuredMessage(properties);
            };

            /**
             * Encodes the specified HighlyStructuredMessage message. Does not implicitly {@link proto.Message.HighlyStructuredMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.HighlyStructuredMessage
             * @static
             * @param {proto.Message.IHighlyStructuredMessage} message HighlyStructuredMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HighlyStructuredMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.elementName != null && Object.hasOwnProperty.call(message, "elementName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.elementName);
                if (message.params != null && message.params.length)
                    for (var i = 0; i < message.params.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.params[i]);
                if (message.fallbackLg != null && Object.hasOwnProperty.call(message, "fallbackLg"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fallbackLg);
                if (message.fallbackLc != null && Object.hasOwnProperty.call(message, "fallbackLc"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fallbackLc);
                if (message.localizableParams != null && message.localizableParams.length)
                    for (var i = 0; i < message.localizableParams.length; ++i)
                        $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.encode(message.localizableParams[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.deterministicLg != null && Object.hasOwnProperty.call(message, "deterministicLg"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.deterministicLg);
                if (message.deterministicLc != null && Object.hasOwnProperty.call(message, "deterministicLc"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.deterministicLc);
                if (message.hydratedHsm != null && Object.hasOwnProperty.call(message, "hydratedHsm"))
                    $root.proto.Message.TemplateMessage.encode(message.hydratedHsm, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HighlyStructuredMessage message, length delimited. Does not implicitly {@link proto.Message.HighlyStructuredMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.HighlyStructuredMessage
             * @static
             * @param {proto.Message.IHighlyStructuredMessage} message HighlyStructuredMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HighlyStructuredMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HighlyStructuredMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.HighlyStructuredMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.HighlyStructuredMessage} HighlyStructuredMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HighlyStructuredMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.HighlyStructuredMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        message.elementName = reader.string();
                        break;
                    case 3:
                        if (!(message.params && message.params.length))
                            message.params = [];
                        message.params.push(reader.string());
                        break;
                    case 4:
                        message.fallbackLg = reader.string();
                        break;
                    case 5:
                        message.fallbackLc = reader.string();
                        break;
                    case 6:
                        if (!(message.localizableParams && message.localizableParams.length))
                            message.localizableParams = [];
                        message.localizableParams.push($root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.deterministicLg = reader.string();
                        break;
                    case 8:
                        message.deterministicLc = reader.string();
                        break;
                    case 9:
                        message.hydratedHsm = $root.proto.Message.TemplateMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HighlyStructuredMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.HighlyStructuredMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.HighlyStructuredMessage} HighlyStructuredMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HighlyStructuredMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HighlyStructuredMessage message.
             * @function verify
             * @memberof proto.Message.HighlyStructuredMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HighlyStructuredMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.elementName != null && message.hasOwnProperty("elementName"))
                    if (!$util.isString(message.elementName))
                        return "elementName: string expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (var i = 0; i < message.params.length; ++i)
                        if (!$util.isString(message.params[i]))
                            return "params: string[] expected";
                }
                if (message.fallbackLg != null && message.hasOwnProperty("fallbackLg"))
                    if (!$util.isString(message.fallbackLg))
                        return "fallbackLg: string expected";
                if (message.fallbackLc != null && message.hasOwnProperty("fallbackLc"))
                    if (!$util.isString(message.fallbackLc))
                        return "fallbackLc: string expected";
                if (message.localizableParams != null && message.hasOwnProperty("localizableParams")) {
                    if (!Array.isArray(message.localizableParams))
                        return "localizableParams: array expected";
                    for (var i = 0; i < message.localizableParams.length; ++i) {
                        var error = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.verify(message.localizableParams[i]);
                        if (error)
                            return "localizableParams." + error;
                    }
                }
                if (message.deterministicLg != null && message.hasOwnProperty("deterministicLg"))
                    if (!$util.isString(message.deterministicLg))
                        return "deterministicLg: string expected";
                if (message.deterministicLc != null && message.hasOwnProperty("deterministicLc"))
                    if (!$util.isString(message.deterministicLc))
                        return "deterministicLc: string expected";
                if (message.hydratedHsm != null && message.hasOwnProperty("hydratedHsm")) {
                    var error = $root.proto.Message.TemplateMessage.verify(message.hydratedHsm);
                    if (error)
                        return "hydratedHsm." + error;
                }
                return null;
            };

            /**
             * Creates a HighlyStructuredMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.HighlyStructuredMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.HighlyStructuredMessage} HighlyStructuredMessage
             */
            HighlyStructuredMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.HighlyStructuredMessage)
                    return object;
                var message = new $root.proto.Message.HighlyStructuredMessage();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.elementName != null)
                    message.elementName = String(object.elementName);
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".proto.Message.HighlyStructuredMessage.params: array expected");
                    message.params = [];
                    for (var i = 0; i < object.params.length; ++i)
                        message.params[i] = String(object.params[i]);
                }
                if (object.fallbackLg != null)
                    message.fallbackLg = String(object.fallbackLg);
                if (object.fallbackLc != null)
                    message.fallbackLc = String(object.fallbackLc);
                if (object.localizableParams) {
                    if (!Array.isArray(object.localizableParams))
                        throw TypeError(".proto.Message.HighlyStructuredMessage.localizableParams: array expected");
                    message.localizableParams = [];
                    for (var i = 0; i < object.localizableParams.length; ++i) {
                        if (typeof object.localizableParams[i] !== "object")
                            throw TypeError(".proto.Message.HighlyStructuredMessage.localizableParams: object expected");
                        message.localizableParams[i] = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.fromObject(object.localizableParams[i]);
                    }
                }
                if (object.deterministicLg != null)
                    message.deterministicLg = String(object.deterministicLg);
                if (object.deterministicLc != null)
                    message.deterministicLc = String(object.deterministicLc);
                if (object.hydratedHsm != null) {
                    if (typeof object.hydratedHsm !== "object")
                        throw TypeError(".proto.Message.HighlyStructuredMessage.hydratedHsm: object expected");
                    message.hydratedHsm = $root.proto.Message.TemplateMessage.fromObject(object.hydratedHsm);
                }
                return message;
            };

            /**
             * Creates a plain object from a HighlyStructuredMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.HighlyStructuredMessage
             * @static
             * @param {proto.Message.HighlyStructuredMessage} message HighlyStructuredMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HighlyStructuredMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.params = [];
                    object.localizableParams = [];
                }
                if (options.defaults) {
                    object.namespace = "";
                    object.elementName = "";
                    object.fallbackLg = "";
                    object.fallbackLc = "";
                    object.deterministicLg = "";
                    object.deterministicLc = "";
                    object.hydratedHsm = null;
                }
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.elementName != null && message.hasOwnProperty("elementName"))
                    object.elementName = message.elementName;
                if (message.params && message.params.length) {
                    object.params = [];
                    for (var j = 0; j < message.params.length; ++j)
                        object.params[j] = message.params[j];
                }
                if (message.fallbackLg != null && message.hasOwnProperty("fallbackLg"))
                    object.fallbackLg = message.fallbackLg;
                if (message.fallbackLc != null && message.hasOwnProperty("fallbackLc"))
                    object.fallbackLc = message.fallbackLc;
                if (message.localizableParams && message.localizableParams.length) {
                    object.localizableParams = [];
                    for (var j = 0; j < message.localizableParams.length; ++j)
                        object.localizableParams[j] = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.toObject(message.localizableParams[j], options);
                }
                if (message.deterministicLg != null && message.hasOwnProperty("deterministicLg"))
                    object.deterministicLg = message.deterministicLg;
                if (message.deterministicLc != null && message.hasOwnProperty("deterministicLc"))
                    object.deterministicLc = message.deterministicLc;
                if (message.hydratedHsm != null && message.hasOwnProperty("hydratedHsm"))
                    object.hydratedHsm = $root.proto.Message.TemplateMessage.toObject(message.hydratedHsm, options);
                return object;
            };

            /**
             * Converts this HighlyStructuredMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.HighlyStructuredMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HighlyStructuredMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            HighlyStructuredMessage.HSMLocalizableParameter = (function() {

                /**
                 * Properties of a HSMLocalizableParameter.
                 * @memberof proto.Message.HighlyStructuredMessage
                 * @interface IHSMLocalizableParameter
                 * @property {string|null} ["default"] HSMLocalizableParameter default
                 * @property {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency|null} [currency] HSMLocalizableParameter currency
                 * @property {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime|null} [dateTime] HSMLocalizableParameter dateTime
                 */

                /**
                 * Constructs a new HSMLocalizableParameter.
                 * @memberof proto.Message.HighlyStructuredMessage
                 * @classdesc Represents a HSMLocalizableParameter.
                 * @implements IHSMLocalizableParameter
                 * @constructor
                 * @param {proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter=} [properties] Properties to set
                 */
                function HSMLocalizableParameter(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HSMLocalizableParameter default.
                 * @member {string} default
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @instance
                 */
                HSMLocalizableParameter.prototype["default"] = "";

                /**
                 * HSMLocalizableParameter currency.
                 * @member {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency|null|undefined} currency
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @instance
                 */
                HSMLocalizableParameter.prototype.currency = null;

                /**
                 * HSMLocalizableParameter dateTime.
                 * @member {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime|null|undefined} dateTime
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @instance
                 */
                HSMLocalizableParameter.prototype.dateTime = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * HSMLocalizableParameter paramOneof.
                 * @member {"currency"|"dateTime"|undefined} paramOneof
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @instance
                 */
                Object.defineProperty(HSMLocalizableParameter.prototype, "paramOneof", {
                    get: $util.oneOfGetter($oneOfFields = ["currency", "dateTime"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new HSMLocalizableParameter instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @static
                 * @param {proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter=} [properties] Properties to set
                 * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter} HSMLocalizableParameter instance
                 */
                HSMLocalizableParameter.create = function create(properties) {
                    return new HSMLocalizableParameter(properties);
                };

                /**
                 * Encodes the specified HSMLocalizableParameter message. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @static
                 * @param {proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter} message HSMLocalizableParameter message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HSMLocalizableParameter.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["default"] != null && Object.hasOwnProperty.call(message, "default"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message["default"]);
                    if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                        $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.encode(message.currency, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.dateTime != null && Object.hasOwnProperty.call(message, "dateTime"))
                        $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.encode(message.dateTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified HSMLocalizableParameter message, length delimited. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @static
                 * @param {proto.Message.HighlyStructuredMessage.IHSMLocalizableParameter} message HSMLocalizableParameter message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HSMLocalizableParameter.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a HSMLocalizableParameter message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter} HSMLocalizableParameter
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HSMLocalizableParameter.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["default"] = reader.string();
                            break;
                        case 2:
                            message.currency = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.dateTime = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a HSMLocalizableParameter message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter} HSMLocalizableParameter
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HSMLocalizableParameter.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a HSMLocalizableParameter message.
                 * @function verify
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HSMLocalizableParameter.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message["default"] != null && message.hasOwnProperty("default"))
                        if (!$util.isString(message["default"]))
                            return "default: string expected";
                    if (message.currency != null && message.hasOwnProperty("currency")) {
                        properties.paramOneof = 1;
                        {
                            var error = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.verify(message.currency);
                            if (error)
                                return "currency." + error;
                        }
                    }
                    if (message.dateTime != null && message.hasOwnProperty("dateTime")) {
                        if (properties.paramOneof === 1)
                            return "paramOneof: multiple values";
                        properties.paramOneof = 1;
                        {
                            var error = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.verify(message.dateTime);
                            if (error)
                                return "dateTime." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a HSMLocalizableParameter message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter} HSMLocalizableParameter
                 */
                HSMLocalizableParameter.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter)
                        return object;
                    var message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter();
                    if (object["default"] != null)
                        message["default"] = String(object["default"]);
                    if (object.currency != null) {
                        if (typeof object.currency !== "object")
                            throw TypeError(".proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.currency: object expected");
                        message.currency = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.fromObject(object.currency);
                    }
                    if (object.dateTime != null) {
                        if (typeof object.dateTime !== "object")
                            throw TypeError(".proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.dateTime: object expected");
                        message.dateTime = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.fromObject(object.dateTime);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a HSMLocalizableParameter message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @static
                 * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter} message HSMLocalizableParameter
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HSMLocalizableParameter.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object["default"] = "";
                    if (message["default"] != null && message.hasOwnProperty("default"))
                        object["default"] = message["default"];
                    if (message.currency != null && message.hasOwnProperty("currency")) {
                        object.currency = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.toObject(message.currency, options);
                        if (options.oneofs)
                            object.paramOneof = "currency";
                    }
                    if (message.dateTime != null && message.hasOwnProperty("dateTime")) {
                        object.dateTime = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.toObject(message.dateTime, options);
                        if (options.oneofs)
                            object.paramOneof = "dateTime";
                    }
                    return object;
                };

                /**
                 * Converts this HSMLocalizableParameter to JSON.
                 * @function toJSON
                 * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HSMLocalizableParameter.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                HSMLocalizableParameter.HSMCurrency = (function() {

                    /**
                     * Properties of a HSMCurrency.
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                     * @interface IHSMCurrency
                     * @property {string|null} [currencyCode] HSMCurrency currencyCode
                     * @property {number|Long|null} [amount1000] HSMCurrency amount1000
                     */

                    /**
                     * Constructs a new HSMCurrency.
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                     * @classdesc Represents a HSMCurrency.
                     * @implements IHSMCurrency
                     * @constructor
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency=} [properties] Properties to set
                     */
                    function HSMCurrency(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * HSMCurrency currencyCode.
                     * @member {string} currencyCode
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @instance
                     */
                    HSMCurrency.prototype.currencyCode = "";

                    /**
                     * HSMCurrency amount1000.
                     * @member {number|Long} amount1000
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @instance
                     */
                    HSMCurrency.prototype.amount1000 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new HSMCurrency instance using the specified properties.
                     * @function create
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @static
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency=} [properties] Properties to set
                     * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency} HSMCurrency instance
                     */
                    HSMCurrency.create = function create(properties) {
                        return new HSMCurrency(properties);
                    };

                    /**
                     * Encodes the specified HSMCurrency message. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.verify|verify} messages.
                     * @function encode
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @static
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency} message HSMCurrency message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    HSMCurrency.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.currencyCode);
                        if (message.amount1000 != null && Object.hasOwnProperty.call(message, "amount1000"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount1000);
                        return writer;
                    };

                    /**
                     * Encodes the specified HSMCurrency message, length delimited. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @static
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMCurrency} message HSMCurrency message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    HSMCurrency.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a HSMCurrency message from the specified reader or buffer.
                     * @function decode
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency} HSMCurrency
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    HSMCurrency.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.currencyCode = reader.string();
                                break;
                            case 2:
                                message.amount1000 = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a HSMCurrency message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency} HSMCurrency
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    HSMCurrency.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a HSMCurrency message.
                     * @function verify
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    HSMCurrency.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                            if (!$util.isString(message.currencyCode))
                                return "currencyCode: string expected";
                        if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                            if (!$util.isInteger(message.amount1000) && !(message.amount1000 && $util.isInteger(message.amount1000.low) && $util.isInteger(message.amount1000.high)))
                                return "amount1000: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a HSMCurrency message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency} HSMCurrency
                     */
                    HSMCurrency.fromObject = function fromObject(object) {
                        if (object instanceof $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency)
                            return object;
                        var message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency();
                        if (object.currencyCode != null)
                            message.currencyCode = String(object.currencyCode);
                        if (object.amount1000 != null)
                            if ($util.Long)
                                (message.amount1000 = $util.Long.fromValue(object.amount1000)).unsigned = false;
                            else if (typeof object.amount1000 === "string")
                                message.amount1000 = parseInt(object.amount1000, 10);
                            else if (typeof object.amount1000 === "number")
                                message.amount1000 = object.amount1000;
                            else if (typeof object.amount1000 === "object")
                                message.amount1000 = new $util.LongBits(object.amount1000.low >>> 0, object.amount1000.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a HSMCurrency message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @static
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency} message HSMCurrency
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HSMCurrency.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.currencyCode = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount1000 = options.longs === String ? "0" : 0;
                        }
                        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                            object.currencyCode = message.currencyCode;
                        if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                            if (typeof message.amount1000 === "number")
                                object.amount1000 = options.longs === String ? String(message.amount1000) : message.amount1000;
                            else
                                object.amount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.amount1000) : options.longs === Number ? new $util.LongBits(message.amount1000.low >>> 0, message.amount1000.high >>> 0).toNumber() : message.amount1000;
                        return object;
                    };

                    /**
                     * Converts this HSMCurrency to JSON.
                     * @function toJSON
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    HSMCurrency.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return HSMCurrency;
                })();

                HSMLocalizableParameter.HSMDateTime = (function() {

                    /**
                     * Properties of a HSMDateTime.
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                     * @interface IHSMDateTime
                     * @property {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent|null} [component] HSMDateTime component
                     * @property {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch|null} [unixEpoch] HSMDateTime unixEpoch
                     */

                    /**
                     * Constructs a new HSMDateTime.
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter
                     * @classdesc Represents a HSMDateTime.
                     * @implements IHSMDateTime
                     * @constructor
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime=} [properties] Properties to set
                     */
                    function HSMDateTime(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * HSMDateTime component.
                     * @member {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent|null|undefined} component
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @instance
                     */
                    HSMDateTime.prototype.component = null;

                    /**
                     * HSMDateTime unixEpoch.
                     * @member {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch|null|undefined} unixEpoch
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @instance
                     */
                    HSMDateTime.prototype.unixEpoch = null;

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * HSMDateTime datetimeOneof.
                     * @member {"component"|"unixEpoch"|undefined} datetimeOneof
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @instance
                     */
                    Object.defineProperty(HSMDateTime.prototype, "datetimeOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["component", "unixEpoch"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new HSMDateTime instance using the specified properties.
                     * @function create
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @static
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime=} [properties] Properties to set
                     * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime} HSMDateTime instance
                     */
                    HSMDateTime.create = function create(properties) {
                        return new HSMDateTime(properties);
                    };

                    /**
                     * Encodes the specified HSMDateTime message. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.verify|verify} messages.
                     * @function encode
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @static
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime} message HSMDateTime message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    HSMDateTime.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.component != null && Object.hasOwnProperty.call(message, "component"))
                            $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.encode(message.component, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.unixEpoch != null && Object.hasOwnProperty.call(message, "unixEpoch"))
                            $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.encode(message.unixEpoch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified HSMDateTime message, length delimited. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @static
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.IHSMDateTime} message HSMDateTime message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    HSMDateTime.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a HSMDateTime message from the specified reader or buffer.
                     * @function decode
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime} HSMDateTime
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    HSMDateTime.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.component = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.unixEpoch = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a HSMDateTime message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime} HSMDateTime
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    HSMDateTime.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a HSMDateTime message.
                     * @function verify
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    HSMDateTime.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.component != null && message.hasOwnProperty("component")) {
                            properties.datetimeOneof = 1;
                            {
                                var error = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.verify(message.component);
                                if (error)
                                    return "component." + error;
                            }
                        }
                        if (message.unixEpoch != null && message.hasOwnProperty("unixEpoch")) {
                            if (properties.datetimeOneof === 1)
                                return "datetimeOneof: multiple values";
                            properties.datetimeOneof = 1;
                            {
                                var error = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.verify(message.unixEpoch);
                                if (error)
                                    return "unixEpoch." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a HSMDateTime message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime} HSMDateTime
                     */
                    HSMDateTime.fromObject = function fromObject(object) {
                        if (object instanceof $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime)
                            return object;
                        var message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime();
                        if (object.component != null) {
                            if (typeof object.component !== "object")
                                throw TypeError(".proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.component: object expected");
                            message.component = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.fromObject(object.component);
                        }
                        if (object.unixEpoch != null) {
                            if (typeof object.unixEpoch !== "object")
                                throw TypeError(".proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.unixEpoch: object expected");
                            message.unixEpoch = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.fromObject(object.unixEpoch);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a HSMDateTime message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @static
                     * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime} message HSMDateTime
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HSMDateTime.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.component != null && message.hasOwnProperty("component")) {
                            object.component = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.toObject(message.component, options);
                            if (options.oneofs)
                                object.datetimeOneof = "component";
                        }
                        if (message.unixEpoch != null && message.hasOwnProperty("unixEpoch")) {
                            object.unixEpoch = $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.toObject(message.unixEpoch, options);
                            if (options.oneofs)
                                object.datetimeOneof = "unixEpoch";
                        }
                        return object;
                    };

                    /**
                     * Converts this HSMDateTime to JSON.
                     * @function toJSON
                     * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    HSMDateTime.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    HSMDateTime.HSMDateTimeComponent = (function() {

                        /**
                         * Properties of a HSMDateTimeComponent.
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                         * @interface IHSMDateTimeComponent
                         * @property {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType|null} [dayOfWeek] HSMDateTimeComponent dayOfWeek
                         * @property {number|null} [year] HSMDateTimeComponent year
                         * @property {number|null} [month] HSMDateTimeComponent month
                         * @property {number|null} [dayOfMonth] HSMDateTimeComponent dayOfMonth
                         * @property {number|null} [hour] HSMDateTimeComponent hour
                         * @property {number|null} [minute] HSMDateTimeComponent minute
                         * @property {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType|null} [calendar] HSMDateTimeComponent calendar
                         */

                        /**
                         * Constructs a new HSMDateTimeComponent.
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                         * @classdesc Represents a HSMDateTimeComponent.
                         * @implements IHSMDateTimeComponent
                         * @constructor
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent=} [properties] Properties to set
                         */
                        function HSMDateTimeComponent(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * HSMDateTimeComponent dayOfWeek.
                         * @member {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType} dayOfWeek
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @instance
                         */
                        HSMDateTimeComponent.prototype.dayOfWeek = 1;

                        /**
                         * HSMDateTimeComponent year.
                         * @member {number} year
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @instance
                         */
                        HSMDateTimeComponent.prototype.year = 0;

                        /**
                         * HSMDateTimeComponent month.
                         * @member {number} month
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @instance
                         */
                        HSMDateTimeComponent.prototype.month = 0;

                        /**
                         * HSMDateTimeComponent dayOfMonth.
                         * @member {number} dayOfMonth
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @instance
                         */
                        HSMDateTimeComponent.prototype.dayOfMonth = 0;

                        /**
                         * HSMDateTimeComponent hour.
                         * @member {number} hour
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @instance
                         */
                        HSMDateTimeComponent.prototype.hour = 0;

                        /**
                         * HSMDateTimeComponent minute.
                         * @member {number} minute
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @instance
                         */
                        HSMDateTimeComponent.prototype.minute = 0;

                        /**
                         * HSMDateTimeComponent calendar.
                         * @member {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType} calendar
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @instance
                         */
                        HSMDateTimeComponent.prototype.calendar = 1;

                        /**
                         * Creates a new HSMDateTimeComponent instance using the specified properties.
                         * @function create
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @static
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent=} [properties] Properties to set
                         * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent} HSMDateTimeComponent instance
                         */
                        HSMDateTimeComponent.create = function create(properties) {
                            return new HSMDateTimeComponent(properties);
                        };

                        /**
                         * Encodes the specified HSMDateTimeComponent message. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.verify|verify} messages.
                         * @function encode
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @static
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent} message HSMDateTimeComponent message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        HSMDateTimeComponent.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.dayOfWeek != null && Object.hasOwnProperty.call(message, "dayOfWeek"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dayOfWeek);
                            if (message.year != null && Object.hasOwnProperty.call(message, "year"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.year);
                            if (message.month != null && Object.hasOwnProperty.call(message, "month"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.month);
                            if (message.dayOfMonth != null && Object.hasOwnProperty.call(message, "dayOfMonth"))
                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.dayOfMonth);
                            if (message.hour != null && Object.hasOwnProperty.call(message, "hour"))
                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.hour);
                            if (message.minute != null && Object.hasOwnProperty.call(message, "minute"))
                                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.minute);
                            if (message.calendar != null && Object.hasOwnProperty.call(message, "calendar"))
                                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.calendar);
                            return writer;
                        };

                        /**
                         * Encodes the specified HSMDateTimeComponent message, length delimited. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @static
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeComponent} message HSMDateTimeComponent message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        HSMDateTimeComponent.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a HSMDateTimeComponent message from the specified reader or buffer.
                         * @function decode
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent} HSMDateTimeComponent
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        HSMDateTimeComponent.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.dayOfWeek = reader.int32();
                                    break;
                                case 2:
                                    message.year = reader.uint32();
                                    break;
                                case 3:
                                    message.month = reader.uint32();
                                    break;
                                case 4:
                                    message.dayOfMonth = reader.uint32();
                                    break;
                                case 5:
                                    message.hour = reader.uint32();
                                    break;
                                case 6:
                                    message.minute = reader.uint32();
                                    break;
                                case 7:
                                    message.calendar = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a HSMDateTimeComponent message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent} HSMDateTimeComponent
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        HSMDateTimeComponent.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a HSMDateTimeComponent message.
                         * @function verify
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        HSMDateTimeComponent.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.dayOfWeek != null && message.hasOwnProperty("dayOfWeek"))
                                switch (message.dayOfWeek) {
                                default:
                                    return "dayOfWeek: enum value expected";
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                    break;
                                }
                            if (message.year != null && message.hasOwnProperty("year"))
                                if (!$util.isInteger(message.year))
                                    return "year: integer expected";
                            if (message.month != null && message.hasOwnProperty("month"))
                                if (!$util.isInteger(message.month))
                                    return "month: integer expected";
                            if (message.dayOfMonth != null && message.hasOwnProperty("dayOfMonth"))
                                if (!$util.isInteger(message.dayOfMonth))
                                    return "dayOfMonth: integer expected";
                            if (message.hour != null && message.hasOwnProperty("hour"))
                                if (!$util.isInteger(message.hour))
                                    return "hour: integer expected";
                            if (message.minute != null && message.hasOwnProperty("minute"))
                                if (!$util.isInteger(message.minute))
                                    return "minute: integer expected";
                            if (message.calendar != null && message.hasOwnProperty("calendar"))
                                switch (message.calendar) {
                                default:
                                    return "calendar: enum value expected";
                                case 1:
                                case 2:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a HSMDateTimeComponent message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent} HSMDateTimeComponent
                         */
                        HSMDateTimeComponent.fromObject = function fromObject(object) {
                            if (object instanceof $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent)
                                return object;
                            var message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent();
                            switch (object.dayOfWeek) {
                            case "MONDAY":
                            case 1:
                                message.dayOfWeek = 1;
                                break;
                            case "TUESDAY":
                            case 2:
                                message.dayOfWeek = 2;
                                break;
                            case "WEDNESDAY":
                            case 3:
                                message.dayOfWeek = 3;
                                break;
                            case "THURSDAY":
                            case 4:
                                message.dayOfWeek = 4;
                                break;
                            case "FRIDAY":
                            case 5:
                                message.dayOfWeek = 5;
                                break;
                            case "SATURDAY":
                            case 6:
                                message.dayOfWeek = 6;
                                break;
                            case "SUNDAY":
                            case 7:
                                message.dayOfWeek = 7;
                                break;
                            }
                            if (object.year != null)
                                message.year = object.year >>> 0;
                            if (object.month != null)
                                message.month = object.month >>> 0;
                            if (object.dayOfMonth != null)
                                message.dayOfMonth = object.dayOfMonth >>> 0;
                            if (object.hour != null)
                                message.hour = object.hour >>> 0;
                            if (object.minute != null)
                                message.minute = object.minute >>> 0;
                            switch (object.calendar) {
                            case "GREGORIAN":
                            case 1:
                                message.calendar = 1;
                                break;
                            case "SOLAR_HIJRI":
                            case 2:
                                message.calendar = 2;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a HSMDateTimeComponent message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @static
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent} message HSMDateTimeComponent
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        HSMDateTimeComponent.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.dayOfWeek = options.enums === String ? "MONDAY" : 1;
                                object.year = 0;
                                object.month = 0;
                                object.dayOfMonth = 0;
                                object.hour = 0;
                                object.minute = 0;
                                object.calendar = options.enums === String ? "GREGORIAN" : 1;
                            }
                            if (message.dayOfWeek != null && message.hasOwnProperty("dayOfWeek"))
                                object.dayOfWeek = options.enums === String ? $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType[message.dayOfWeek] : message.dayOfWeek;
                            if (message.year != null && message.hasOwnProperty("year"))
                                object.year = message.year;
                            if (message.month != null && message.hasOwnProperty("month"))
                                object.month = message.month;
                            if (message.dayOfMonth != null && message.hasOwnProperty("dayOfMonth"))
                                object.dayOfMonth = message.dayOfMonth;
                            if (message.hour != null && message.hasOwnProperty("hour"))
                                object.hour = message.hour;
                            if (message.minute != null && message.hasOwnProperty("minute"))
                                object.minute = message.minute;
                            if (message.calendar != null && message.hasOwnProperty("calendar"))
                                object.calendar = options.enums === String ? $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType[message.calendar] : message.calendar;
                            return object;
                        };

                        /**
                         * Converts this HSMDateTimeComponent to JSON.
                         * @function toJSON
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        HSMDateTimeComponent.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * CalendarType enum.
                         * @name proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType
                         * @enum {number}
                         * @property {number} GREGORIAN=1 GREGORIAN value
                         * @property {number} SOLAR_HIJRI=2 SOLAR_HIJRI value
                         */
                        HSMDateTimeComponent.CalendarType = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[1] = "GREGORIAN"] = 1;
                            values[valuesById[2] = "SOLAR_HIJRI"] = 2;
                            return values;
                        })();

                        /**
                         * DayOfWeekType enum.
                         * @name proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType
                         * @enum {number}
                         * @property {number} MONDAY=1 MONDAY value
                         * @property {number} TUESDAY=2 TUESDAY value
                         * @property {number} WEDNESDAY=3 WEDNESDAY value
                         * @property {number} THURSDAY=4 THURSDAY value
                         * @property {number} FRIDAY=5 FRIDAY value
                         * @property {number} SATURDAY=6 SATURDAY value
                         * @property {number} SUNDAY=7 SUNDAY value
                         */
                        HSMDateTimeComponent.DayOfWeekType = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[1] = "MONDAY"] = 1;
                            values[valuesById[2] = "TUESDAY"] = 2;
                            values[valuesById[3] = "WEDNESDAY"] = 3;
                            values[valuesById[4] = "THURSDAY"] = 4;
                            values[valuesById[5] = "FRIDAY"] = 5;
                            values[valuesById[6] = "SATURDAY"] = 6;
                            values[valuesById[7] = "SUNDAY"] = 7;
                            return values;
                        })();

                        return HSMDateTimeComponent;
                    })();

                    HSMDateTime.HSMDateTimeUnixEpoch = (function() {

                        /**
                         * Properties of a HSMDateTimeUnixEpoch.
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                         * @interface IHSMDateTimeUnixEpoch
                         * @property {number|Long|null} [timestamp] HSMDateTimeUnixEpoch timestamp
                         */

                        /**
                         * Constructs a new HSMDateTimeUnixEpoch.
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime
                         * @classdesc Represents a HSMDateTimeUnixEpoch.
                         * @implements IHSMDateTimeUnixEpoch
                         * @constructor
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch=} [properties] Properties to set
                         */
                        function HSMDateTimeUnixEpoch(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * HSMDateTimeUnixEpoch timestamp.
                         * @member {number|Long} timestamp
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @instance
                         */
                        HSMDateTimeUnixEpoch.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * Creates a new HSMDateTimeUnixEpoch instance using the specified properties.
                         * @function create
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @static
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch=} [properties] Properties to set
                         * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch} HSMDateTimeUnixEpoch instance
                         */
                        HSMDateTimeUnixEpoch.create = function create(properties) {
                            return new HSMDateTimeUnixEpoch(properties);
                        };

                        /**
                         * Encodes the specified HSMDateTimeUnixEpoch message. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.verify|verify} messages.
                         * @function encode
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @static
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch} message HSMDateTimeUnixEpoch message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        HSMDateTimeUnixEpoch.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                            return writer;
                        };

                        /**
                         * Encodes the specified HSMDateTimeUnixEpoch message, length delimited. Does not implicitly {@link proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @static
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.IHSMDateTimeUnixEpoch} message HSMDateTimeUnixEpoch message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        HSMDateTimeUnixEpoch.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a HSMDateTimeUnixEpoch message from the specified reader or buffer.
                         * @function decode
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch} HSMDateTimeUnixEpoch
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        HSMDateTimeUnixEpoch.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.timestamp = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a HSMDateTimeUnixEpoch message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch} HSMDateTimeUnixEpoch
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        HSMDateTimeUnixEpoch.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a HSMDateTimeUnixEpoch message.
                         * @function verify
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        HSMDateTimeUnixEpoch.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                    return "timestamp: integer|Long expected";
                            return null;
                        };

                        /**
                         * Creates a HSMDateTimeUnixEpoch message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch} HSMDateTimeUnixEpoch
                         */
                        HSMDateTimeUnixEpoch.fromObject = function fromObject(object) {
                            if (object instanceof $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch)
                                return object;
                            var message = new $root.proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch();
                            if (object.timestamp != null)
                                if ($util.Long)
                                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                                else if (typeof object.timestamp === "string")
                                    message.timestamp = parseInt(object.timestamp, 10);
                                else if (typeof object.timestamp === "number")
                                    message.timestamp = object.timestamp;
                                else if (typeof object.timestamp === "object")
                                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                            return message;
                        };

                        /**
                         * Creates a plain object from a HSMDateTimeUnixEpoch message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @static
                         * @param {proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch} message HSMDateTimeUnixEpoch
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        HSMDateTimeUnixEpoch.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, false);
                                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.timestamp = options.longs === String ? "0" : 0;
                            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                                if (typeof message.timestamp === "number")
                                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                                else
                                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                            return object;
                        };

                        /**
                         * Converts this HSMDateTimeUnixEpoch to JSON.
                         * @function toJSON
                         * @memberof proto.Message.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        HSMDateTimeUnixEpoch.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return HSMDateTimeUnixEpoch;
                    })();

                    return HSMDateTime;
                })();

                return HSMLocalizableParameter;
            })();

            return HighlyStructuredMessage;
        })();

        Message.HistorySyncNotification = (function() {

            /**
             * Properties of a HistorySyncNotification.
             * @memberof proto.Message
             * @interface IHistorySyncNotification
             * @property {Uint8Array|null} [fileSha256] HistorySyncNotification fileSha256
             * @property {number|Long|null} [fileLength] HistorySyncNotification fileLength
             * @property {Uint8Array|null} [mediaKey] HistorySyncNotification mediaKey
             * @property {Uint8Array|null} [fileEncSha256] HistorySyncNotification fileEncSha256
             * @property {string|null} [directPath] HistorySyncNotification directPath
             * @property {proto.Message.HistorySyncNotification.HistorySyncType|null} [syncType] HistorySyncNotification syncType
             * @property {number|null} [chunkOrder] HistorySyncNotification chunkOrder
             * @property {string|null} [originalMessageId] HistorySyncNotification originalMessageId
             * @property {number|null} [progress] HistorySyncNotification progress
             * @property {number|Long|null} [oldestMsgInChunkTimestampSec] HistorySyncNotification oldestMsgInChunkTimestampSec
             */

            /**
             * Constructs a new HistorySyncNotification.
             * @memberof proto.Message
             * @classdesc Represents a HistorySyncNotification.
             * @implements IHistorySyncNotification
             * @constructor
             * @param {proto.Message.IHistorySyncNotification=} [properties] Properties to set
             */
            function HistorySyncNotification(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HistorySyncNotification fileSha256.
             * @member {Uint8Array} fileSha256
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.fileSha256 = $util.newBuffer([]);

            /**
             * HistorySyncNotification fileLength.
             * @member {number|Long} fileLength
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * HistorySyncNotification mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.mediaKey = $util.newBuffer([]);

            /**
             * HistorySyncNotification fileEncSha256.
             * @member {Uint8Array} fileEncSha256
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.fileEncSha256 = $util.newBuffer([]);

            /**
             * HistorySyncNotification directPath.
             * @member {string} directPath
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.directPath = "";

            /**
             * HistorySyncNotification syncType.
             * @member {proto.Message.HistorySyncNotification.HistorySyncType} syncType
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.syncType = 0;

            /**
             * HistorySyncNotification chunkOrder.
             * @member {number} chunkOrder
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.chunkOrder = 0;

            /**
             * HistorySyncNotification originalMessageId.
             * @member {string} originalMessageId
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.originalMessageId = "";

            /**
             * HistorySyncNotification progress.
             * @member {number} progress
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.progress = 0;

            /**
             * HistorySyncNotification oldestMsgInChunkTimestampSec.
             * @member {number|Long} oldestMsgInChunkTimestampSec
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             */
            HistorySyncNotification.prototype.oldestMsgInChunkTimestampSec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new HistorySyncNotification instance using the specified properties.
             * @function create
             * @memberof proto.Message.HistorySyncNotification
             * @static
             * @param {proto.Message.IHistorySyncNotification=} [properties] Properties to set
             * @returns {proto.Message.HistorySyncNotification} HistorySyncNotification instance
             */
            HistorySyncNotification.create = function create(properties) {
                return new HistorySyncNotification(properties);
            };

            /**
             * Encodes the specified HistorySyncNotification message. Does not implicitly {@link proto.Message.HistorySyncNotification.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.HistorySyncNotification
             * @static
             * @param {proto.Message.IHistorySyncNotification} message HistorySyncNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HistorySyncNotification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fileSha256);
                if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.fileLength);
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.mediaKey);
                if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fileEncSha256);
                if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.directPath);
                if (message.syncType != null && Object.hasOwnProperty.call(message, "syncType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.syncType);
                if (message.chunkOrder != null && Object.hasOwnProperty.call(message, "chunkOrder"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.chunkOrder);
                if (message.originalMessageId != null && Object.hasOwnProperty.call(message, "originalMessageId"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.originalMessageId);
                if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.progress);
                if (message.oldestMsgInChunkTimestampSec != null && Object.hasOwnProperty.call(message, "oldestMsgInChunkTimestampSec"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.oldestMsgInChunkTimestampSec);
                return writer;
            };

            /**
             * Encodes the specified HistorySyncNotification message, length delimited. Does not implicitly {@link proto.Message.HistorySyncNotification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.HistorySyncNotification
             * @static
             * @param {proto.Message.IHistorySyncNotification} message HistorySyncNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HistorySyncNotification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HistorySyncNotification message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.HistorySyncNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.HistorySyncNotification} HistorySyncNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HistorySyncNotification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.HistorySyncNotification();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fileSha256 = reader.bytes();
                        break;
                    case 2:
                        message.fileLength = reader.uint64();
                        break;
                    case 3:
                        message.mediaKey = reader.bytes();
                        break;
                    case 4:
                        message.fileEncSha256 = reader.bytes();
                        break;
                    case 5:
                        message.directPath = reader.string();
                        break;
                    case 6:
                        message.syncType = reader.int32();
                        break;
                    case 7:
                        message.chunkOrder = reader.uint32();
                        break;
                    case 8:
                        message.originalMessageId = reader.string();
                        break;
                    case 9:
                        message.progress = reader.uint32();
                        break;
                    case 10:
                        message.oldestMsgInChunkTimestampSec = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HistorySyncNotification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.HistorySyncNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.HistorySyncNotification} HistorySyncNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HistorySyncNotification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HistorySyncNotification message.
             * @function verify
             * @memberof proto.Message.HistorySyncNotification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HistorySyncNotification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                        return "fileSha256: buffer expected";
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                        return "fileLength: integer|Long expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                        return "fileEncSha256: buffer expected";
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    if (!$util.isString(message.directPath))
                        return "directPath: string expected";
                if (message.syncType != null && message.hasOwnProperty("syncType"))
                    switch (message.syncType) {
                    default:
                        return "syncType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.chunkOrder != null && message.hasOwnProperty("chunkOrder"))
                    if (!$util.isInteger(message.chunkOrder))
                        return "chunkOrder: integer expected";
                if (message.originalMessageId != null && message.hasOwnProperty("originalMessageId"))
                    if (!$util.isString(message.originalMessageId))
                        return "originalMessageId: string expected";
                if (message.progress != null && message.hasOwnProperty("progress"))
                    if (!$util.isInteger(message.progress))
                        return "progress: integer expected";
                if (message.oldestMsgInChunkTimestampSec != null && message.hasOwnProperty("oldestMsgInChunkTimestampSec"))
                    if (!$util.isInteger(message.oldestMsgInChunkTimestampSec) && !(message.oldestMsgInChunkTimestampSec && $util.isInteger(message.oldestMsgInChunkTimestampSec.low) && $util.isInteger(message.oldestMsgInChunkTimestampSec.high)))
                        return "oldestMsgInChunkTimestampSec: integer|Long expected";
                return null;
            };

            /**
             * Creates a HistorySyncNotification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.HistorySyncNotification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.HistorySyncNotification} HistorySyncNotification
             */
            HistorySyncNotification.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.HistorySyncNotification)
                    return object;
                var message = new $root.proto.Message.HistorySyncNotification();
                if (object.fileSha256 != null)
                    if (typeof object.fileSha256 === "string")
                        $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                    else if (object.fileSha256.length)
                        message.fileSha256 = object.fileSha256;
                if (object.fileLength != null)
                    if ($util.Long)
                        (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                    else if (typeof object.fileLength === "string")
                        message.fileLength = parseInt(object.fileLength, 10);
                    else if (typeof object.fileLength === "number")
                        message.fileLength = object.fileLength;
                    else if (typeof object.fileLength === "object")
                        message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.fileEncSha256 != null)
                    if (typeof object.fileEncSha256 === "string")
                        $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                    else if (object.fileEncSha256.length)
                        message.fileEncSha256 = object.fileEncSha256;
                if (object.directPath != null)
                    message.directPath = String(object.directPath);
                switch (object.syncType) {
                case "INITIAL_BOOTSTRAP":
                case 0:
                    message.syncType = 0;
                    break;
                case "INITIAL_STATUS_V3":
                case 1:
                    message.syncType = 1;
                    break;
                case "FULL":
                case 2:
                    message.syncType = 2;
                    break;
                case "RECENT":
                case 3:
                    message.syncType = 3;
                    break;
                case "PUSH_NAME":
                case 4:
                    message.syncType = 4;
                    break;
                case "NON_BLOCKING_DATA":
                case 5:
                    message.syncType = 5;
                    break;
                }
                if (object.chunkOrder != null)
                    message.chunkOrder = object.chunkOrder >>> 0;
                if (object.originalMessageId != null)
                    message.originalMessageId = String(object.originalMessageId);
                if (object.progress != null)
                    message.progress = object.progress >>> 0;
                if (object.oldestMsgInChunkTimestampSec != null)
                    if ($util.Long)
                        (message.oldestMsgInChunkTimestampSec = $util.Long.fromValue(object.oldestMsgInChunkTimestampSec)).unsigned = false;
                    else if (typeof object.oldestMsgInChunkTimestampSec === "string")
                        message.oldestMsgInChunkTimestampSec = parseInt(object.oldestMsgInChunkTimestampSec, 10);
                    else if (typeof object.oldestMsgInChunkTimestampSec === "number")
                        message.oldestMsgInChunkTimestampSec = object.oldestMsgInChunkTimestampSec;
                    else if (typeof object.oldestMsgInChunkTimestampSec === "object")
                        message.oldestMsgInChunkTimestampSec = new $util.LongBits(object.oldestMsgInChunkTimestampSec.low >>> 0, object.oldestMsgInChunkTimestampSec.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a HistorySyncNotification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.HistorySyncNotification
             * @static
             * @param {proto.Message.HistorySyncNotification} message HistorySyncNotification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HistorySyncNotification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.fileSha256 = "";
                    else {
                        object.fileSha256 = [];
                        if (options.bytes !== Array)
                            object.fileSha256 = $util.newBuffer(object.fileSha256);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileLength = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    if (options.bytes === String)
                        object.fileEncSha256 = "";
                    else {
                        object.fileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                    }
                    object.directPath = "";
                    object.syncType = options.enums === String ? "INITIAL_BOOTSTRAP" : 0;
                    object.chunkOrder = 0;
                    object.originalMessageId = "";
                    object.progress = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.oldestMsgInChunkTimestampSec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.oldestMsgInChunkTimestampSec = options.longs === String ? "0" : 0;
                }
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (typeof message.fileLength === "number")
                        object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                    else
                        object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    object.directPath = message.directPath;
                if (message.syncType != null && message.hasOwnProperty("syncType"))
                    object.syncType = options.enums === String ? $root.proto.Message.HistorySyncNotification.HistorySyncType[message.syncType] : message.syncType;
                if (message.chunkOrder != null && message.hasOwnProperty("chunkOrder"))
                    object.chunkOrder = message.chunkOrder;
                if (message.originalMessageId != null && message.hasOwnProperty("originalMessageId"))
                    object.originalMessageId = message.originalMessageId;
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = message.progress;
                if (message.oldestMsgInChunkTimestampSec != null && message.hasOwnProperty("oldestMsgInChunkTimestampSec"))
                    if (typeof message.oldestMsgInChunkTimestampSec === "number")
                        object.oldestMsgInChunkTimestampSec = options.longs === String ? String(message.oldestMsgInChunkTimestampSec) : message.oldestMsgInChunkTimestampSec;
                    else
                        object.oldestMsgInChunkTimestampSec = options.longs === String ? $util.Long.prototype.toString.call(message.oldestMsgInChunkTimestampSec) : options.longs === Number ? new $util.LongBits(message.oldestMsgInChunkTimestampSec.low >>> 0, message.oldestMsgInChunkTimestampSec.high >>> 0).toNumber() : message.oldestMsgInChunkTimestampSec;
                return object;
            };

            /**
             * Converts this HistorySyncNotification to JSON.
             * @function toJSON
             * @memberof proto.Message.HistorySyncNotification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HistorySyncNotification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * HistorySyncType enum.
             * @name proto.Message.HistorySyncNotification.HistorySyncType
             * @enum {number}
             * @property {number} INITIAL_BOOTSTRAP=0 INITIAL_BOOTSTRAP value
             * @property {number} INITIAL_STATUS_V3=1 INITIAL_STATUS_V3 value
             * @property {number} FULL=2 FULL value
             * @property {number} RECENT=3 RECENT value
             * @property {number} PUSH_NAME=4 PUSH_NAME value
             * @property {number} NON_BLOCKING_DATA=5 NON_BLOCKING_DATA value
             */
            HistorySyncNotification.HistorySyncType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INITIAL_BOOTSTRAP"] = 0;
                values[valuesById[1] = "INITIAL_STATUS_V3"] = 1;
                values[valuesById[2] = "FULL"] = 2;
                values[valuesById[3] = "RECENT"] = 3;
                values[valuesById[4] = "PUSH_NAME"] = 4;
                values[valuesById[5] = "NON_BLOCKING_DATA"] = 5;
                return values;
            })();

            return HistorySyncNotification;
        })();

        Message.ImageMessage = (function() {

            /**
             * Properties of an ImageMessage.
             * @memberof proto.Message
             * @interface IImageMessage
             * @property {string|null} [url] ImageMessage url
             * @property {string|null} [mimetype] ImageMessage mimetype
             * @property {string|null} [caption] ImageMessage caption
             * @property {Uint8Array|null} [fileSha256] ImageMessage fileSha256
             * @property {number|Long|null} [fileLength] ImageMessage fileLength
             * @property {number|null} [height] ImageMessage height
             * @property {number|null} [width] ImageMessage width
             * @property {Uint8Array|null} [mediaKey] ImageMessage mediaKey
             * @property {Uint8Array|null} [fileEncSha256] ImageMessage fileEncSha256
             * @property {Array.<proto.IInteractiveAnnotation>|null} [interactiveAnnotations] ImageMessage interactiveAnnotations
             * @property {string|null} [directPath] ImageMessage directPath
             * @property {number|Long|null} [mediaKeyTimestamp] ImageMessage mediaKeyTimestamp
             * @property {Uint8Array|null} [jpegThumbnail] ImageMessage jpegThumbnail
             * @property {proto.IContextInfo|null} [contextInfo] ImageMessage contextInfo
             * @property {Uint8Array|null} [firstScanSidecar] ImageMessage firstScanSidecar
             * @property {number|null} [firstScanLength] ImageMessage firstScanLength
             * @property {number|null} [experimentGroupId] ImageMessage experimentGroupId
             * @property {Uint8Array|null} [scansSidecar] ImageMessage scansSidecar
             * @property {Array.<number>|null} [scanLengths] ImageMessage scanLengths
             * @property {Uint8Array|null} [midQualityFileSha256] ImageMessage midQualityFileSha256
             * @property {Uint8Array|null} [midQualityFileEncSha256] ImageMessage midQualityFileEncSha256
             * @property {boolean|null} [viewOnce] ImageMessage viewOnce
             * @property {string|null} [thumbnailDirectPath] ImageMessage thumbnailDirectPath
             * @property {Uint8Array|null} [thumbnailSha256] ImageMessage thumbnailSha256
             * @property {Uint8Array|null} [thumbnailEncSha256] ImageMessage thumbnailEncSha256
             * @property {string|null} [staticUrl] ImageMessage staticUrl
             */

            /**
             * Constructs a new ImageMessage.
             * @memberof proto.Message
             * @classdesc Represents an ImageMessage.
             * @implements IImageMessage
             * @constructor
             * @param {proto.Message.IImageMessage=} [properties] Properties to set
             */
            function ImageMessage(properties) {
                this.interactiveAnnotations = [];
                this.scanLengths = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ImageMessage url.
             * @member {string} url
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.url = "";

            /**
             * ImageMessage mimetype.
             * @member {string} mimetype
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.mimetype = "";

            /**
             * ImageMessage caption.
             * @member {string} caption
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.caption = "";

            /**
             * ImageMessage fileSha256.
             * @member {Uint8Array} fileSha256
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.fileSha256 = $util.newBuffer([]);

            /**
             * ImageMessage fileLength.
             * @member {number|Long} fileLength
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ImageMessage height.
             * @member {number} height
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.height = 0;

            /**
             * ImageMessage width.
             * @member {number} width
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.width = 0;

            /**
             * ImageMessage mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.mediaKey = $util.newBuffer([]);

            /**
             * ImageMessage fileEncSha256.
             * @member {Uint8Array} fileEncSha256
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.fileEncSha256 = $util.newBuffer([]);

            /**
             * ImageMessage interactiveAnnotations.
             * @member {Array.<proto.IInteractiveAnnotation>} interactiveAnnotations
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.interactiveAnnotations = $util.emptyArray;

            /**
             * ImageMessage directPath.
             * @member {string} directPath
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.directPath = "";

            /**
             * ImageMessage mediaKeyTimestamp.
             * @member {number|Long} mediaKeyTimestamp
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ImageMessage jpegThumbnail.
             * @member {Uint8Array} jpegThumbnail
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.jpegThumbnail = $util.newBuffer([]);

            /**
             * ImageMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.contextInfo = null;

            /**
             * ImageMessage firstScanSidecar.
             * @member {Uint8Array} firstScanSidecar
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.firstScanSidecar = $util.newBuffer([]);

            /**
             * ImageMessage firstScanLength.
             * @member {number} firstScanLength
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.firstScanLength = 0;

            /**
             * ImageMessage experimentGroupId.
             * @member {number} experimentGroupId
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.experimentGroupId = 0;

            /**
             * ImageMessage scansSidecar.
             * @member {Uint8Array} scansSidecar
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.scansSidecar = $util.newBuffer([]);

            /**
             * ImageMessage scanLengths.
             * @member {Array.<number>} scanLengths
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.scanLengths = $util.emptyArray;

            /**
             * ImageMessage midQualityFileSha256.
             * @member {Uint8Array} midQualityFileSha256
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.midQualityFileSha256 = $util.newBuffer([]);

            /**
             * ImageMessage midQualityFileEncSha256.
             * @member {Uint8Array} midQualityFileEncSha256
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.midQualityFileEncSha256 = $util.newBuffer([]);

            /**
             * ImageMessage viewOnce.
             * @member {boolean} viewOnce
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.viewOnce = false;

            /**
             * ImageMessage thumbnailDirectPath.
             * @member {string} thumbnailDirectPath
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.thumbnailDirectPath = "";

            /**
             * ImageMessage thumbnailSha256.
             * @member {Uint8Array} thumbnailSha256
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.thumbnailSha256 = $util.newBuffer([]);

            /**
             * ImageMessage thumbnailEncSha256.
             * @member {Uint8Array} thumbnailEncSha256
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.thumbnailEncSha256 = $util.newBuffer([]);

            /**
             * ImageMessage staticUrl.
             * @member {string} staticUrl
             * @memberof proto.Message.ImageMessage
             * @instance
             */
            ImageMessage.prototype.staticUrl = "";

            /**
             * Creates a new ImageMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ImageMessage
             * @static
             * @param {proto.Message.IImageMessage=} [properties] Properties to set
             * @returns {proto.Message.ImageMessage} ImageMessage instance
             */
            ImageMessage.create = function create(properties) {
                return new ImageMessage(properties);
            };

            /**
             * Encodes the specified ImageMessage message. Does not implicitly {@link proto.Message.ImageMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ImageMessage
             * @static
             * @param {proto.Message.IImageMessage} message ImageMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimetype);
                if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.caption);
                if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fileSha256);
                if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.fileLength);
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.height);
                if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.width);
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.mediaKey);
                if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.fileEncSha256);
                if (message.interactiveAnnotations != null && message.interactiveAnnotations.length)
                    for (var i = 0; i < message.interactiveAnnotations.length; ++i)
                        $root.proto.InteractiveAnnotation.encode(message.interactiveAnnotations[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.directPath);
                if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.mediaKeyTimestamp);
                if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.firstScanSidecar != null && Object.hasOwnProperty.call(message, "firstScanSidecar"))
                    writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.firstScanSidecar);
                if (message.firstScanLength != null && Object.hasOwnProperty.call(message, "firstScanLength"))
                    writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.firstScanLength);
                if (message.experimentGroupId != null && Object.hasOwnProperty.call(message, "experimentGroupId"))
                    writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.experimentGroupId);
                if (message.scansSidecar != null && Object.hasOwnProperty.call(message, "scansSidecar"))
                    writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.scansSidecar);
                if (message.scanLengths != null && message.scanLengths.length)
                    for (var i = 0; i < message.scanLengths.length; ++i)
                        writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.scanLengths[i]);
                if (message.midQualityFileSha256 != null && Object.hasOwnProperty.call(message, "midQualityFileSha256"))
                    writer.uint32(/* id 23, wireType 2 =*/186).bytes(message.midQualityFileSha256);
                if (message.midQualityFileEncSha256 != null && Object.hasOwnProperty.call(message, "midQualityFileEncSha256"))
                    writer.uint32(/* id 24, wireType 2 =*/194).bytes(message.midQualityFileEncSha256);
                if (message.viewOnce != null && Object.hasOwnProperty.call(message, "viewOnce"))
                    writer.uint32(/* id 25, wireType 0 =*/200).bool(message.viewOnce);
                if (message.thumbnailDirectPath != null && Object.hasOwnProperty.call(message, "thumbnailDirectPath"))
                    writer.uint32(/* id 26, wireType 2 =*/210).string(message.thumbnailDirectPath);
                if (message.thumbnailSha256 != null && Object.hasOwnProperty.call(message, "thumbnailSha256"))
                    writer.uint32(/* id 27, wireType 2 =*/218).bytes(message.thumbnailSha256);
                if (message.thumbnailEncSha256 != null && Object.hasOwnProperty.call(message, "thumbnailEncSha256"))
                    writer.uint32(/* id 28, wireType 2 =*/226).bytes(message.thumbnailEncSha256);
                if (message.staticUrl != null && Object.hasOwnProperty.call(message, "staticUrl"))
                    writer.uint32(/* id 29, wireType 2 =*/234).string(message.staticUrl);
                return writer;
            };

            /**
             * Encodes the specified ImageMessage message, length delimited. Does not implicitly {@link proto.Message.ImageMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ImageMessage
             * @static
             * @param {proto.Message.IImageMessage} message ImageMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImageMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ImageMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ImageMessage} ImageMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ImageMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        message.mimetype = reader.string();
                        break;
                    case 3:
                        message.caption = reader.string();
                        break;
                    case 4:
                        message.fileSha256 = reader.bytes();
                        break;
                    case 5:
                        message.fileLength = reader.uint64();
                        break;
                    case 6:
                        message.height = reader.uint32();
                        break;
                    case 7:
                        message.width = reader.uint32();
                        break;
                    case 8:
                        message.mediaKey = reader.bytes();
                        break;
                    case 9:
                        message.fileEncSha256 = reader.bytes();
                        break;
                    case 10:
                        if (!(message.interactiveAnnotations && message.interactiveAnnotations.length))
                            message.interactiveAnnotations = [];
                        message.interactiveAnnotations.push($root.proto.InteractiveAnnotation.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        message.directPath = reader.string();
                        break;
                    case 12:
                        message.mediaKeyTimestamp = reader.int64();
                        break;
                    case 16:
                        message.jpegThumbnail = reader.bytes();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.firstScanSidecar = reader.bytes();
                        break;
                    case 19:
                        message.firstScanLength = reader.uint32();
                        break;
                    case 20:
                        message.experimentGroupId = reader.uint32();
                        break;
                    case 21:
                        message.scansSidecar = reader.bytes();
                        break;
                    case 22:
                        if (!(message.scanLengths && message.scanLengths.length))
                            message.scanLengths = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.scanLengths.push(reader.uint32());
                        } else
                            message.scanLengths.push(reader.uint32());
                        break;
                    case 23:
                        message.midQualityFileSha256 = reader.bytes();
                        break;
                    case 24:
                        message.midQualityFileEncSha256 = reader.bytes();
                        break;
                    case 25:
                        message.viewOnce = reader.bool();
                        break;
                    case 26:
                        message.thumbnailDirectPath = reader.string();
                        break;
                    case 27:
                        message.thumbnailSha256 = reader.bytes();
                        break;
                    case 28:
                        message.thumbnailEncSha256 = reader.bytes();
                        break;
                    case 29:
                        message.staticUrl = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImageMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ImageMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ImageMessage} ImageMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImageMessage message.
             * @function verify
             * @memberof proto.Message.ImageMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImageMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    if (!$util.isString(message.mimetype))
                        return "mimetype: string expected";
                if (message.caption != null && message.hasOwnProperty("caption"))
                    if (!$util.isString(message.caption))
                        return "caption: string expected";
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                        return "fileSha256: buffer expected";
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                        return "fileLength: integer|Long expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height))
                        return "height: integer expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                        return "fileEncSha256: buffer expected";
                if (message.interactiveAnnotations != null && message.hasOwnProperty("interactiveAnnotations")) {
                    if (!Array.isArray(message.interactiveAnnotations))
                        return "interactiveAnnotations: array expected";
                    for (var i = 0; i < message.interactiveAnnotations.length; ++i) {
                        var error = $root.proto.InteractiveAnnotation.verify(message.interactiveAnnotations[i]);
                        if (error)
                            return "interactiveAnnotations." + error;
                    }
                }
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    if (!$util.isString(message.directPath))
                        return "directPath: string expected";
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                        return "mediaKeyTimestamp: integer|Long expected";
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                        return "jpegThumbnail: buffer expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.firstScanSidecar != null && message.hasOwnProperty("firstScanSidecar"))
                    if (!(message.firstScanSidecar && typeof message.firstScanSidecar.length === "number" || $util.isString(message.firstScanSidecar)))
                        return "firstScanSidecar: buffer expected";
                if (message.firstScanLength != null && message.hasOwnProperty("firstScanLength"))
                    if (!$util.isInteger(message.firstScanLength))
                        return "firstScanLength: integer expected";
                if (message.experimentGroupId != null && message.hasOwnProperty("experimentGroupId"))
                    if (!$util.isInteger(message.experimentGroupId))
                        return "experimentGroupId: integer expected";
                if (message.scansSidecar != null && message.hasOwnProperty("scansSidecar"))
                    if (!(message.scansSidecar && typeof message.scansSidecar.length === "number" || $util.isString(message.scansSidecar)))
                        return "scansSidecar: buffer expected";
                if (message.scanLengths != null && message.hasOwnProperty("scanLengths")) {
                    if (!Array.isArray(message.scanLengths))
                        return "scanLengths: array expected";
                    for (var i = 0; i < message.scanLengths.length; ++i)
                        if (!$util.isInteger(message.scanLengths[i]))
                            return "scanLengths: integer[] expected";
                }
                if (message.midQualityFileSha256 != null && message.hasOwnProperty("midQualityFileSha256"))
                    if (!(message.midQualityFileSha256 && typeof message.midQualityFileSha256.length === "number" || $util.isString(message.midQualityFileSha256)))
                        return "midQualityFileSha256: buffer expected";
                if (message.midQualityFileEncSha256 != null && message.hasOwnProperty("midQualityFileEncSha256"))
                    if (!(message.midQualityFileEncSha256 && typeof message.midQualityFileEncSha256.length === "number" || $util.isString(message.midQualityFileEncSha256)))
                        return "midQualityFileEncSha256: buffer expected";
                if (message.viewOnce != null && message.hasOwnProperty("viewOnce"))
                    if (typeof message.viewOnce !== "boolean")
                        return "viewOnce: boolean expected";
                if (message.thumbnailDirectPath != null && message.hasOwnProperty("thumbnailDirectPath"))
                    if (!$util.isString(message.thumbnailDirectPath))
                        return "thumbnailDirectPath: string expected";
                if (message.thumbnailSha256 != null && message.hasOwnProperty("thumbnailSha256"))
                    if (!(message.thumbnailSha256 && typeof message.thumbnailSha256.length === "number" || $util.isString(message.thumbnailSha256)))
                        return "thumbnailSha256: buffer expected";
                if (message.thumbnailEncSha256 != null && message.hasOwnProperty("thumbnailEncSha256"))
                    if (!(message.thumbnailEncSha256 && typeof message.thumbnailEncSha256.length === "number" || $util.isString(message.thumbnailEncSha256)))
                        return "thumbnailEncSha256: buffer expected";
                if (message.staticUrl != null && message.hasOwnProperty("staticUrl"))
                    if (!$util.isString(message.staticUrl))
                        return "staticUrl: string expected";
                return null;
            };

            /**
             * Creates an ImageMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ImageMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ImageMessage} ImageMessage
             */
            ImageMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ImageMessage)
                    return object;
                var message = new $root.proto.Message.ImageMessage();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.mimetype != null)
                    message.mimetype = String(object.mimetype);
                if (object.caption != null)
                    message.caption = String(object.caption);
                if (object.fileSha256 != null)
                    if (typeof object.fileSha256 === "string")
                        $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                    else if (object.fileSha256.length)
                        message.fileSha256 = object.fileSha256;
                if (object.fileLength != null)
                    if ($util.Long)
                        (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                    else if (typeof object.fileLength === "string")
                        message.fileLength = parseInt(object.fileLength, 10);
                    else if (typeof object.fileLength === "number")
                        message.fileLength = object.fileLength;
                    else if (typeof object.fileLength === "object")
                        message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
                if (object.height != null)
                    message.height = object.height >>> 0;
                if (object.width != null)
                    message.width = object.width >>> 0;
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.fileEncSha256 != null)
                    if (typeof object.fileEncSha256 === "string")
                        $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                    else if (object.fileEncSha256.length)
                        message.fileEncSha256 = object.fileEncSha256;
                if (object.interactiveAnnotations) {
                    if (!Array.isArray(object.interactiveAnnotations))
                        throw TypeError(".proto.Message.ImageMessage.interactiveAnnotations: array expected");
                    message.interactiveAnnotations = [];
                    for (var i = 0; i < object.interactiveAnnotations.length; ++i) {
                        if (typeof object.interactiveAnnotations[i] !== "object")
                            throw TypeError(".proto.Message.ImageMessage.interactiveAnnotations: object expected");
                        message.interactiveAnnotations[i] = $root.proto.InteractiveAnnotation.fromObject(object.interactiveAnnotations[i]);
                    }
                }
                if (object.directPath != null)
                    message.directPath = String(object.directPath);
                if (object.mediaKeyTimestamp != null)
                    if ($util.Long)
                        (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                    else if (typeof object.mediaKeyTimestamp === "string")
                        message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                    else if (typeof object.mediaKeyTimestamp === "number")
                        message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                    else if (typeof object.mediaKeyTimestamp === "object")
                        message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
                if (object.jpegThumbnail != null)
                    if (typeof object.jpegThumbnail === "string")
                        $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                    else if (object.jpegThumbnail.length)
                        message.jpegThumbnail = object.jpegThumbnail;
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ImageMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.firstScanSidecar != null)
                    if (typeof object.firstScanSidecar === "string")
                        $util.base64.decode(object.firstScanSidecar, message.firstScanSidecar = $util.newBuffer($util.base64.length(object.firstScanSidecar)), 0);
                    else if (object.firstScanSidecar.length)
                        message.firstScanSidecar = object.firstScanSidecar;
                if (object.firstScanLength != null)
                    message.firstScanLength = object.firstScanLength >>> 0;
                if (object.experimentGroupId != null)
                    message.experimentGroupId = object.experimentGroupId >>> 0;
                if (object.scansSidecar != null)
                    if (typeof object.scansSidecar === "string")
                        $util.base64.decode(object.scansSidecar, message.scansSidecar = $util.newBuffer($util.base64.length(object.scansSidecar)), 0);
                    else if (object.scansSidecar.length)
                        message.scansSidecar = object.scansSidecar;
                if (object.scanLengths) {
                    if (!Array.isArray(object.scanLengths))
                        throw TypeError(".proto.Message.ImageMessage.scanLengths: array expected");
                    message.scanLengths = [];
                    for (var i = 0; i < object.scanLengths.length; ++i)
                        message.scanLengths[i] = object.scanLengths[i] >>> 0;
                }
                if (object.midQualityFileSha256 != null)
                    if (typeof object.midQualityFileSha256 === "string")
                        $util.base64.decode(object.midQualityFileSha256, message.midQualityFileSha256 = $util.newBuffer($util.base64.length(object.midQualityFileSha256)), 0);
                    else if (object.midQualityFileSha256.length)
                        message.midQualityFileSha256 = object.midQualityFileSha256;
                if (object.midQualityFileEncSha256 != null)
                    if (typeof object.midQualityFileEncSha256 === "string")
                        $util.base64.decode(object.midQualityFileEncSha256, message.midQualityFileEncSha256 = $util.newBuffer($util.base64.length(object.midQualityFileEncSha256)), 0);
                    else if (object.midQualityFileEncSha256.length)
                        message.midQualityFileEncSha256 = object.midQualityFileEncSha256;
                if (object.viewOnce != null)
                    message.viewOnce = Boolean(object.viewOnce);
                if (object.thumbnailDirectPath != null)
                    message.thumbnailDirectPath = String(object.thumbnailDirectPath);
                if (object.thumbnailSha256 != null)
                    if (typeof object.thumbnailSha256 === "string")
                        $util.base64.decode(object.thumbnailSha256, message.thumbnailSha256 = $util.newBuffer($util.base64.length(object.thumbnailSha256)), 0);
                    else if (object.thumbnailSha256.length)
                        message.thumbnailSha256 = object.thumbnailSha256;
                if (object.thumbnailEncSha256 != null)
                    if (typeof object.thumbnailEncSha256 === "string")
                        $util.base64.decode(object.thumbnailEncSha256, message.thumbnailEncSha256 = $util.newBuffer($util.base64.length(object.thumbnailEncSha256)), 0);
                    else if (object.thumbnailEncSha256.length)
                        message.thumbnailEncSha256 = object.thumbnailEncSha256;
                if (object.staticUrl != null)
                    message.staticUrl = String(object.staticUrl);
                return message;
            };

            /**
             * Creates a plain object from an ImageMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ImageMessage
             * @static
             * @param {proto.Message.ImageMessage} message ImageMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImageMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.interactiveAnnotations = [];
                    object.scanLengths = [];
                }
                if (options.defaults) {
                    object.url = "";
                    object.mimetype = "";
                    object.caption = "";
                    if (options.bytes === String)
                        object.fileSha256 = "";
                    else {
                        object.fileSha256 = [];
                        if (options.bytes !== Array)
                            object.fileSha256 = $util.newBuffer(object.fileSha256);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileLength = options.longs === String ? "0" : 0;
                    object.height = 0;
                    object.width = 0;
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    if (options.bytes === String)
                        object.fileEncSha256 = "";
                    else {
                        object.fileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                    }
                    object.directPath = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.jpegThumbnail = "";
                    else {
                        object.jpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                    }
                    object.contextInfo = null;
                    if (options.bytes === String)
                        object.firstScanSidecar = "";
                    else {
                        object.firstScanSidecar = [];
                        if (options.bytes !== Array)
                            object.firstScanSidecar = $util.newBuffer(object.firstScanSidecar);
                    }
                    object.firstScanLength = 0;
                    object.experimentGroupId = 0;
                    if (options.bytes === String)
                        object.scansSidecar = "";
                    else {
                        object.scansSidecar = [];
                        if (options.bytes !== Array)
                            object.scansSidecar = $util.newBuffer(object.scansSidecar);
                    }
                    if (options.bytes === String)
                        object.midQualityFileSha256 = "";
                    else {
                        object.midQualityFileSha256 = [];
                        if (options.bytes !== Array)
                            object.midQualityFileSha256 = $util.newBuffer(object.midQualityFileSha256);
                    }
                    if (options.bytes === String)
                        object.midQualityFileEncSha256 = "";
                    else {
                        object.midQualityFileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.midQualityFileEncSha256 = $util.newBuffer(object.midQualityFileEncSha256);
                    }
                    object.viewOnce = false;
                    object.thumbnailDirectPath = "";
                    if (options.bytes === String)
                        object.thumbnailSha256 = "";
                    else {
                        object.thumbnailSha256 = [];
                        if (options.bytes !== Array)
                            object.thumbnailSha256 = $util.newBuffer(object.thumbnailSha256);
                    }
                    if (options.bytes === String)
                        object.thumbnailEncSha256 = "";
                    else {
                        object.thumbnailEncSha256 = [];
                        if (options.bytes !== Array)
                            object.thumbnailEncSha256 = $util.newBuffer(object.thumbnailEncSha256);
                    }
                    object.staticUrl = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    object.mimetype = message.mimetype;
                if (message.caption != null && message.hasOwnProperty("caption"))
                    object.caption = message.caption;
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (typeof message.fileLength === "number")
                        object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                    else
                        object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
                if (message.height != null && message.hasOwnProperty("height"))
                    object.height = message.height;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = message.width;
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
                if (message.interactiveAnnotations && message.interactiveAnnotations.length) {
                    object.interactiveAnnotations = [];
                    for (var j = 0; j < message.interactiveAnnotations.length; ++j)
                        object.interactiveAnnotations[j] = $root.proto.InteractiveAnnotation.toObject(message.interactiveAnnotations[j], options);
                }
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    object.directPath = message.directPath;
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (typeof message.mediaKeyTimestamp === "number")
                        object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                    else
                        object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.firstScanSidecar != null && message.hasOwnProperty("firstScanSidecar"))
                    object.firstScanSidecar = options.bytes === String ? $util.base64.encode(message.firstScanSidecar, 0, message.firstScanSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.firstScanSidecar) : message.firstScanSidecar;
                if (message.firstScanLength != null && message.hasOwnProperty("firstScanLength"))
                    object.firstScanLength = message.firstScanLength;
                if (message.experimentGroupId != null && message.hasOwnProperty("experimentGroupId"))
                    object.experimentGroupId = message.experimentGroupId;
                if (message.scansSidecar != null && message.hasOwnProperty("scansSidecar"))
                    object.scansSidecar = options.bytes === String ? $util.base64.encode(message.scansSidecar, 0, message.scansSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.scansSidecar) : message.scansSidecar;
                if (message.scanLengths && message.scanLengths.length) {
                    object.scanLengths = [];
                    for (var j = 0; j < message.scanLengths.length; ++j)
                        object.scanLengths[j] = message.scanLengths[j];
                }
                if (message.midQualityFileSha256 != null && message.hasOwnProperty("midQualityFileSha256"))
                    object.midQualityFileSha256 = options.bytes === String ? $util.base64.encode(message.midQualityFileSha256, 0, message.midQualityFileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.midQualityFileSha256) : message.midQualityFileSha256;
                if (message.midQualityFileEncSha256 != null && message.hasOwnProperty("midQualityFileEncSha256"))
                    object.midQualityFileEncSha256 = options.bytes === String ? $util.base64.encode(message.midQualityFileEncSha256, 0, message.midQualityFileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.midQualityFileEncSha256) : message.midQualityFileEncSha256;
                if (message.viewOnce != null && message.hasOwnProperty("viewOnce"))
                    object.viewOnce = message.viewOnce;
                if (message.thumbnailDirectPath != null && message.hasOwnProperty("thumbnailDirectPath"))
                    object.thumbnailDirectPath = message.thumbnailDirectPath;
                if (message.thumbnailSha256 != null && message.hasOwnProperty("thumbnailSha256"))
                    object.thumbnailSha256 = options.bytes === String ? $util.base64.encode(message.thumbnailSha256, 0, message.thumbnailSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnailSha256) : message.thumbnailSha256;
                if (message.thumbnailEncSha256 != null && message.hasOwnProperty("thumbnailEncSha256"))
                    object.thumbnailEncSha256 = options.bytes === String ? $util.base64.encode(message.thumbnailEncSha256, 0, message.thumbnailEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnailEncSha256) : message.thumbnailEncSha256;
                if (message.staticUrl != null && message.hasOwnProperty("staticUrl"))
                    object.staticUrl = message.staticUrl;
                return object;
            };

            /**
             * Converts this ImageMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ImageMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImageMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ImageMessage;
        })();

        Message.InitialSecurityNotificationSettingSync = (function() {

            /**
             * Properties of an InitialSecurityNotificationSettingSync.
             * @memberof proto.Message
             * @interface IInitialSecurityNotificationSettingSync
             * @property {boolean|null} [securityNotificationEnabled] InitialSecurityNotificationSettingSync securityNotificationEnabled
             */

            /**
             * Constructs a new InitialSecurityNotificationSettingSync.
             * @memberof proto.Message
             * @classdesc Represents an InitialSecurityNotificationSettingSync.
             * @implements IInitialSecurityNotificationSettingSync
             * @constructor
             * @param {proto.Message.IInitialSecurityNotificationSettingSync=} [properties] Properties to set
             */
            function InitialSecurityNotificationSettingSync(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InitialSecurityNotificationSettingSync securityNotificationEnabled.
             * @member {boolean} securityNotificationEnabled
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @instance
             */
            InitialSecurityNotificationSettingSync.prototype.securityNotificationEnabled = false;

            /**
             * Creates a new InitialSecurityNotificationSettingSync instance using the specified properties.
             * @function create
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @static
             * @param {proto.Message.IInitialSecurityNotificationSettingSync=} [properties] Properties to set
             * @returns {proto.Message.InitialSecurityNotificationSettingSync} InitialSecurityNotificationSettingSync instance
             */
            InitialSecurityNotificationSettingSync.create = function create(properties) {
                return new InitialSecurityNotificationSettingSync(properties);
            };

            /**
             * Encodes the specified InitialSecurityNotificationSettingSync message. Does not implicitly {@link proto.Message.InitialSecurityNotificationSettingSync.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @static
             * @param {proto.Message.IInitialSecurityNotificationSettingSync} message InitialSecurityNotificationSettingSync message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InitialSecurityNotificationSettingSync.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.securityNotificationEnabled != null && Object.hasOwnProperty.call(message, "securityNotificationEnabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.securityNotificationEnabled);
                return writer;
            };

            /**
             * Encodes the specified InitialSecurityNotificationSettingSync message, length delimited. Does not implicitly {@link proto.Message.InitialSecurityNotificationSettingSync.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @static
             * @param {proto.Message.IInitialSecurityNotificationSettingSync} message InitialSecurityNotificationSettingSync message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InitialSecurityNotificationSettingSync.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InitialSecurityNotificationSettingSync message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.InitialSecurityNotificationSettingSync} InitialSecurityNotificationSettingSync
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InitialSecurityNotificationSettingSync.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InitialSecurityNotificationSettingSync();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.securityNotificationEnabled = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InitialSecurityNotificationSettingSync message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.InitialSecurityNotificationSettingSync} InitialSecurityNotificationSettingSync
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InitialSecurityNotificationSettingSync.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InitialSecurityNotificationSettingSync message.
             * @function verify
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InitialSecurityNotificationSettingSync.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.securityNotificationEnabled != null && message.hasOwnProperty("securityNotificationEnabled"))
                    if (typeof message.securityNotificationEnabled !== "boolean")
                        return "securityNotificationEnabled: boolean expected";
                return null;
            };

            /**
             * Creates an InitialSecurityNotificationSettingSync message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.InitialSecurityNotificationSettingSync} InitialSecurityNotificationSettingSync
             */
            InitialSecurityNotificationSettingSync.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.InitialSecurityNotificationSettingSync)
                    return object;
                var message = new $root.proto.Message.InitialSecurityNotificationSettingSync();
                if (object.securityNotificationEnabled != null)
                    message.securityNotificationEnabled = Boolean(object.securityNotificationEnabled);
                return message;
            };

            /**
             * Creates a plain object from an InitialSecurityNotificationSettingSync message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @static
             * @param {proto.Message.InitialSecurityNotificationSettingSync} message InitialSecurityNotificationSettingSync
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InitialSecurityNotificationSettingSync.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.securityNotificationEnabled = false;
                if (message.securityNotificationEnabled != null && message.hasOwnProperty("securityNotificationEnabled"))
                    object.securityNotificationEnabled = message.securityNotificationEnabled;
                return object;
            };

            /**
             * Converts this InitialSecurityNotificationSettingSync to JSON.
             * @function toJSON
             * @memberof proto.Message.InitialSecurityNotificationSettingSync
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InitialSecurityNotificationSettingSync.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return InitialSecurityNotificationSettingSync;
        })();

        Message.InteractiveMessage = (function() {

            /**
             * Properties of an InteractiveMessage.
             * @memberof proto.Message
             * @interface IInteractiveMessage
             * @property {proto.Message.InteractiveMessage.IHeader|null} [header] InteractiveMessage header
             * @property {proto.Message.InteractiveMessage.IBody|null} [body] InteractiveMessage body
             * @property {proto.Message.InteractiveMessage.IFooter|null} [footer] InteractiveMessage footer
             * @property {proto.IContextInfo|null} [contextInfo] InteractiveMessage contextInfo
             * @property {proto.Message.InteractiveMessage.IShopMessage|null} [shopStorefrontMessage] InteractiveMessage shopStorefrontMessage
             * @property {proto.Message.InteractiveMessage.ICollectionMessage|null} [collectionMessage] InteractiveMessage collectionMessage
             * @property {proto.Message.InteractiveMessage.INativeFlowMessage|null} [nativeFlowMessage] InteractiveMessage nativeFlowMessage
             */

            /**
             * Constructs a new InteractiveMessage.
             * @memberof proto.Message
             * @classdesc Represents an InteractiveMessage.
             * @implements IInteractiveMessage
             * @constructor
             * @param {proto.Message.IInteractiveMessage=} [properties] Properties to set
             */
            function InteractiveMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InteractiveMessage header.
             * @member {proto.Message.InteractiveMessage.IHeader|null|undefined} header
             * @memberof proto.Message.InteractiveMessage
             * @instance
             */
            InteractiveMessage.prototype.header = null;

            /**
             * InteractiveMessage body.
             * @member {proto.Message.InteractiveMessage.IBody|null|undefined} body
             * @memberof proto.Message.InteractiveMessage
             * @instance
             */
            InteractiveMessage.prototype.body = null;

            /**
             * InteractiveMessage footer.
             * @member {proto.Message.InteractiveMessage.IFooter|null|undefined} footer
             * @memberof proto.Message.InteractiveMessage
             * @instance
             */
            InteractiveMessage.prototype.footer = null;

            /**
             * InteractiveMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.InteractiveMessage
             * @instance
             */
            InteractiveMessage.prototype.contextInfo = null;

            /**
             * InteractiveMessage shopStorefrontMessage.
             * @member {proto.Message.InteractiveMessage.IShopMessage|null|undefined} shopStorefrontMessage
             * @memberof proto.Message.InteractiveMessage
             * @instance
             */
            InteractiveMessage.prototype.shopStorefrontMessage = null;

            /**
             * InteractiveMessage collectionMessage.
             * @member {proto.Message.InteractiveMessage.ICollectionMessage|null|undefined} collectionMessage
             * @memberof proto.Message.InteractiveMessage
             * @instance
             */
            InteractiveMessage.prototype.collectionMessage = null;

            /**
             * InteractiveMessage nativeFlowMessage.
             * @member {proto.Message.InteractiveMessage.INativeFlowMessage|null|undefined} nativeFlowMessage
             * @memberof proto.Message.InteractiveMessage
             * @instance
             */
            InteractiveMessage.prototype.nativeFlowMessage = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * InteractiveMessage interactiveMessage.
             * @member {"shopStorefrontMessage"|"collectionMessage"|"nativeFlowMessage"|undefined} interactiveMessage
             * @memberof proto.Message.InteractiveMessage
             * @instance
             */
            Object.defineProperty(InteractiveMessage.prototype, "interactiveMessage", {
                get: $util.oneOfGetter($oneOfFields = ["shopStorefrontMessage", "collectionMessage", "nativeFlowMessage"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new InteractiveMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.InteractiveMessage
             * @static
             * @param {proto.Message.IInteractiveMessage=} [properties] Properties to set
             * @returns {proto.Message.InteractiveMessage} InteractiveMessage instance
             */
            InteractiveMessage.create = function create(properties) {
                return new InteractiveMessage(properties);
            };

            /**
             * Encodes the specified InteractiveMessage message. Does not implicitly {@link proto.Message.InteractiveMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.InteractiveMessage
             * @static
             * @param {proto.Message.IInteractiveMessage} message InteractiveMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InteractiveMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    $root.proto.Message.InteractiveMessage.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    $root.proto.Message.InteractiveMessage.Body.encode(message.body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.footer != null && Object.hasOwnProperty.call(message, "footer"))
                    $root.proto.Message.InteractiveMessage.Footer.encode(message.footer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.shopStorefrontMessage != null && Object.hasOwnProperty.call(message, "shopStorefrontMessage"))
                    $root.proto.Message.InteractiveMessage.ShopMessage.encode(message.shopStorefrontMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.collectionMessage != null && Object.hasOwnProperty.call(message, "collectionMessage"))
                    $root.proto.Message.InteractiveMessage.CollectionMessage.encode(message.collectionMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.nativeFlowMessage != null && Object.hasOwnProperty.call(message, "nativeFlowMessage"))
                    $root.proto.Message.InteractiveMessage.NativeFlowMessage.encode(message.nativeFlowMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InteractiveMessage message, length delimited. Does not implicitly {@link proto.Message.InteractiveMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.InteractiveMessage
             * @static
             * @param {proto.Message.IInteractiveMessage} message InteractiveMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InteractiveMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InteractiveMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.InteractiveMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.InteractiveMessage} InteractiveMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InteractiveMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = $root.proto.Message.InteractiveMessage.Header.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.body = $root.proto.Message.InteractiveMessage.Body.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.footer = $root.proto.Message.InteractiveMessage.Footer.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.shopStorefrontMessage = $root.proto.Message.InteractiveMessage.ShopMessage.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.collectionMessage = $root.proto.Message.InteractiveMessage.CollectionMessage.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.nativeFlowMessage = $root.proto.Message.InteractiveMessage.NativeFlowMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InteractiveMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.InteractiveMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.InteractiveMessage} InteractiveMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InteractiveMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InteractiveMessage message.
             * @function verify
             * @memberof proto.Message.InteractiveMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InteractiveMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.proto.Message.InteractiveMessage.Header.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.body != null && message.hasOwnProperty("body")) {
                    var error = $root.proto.Message.InteractiveMessage.Body.verify(message.body);
                    if (error)
                        return "body." + error;
                }
                if (message.footer != null && message.hasOwnProperty("footer")) {
                    var error = $root.proto.Message.InteractiveMessage.Footer.verify(message.footer);
                    if (error)
                        return "footer." + error;
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.shopStorefrontMessage != null && message.hasOwnProperty("shopStorefrontMessage")) {
                    properties.interactiveMessage = 1;
                    {
                        var error = $root.proto.Message.InteractiveMessage.ShopMessage.verify(message.shopStorefrontMessage);
                        if (error)
                            return "shopStorefrontMessage." + error;
                    }
                }
                if (message.collectionMessage != null && message.hasOwnProperty("collectionMessage")) {
                    if (properties.interactiveMessage === 1)
                        return "interactiveMessage: multiple values";
                    properties.interactiveMessage = 1;
                    {
                        var error = $root.proto.Message.InteractiveMessage.CollectionMessage.verify(message.collectionMessage);
                        if (error)
                            return "collectionMessage." + error;
                    }
                }
                if (message.nativeFlowMessage != null && message.hasOwnProperty("nativeFlowMessage")) {
                    if (properties.interactiveMessage === 1)
                        return "interactiveMessage: multiple values";
                    properties.interactiveMessage = 1;
                    {
                        var error = $root.proto.Message.InteractiveMessage.NativeFlowMessage.verify(message.nativeFlowMessage);
                        if (error)
                            return "nativeFlowMessage." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an InteractiveMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.InteractiveMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.InteractiveMessage} InteractiveMessage
             */
            InteractiveMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.InteractiveMessage)
                    return object;
                var message = new $root.proto.Message.InteractiveMessage();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".proto.Message.InteractiveMessage.header: object expected");
                    message.header = $root.proto.Message.InteractiveMessage.Header.fromObject(object.header);
                }
                if (object.body != null) {
                    if (typeof object.body !== "object")
                        throw TypeError(".proto.Message.InteractiveMessage.body: object expected");
                    message.body = $root.proto.Message.InteractiveMessage.Body.fromObject(object.body);
                }
                if (object.footer != null) {
                    if (typeof object.footer !== "object")
                        throw TypeError(".proto.Message.InteractiveMessage.footer: object expected");
                    message.footer = $root.proto.Message.InteractiveMessage.Footer.fromObject(object.footer);
                }
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.InteractiveMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.shopStorefrontMessage != null) {
                    if (typeof object.shopStorefrontMessage !== "object")
                        throw TypeError(".proto.Message.InteractiveMessage.shopStorefrontMessage: object expected");
                    message.shopStorefrontMessage = $root.proto.Message.InteractiveMessage.ShopMessage.fromObject(object.shopStorefrontMessage);
                }
                if (object.collectionMessage != null) {
                    if (typeof object.collectionMessage !== "object")
                        throw TypeError(".proto.Message.InteractiveMessage.collectionMessage: object expected");
                    message.collectionMessage = $root.proto.Message.InteractiveMessage.CollectionMessage.fromObject(object.collectionMessage);
                }
                if (object.nativeFlowMessage != null) {
                    if (typeof object.nativeFlowMessage !== "object")
                        throw TypeError(".proto.Message.InteractiveMessage.nativeFlowMessage: object expected");
                    message.nativeFlowMessage = $root.proto.Message.InteractiveMessage.NativeFlowMessage.fromObject(object.nativeFlowMessage);
                }
                return message;
            };

            /**
             * Creates a plain object from an InteractiveMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.InteractiveMessage
             * @static
             * @param {proto.Message.InteractiveMessage} message InteractiveMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InteractiveMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.header = null;
                    object.body = null;
                    object.footer = null;
                    object.contextInfo = null;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.proto.Message.InteractiveMessage.Header.toObject(message.header, options);
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = $root.proto.Message.InteractiveMessage.Body.toObject(message.body, options);
                if (message.footer != null && message.hasOwnProperty("footer"))
                    object.footer = $root.proto.Message.InteractiveMessage.Footer.toObject(message.footer, options);
                if (message.shopStorefrontMessage != null && message.hasOwnProperty("shopStorefrontMessage")) {
                    object.shopStorefrontMessage = $root.proto.Message.InteractiveMessage.ShopMessage.toObject(message.shopStorefrontMessage, options);
                    if (options.oneofs)
                        object.interactiveMessage = "shopStorefrontMessage";
                }
                if (message.collectionMessage != null && message.hasOwnProperty("collectionMessage")) {
                    object.collectionMessage = $root.proto.Message.InteractiveMessage.CollectionMessage.toObject(message.collectionMessage, options);
                    if (options.oneofs)
                        object.interactiveMessage = "collectionMessage";
                }
                if (message.nativeFlowMessage != null && message.hasOwnProperty("nativeFlowMessage")) {
                    object.nativeFlowMessage = $root.proto.Message.InteractiveMessage.NativeFlowMessage.toObject(message.nativeFlowMessage, options);
                    if (options.oneofs)
                        object.interactiveMessage = "nativeFlowMessage";
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this InteractiveMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.InteractiveMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InteractiveMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            InteractiveMessage.Body = (function() {

                /**
                 * Properties of a Body.
                 * @memberof proto.Message.InteractiveMessage
                 * @interface IBody
                 * @property {string|null} [text] Body text
                 */

                /**
                 * Constructs a new Body.
                 * @memberof proto.Message.InteractiveMessage
                 * @classdesc Represents a Body.
                 * @implements IBody
                 * @constructor
                 * @param {proto.Message.InteractiveMessage.IBody=} [properties] Properties to set
                 */
                function Body(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Body text.
                 * @member {string} text
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @instance
                 */
                Body.prototype.text = "";

                /**
                 * Creates a new Body instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @static
                 * @param {proto.Message.InteractiveMessage.IBody=} [properties] Properties to set
                 * @returns {proto.Message.InteractiveMessage.Body} Body instance
                 */
                Body.create = function create(properties) {
                    return new Body(properties);
                };

                /**
                 * Encodes the specified Body message. Does not implicitly {@link proto.Message.InteractiveMessage.Body.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @static
                 * @param {proto.Message.InteractiveMessage.IBody} message Body message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Body.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                    return writer;
                };

                /**
                 * Encodes the specified Body message, length delimited. Does not implicitly {@link proto.Message.InteractiveMessage.Body.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @static
                 * @param {proto.Message.InteractiveMessage.IBody} message Body message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Body.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Body message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.InteractiveMessage.Body} Body
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Body.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveMessage.Body();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Body message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.InteractiveMessage.Body} Body
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Body.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Body message.
                 * @function verify
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Body.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.text != null && message.hasOwnProperty("text"))
                        if (!$util.isString(message.text))
                            return "text: string expected";
                    return null;
                };

                /**
                 * Creates a Body message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.InteractiveMessage.Body} Body
                 */
                Body.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.InteractiveMessage.Body)
                        return object;
                    var message = new $root.proto.Message.InteractiveMessage.Body();
                    if (object.text != null)
                        message.text = String(object.text);
                    return message;
                };

                /**
                 * Creates a plain object from a Body message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @static
                 * @param {proto.Message.InteractiveMessage.Body} message Body
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Body.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.text = "";
                    if (message.text != null && message.hasOwnProperty("text"))
                        object.text = message.text;
                    return object;
                };

                /**
                 * Converts this Body to JSON.
                 * @function toJSON
                 * @memberof proto.Message.InteractiveMessage.Body
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Body.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Body;
            })();

            InteractiveMessage.CollectionMessage = (function() {

                /**
                 * Properties of a CollectionMessage.
                 * @memberof proto.Message.InteractiveMessage
                 * @interface ICollectionMessage
                 * @property {string|null} [bizJid] CollectionMessage bizJid
                 * @property {string|null} [id] CollectionMessage id
                 * @property {number|null} [messageVersion] CollectionMessage messageVersion
                 */

                /**
                 * Constructs a new CollectionMessage.
                 * @memberof proto.Message.InteractiveMessage
                 * @classdesc Represents a CollectionMessage.
                 * @implements ICollectionMessage
                 * @constructor
                 * @param {proto.Message.InteractiveMessage.ICollectionMessage=} [properties] Properties to set
                 */
                function CollectionMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CollectionMessage bizJid.
                 * @member {string} bizJid
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @instance
                 */
                CollectionMessage.prototype.bizJid = "";

                /**
                 * CollectionMessage id.
                 * @member {string} id
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @instance
                 */
                CollectionMessage.prototype.id = "";

                /**
                 * CollectionMessage messageVersion.
                 * @member {number} messageVersion
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @instance
                 */
                CollectionMessage.prototype.messageVersion = 0;

                /**
                 * Creates a new CollectionMessage instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.ICollectionMessage=} [properties] Properties to set
                 * @returns {proto.Message.InteractiveMessage.CollectionMessage} CollectionMessage instance
                 */
                CollectionMessage.create = function create(properties) {
                    return new CollectionMessage(properties);
                };

                /**
                 * Encodes the specified CollectionMessage message. Does not implicitly {@link proto.Message.InteractiveMessage.CollectionMessage.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.ICollectionMessage} message CollectionMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CollectionMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bizJid != null && Object.hasOwnProperty.call(message, "bizJid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.bizJid);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                    if (message.messageVersion != null && Object.hasOwnProperty.call(message, "messageVersion"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.messageVersion);
                    return writer;
                };

                /**
                 * Encodes the specified CollectionMessage message, length delimited. Does not implicitly {@link proto.Message.InteractiveMessage.CollectionMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.ICollectionMessage} message CollectionMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CollectionMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CollectionMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.InteractiveMessage.CollectionMessage} CollectionMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CollectionMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveMessage.CollectionMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bizJid = reader.string();
                            break;
                        case 2:
                            message.id = reader.string();
                            break;
                        case 3:
                            message.messageVersion = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CollectionMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.InteractiveMessage.CollectionMessage} CollectionMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CollectionMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CollectionMessage message.
                 * @function verify
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CollectionMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bizJid != null && message.hasOwnProperty("bizJid"))
                        if (!$util.isString(message.bizJid))
                            return "bizJid: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.messageVersion != null && message.hasOwnProperty("messageVersion"))
                        if (!$util.isInteger(message.messageVersion))
                            return "messageVersion: integer expected";
                    return null;
                };

                /**
                 * Creates a CollectionMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.InteractiveMessage.CollectionMessage} CollectionMessage
                 */
                CollectionMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.InteractiveMessage.CollectionMessage)
                        return object;
                    var message = new $root.proto.Message.InteractiveMessage.CollectionMessage();
                    if (object.bizJid != null)
                        message.bizJid = String(object.bizJid);
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.messageVersion != null)
                        message.messageVersion = object.messageVersion | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a CollectionMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.CollectionMessage} message CollectionMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CollectionMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.bizJid = "";
                        object.id = "";
                        object.messageVersion = 0;
                    }
                    if (message.bizJid != null && message.hasOwnProperty("bizJid"))
                        object.bizJid = message.bizJid;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.messageVersion != null && message.hasOwnProperty("messageVersion"))
                        object.messageVersion = message.messageVersion;
                    return object;
                };

                /**
                 * Converts this CollectionMessage to JSON.
                 * @function toJSON
                 * @memberof proto.Message.InteractiveMessage.CollectionMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CollectionMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CollectionMessage;
            })();

            InteractiveMessage.Footer = (function() {

                /**
                 * Properties of a Footer.
                 * @memberof proto.Message.InteractiveMessage
                 * @interface IFooter
                 * @property {string|null} [text] Footer text
                 */

                /**
                 * Constructs a new Footer.
                 * @memberof proto.Message.InteractiveMessage
                 * @classdesc Represents a Footer.
                 * @implements IFooter
                 * @constructor
                 * @param {proto.Message.InteractiveMessage.IFooter=} [properties] Properties to set
                 */
                function Footer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Footer text.
                 * @member {string} text
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @instance
                 */
                Footer.prototype.text = "";

                /**
                 * Creates a new Footer instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @static
                 * @param {proto.Message.InteractiveMessage.IFooter=} [properties] Properties to set
                 * @returns {proto.Message.InteractiveMessage.Footer} Footer instance
                 */
                Footer.create = function create(properties) {
                    return new Footer(properties);
                };

                /**
                 * Encodes the specified Footer message. Does not implicitly {@link proto.Message.InteractiveMessage.Footer.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @static
                 * @param {proto.Message.InteractiveMessage.IFooter} message Footer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Footer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                    return writer;
                };

                /**
                 * Encodes the specified Footer message, length delimited. Does not implicitly {@link proto.Message.InteractiveMessage.Footer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @static
                 * @param {proto.Message.InteractiveMessage.IFooter} message Footer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Footer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Footer message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.InteractiveMessage.Footer} Footer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Footer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveMessage.Footer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Footer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.InteractiveMessage.Footer} Footer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Footer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Footer message.
                 * @function verify
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Footer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.text != null && message.hasOwnProperty("text"))
                        if (!$util.isString(message.text))
                            return "text: string expected";
                    return null;
                };

                /**
                 * Creates a Footer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.InteractiveMessage.Footer} Footer
                 */
                Footer.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.InteractiveMessage.Footer)
                        return object;
                    var message = new $root.proto.Message.InteractiveMessage.Footer();
                    if (object.text != null)
                        message.text = String(object.text);
                    return message;
                };

                /**
                 * Creates a plain object from a Footer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @static
                 * @param {proto.Message.InteractiveMessage.Footer} message Footer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Footer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.text = "";
                    if (message.text != null && message.hasOwnProperty("text"))
                        object.text = message.text;
                    return object;
                };

                /**
                 * Converts this Footer to JSON.
                 * @function toJSON
                 * @memberof proto.Message.InteractiveMessage.Footer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Footer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Footer;
            })();

            InteractiveMessage.Header = (function() {

                /**
                 * Properties of a Header.
                 * @memberof proto.Message.InteractiveMessage
                 * @interface IHeader
                 * @property {string|null} [title] Header title
                 * @property {string|null} [subtitle] Header subtitle
                 * @property {boolean|null} [hasMediaAttachment] Header hasMediaAttachment
                 * @property {proto.Message.IDocumentMessage|null} [documentMessage] Header documentMessage
                 * @property {proto.Message.IImageMessage|null} [imageMessage] Header imageMessage
                 * @property {Uint8Array|null} [jpegThumbnail] Header jpegThumbnail
                 * @property {proto.Message.IVideoMessage|null} [videoMessage] Header videoMessage
                 */

                /**
                 * Constructs a new Header.
                 * @memberof proto.Message.InteractiveMessage
                 * @classdesc Represents a Header.
                 * @implements IHeader
                 * @constructor
                 * @param {proto.Message.InteractiveMessage.IHeader=} [properties] Properties to set
                 */
                function Header(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Header title.
                 * @member {string} title
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 */
                Header.prototype.title = "";

                /**
                 * Header subtitle.
                 * @member {string} subtitle
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 */
                Header.prototype.subtitle = "";

                /**
                 * Header hasMediaAttachment.
                 * @member {boolean} hasMediaAttachment
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 */
                Header.prototype.hasMediaAttachment = false;

                /**
                 * Header documentMessage.
                 * @member {proto.Message.IDocumentMessage|null|undefined} documentMessage
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 */
                Header.prototype.documentMessage = null;

                /**
                 * Header imageMessage.
                 * @member {proto.Message.IImageMessage|null|undefined} imageMessage
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 */
                Header.prototype.imageMessage = null;

                /**
                 * Header jpegThumbnail.
                 * @member {Uint8Array|null|undefined} jpegThumbnail
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 */
                Header.prototype.jpegThumbnail = null;

                /**
                 * Header videoMessage.
                 * @member {proto.Message.IVideoMessage|null|undefined} videoMessage
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 */
                Header.prototype.videoMessage = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Header media.
                 * @member {"documentMessage"|"imageMessage"|"jpegThumbnail"|"videoMessage"|undefined} media
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 */
                Object.defineProperty(Header.prototype, "media", {
                    get: $util.oneOfGetter($oneOfFields = ["documentMessage", "imageMessage", "jpegThumbnail", "videoMessage"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Header instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @static
                 * @param {proto.Message.InteractiveMessage.IHeader=} [properties] Properties to set
                 * @returns {proto.Message.InteractiveMessage.Header} Header instance
                 */
                Header.create = function create(properties) {
                    return new Header(properties);
                };

                /**
                 * Encodes the specified Header message. Does not implicitly {@link proto.Message.InteractiveMessage.Header.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @static
                 * @param {proto.Message.InteractiveMessage.IHeader} message Header message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Header.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                    if (message.subtitle != null && Object.hasOwnProperty.call(message, "subtitle"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.subtitle);
                    if (message.documentMessage != null && Object.hasOwnProperty.call(message, "documentMessage"))
                        $root.proto.Message.DocumentMessage.encode(message.documentMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.imageMessage != null && Object.hasOwnProperty.call(message, "imageMessage"))
                        $root.proto.Message.ImageMessage.encode(message.imageMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.hasMediaAttachment != null && Object.hasOwnProperty.call(message, "hasMediaAttachment"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasMediaAttachment);
                    if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.jpegThumbnail);
                    if (message.videoMessage != null && Object.hasOwnProperty.call(message, "videoMessage"))
                        $root.proto.Message.VideoMessage.encode(message.videoMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Header message, length delimited. Does not implicitly {@link proto.Message.InteractiveMessage.Header.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @static
                 * @param {proto.Message.InteractiveMessage.IHeader} message Header message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Header.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Header message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.InteractiveMessage.Header} Header
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Header.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveMessage.Header();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.title = reader.string();
                            break;
                        case 2:
                            message.subtitle = reader.string();
                            break;
                        case 5:
                            message.hasMediaAttachment = reader.bool();
                            break;
                        case 3:
                            message.documentMessage = $root.proto.Message.DocumentMessage.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.imageMessage = $root.proto.Message.ImageMessage.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.jpegThumbnail = reader.bytes();
                            break;
                        case 7:
                            message.videoMessage = $root.proto.Message.VideoMessage.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Header message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.InteractiveMessage.Header} Header
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Header.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Header message.
                 * @function verify
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Header.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.subtitle != null && message.hasOwnProperty("subtitle"))
                        if (!$util.isString(message.subtitle))
                            return "subtitle: string expected";
                    if (message.hasMediaAttachment != null && message.hasOwnProperty("hasMediaAttachment"))
                        if (typeof message.hasMediaAttachment !== "boolean")
                            return "hasMediaAttachment: boolean expected";
                    if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                        properties.media = 1;
                        {
                            var error = $root.proto.Message.DocumentMessage.verify(message.documentMessage);
                            if (error)
                                return "documentMessage." + error;
                        }
                    }
                    if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                        if (properties.media === 1)
                            return "media: multiple values";
                        properties.media = 1;
                        {
                            var error = $root.proto.Message.ImageMessage.verify(message.imageMessage);
                            if (error)
                                return "imageMessage." + error;
                        }
                    }
                    if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail")) {
                        if (properties.media === 1)
                            return "media: multiple values";
                        properties.media = 1;
                        if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                            return "jpegThumbnail: buffer expected";
                    }
                    if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                        if (properties.media === 1)
                            return "media: multiple values";
                        properties.media = 1;
                        {
                            var error = $root.proto.Message.VideoMessage.verify(message.videoMessage);
                            if (error)
                                return "videoMessage." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Header message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.InteractiveMessage.Header} Header
                 */
                Header.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.InteractiveMessage.Header)
                        return object;
                    var message = new $root.proto.Message.InteractiveMessage.Header();
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.subtitle != null)
                        message.subtitle = String(object.subtitle);
                    if (object.hasMediaAttachment != null)
                        message.hasMediaAttachment = Boolean(object.hasMediaAttachment);
                    if (object.documentMessage != null) {
                        if (typeof object.documentMessage !== "object")
                            throw TypeError(".proto.Message.InteractiveMessage.Header.documentMessage: object expected");
                        message.documentMessage = $root.proto.Message.DocumentMessage.fromObject(object.documentMessage);
                    }
                    if (object.imageMessage != null) {
                        if (typeof object.imageMessage !== "object")
                            throw TypeError(".proto.Message.InteractiveMessage.Header.imageMessage: object expected");
                        message.imageMessage = $root.proto.Message.ImageMessage.fromObject(object.imageMessage);
                    }
                    if (object.jpegThumbnail != null)
                        if (typeof object.jpegThumbnail === "string")
                            $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                        else if (object.jpegThumbnail.length)
                            message.jpegThumbnail = object.jpegThumbnail;
                    if (object.videoMessage != null) {
                        if (typeof object.videoMessage !== "object")
                            throw TypeError(".proto.Message.InteractiveMessage.Header.videoMessage: object expected");
                        message.videoMessage = $root.proto.Message.VideoMessage.fromObject(object.videoMessage);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Header message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @static
                 * @param {proto.Message.InteractiveMessage.Header} message Header
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Header.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.title = "";
                        object.subtitle = "";
                        object.hasMediaAttachment = false;
                    }
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.subtitle != null && message.hasOwnProperty("subtitle"))
                        object.subtitle = message.subtitle;
                    if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                        object.documentMessage = $root.proto.Message.DocumentMessage.toObject(message.documentMessage, options);
                        if (options.oneofs)
                            object.media = "documentMessage";
                    }
                    if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                        object.imageMessage = $root.proto.Message.ImageMessage.toObject(message.imageMessage, options);
                        if (options.oneofs)
                            object.media = "imageMessage";
                    }
                    if (message.hasMediaAttachment != null && message.hasOwnProperty("hasMediaAttachment"))
                        object.hasMediaAttachment = message.hasMediaAttachment;
                    if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail")) {
                        object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                        if (options.oneofs)
                            object.media = "jpegThumbnail";
                    }
                    if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                        object.videoMessage = $root.proto.Message.VideoMessage.toObject(message.videoMessage, options);
                        if (options.oneofs)
                            object.media = "videoMessage";
                    }
                    return object;
                };

                /**
                 * Converts this Header to JSON.
                 * @function toJSON
                 * @memberof proto.Message.InteractiveMessage.Header
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Header.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Header;
            })();

            InteractiveMessage.NativeFlowMessage = (function() {

                /**
                 * Properties of a NativeFlowMessage.
                 * @memberof proto.Message.InteractiveMessage
                 * @interface INativeFlowMessage
                 * @property {Array.<proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton>|null} [buttons] NativeFlowMessage buttons
                 * @property {string|null} [messageParamsJson] NativeFlowMessage messageParamsJson
                 * @property {number|null} [messageVersion] NativeFlowMessage messageVersion
                 */

                /**
                 * Constructs a new NativeFlowMessage.
                 * @memberof proto.Message.InteractiveMessage
                 * @classdesc Represents a NativeFlowMessage.
                 * @implements INativeFlowMessage
                 * @constructor
                 * @param {proto.Message.InteractiveMessage.INativeFlowMessage=} [properties] Properties to set
                 */
                function NativeFlowMessage(properties) {
                    this.buttons = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NativeFlowMessage buttons.
                 * @member {Array.<proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton>} buttons
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @instance
                 */
                NativeFlowMessage.prototype.buttons = $util.emptyArray;

                /**
                 * NativeFlowMessage messageParamsJson.
                 * @member {string} messageParamsJson
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @instance
                 */
                NativeFlowMessage.prototype.messageParamsJson = "";

                /**
                 * NativeFlowMessage messageVersion.
                 * @member {number} messageVersion
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @instance
                 */
                NativeFlowMessage.prototype.messageVersion = 0;

                /**
                 * Creates a new NativeFlowMessage instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.INativeFlowMessage=} [properties] Properties to set
                 * @returns {proto.Message.InteractiveMessage.NativeFlowMessage} NativeFlowMessage instance
                 */
                NativeFlowMessage.create = function create(properties) {
                    return new NativeFlowMessage(properties);
                };

                /**
                 * Encodes the specified NativeFlowMessage message. Does not implicitly {@link proto.Message.InteractiveMessage.NativeFlowMessage.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.INativeFlowMessage} message NativeFlowMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NativeFlowMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.buttons != null && message.buttons.length)
                        for (var i = 0; i < message.buttons.length; ++i)
                            $root.proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.encode(message.buttons[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.messageParamsJson != null && Object.hasOwnProperty.call(message, "messageParamsJson"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageParamsJson);
                    if (message.messageVersion != null && Object.hasOwnProperty.call(message, "messageVersion"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.messageVersion);
                    return writer;
                };

                /**
                 * Encodes the specified NativeFlowMessage message, length delimited. Does not implicitly {@link proto.Message.InteractiveMessage.NativeFlowMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.INativeFlowMessage} message NativeFlowMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NativeFlowMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NativeFlowMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.InteractiveMessage.NativeFlowMessage} NativeFlowMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NativeFlowMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveMessage.NativeFlowMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.buttons && message.buttons.length))
                                message.buttons = [];
                            message.buttons.push($root.proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.messageParamsJson = reader.string();
                            break;
                        case 3:
                            message.messageVersion = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NativeFlowMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.InteractiveMessage.NativeFlowMessage} NativeFlowMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NativeFlowMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NativeFlowMessage message.
                 * @function verify
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NativeFlowMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.buttons != null && message.hasOwnProperty("buttons")) {
                        if (!Array.isArray(message.buttons))
                            return "buttons: array expected";
                        for (var i = 0; i < message.buttons.length; ++i) {
                            var error = $root.proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.verify(message.buttons[i]);
                            if (error)
                                return "buttons." + error;
                        }
                    }
                    if (message.messageParamsJson != null && message.hasOwnProperty("messageParamsJson"))
                        if (!$util.isString(message.messageParamsJson))
                            return "messageParamsJson: string expected";
                    if (message.messageVersion != null && message.hasOwnProperty("messageVersion"))
                        if (!$util.isInteger(message.messageVersion))
                            return "messageVersion: integer expected";
                    return null;
                };

                /**
                 * Creates a NativeFlowMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.InteractiveMessage.NativeFlowMessage} NativeFlowMessage
                 */
                NativeFlowMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.InteractiveMessage.NativeFlowMessage)
                        return object;
                    var message = new $root.proto.Message.InteractiveMessage.NativeFlowMessage();
                    if (object.buttons) {
                        if (!Array.isArray(object.buttons))
                            throw TypeError(".proto.Message.InteractiveMessage.NativeFlowMessage.buttons: array expected");
                        message.buttons = [];
                        for (var i = 0; i < object.buttons.length; ++i) {
                            if (typeof object.buttons[i] !== "object")
                                throw TypeError(".proto.Message.InteractiveMessage.NativeFlowMessage.buttons: object expected");
                            message.buttons[i] = $root.proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.fromObject(object.buttons[i]);
                        }
                    }
                    if (object.messageParamsJson != null)
                        message.messageParamsJson = String(object.messageParamsJson);
                    if (object.messageVersion != null)
                        message.messageVersion = object.messageVersion | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a NativeFlowMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.NativeFlowMessage} message NativeFlowMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NativeFlowMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.buttons = [];
                    if (options.defaults) {
                        object.messageParamsJson = "";
                        object.messageVersion = 0;
                    }
                    if (message.buttons && message.buttons.length) {
                        object.buttons = [];
                        for (var j = 0; j < message.buttons.length; ++j)
                            object.buttons[j] = $root.proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.toObject(message.buttons[j], options);
                    }
                    if (message.messageParamsJson != null && message.hasOwnProperty("messageParamsJson"))
                        object.messageParamsJson = message.messageParamsJson;
                    if (message.messageVersion != null && message.hasOwnProperty("messageVersion"))
                        object.messageVersion = message.messageVersion;
                    return object;
                };

                /**
                 * Converts this NativeFlowMessage to JSON.
                 * @function toJSON
                 * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NativeFlowMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                NativeFlowMessage.NativeFlowButton = (function() {

                    /**
                     * Properties of a NativeFlowButton.
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                     * @interface INativeFlowButton
                     * @property {string|null} [name] NativeFlowButton name
                     * @property {string|null} [buttonParamsJson] NativeFlowButton buttonParamsJson
                     */

                    /**
                     * Constructs a new NativeFlowButton.
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage
                     * @classdesc Represents a NativeFlowButton.
                     * @implements INativeFlowButton
                     * @constructor
                     * @param {proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton=} [properties] Properties to set
                     */
                    function NativeFlowButton(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * NativeFlowButton name.
                     * @member {string} name
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @instance
                     */
                    NativeFlowButton.prototype.name = "";

                    /**
                     * NativeFlowButton buttonParamsJson.
                     * @member {string} buttonParamsJson
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @instance
                     */
                    NativeFlowButton.prototype.buttonParamsJson = "";

                    /**
                     * Creates a new NativeFlowButton instance using the specified properties.
                     * @function create
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @static
                     * @param {proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton=} [properties] Properties to set
                     * @returns {proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton} NativeFlowButton instance
                     */
                    NativeFlowButton.create = function create(properties) {
                        return new NativeFlowButton(properties);
                    };

                    /**
                     * Encodes the specified NativeFlowButton message. Does not implicitly {@link proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.verify|verify} messages.
                     * @function encode
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @static
                     * @param {proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton} message NativeFlowButton message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NativeFlowButton.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.buttonParamsJson != null && Object.hasOwnProperty.call(message, "buttonParamsJson"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.buttonParamsJson);
                        return writer;
                    };

                    /**
                     * Encodes the specified NativeFlowButton message, length delimited. Does not implicitly {@link proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @static
                     * @param {proto.Message.InteractiveMessage.NativeFlowMessage.INativeFlowButton} message NativeFlowButton message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NativeFlowButton.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a NativeFlowButton message from the specified reader or buffer.
                     * @function decode
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton} NativeFlowButton
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NativeFlowButton.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.buttonParamsJson = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a NativeFlowButton message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton} NativeFlowButton
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NativeFlowButton.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a NativeFlowButton message.
                     * @function verify
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NativeFlowButton.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.buttonParamsJson != null && message.hasOwnProperty("buttonParamsJson"))
                            if (!$util.isString(message.buttonParamsJson))
                                return "buttonParamsJson: string expected";
                        return null;
                    };

                    /**
                     * Creates a NativeFlowButton message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton} NativeFlowButton
                     */
                    NativeFlowButton.fromObject = function fromObject(object) {
                        if (object instanceof $root.proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton)
                            return object;
                        var message = new $root.proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.buttonParamsJson != null)
                            message.buttonParamsJson = String(object.buttonParamsJson);
                        return message;
                    };

                    /**
                     * Creates a plain object from a NativeFlowButton message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @static
                     * @param {proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton} message NativeFlowButton
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NativeFlowButton.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.buttonParamsJson = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.buttonParamsJson != null && message.hasOwnProperty("buttonParamsJson"))
                            object.buttonParamsJson = message.buttonParamsJson;
                        return object;
                    };

                    /**
                     * Converts this NativeFlowButton to JSON.
                     * @function toJSON
                     * @memberof proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NativeFlowButton.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return NativeFlowButton;
                })();

                return NativeFlowMessage;
            })();

            InteractiveMessage.ShopMessage = (function() {

                /**
                 * Properties of a ShopMessage.
                 * @memberof proto.Message.InteractiveMessage
                 * @interface IShopMessage
                 * @property {string|null} [id] ShopMessage id
                 * @property {proto.Message.InteractiveMessage.ShopMessage.Surface|null} [surface] ShopMessage surface
                 * @property {number|null} [messageVersion] ShopMessage messageVersion
                 */

                /**
                 * Constructs a new ShopMessage.
                 * @memberof proto.Message.InteractiveMessage
                 * @classdesc Represents a ShopMessage.
                 * @implements IShopMessage
                 * @constructor
                 * @param {proto.Message.InteractiveMessage.IShopMessage=} [properties] Properties to set
                 */
                function ShopMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ShopMessage id.
                 * @member {string} id
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @instance
                 */
                ShopMessage.prototype.id = "";

                /**
                 * ShopMessage surface.
                 * @member {proto.Message.InteractiveMessage.ShopMessage.Surface} surface
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @instance
                 */
                ShopMessage.prototype.surface = 0;

                /**
                 * ShopMessage messageVersion.
                 * @member {number} messageVersion
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @instance
                 */
                ShopMessage.prototype.messageVersion = 0;

                /**
                 * Creates a new ShopMessage instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.IShopMessage=} [properties] Properties to set
                 * @returns {proto.Message.InteractiveMessage.ShopMessage} ShopMessage instance
                 */
                ShopMessage.create = function create(properties) {
                    return new ShopMessage(properties);
                };

                /**
                 * Encodes the specified ShopMessage message. Does not implicitly {@link proto.Message.InteractiveMessage.ShopMessage.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.IShopMessage} message ShopMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ShopMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.surface != null && Object.hasOwnProperty.call(message, "surface"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.surface);
                    if (message.messageVersion != null && Object.hasOwnProperty.call(message, "messageVersion"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.messageVersion);
                    return writer;
                };

                /**
                 * Encodes the specified ShopMessage message, length delimited. Does not implicitly {@link proto.Message.InteractiveMessage.ShopMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.IShopMessage} message ShopMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ShopMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ShopMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.InteractiveMessage.ShopMessage} ShopMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ShopMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveMessage.ShopMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.surface = reader.int32();
                            break;
                        case 3:
                            message.messageVersion = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ShopMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.InteractiveMessage.ShopMessage} ShopMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ShopMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ShopMessage message.
                 * @function verify
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ShopMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.surface != null && message.hasOwnProperty("surface"))
                        switch (message.surface) {
                        default:
                            return "surface: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.messageVersion != null && message.hasOwnProperty("messageVersion"))
                        if (!$util.isInteger(message.messageVersion))
                            return "messageVersion: integer expected";
                    return null;
                };

                /**
                 * Creates a ShopMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.InteractiveMessage.ShopMessage} ShopMessage
                 */
                ShopMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.InteractiveMessage.ShopMessage)
                        return object;
                    var message = new $root.proto.Message.InteractiveMessage.ShopMessage();
                    if (object.id != null)
                        message.id = String(object.id);
                    switch (object.surface) {
                    case "UNKNOWN_SURFACE":
                    case 0:
                        message.surface = 0;
                        break;
                    case "FB":
                    case 1:
                        message.surface = 1;
                        break;
                    case "IG":
                    case 2:
                        message.surface = 2;
                        break;
                    case "WA":
                    case 3:
                        message.surface = 3;
                        break;
                    }
                    if (object.messageVersion != null)
                        message.messageVersion = object.messageVersion | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ShopMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @static
                 * @param {proto.Message.InteractiveMessage.ShopMessage} message ShopMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ShopMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.surface = options.enums === String ? "UNKNOWN_SURFACE" : 0;
                        object.messageVersion = 0;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.surface != null && message.hasOwnProperty("surface"))
                        object.surface = options.enums === String ? $root.proto.Message.InteractiveMessage.ShopMessage.Surface[message.surface] : message.surface;
                    if (message.messageVersion != null && message.hasOwnProperty("messageVersion"))
                        object.messageVersion = message.messageVersion;
                    return object;
                };

                /**
                 * Converts this ShopMessage to JSON.
                 * @function toJSON
                 * @memberof proto.Message.InteractiveMessage.ShopMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ShopMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Surface enum.
                 * @name proto.Message.InteractiveMessage.ShopMessage.Surface
                 * @enum {number}
                 * @property {number} UNKNOWN_SURFACE=0 UNKNOWN_SURFACE value
                 * @property {number} FB=1 FB value
                 * @property {number} IG=2 IG value
                 * @property {number} WA=3 WA value
                 */
                ShopMessage.Surface = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_SURFACE"] = 0;
                    values[valuesById[1] = "FB"] = 1;
                    values[valuesById[2] = "IG"] = 2;
                    values[valuesById[3] = "WA"] = 3;
                    return values;
                })();

                return ShopMessage;
            })();

            return InteractiveMessage;
        })();

        Message.InteractiveResponseMessage = (function() {

            /**
             * Properties of an InteractiveResponseMessage.
             * @memberof proto.Message
             * @interface IInteractiveResponseMessage
             * @property {proto.Message.InteractiveResponseMessage.IBody|null} [body] InteractiveResponseMessage body
             * @property {proto.IContextInfo|null} [contextInfo] InteractiveResponseMessage contextInfo
             * @property {proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage|null} [nativeFlowResponseMessage] InteractiveResponseMessage nativeFlowResponseMessage
             */

            /**
             * Constructs a new InteractiveResponseMessage.
             * @memberof proto.Message
             * @classdesc Represents an InteractiveResponseMessage.
             * @implements IInteractiveResponseMessage
             * @constructor
             * @param {proto.Message.IInteractiveResponseMessage=} [properties] Properties to set
             */
            function InteractiveResponseMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InteractiveResponseMessage body.
             * @member {proto.Message.InteractiveResponseMessage.IBody|null|undefined} body
             * @memberof proto.Message.InteractiveResponseMessage
             * @instance
             */
            InteractiveResponseMessage.prototype.body = null;

            /**
             * InteractiveResponseMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.InteractiveResponseMessage
             * @instance
             */
            InteractiveResponseMessage.prototype.contextInfo = null;

            /**
             * InteractiveResponseMessage nativeFlowResponseMessage.
             * @member {proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage|null|undefined} nativeFlowResponseMessage
             * @memberof proto.Message.InteractiveResponseMessage
             * @instance
             */
            InteractiveResponseMessage.prototype.nativeFlowResponseMessage = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * InteractiveResponseMessage interactiveResponseMessage.
             * @member {"nativeFlowResponseMessage"|undefined} interactiveResponseMessage
             * @memberof proto.Message.InteractiveResponseMessage
             * @instance
             */
            Object.defineProperty(InteractiveResponseMessage.prototype, "interactiveResponseMessage", {
                get: $util.oneOfGetter($oneOfFields = ["nativeFlowResponseMessage"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new InteractiveResponseMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.InteractiveResponseMessage
             * @static
             * @param {proto.Message.IInteractiveResponseMessage=} [properties] Properties to set
             * @returns {proto.Message.InteractiveResponseMessage} InteractiveResponseMessage instance
             */
            InteractiveResponseMessage.create = function create(properties) {
                return new InteractiveResponseMessage(properties);
            };

            /**
             * Encodes the specified InteractiveResponseMessage message. Does not implicitly {@link proto.Message.InteractiveResponseMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.InteractiveResponseMessage
             * @static
             * @param {proto.Message.IInteractiveResponseMessage} message InteractiveResponseMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InteractiveResponseMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    $root.proto.Message.InteractiveResponseMessage.Body.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nativeFlowResponseMessage != null && Object.hasOwnProperty.call(message, "nativeFlowResponseMessage"))
                    $root.proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.encode(message.nativeFlowResponseMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InteractiveResponseMessage message, length delimited. Does not implicitly {@link proto.Message.InteractiveResponseMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.InteractiveResponseMessage
             * @static
             * @param {proto.Message.IInteractiveResponseMessage} message InteractiveResponseMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InteractiveResponseMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InteractiveResponseMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.InteractiveResponseMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.InteractiveResponseMessage} InteractiveResponseMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InteractiveResponseMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveResponseMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.body = $root.proto.Message.InteractiveResponseMessage.Body.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.nativeFlowResponseMessage = $root.proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InteractiveResponseMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.InteractiveResponseMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.InteractiveResponseMessage} InteractiveResponseMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InteractiveResponseMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InteractiveResponseMessage message.
             * @function verify
             * @memberof proto.Message.InteractiveResponseMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InteractiveResponseMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.body != null && message.hasOwnProperty("body")) {
                    var error = $root.proto.Message.InteractiveResponseMessage.Body.verify(message.body);
                    if (error)
                        return "body." + error;
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.nativeFlowResponseMessage != null && message.hasOwnProperty("nativeFlowResponseMessage")) {
                    properties.interactiveResponseMessage = 1;
                    {
                        var error = $root.proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.verify(message.nativeFlowResponseMessage);
                        if (error)
                            return "nativeFlowResponseMessage." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an InteractiveResponseMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.InteractiveResponseMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.InteractiveResponseMessage} InteractiveResponseMessage
             */
            InteractiveResponseMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.InteractiveResponseMessage)
                    return object;
                var message = new $root.proto.Message.InteractiveResponseMessage();
                if (object.body != null) {
                    if (typeof object.body !== "object")
                        throw TypeError(".proto.Message.InteractiveResponseMessage.body: object expected");
                    message.body = $root.proto.Message.InteractiveResponseMessage.Body.fromObject(object.body);
                }
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.InteractiveResponseMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.nativeFlowResponseMessage != null) {
                    if (typeof object.nativeFlowResponseMessage !== "object")
                        throw TypeError(".proto.Message.InteractiveResponseMessage.nativeFlowResponseMessage: object expected");
                    message.nativeFlowResponseMessage = $root.proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.fromObject(object.nativeFlowResponseMessage);
                }
                return message;
            };

            /**
             * Creates a plain object from an InteractiveResponseMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.InteractiveResponseMessage
             * @static
             * @param {proto.Message.InteractiveResponseMessage} message InteractiveResponseMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InteractiveResponseMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.body = null;
                    object.contextInfo = null;
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = $root.proto.Message.InteractiveResponseMessage.Body.toObject(message.body, options);
                if (message.nativeFlowResponseMessage != null && message.hasOwnProperty("nativeFlowResponseMessage")) {
                    object.nativeFlowResponseMessage = $root.proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.toObject(message.nativeFlowResponseMessage, options);
                    if (options.oneofs)
                        object.interactiveResponseMessage = "nativeFlowResponseMessage";
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this InteractiveResponseMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.InteractiveResponseMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InteractiveResponseMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            InteractiveResponseMessage.Body = (function() {

                /**
                 * Properties of a Body.
                 * @memberof proto.Message.InteractiveResponseMessage
                 * @interface IBody
                 * @property {string|null} [text] Body text
                 */

                /**
                 * Constructs a new Body.
                 * @memberof proto.Message.InteractiveResponseMessage
                 * @classdesc Represents a Body.
                 * @implements IBody
                 * @constructor
                 * @param {proto.Message.InteractiveResponseMessage.IBody=} [properties] Properties to set
                 */
                function Body(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Body text.
                 * @member {string} text
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @instance
                 */
                Body.prototype.text = "";

                /**
                 * Creates a new Body instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @static
                 * @param {proto.Message.InteractiveResponseMessage.IBody=} [properties] Properties to set
                 * @returns {proto.Message.InteractiveResponseMessage.Body} Body instance
                 */
                Body.create = function create(properties) {
                    return new Body(properties);
                };

                /**
                 * Encodes the specified Body message. Does not implicitly {@link proto.Message.InteractiveResponseMessage.Body.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @static
                 * @param {proto.Message.InteractiveResponseMessage.IBody} message Body message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Body.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                    return writer;
                };

                /**
                 * Encodes the specified Body message, length delimited. Does not implicitly {@link proto.Message.InteractiveResponseMessage.Body.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @static
                 * @param {proto.Message.InteractiveResponseMessage.IBody} message Body message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Body.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Body message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.InteractiveResponseMessage.Body} Body
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Body.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveResponseMessage.Body();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Body message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.InteractiveResponseMessage.Body} Body
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Body.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Body message.
                 * @function verify
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Body.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.text != null && message.hasOwnProperty("text"))
                        if (!$util.isString(message.text))
                            return "text: string expected";
                    return null;
                };

                /**
                 * Creates a Body message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.InteractiveResponseMessage.Body} Body
                 */
                Body.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.InteractiveResponseMessage.Body)
                        return object;
                    var message = new $root.proto.Message.InteractiveResponseMessage.Body();
                    if (object.text != null)
                        message.text = String(object.text);
                    return message;
                };

                /**
                 * Creates a plain object from a Body message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @static
                 * @param {proto.Message.InteractiveResponseMessage.Body} message Body
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Body.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.text = "";
                    if (message.text != null && message.hasOwnProperty("text"))
                        object.text = message.text;
                    return object;
                };

                /**
                 * Converts this Body to JSON.
                 * @function toJSON
                 * @memberof proto.Message.InteractiveResponseMessage.Body
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Body.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Body;
            })();

            InteractiveResponseMessage.NativeFlowResponseMessage = (function() {

                /**
                 * Properties of a NativeFlowResponseMessage.
                 * @memberof proto.Message.InteractiveResponseMessage
                 * @interface INativeFlowResponseMessage
                 * @property {string|null} [name] NativeFlowResponseMessage name
                 * @property {string|null} [paramsJson] NativeFlowResponseMessage paramsJson
                 * @property {number|null} [version] NativeFlowResponseMessage version
                 */

                /**
                 * Constructs a new NativeFlowResponseMessage.
                 * @memberof proto.Message.InteractiveResponseMessage
                 * @classdesc Represents a NativeFlowResponseMessage.
                 * @implements INativeFlowResponseMessage
                 * @constructor
                 * @param {proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage=} [properties] Properties to set
                 */
                function NativeFlowResponseMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NativeFlowResponseMessage name.
                 * @member {string} name
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @instance
                 */
                NativeFlowResponseMessage.prototype.name = "";

                /**
                 * NativeFlowResponseMessage paramsJson.
                 * @member {string} paramsJson
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @instance
                 */
                NativeFlowResponseMessage.prototype.paramsJson = "";

                /**
                 * NativeFlowResponseMessage version.
                 * @member {number} version
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @instance
                 */
                NativeFlowResponseMessage.prototype.version = 0;

                /**
                 * Creates a new NativeFlowResponseMessage instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @static
                 * @param {proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage=} [properties] Properties to set
                 * @returns {proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage} NativeFlowResponseMessage instance
                 */
                NativeFlowResponseMessage.create = function create(properties) {
                    return new NativeFlowResponseMessage(properties);
                };

                /**
                 * Encodes the specified NativeFlowResponseMessage message. Does not implicitly {@link proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @static
                 * @param {proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage} message NativeFlowResponseMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NativeFlowResponseMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.paramsJson != null && Object.hasOwnProperty.call(message, "paramsJson"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.paramsJson);
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
                    return writer;
                };

                /**
                 * Encodes the specified NativeFlowResponseMessage message, length delimited. Does not implicitly {@link proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @static
                 * @param {proto.Message.InteractiveResponseMessage.INativeFlowResponseMessage} message NativeFlowResponseMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NativeFlowResponseMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NativeFlowResponseMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage} NativeFlowResponseMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NativeFlowResponseMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.paramsJson = reader.string();
                            break;
                        case 3:
                            message.version = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NativeFlowResponseMessage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage} NativeFlowResponseMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NativeFlowResponseMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NativeFlowResponseMessage message.
                 * @function verify
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NativeFlowResponseMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.paramsJson != null && message.hasOwnProperty("paramsJson"))
                        if (!$util.isString(message.paramsJson))
                            return "paramsJson: string expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isInteger(message.version))
                            return "version: integer expected";
                    return null;
                };

                /**
                 * Creates a NativeFlowResponseMessage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage} NativeFlowResponseMessage
                 */
                NativeFlowResponseMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage)
                        return object;
                    var message = new $root.proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.paramsJson != null)
                        message.paramsJson = String(object.paramsJson);
                    if (object.version != null)
                        message.version = object.version | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a NativeFlowResponseMessage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @static
                 * @param {proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage} message NativeFlowResponseMessage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NativeFlowResponseMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.paramsJson = "";
                        object.version = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.paramsJson != null && message.hasOwnProperty("paramsJson"))
                        object.paramsJson = message.paramsJson;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    return object;
                };

                /**
                 * Converts this NativeFlowResponseMessage to JSON.
                 * @function toJSON
                 * @memberof proto.Message.InteractiveResponseMessage.NativeFlowResponseMessage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NativeFlowResponseMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NativeFlowResponseMessage;
            })();

            return InteractiveResponseMessage;
        })();

        Message.InvoiceMessage = (function() {

            /**
             * Properties of an InvoiceMessage.
             * @memberof proto.Message
             * @interface IInvoiceMessage
             * @property {string|null} [note] InvoiceMessage note
             * @property {string|null} [token] InvoiceMessage token
             * @property {proto.Message.InvoiceMessage.AttachmentType|null} [attachmentType] InvoiceMessage attachmentType
             * @property {string|null} [attachmentMimetype] InvoiceMessage attachmentMimetype
             * @property {Uint8Array|null} [attachmentMediaKey] InvoiceMessage attachmentMediaKey
             * @property {number|Long|null} [attachmentMediaKeyTimestamp] InvoiceMessage attachmentMediaKeyTimestamp
             * @property {Uint8Array|null} [attachmentFileSha256] InvoiceMessage attachmentFileSha256
             * @property {Uint8Array|null} [attachmentFileEncSha256] InvoiceMessage attachmentFileEncSha256
             * @property {string|null} [attachmentDirectPath] InvoiceMessage attachmentDirectPath
             * @property {Uint8Array|null} [attachmentJpegThumbnail] InvoiceMessage attachmentJpegThumbnail
             */

            /**
             * Constructs a new InvoiceMessage.
             * @memberof proto.Message
             * @classdesc Represents an InvoiceMessage.
             * @implements IInvoiceMessage
             * @constructor
             * @param {proto.Message.IInvoiceMessage=} [properties] Properties to set
             */
            function InvoiceMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InvoiceMessage note.
             * @member {string} note
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.note = "";

            /**
             * InvoiceMessage token.
             * @member {string} token
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.token = "";

            /**
             * InvoiceMessage attachmentType.
             * @member {proto.Message.InvoiceMessage.AttachmentType} attachmentType
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.attachmentType = 0;

            /**
             * InvoiceMessage attachmentMimetype.
             * @member {string} attachmentMimetype
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.attachmentMimetype = "";

            /**
             * InvoiceMessage attachmentMediaKey.
             * @member {Uint8Array} attachmentMediaKey
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.attachmentMediaKey = $util.newBuffer([]);

            /**
             * InvoiceMessage attachmentMediaKeyTimestamp.
             * @member {number|Long} attachmentMediaKeyTimestamp
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.attachmentMediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * InvoiceMessage attachmentFileSha256.
             * @member {Uint8Array} attachmentFileSha256
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.attachmentFileSha256 = $util.newBuffer([]);

            /**
             * InvoiceMessage attachmentFileEncSha256.
             * @member {Uint8Array} attachmentFileEncSha256
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.attachmentFileEncSha256 = $util.newBuffer([]);

            /**
             * InvoiceMessage attachmentDirectPath.
             * @member {string} attachmentDirectPath
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.attachmentDirectPath = "";

            /**
             * InvoiceMessage attachmentJpegThumbnail.
             * @member {Uint8Array} attachmentJpegThumbnail
             * @memberof proto.Message.InvoiceMessage
             * @instance
             */
            InvoiceMessage.prototype.attachmentJpegThumbnail = $util.newBuffer([]);

            /**
             * Creates a new InvoiceMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.InvoiceMessage
             * @static
             * @param {proto.Message.IInvoiceMessage=} [properties] Properties to set
             * @returns {proto.Message.InvoiceMessage} InvoiceMessage instance
             */
            InvoiceMessage.create = function create(properties) {
                return new InvoiceMessage(properties);
            };

            /**
             * Encodes the specified InvoiceMessage message. Does not implicitly {@link proto.Message.InvoiceMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.InvoiceMessage
             * @static
             * @param {proto.Message.IInvoiceMessage} message InvoiceMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InvoiceMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.note != null && Object.hasOwnProperty.call(message, "note"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.note);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                if (message.attachmentType != null && Object.hasOwnProperty.call(message, "attachmentType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.attachmentType);
                if (message.attachmentMimetype != null && Object.hasOwnProperty.call(message, "attachmentMimetype"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.attachmentMimetype);
                if (message.attachmentMediaKey != null && Object.hasOwnProperty.call(message, "attachmentMediaKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.attachmentMediaKey);
                if (message.attachmentMediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "attachmentMediaKeyTimestamp"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.attachmentMediaKeyTimestamp);
                if (message.attachmentFileSha256 != null && Object.hasOwnProperty.call(message, "attachmentFileSha256"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.attachmentFileSha256);
                if (message.attachmentFileEncSha256 != null && Object.hasOwnProperty.call(message, "attachmentFileEncSha256"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.attachmentFileEncSha256);
                if (message.attachmentDirectPath != null && Object.hasOwnProperty.call(message, "attachmentDirectPath"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.attachmentDirectPath);
                if (message.attachmentJpegThumbnail != null && Object.hasOwnProperty.call(message, "attachmentJpegThumbnail"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.attachmentJpegThumbnail);
                return writer;
            };

            /**
             * Encodes the specified InvoiceMessage message, length delimited. Does not implicitly {@link proto.Message.InvoiceMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.InvoiceMessage
             * @static
             * @param {proto.Message.IInvoiceMessage} message InvoiceMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InvoiceMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InvoiceMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.InvoiceMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.InvoiceMessage} InvoiceMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InvoiceMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.InvoiceMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.note = reader.string();
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    case 3:
                        message.attachmentType = reader.int32();
                        break;
                    case 4:
                        message.attachmentMimetype = reader.string();
                        break;
                    case 5:
                        message.attachmentMediaKey = reader.bytes();
                        break;
                    case 6:
                        message.attachmentMediaKeyTimestamp = reader.int64();
                        break;
                    case 7:
                        message.attachmentFileSha256 = reader.bytes();
                        break;
                    case 8:
                        message.attachmentFileEncSha256 = reader.bytes();
                        break;
                    case 9:
                        message.attachmentDirectPath = reader.string();
                        break;
                    case 10:
                        message.attachmentJpegThumbnail = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InvoiceMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.InvoiceMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.InvoiceMessage} InvoiceMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InvoiceMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InvoiceMessage message.
             * @function verify
             * @memberof proto.Message.InvoiceMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InvoiceMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.note != null && message.hasOwnProperty("note"))
                    if (!$util.isString(message.note))
                        return "note: string expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.attachmentType != null && message.hasOwnProperty("attachmentType"))
                    switch (message.attachmentType) {
                    default:
                        return "attachmentType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.attachmentMimetype != null && message.hasOwnProperty("attachmentMimetype"))
                    if (!$util.isString(message.attachmentMimetype))
                        return "attachmentMimetype: string expected";
                if (message.attachmentMediaKey != null && message.hasOwnProperty("attachmentMediaKey"))
                    if (!(message.attachmentMediaKey && typeof message.attachmentMediaKey.length === "number" || $util.isString(message.attachmentMediaKey)))
                        return "attachmentMediaKey: buffer expected";
                if (message.attachmentMediaKeyTimestamp != null && message.hasOwnProperty("attachmentMediaKeyTimestamp"))
                    if (!$util.isInteger(message.attachmentMediaKeyTimestamp) && !(message.attachmentMediaKeyTimestamp && $util.isInteger(message.attachmentMediaKeyTimestamp.low) && $util.isInteger(message.attachmentMediaKeyTimestamp.high)))
                        return "attachmentMediaKeyTimestamp: integer|Long expected";
                if (message.attachmentFileSha256 != null && message.hasOwnProperty("attachmentFileSha256"))
                    if (!(message.attachmentFileSha256 && typeof message.attachmentFileSha256.length === "number" || $util.isString(message.attachmentFileSha256)))
                        return "attachmentFileSha256: buffer expected";
                if (message.attachmentFileEncSha256 != null && message.hasOwnProperty("attachmentFileEncSha256"))
                    if (!(message.attachmentFileEncSha256 && typeof message.attachmentFileEncSha256.length === "number" || $util.isString(message.attachmentFileEncSha256)))
                        return "attachmentFileEncSha256: buffer expected";
                if (message.attachmentDirectPath != null && message.hasOwnProperty("attachmentDirectPath"))
                    if (!$util.isString(message.attachmentDirectPath))
                        return "attachmentDirectPath: string expected";
                if (message.attachmentJpegThumbnail != null && message.hasOwnProperty("attachmentJpegThumbnail"))
                    if (!(message.attachmentJpegThumbnail && typeof message.attachmentJpegThumbnail.length === "number" || $util.isString(message.attachmentJpegThumbnail)))
                        return "attachmentJpegThumbnail: buffer expected";
                return null;
            };

            /**
             * Creates an InvoiceMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.InvoiceMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.InvoiceMessage} InvoiceMessage
             */
            InvoiceMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.InvoiceMessage)
                    return object;
                var message = new $root.proto.Message.InvoiceMessage();
                if (object.note != null)
                    message.note = String(object.note);
                if (object.token != null)
                    message.token = String(object.token);
                switch (object.attachmentType) {
                case "IMAGE":
                case 0:
                    message.attachmentType = 0;
                    break;
                case "PDF":
                case 1:
                    message.attachmentType = 1;
                    break;
                }
                if (object.attachmentMimetype != null)
                    message.attachmentMimetype = String(object.attachmentMimetype);
                if (object.attachmentMediaKey != null)
                    if (typeof object.attachmentMediaKey === "string")
                        $util.base64.decode(object.attachmentMediaKey, message.attachmentMediaKey = $util.newBuffer($util.base64.length(object.attachmentMediaKey)), 0);
                    else if (object.attachmentMediaKey.length)
                        message.attachmentMediaKey = object.attachmentMediaKey;
                if (object.attachmentMediaKeyTimestamp != null)
                    if ($util.Long)
                        (message.attachmentMediaKeyTimestamp = $util.Long.fromValue(object.attachmentMediaKeyTimestamp)).unsigned = false;
                    else if (typeof object.attachmentMediaKeyTimestamp === "string")
                        message.attachmentMediaKeyTimestamp = parseInt(object.attachmentMediaKeyTimestamp, 10);
                    else if (typeof object.attachmentMediaKeyTimestamp === "number")
                        message.attachmentMediaKeyTimestamp = object.attachmentMediaKeyTimestamp;
                    else if (typeof object.attachmentMediaKeyTimestamp === "object")
                        message.attachmentMediaKeyTimestamp = new $util.LongBits(object.attachmentMediaKeyTimestamp.low >>> 0, object.attachmentMediaKeyTimestamp.high >>> 0).toNumber();
                if (object.attachmentFileSha256 != null)
                    if (typeof object.attachmentFileSha256 === "string")
                        $util.base64.decode(object.attachmentFileSha256, message.attachmentFileSha256 = $util.newBuffer($util.base64.length(object.attachmentFileSha256)), 0);
                    else if (object.attachmentFileSha256.length)
                        message.attachmentFileSha256 = object.attachmentFileSha256;
                if (object.attachmentFileEncSha256 != null)
                    if (typeof object.attachmentFileEncSha256 === "string")
                        $util.base64.decode(object.attachmentFileEncSha256, message.attachmentFileEncSha256 = $util.newBuffer($util.base64.length(object.attachmentFileEncSha256)), 0);
                    else if (object.attachmentFileEncSha256.length)
                        message.attachmentFileEncSha256 = object.attachmentFileEncSha256;
                if (object.attachmentDirectPath != null)
                    message.attachmentDirectPath = String(object.attachmentDirectPath);
                if (object.attachmentJpegThumbnail != null)
                    if (typeof object.attachmentJpegThumbnail === "string")
                        $util.base64.decode(object.attachmentJpegThumbnail, message.attachmentJpegThumbnail = $util.newBuffer($util.base64.length(object.attachmentJpegThumbnail)), 0);
                    else if (object.attachmentJpegThumbnail.length)
                        message.attachmentJpegThumbnail = object.attachmentJpegThumbnail;
                return message;
            };

            /**
             * Creates a plain object from an InvoiceMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.InvoiceMessage
             * @static
             * @param {proto.Message.InvoiceMessage} message InvoiceMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InvoiceMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.note = "";
                    object.token = "";
                    object.attachmentType = options.enums === String ? "IMAGE" : 0;
                    object.attachmentMimetype = "";
                    if (options.bytes === String)
                        object.attachmentMediaKey = "";
                    else {
                        object.attachmentMediaKey = [];
                        if (options.bytes !== Array)
                            object.attachmentMediaKey = $util.newBuffer(object.attachmentMediaKey);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.attachmentMediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.attachmentMediaKeyTimestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.attachmentFileSha256 = "";
                    else {
                        object.attachmentFileSha256 = [];
                        if (options.bytes !== Array)
                            object.attachmentFileSha256 = $util.newBuffer(object.attachmentFileSha256);
                    }
                    if (options.bytes === String)
                        object.attachmentFileEncSha256 = "";
                    else {
                        object.attachmentFileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.attachmentFileEncSha256 = $util.newBuffer(object.attachmentFileEncSha256);
                    }
                    object.attachmentDirectPath = "";
                    if (options.bytes === String)
                        object.attachmentJpegThumbnail = "";
                    else {
                        object.attachmentJpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.attachmentJpegThumbnail = $util.newBuffer(object.attachmentJpegThumbnail);
                    }
                }
                if (message.note != null && message.hasOwnProperty("note"))
                    object.note = message.note;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.attachmentType != null && message.hasOwnProperty("attachmentType"))
                    object.attachmentType = options.enums === String ? $root.proto.Message.InvoiceMessage.AttachmentType[message.attachmentType] : message.attachmentType;
                if (message.attachmentMimetype != null && message.hasOwnProperty("attachmentMimetype"))
                    object.attachmentMimetype = message.attachmentMimetype;
                if (message.attachmentMediaKey != null && message.hasOwnProperty("attachmentMediaKey"))
                    object.attachmentMediaKey = options.bytes === String ? $util.base64.encode(message.attachmentMediaKey, 0, message.attachmentMediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.attachmentMediaKey) : message.attachmentMediaKey;
                if (message.attachmentMediaKeyTimestamp != null && message.hasOwnProperty("attachmentMediaKeyTimestamp"))
                    if (typeof message.attachmentMediaKeyTimestamp === "number")
                        object.attachmentMediaKeyTimestamp = options.longs === String ? String(message.attachmentMediaKeyTimestamp) : message.attachmentMediaKeyTimestamp;
                    else
                        object.attachmentMediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.attachmentMediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.attachmentMediaKeyTimestamp.low >>> 0, message.attachmentMediaKeyTimestamp.high >>> 0).toNumber() : message.attachmentMediaKeyTimestamp;
                if (message.attachmentFileSha256 != null && message.hasOwnProperty("attachmentFileSha256"))
                    object.attachmentFileSha256 = options.bytes === String ? $util.base64.encode(message.attachmentFileSha256, 0, message.attachmentFileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.attachmentFileSha256) : message.attachmentFileSha256;
                if (message.attachmentFileEncSha256 != null && message.hasOwnProperty("attachmentFileEncSha256"))
                    object.attachmentFileEncSha256 = options.bytes === String ? $util.base64.encode(message.attachmentFileEncSha256, 0, message.attachmentFileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.attachmentFileEncSha256) : message.attachmentFileEncSha256;
                if (message.attachmentDirectPath != null && message.hasOwnProperty("attachmentDirectPath"))
                    object.attachmentDirectPath = message.attachmentDirectPath;
                if (message.attachmentJpegThumbnail != null && message.hasOwnProperty("attachmentJpegThumbnail"))
                    object.attachmentJpegThumbnail = options.bytes === String ? $util.base64.encode(message.attachmentJpegThumbnail, 0, message.attachmentJpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.attachmentJpegThumbnail) : message.attachmentJpegThumbnail;
                return object;
            };

            /**
             * Converts this InvoiceMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.InvoiceMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InvoiceMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * AttachmentType enum.
             * @name proto.Message.InvoiceMessage.AttachmentType
             * @enum {number}
             * @property {number} IMAGE=0 IMAGE value
             * @property {number} PDF=1 PDF value
             */
            InvoiceMessage.AttachmentType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "IMAGE"] = 0;
                values[valuesById[1] = "PDF"] = 1;
                return values;
            })();

            return InvoiceMessage;
        })();

        Message.KeepInChatMessage = (function() {

            /**
             * Properties of a KeepInChatMessage.
             * @memberof proto.Message
             * @interface IKeepInChatMessage
             * @property {proto.IMessageKey|null} [key] KeepInChatMessage key
             * @property {proto.KeepType|null} [keepType] KeepInChatMessage keepType
             * @property {number|Long|null} [timestampMs] KeepInChatMessage timestampMs
             */

            /**
             * Constructs a new KeepInChatMessage.
             * @memberof proto.Message
             * @classdesc Represents a KeepInChatMessage.
             * @implements IKeepInChatMessage
             * @constructor
             * @param {proto.Message.IKeepInChatMessage=} [properties] Properties to set
             */
            function KeepInChatMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeepInChatMessage key.
             * @member {proto.IMessageKey|null|undefined} key
             * @memberof proto.Message.KeepInChatMessage
             * @instance
             */
            KeepInChatMessage.prototype.key = null;

            /**
             * KeepInChatMessage keepType.
             * @member {proto.KeepType} keepType
             * @memberof proto.Message.KeepInChatMessage
             * @instance
             */
            KeepInChatMessage.prototype.keepType = 0;

            /**
             * KeepInChatMessage timestampMs.
             * @member {number|Long} timestampMs
             * @memberof proto.Message.KeepInChatMessage
             * @instance
             */
            KeepInChatMessage.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new KeepInChatMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.KeepInChatMessage
             * @static
             * @param {proto.Message.IKeepInChatMessage=} [properties] Properties to set
             * @returns {proto.Message.KeepInChatMessage} KeepInChatMessage instance
             */
            KeepInChatMessage.create = function create(properties) {
                return new KeepInChatMessage(properties);
            };

            /**
             * Encodes the specified KeepInChatMessage message. Does not implicitly {@link proto.Message.KeepInChatMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.KeepInChatMessage
             * @static
             * @param {proto.Message.IKeepInChatMessage} message KeepInChatMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepInChatMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.keepType != null && Object.hasOwnProperty.call(message, "keepType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.keepType);
                if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
                return writer;
            };

            /**
             * Encodes the specified KeepInChatMessage message, length delimited. Does not implicitly {@link proto.Message.KeepInChatMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.KeepInChatMessage
             * @static
             * @param {proto.Message.IKeepInChatMessage} message KeepInChatMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepInChatMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeepInChatMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.KeepInChatMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.KeepInChatMessage} KeepInChatMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepInChatMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.KeepInChatMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.keepType = reader.int32();
                        break;
                    case 3:
                        message.timestampMs = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeepInChatMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.KeepInChatMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.KeepInChatMessage} KeepInChatMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepInChatMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeepInChatMessage message.
             * @function verify
             * @memberof proto.Message.KeepInChatMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeepInChatMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key")) {
                    var error = $root.proto.MessageKey.verify(message.key);
                    if (error)
                        return "key." + error;
                }
                if (message.keepType != null && message.hasOwnProperty("keepType"))
                    switch (message.keepType) {
                    default:
                        return "keepType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                    if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                        return "timestampMs: integer|Long expected";
                return null;
            };

            /**
             * Creates a KeepInChatMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.KeepInChatMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.KeepInChatMessage} KeepInChatMessage
             */
            KeepInChatMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.KeepInChatMessage)
                    return object;
                var message = new $root.proto.Message.KeepInChatMessage();
                if (object.key != null) {
                    if (typeof object.key !== "object")
                        throw TypeError(".proto.Message.KeepInChatMessage.key: object expected");
                    message.key = $root.proto.MessageKey.fromObject(object.key);
                }
                switch (object.keepType) {
                case "UNKNOWN":
                case 0:
                    message.keepType = 0;
                    break;
                case "KEEP_FOR_ALL":
                case 1:
                    message.keepType = 1;
                    break;
                case "UNDO_KEEP_FOR_ALL":
                case 2:
                    message.keepType = 2;
                    break;
                }
                if (object.timestampMs != null)
                    if ($util.Long)
                        (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                    else if (typeof object.timestampMs === "string")
                        message.timestampMs = parseInt(object.timestampMs, 10);
                    else if (typeof object.timestampMs === "number")
                        message.timestampMs = object.timestampMs;
                    else if (typeof object.timestampMs === "object")
                        message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a KeepInChatMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.KeepInChatMessage
             * @static
             * @param {proto.Message.KeepInChatMessage} message KeepInChatMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeepInChatMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = null;
                    object.keepType = options.enums === String ? "UNKNOWN" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestampMs = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = $root.proto.MessageKey.toObject(message.key, options);
                if (message.keepType != null && message.hasOwnProperty("keepType"))
                    object.keepType = options.enums === String ? $root.proto.KeepType[message.keepType] : message.keepType;
                if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                    if (typeof message.timestampMs === "number")
                        object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                    else
                        object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
                return object;
            };

            /**
             * Converts this KeepInChatMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.KeepInChatMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeepInChatMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeepInChatMessage;
        })();

        Message.ListMessage = (function() {

            /**
             * Properties of a ListMessage.
             * @memberof proto.Message
             * @interface IListMessage
             * @property {string|null} [title] ListMessage title
             * @property {string|null} [description] ListMessage description
             * @property {string|null} [buttonText] ListMessage buttonText
             * @property {proto.Message.ListMessage.ListType|null} [listType] ListMessage listType
             * @property {Array.<proto.Message.ListMessage.ISection>|null} [sections] ListMessage sections
             * @property {proto.Message.ListMessage.IProductListInfo|null} [productListInfo] ListMessage productListInfo
             * @property {string|null} [footerText] ListMessage footerText
             * @property {proto.IContextInfo|null} [contextInfo] ListMessage contextInfo
             */

            /**
             * Constructs a new ListMessage.
             * @memberof proto.Message
             * @classdesc Represents a ListMessage.
             * @implements IListMessage
             * @constructor
             * @param {proto.Message.IListMessage=} [properties] Properties to set
             */
            function ListMessage(properties) {
                this.sections = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListMessage title.
             * @member {string} title
             * @memberof proto.Message.ListMessage
             * @instance
             */
            ListMessage.prototype.title = "";

            /**
             * ListMessage description.
             * @member {string} description
             * @memberof proto.Message.ListMessage
             * @instance
             */
            ListMessage.prototype.description = "";

            /**
             * ListMessage buttonText.
             * @member {string} buttonText
             * @memberof proto.Message.ListMessage
             * @instance
             */
            ListMessage.prototype.buttonText = "";

            /**
             * ListMessage listType.
             * @member {proto.Message.ListMessage.ListType} listType
             * @memberof proto.Message.ListMessage
             * @instance
             */
            ListMessage.prototype.listType = 0;

            /**
             * ListMessage sections.
             * @member {Array.<proto.Message.ListMessage.ISection>} sections
             * @memberof proto.Message.ListMessage
             * @instance
             */
            ListMessage.prototype.sections = $util.emptyArray;

            /**
             * ListMessage productListInfo.
             * @member {proto.Message.ListMessage.IProductListInfo|null|undefined} productListInfo
             * @memberof proto.Message.ListMessage
             * @instance
             */
            ListMessage.prototype.productListInfo = null;

            /**
             * ListMessage footerText.
             * @member {string} footerText
             * @memberof proto.Message.ListMessage
             * @instance
             */
            ListMessage.prototype.footerText = "";

            /**
             * ListMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ListMessage
             * @instance
             */
            ListMessage.prototype.contextInfo = null;

            /**
             * Creates a new ListMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ListMessage
             * @static
             * @param {proto.Message.IListMessage=} [properties] Properties to set
             * @returns {proto.Message.ListMessage} ListMessage instance
             */
            ListMessage.create = function create(properties) {
                return new ListMessage(properties);
            };

            /**
             * Encodes the specified ListMessage message. Does not implicitly {@link proto.Message.ListMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ListMessage
             * @static
             * @param {proto.Message.IListMessage} message ListMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                if (message.buttonText != null && Object.hasOwnProperty.call(message, "buttonText"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.buttonText);
                if (message.listType != null && Object.hasOwnProperty.call(message, "listType"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.listType);
                if (message.sections != null && message.sections.length)
                    for (var i = 0; i < message.sections.length; ++i)
                        $root.proto.Message.ListMessage.Section.encode(message.sections[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.productListInfo != null && Object.hasOwnProperty.call(message, "productListInfo"))
                    $root.proto.Message.ListMessage.ProductListInfo.encode(message.productListInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.footerText != null && Object.hasOwnProperty.call(message, "footerText"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.footerText);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListMessage message, length delimited. Does not implicitly {@link proto.Message.ListMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ListMessage
             * @static
             * @param {proto.Message.IListMessage} message ListMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ListMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ListMessage} ListMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.title = reader.string();
                        break;
                    case 2:
                        message.description = reader.string();
                        break;
                    case 3:
                        message.buttonText = reader.string();
                        break;
                    case 4:
                        message.listType = reader.int32();
                        break;
                    case 5:
                        if (!(message.sections && message.sections.length))
                            message.sections = [];
                        message.sections.push($root.proto.Message.ListMessage.Section.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.productListInfo = $root.proto.Message.ListMessage.ProductListInfo.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.footerText = reader.string();
                        break;
                    case 8:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ListMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ListMessage} ListMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListMessage message.
             * @function verify
             * @memberof proto.Message.ListMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.buttonText != null && message.hasOwnProperty("buttonText"))
                    if (!$util.isString(message.buttonText))
                        return "buttonText: string expected";
                if (message.listType != null && message.hasOwnProperty("listType"))
                    switch (message.listType) {
                    default:
                        return "listType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.sections != null && message.hasOwnProperty("sections")) {
                    if (!Array.isArray(message.sections))
                        return "sections: array expected";
                    for (var i = 0; i < message.sections.length; ++i) {
                        var error = $root.proto.Message.ListMessage.Section.verify(message.sections[i]);
                        if (error)
                            return "sections." + error;
                    }
                }
                if (message.productListInfo != null && message.hasOwnProperty("productListInfo")) {
                    var error = $root.proto.Message.ListMessage.ProductListInfo.verify(message.productListInfo);
                    if (error)
                        return "productListInfo." + error;
                }
                if (message.footerText != null && message.hasOwnProperty("footerText"))
                    if (!$util.isString(message.footerText))
                        return "footerText: string expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates a ListMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ListMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ListMessage} ListMessage
             */
            ListMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ListMessage)
                    return object;
                var message = new $root.proto.Message.ListMessage();
                if (object.title != null)
                    message.title = String(object.title);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.buttonText != null)
                    message.buttonText = String(object.buttonText);
                switch (object.listType) {
                case "UNKNOWN":
                case 0:
                    message.listType = 0;
                    break;
                case "SINGLE_SELECT":
                case 1:
                    message.listType = 1;
                    break;
                case "PRODUCT_LIST":
                case 2:
                    message.listType = 2;
                    break;
                }
                if (object.sections) {
                    if (!Array.isArray(object.sections))
                        throw TypeError(".proto.Message.ListMessage.sections: array expected");
                    message.sections = [];
                    for (var i = 0; i < object.sections.length; ++i) {
                        if (typeof object.sections[i] !== "object")
                            throw TypeError(".proto.Message.ListMessage.sections: object expected");
                        message.sections[i] = $root.proto.Message.ListMessage.Section.fromObject(object.sections[i]);
                    }
                }
                if (object.productListInfo != null) {
                    if (typeof object.productListInfo !== "object")
                        throw TypeError(".proto.Message.ListMessage.productListInfo: object expected");
                    message.productListInfo = $root.proto.Message.ListMessage.ProductListInfo.fromObject(object.productListInfo);
                }
                if (object.footerText != null)
                    message.footerText = String(object.footerText);
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ListMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ListMessage
             * @static
             * @param {proto.Message.ListMessage} message ListMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.sections = [];
                if (options.defaults) {
                    object.title = "";
                    object.description = "";
                    object.buttonText = "";
                    object.listType = options.enums === String ? "UNKNOWN" : 0;
                    object.productListInfo = null;
                    object.footerText = "";
                    object.contextInfo = null;
                }
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.buttonText != null && message.hasOwnProperty("buttonText"))
                    object.buttonText = message.buttonText;
                if (message.listType != null && message.hasOwnProperty("listType"))
                    object.listType = options.enums === String ? $root.proto.Message.ListMessage.ListType[message.listType] : message.listType;
                if (message.sections && message.sections.length) {
                    object.sections = [];
                    for (var j = 0; j < message.sections.length; ++j)
                        object.sections[j] = $root.proto.Message.ListMessage.Section.toObject(message.sections[j], options);
                }
                if (message.productListInfo != null && message.hasOwnProperty("productListInfo"))
                    object.productListInfo = $root.proto.Message.ListMessage.ProductListInfo.toObject(message.productListInfo, options);
                if (message.footerText != null && message.hasOwnProperty("footerText"))
                    object.footerText = message.footerText;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this ListMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ListMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ListType enum.
             * @name proto.Message.ListMessage.ListType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SINGLE_SELECT=1 SINGLE_SELECT value
             * @property {number} PRODUCT_LIST=2 PRODUCT_LIST value
             */
            ListMessage.ListType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SINGLE_SELECT"] = 1;
                values[valuesById[2] = "PRODUCT_LIST"] = 2;
                return values;
            })();

            ListMessage.Product = (function() {

                /**
                 * Properties of a Product.
                 * @memberof proto.Message.ListMessage
                 * @interface IProduct
                 * @property {string|null} [productId] Product productId
                 */

                /**
                 * Constructs a new Product.
                 * @memberof proto.Message.ListMessage
                 * @classdesc Represents a Product.
                 * @implements IProduct
                 * @constructor
                 * @param {proto.Message.ListMessage.IProduct=} [properties] Properties to set
                 */
                function Product(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Product productId.
                 * @member {string} productId
                 * @memberof proto.Message.ListMessage.Product
                 * @instance
                 */
                Product.prototype.productId = "";

                /**
                 * Creates a new Product instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ListMessage.Product
                 * @static
                 * @param {proto.Message.ListMessage.IProduct=} [properties] Properties to set
                 * @returns {proto.Message.ListMessage.Product} Product instance
                 */
                Product.create = function create(properties) {
                    return new Product(properties);
                };

                /**
                 * Encodes the specified Product message. Does not implicitly {@link proto.Message.ListMessage.Product.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ListMessage.Product
                 * @static
                 * @param {proto.Message.ListMessage.IProduct} message Product message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Product.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.productId != null && Object.hasOwnProperty.call(message, "productId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.productId);
                    return writer;
                };

                /**
                 * Encodes the specified Product message, length delimited. Does not implicitly {@link proto.Message.ListMessage.Product.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ListMessage.Product
                 * @static
                 * @param {proto.Message.ListMessage.IProduct} message Product message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Product.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Product message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ListMessage.Product
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ListMessage.Product} Product
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Product.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListMessage.Product();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.productId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Product message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ListMessage.Product
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ListMessage.Product} Product
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Product.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Product message.
                 * @function verify
                 * @memberof proto.Message.ListMessage.Product
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Product.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.productId != null && message.hasOwnProperty("productId"))
                        if (!$util.isString(message.productId))
                            return "productId: string expected";
                    return null;
                };

                /**
                 * Creates a Product message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ListMessage.Product
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ListMessage.Product} Product
                 */
                Product.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ListMessage.Product)
                        return object;
                    var message = new $root.proto.Message.ListMessage.Product();
                    if (object.productId != null)
                        message.productId = String(object.productId);
                    return message;
                };

                /**
                 * Creates a plain object from a Product message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ListMessage.Product
                 * @static
                 * @param {proto.Message.ListMessage.Product} message Product
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Product.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.productId = "";
                    if (message.productId != null && message.hasOwnProperty("productId"))
                        object.productId = message.productId;
                    return object;
                };

                /**
                 * Converts this Product to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ListMessage.Product
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Product.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Product;
            })();

            ListMessage.ProductListHeaderImage = (function() {

                /**
                 * Properties of a ProductListHeaderImage.
                 * @memberof proto.Message.ListMessage
                 * @interface IProductListHeaderImage
                 * @property {string|null} [productId] ProductListHeaderImage productId
                 * @property {Uint8Array|null} [jpegThumbnail] ProductListHeaderImage jpegThumbnail
                 */

                /**
                 * Constructs a new ProductListHeaderImage.
                 * @memberof proto.Message.ListMessage
                 * @classdesc Represents a ProductListHeaderImage.
                 * @implements IProductListHeaderImage
                 * @constructor
                 * @param {proto.Message.ListMessage.IProductListHeaderImage=} [properties] Properties to set
                 */
                function ProductListHeaderImage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProductListHeaderImage productId.
                 * @member {string} productId
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @instance
                 */
                ProductListHeaderImage.prototype.productId = "";

                /**
                 * ProductListHeaderImage jpegThumbnail.
                 * @member {Uint8Array} jpegThumbnail
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @instance
                 */
                ProductListHeaderImage.prototype.jpegThumbnail = $util.newBuffer([]);

                /**
                 * Creates a new ProductListHeaderImage instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @static
                 * @param {proto.Message.ListMessage.IProductListHeaderImage=} [properties] Properties to set
                 * @returns {proto.Message.ListMessage.ProductListHeaderImage} ProductListHeaderImage instance
                 */
                ProductListHeaderImage.create = function create(properties) {
                    return new ProductListHeaderImage(properties);
                };

                /**
                 * Encodes the specified ProductListHeaderImage message. Does not implicitly {@link proto.Message.ListMessage.ProductListHeaderImage.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @static
                 * @param {proto.Message.ListMessage.IProductListHeaderImage} message ProductListHeaderImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProductListHeaderImage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.productId != null && Object.hasOwnProperty.call(message, "productId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.productId);
                    if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.jpegThumbnail);
                    return writer;
                };

                /**
                 * Encodes the specified ProductListHeaderImage message, length delimited. Does not implicitly {@link proto.Message.ListMessage.ProductListHeaderImage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @static
                 * @param {proto.Message.ListMessage.IProductListHeaderImage} message ProductListHeaderImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProductListHeaderImage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProductListHeaderImage message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ListMessage.ProductListHeaderImage} ProductListHeaderImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProductListHeaderImage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListMessage.ProductListHeaderImage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.productId = reader.string();
                            break;
                        case 2:
                            message.jpegThumbnail = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProductListHeaderImage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ListMessage.ProductListHeaderImage} ProductListHeaderImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProductListHeaderImage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProductListHeaderImage message.
                 * @function verify
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProductListHeaderImage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.productId != null && message.hasOwnProperty("productId"))
                        if (!$util.isString(message.productId))
                            return "productId: string expected";
                    if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                        if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                            return "jpegThumbnail: buffer expected";
                    return null;
                };

                /**
                 * Creates a ProductListHeaderImage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ListMessage.ProductListHeaderImage} ProductListHeaderImage
                 */
                ProductListHeaderImage.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ListMessage.ProductListHeaderImage)
                        return object;
                    var message = new $root.proto.Message.ListMessage.ProductListHeaderImage();
                    if (object.productId != null)
                        message.productId = String(object.productId);
                    if (object.jpegThumbnail != null)
                        if (typeof object.jpegThumbnail === "string")
                            $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                        else if (object.jpegThumbnail.length)
                            message.jpegThumbnail = object.jpegThumbnail;
                    return message;
                };

                /**
                 * Creates a plain object from a ProductListHeaderImage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @static
                 * @param {proto.Message.ListMessage.ProductListHeaderImage} message ProductListHeaderImage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProductListHeaderImage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.productId = "";
                        if (options.bytes === String)
                            object.jpegThumbnail = "";
                        else {
                            object.jpegThumbnail = [];
                            if (options.bytes !== Array)
                                object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                        }
                    }
                    if (message.productId != null && message.hasOwnProperty("productId"))
                        object.productId = message.productId;
                    if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                        object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                    return object;
                };

                /**
                 * Converts this ProductListHeaderImage to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ListMessage.ProductListHeaderImage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProductListHeaderImage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProductListHeaderImage;
            })();

            ListMessage.ProductListInfo = (function() {

                /**
                 * Properties of a ProductListInfo.
                 * @memberof proto.Message.ListMessage
                 * @interface IProductListInfo
                 * @property {Array.<proto.Message.ListMessage.IProductSection>|null} [productSections] ProductListInfo productSections
                 * @property {proto.Message.ListMessage.IProductListHeaderImage|null} [headerImage] ProductListInfo headerImage
                 * @property {string|null} [businessOwnerJid] ProductListInfo businessOwnerJid
                 */

                /**
                 * Constructs a new ProductListInfo.
                 * @memberof proto.Message.ListMessage
                 * @classdesc Represents a ProductListInfo.
                 * @implements IProductListInfo
                 * @constructor
                 * @param {proto.Message.ListMessage.IProductListInfo=} [properties] Properties to set
                 */
                function ProductListInfo(properties) {
                    this.productSections = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProductListInfo productSections.
                 * @member {Array.<proto.Message.ListMessage.IProductSection>} productSections
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @instance
                 */
                ProductListInfo.prototype.productSections = $util.emptyArray;

                /**
                 * ProductListInfo headerImage.
                 * @member {proto.Message.ListMessage.IProductListHeaderImage|null|undefined} headerImage
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @instance
                 */
                ProductListInfo.prototype.headerImage = null;

                /**
                 * ProductListInfo businessOwnerJid.
                 * @member {string} businessOwnerJid
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @instance
                 */
                ProductListInfo.prototype.businessOwnerJid = "";

                /**
                 * Creates a new ProductListInfo instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @static
                 * @param {proto.Message.ListMessage.IProductListInfo=} [properties] Properties to set
                 * @returns {proto.Message.ListMessage.ProductListInfo} ProductListInfo instance
                 */
                ProductListInfo.create = function create(properties) {
                    return new ProductListInfo(properties);
                };

                /**
                 * Encodes the specified ProductListInfo message. Does not implicitly {@link proto.Message.ListMessage.ProductListInfo.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @static
                 * @param {proto.Message.ListMessage.IProductListInfo} message ProductListInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProductListInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.productSections != null && message.productSections.length)
                        for (var i = 0; i < message.productSections.length; ++i)
                            $root.proto.Message.ListMessage.ProductSection.encode(message.productSections[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.headerImage != null && Object.hasOwnProperty.call(message, "headerImage"))
                        $root.proto.Message.ListMessage.ProductListHeaderImage.encode(message.headerImage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.businessOwnerJid != null && Object.hasOwnProperty.call(message, "businessOwnerJid"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.businessOwnerJid);
                    return writer;
                };

                /**
                 * Encodes the specified ProductListInfo message, length delimited. Does not implicitly {@link proto.Message.ListMessage.ProductListInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @static
                 * @param {proto.Message.ListMessage.IProductListInfo} message ProductListInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProductListInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProductListInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ListMessage.ProductListInfo} ProductListInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProductListInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListMessage.ProductListInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.productSections && message.productSections.length))
                                message.productSections = [];
                            message.productSections.push($root.proto.Message.ListMessage.ProductSection.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.headerImage = $root.proto.Message.ListMessage.ProductListHeaderImage.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.businessOwnerJid = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProductListInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ListMessage.ProductListInfo} ProductListInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProductListInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProductListInfo message.
                 * @function verify
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProductListInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.productSections != null && message.hasOwnProperty("productSections")) {
                        if (!Array.isArray(message.productSections))
                            return "productSections: array expected";
                        for (var i = 0; i < message.productSections.length; ++i) {
                            var error = $root.proto.Message.ListMessage.ProductSection.verify(message.productSections[i]);
                            if (error)
                                return "productSections." + error;
                        }
                    }
                    if (message.headerImage != null && message.hasOwnProperty("headerImage")) {
                        var error = $root.proto.Message.ListMessage.ProductListHeaderImage.verify(message.headerImage);
                        if (error)
                            return "headerImage." + error;
                    }
                    if (message.businessOwnerJid != null && message.hasOwnProperty("businessOwnerJid"))
                        if (!$util.isString(message.businessOwnerJid))
                            return "businessOwnerJid: string expected";
                    return null;
                };

                /**
                 * Creates a ProductListInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ListMessage.ProductListInfo} ProductListInfo
                 */
                ProductListInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ListMessage.ProductListInfo)
                        return object;
                    var message = new $root.proto.Message.ListMessage.ProductListInfo();
                    if (object.productSections) {
                        if (!Array.isArray(object.productSections))
                            throw TypeError(".proto.Message.ListMessage.ProductListInfo.productSections: array expected");
                        message.productSections = [];
                        for (var i = 0; i < object.productSections.length; ++i) {
                            if (typeof object.productSections[i] !== "object")
                                throw TypeError(".proto.Message.ListMessage.ProductListInfo.productSections: object expected");
                            message.productSections[i] = $root.proto.Message.ListMessage.ProductSection.fromObject(object.productSections[i]);
                        }
                    }
                    if (object.headerImage != null) {
                        if (typeof object.headerImage !== "object")
                            throw TypeError(".proto.Message.ListMessage.ProductListInfo.headerImage: object expected");
                        message.headerImage = $root.proto.Message.ListMessage.ProductListHeaderImage.fromObject(object.headerImage);
                    }
                    if (object.businessOwnerJid != null)
                        message.businessOwnerJid = String(object.businessOwnerJid);
                    return message;
                };

                /**
                 * Creates a plain object from a ProductListInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @static
                 * @param {proto.Message.ListMessage.ProductListInfo} message ProductListInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProductListInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.productSections = [];
                    if (options.defaults) {
                        object.headerImage = null;
                        object.businessOwnerJid = "";
                    }
                    if (message.productSections && message.productSections.length) {
                        object.productSections = [];
                        for (var j = 0; j < message.productSections.length; ++j)
                            object.productSections[j] = $root.proto.Message.ListMessage.ProductSection.toObject(message.productSections[j], options);
                    }
                    if (message.headerImage != null && message.hasOwnProperty("headerImage"))
                        object.headerImage = $root.proto.Message.ListMessage.ProductListHeaderImage.toObject(message.headerImage, options);
                    if (message.businessOwnerJid != null && message.hasOwnProperty("businessOwnerJid"))
                        object.businessOwnerJid = message.businessOwnerJid;
                    return object;
                };

                /**
                 * Converts this ProductListInfo to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ListMessage.ProductListInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProductListInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProductListInfo;
            })();

            ListMessage.ProductSection = (function() {

                /**
                 * Properties of a ProductSection.
                 * @memberof proto.Message.ListMessage
                 * @interface IProductSection
                 * @property {string|null} [title] ProductSection title
                 * @property {Array.<proto.Message.ListMessage.IProduct>|null} [products] ProductSection products
                 */

                /**
                 * Constructs a new ProductSection.
                 * @memberof proto.Message.ListMessage
                 * @classdesc Represents a ProductSection.
                 * @implements IProductSection
                 * @constructor
                 * @param {proto.Message.ListMessage.IProductSection=} [properties] Properties to set
                 */
                function ProductSection(properties) {
                    this.products = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProductSection title.
                 * @member {string} title
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @instance
                 */
                ProductSection.prototype.title = "";

                /**
                 * ProductSection products.
                 * @member {Array.<proto.Message.ListMessage.IProduct>} products
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @instance
                 */
                ProductSection.prototype.products = $util.emptyArray;

                /**
                 * Creates a new ProductSection instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @static
                 * @param {proto.Message.ListMessage.IProductSection=} [properties] Properties to set
                 * @returns {proto.Message.ListMessage.ProductSection} ProductSection instance
                 */
                ProductSection.create = function create(properties) {
                    return new ProductSection(properties);
                };

                /**
                 * Encodes the specified ProductSection message. Does not implicitly {@link proto.Message.ListMessage.ProductSection.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @static
                 * @param {proto.Message.ListMessage.IProductSection} message ProductSection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProductSection.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                    if (message.products != null && message.products.length)
                        for (var i = 0; i < message.products.length; ++i)
                            $root.proto.Message.ListMessage.Product.encode(message.products[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ProductSection message, length delimited. Does not implicitly {@link proto.Message.ListMessage.ProductSection.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @static
                 * @param {proto.Message.ListMessage.IProductSection} message ProductSection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProductSection.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProductSection message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ListMessage.ProductSection} ProductSection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProductSection.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListMessage.ProductSection();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.title = reader.string();
                            break;
                        case 2:
                            if (!(message.products && message.products.length))
                                message.products = [];
                            message.products.push($root.proto.Message.ListMessage.Product.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProductSection message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ListMessage.ProductSection} ProductSection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProductSection.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProductSection message.
                 * @function verify
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProductSection.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.products != null && message.hasOwnProperty("products")) {
                        if (!Array.isArray(message.products))
                            return "products: array expected";
                        for (var i = 0; i < message.products.length; ++i) {
                            var error = $root.proto.Message.ListMessage.Product.verify(message.products[i]);
                            if (error)
                                return "products." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ProductSection message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ListMessage.ProductSection} ProductSection
                 */
                ProductSection.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ListMessage.ProductSection)
                        return object;
                    var message = new $root.proto.Message.ListMessage.ProductSection();
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.products) {
                        if (!Array.isArray(object.products))
                            throw TypeError(".proto.Message.ListMessage.ProductSection.products: array expected");
                        message.products = [];
                        for (var i = 0; i < object.products.length; ++i) {
                            if (typeof object.products[i] !== "object")
                                throw TypeError(".proto.Message.ListMessage.ProductSection.products: object expected");
                            message.products[i] = $root.proto.Message.ListMessage.Product.fromObject(object.products[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ProductSection message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @static
                 * @param {proto.Message.ListMessage.ProductSection} message ProductSection
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProductSection.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.products = [];
                    if (options.defaults)
                        object.title = "";
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.products && message.products.length) {
                        object.products = [];
                        for (var j = 0; j < message.products.length; ++j)
                            object.products[j] = $root.proto.Message.ListMessage.Product.toObject(message.products[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ProductSection to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ListMessage.ProductSection
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProductSection.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProductSection;
            })();

            ListMessage.Row = (function() {

                /**
                 * Properties of a Row.
                 * @memberof proto.Message.ListMessage
                 * @interface IRow
                 * @property {string|null} [title] Row title
                 * @property {string|null} [description] Row description
                 * @property {string|null} [rowId] Row rowId
                 */

                /**
                 * Constructs a new Row.
                 * @memberof proto.Message.ListMessage
                 * @classdesc Represents a Row.
                 * @implements IRow
                 * @constructor
                 * @param {proto.Message.ListMessage.IRow=} [properties] Properties to set
                 */
                function Row(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Row title.
                 * @member {string} title
                 * @memberof proto.Message.ListMessage.Row
                 * @instance
                 */
                Row.prototype.title = "";

                /**
                 * Row description.
                 * @member {string} description
                 * @memberof proto.Message.ListMessage.Row
                 * @instance
                 */
                Row.prototype.description = "";

                /**
                 * Row rowId.
                 * @member {string} rowId
                 * @memberof proto.Message.ListMessage.Row
                 * @instance
                 */
                Row.prototype.rowId = "";

                /**
                 * Creates a new Row instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ListMessage.Row
                 * @static
                 * @param {proto.Message.ListMessage.IRow=} [properties] Properties to set
                 * @returns {proto.Message.ListMessage.Row} Row instance
                 */
                Row.create = function create(properties) {
                    return new Row(properties);
                };

                /**
                 * Encodes the specified Row message. Does not implicitly {@link proto.Message.ListMessage.Row.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ListMessage.Row
                 * @static
                 * @param {proto.Message.ListMessage.IRow} message Row message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Row.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                    if (message.rowId != null && Object.hasOwnProperty.call(message, "rowId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.rowId);
                    return writer;
                };

                /**
                 * Encodes the specified Row message, length delimited. Does not implicitly {@link proto.Message.ListMessage.Row.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ListMessage.Row
                 * @static
                 * @param {proto.Message.ListMessage.IRow} message Row message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Row.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Row message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ListMessage.Row
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ListMessage.Row} Row
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Row.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListMessage.Row();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.title = reader.string();
                            break;
                        case 2:
                            message.description = reader.string();
                            break;
                        case 3:
                            message.rowId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Row message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ListMessage.Row
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ListMessage.Row} Row
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Row.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Row message.
                 * @function verify
                 * @memberof proto.Message.ListMessage.Row
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Row.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.rowId != null && message.hasOwnProperty("rowId"))
                        if (!$util.isString(message.rowId))
                            return "rowId: string expected";
                    return null;
                };

                /**
                 * Creates a Row message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ListMessage.Row
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ListMessage.Row} Row
                 */
                Row.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ListMessage.Row)
                        return object;
                    var message = new $root.proto.Message.ListMessage.Row();
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.rowId != null)
                        message.rowId = String(object.rowId);
                    return message;
                };

                /**
                 * Creates a plain object from a Row message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ListMessage.Row
                 * @static
                 * @param {proto.Message.ListMessage.Row} message Row
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Row.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.title = "";
                        object.description = "";
                        object.rowId = "";
                    }
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.rowId != null && message.hasOwnProperty("rowId"))
                        object.rowId = message.rowId;
                    return object;
                };

                /**
                 * Converts this Row to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ListMessage.Row
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Row.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Row;
            })();

            ListMessage.Section = (function() {

                /**
                 * Properties of a Section.
                 * @memberof proto.Message.ListMessage
                 * @interface ISection
                 * @property {string|null} [title] Section title
                 * @property {Array.<proto.Message.ListMessage.IRow>|null} [rows] Section rows
                 */

                /**
                 * Constructs a new Section.
                 * @memberof proto.Message.ListMessage
                 * @classdesc Represents a Section.
                 * @implements ISection
                 * @constructor
                 * @param {proto.Message.ListMessage.ISection=} [properties] Properties to set
                 */
                function Section(properties) {
                    this.rows = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Section title.
                 * @member {string} title
                 * @memberof proto.Message.ListMessage.Section
                 * @instance
                 */
                Section.prototype.title = "";

                /**
                 * Section rows.
                 * @member {Array.<proto.Message.ListMessage.IRow>} rows
                 * @memberof proto.Message.ListMessage.Section
                 * @instance
                 */
                Section.prototype.rows = $util.emptyArray;

                /**
                 * Creates a new Section instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ListMessage.Section
                 * @static
                 * @param {proto.Message.ListMessage.ISection=} [properties] Properties to set
                 * @returns {proto.Message.ListMessage.Section} Section instance
                 */
                Section.create = function create(properties) {
                    return new Section(properties);
                };

                /**
                 * Encodes the specified Section message. Does not implicitly {@link proto.Message.ListMessage.Section.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ListMessage.Section
                 * @static
                 * @param {proto.Message.ListMessage.ISection} message Section message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Section.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                    if (message.rows != null && message.rows.length)
                        for (var i = 0; i < message.rows.length; ++i)
                            $root.proto.Message.ListMessage.Row.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Section message, length delimited. Does not implicitly {@link proto.Message.ListMessage.Section.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ListMessage.Section
                 * @static
                 * @param {proto.Message.ListMessage.ISection} message Section message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Section.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Section message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ListMessage.Section
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ListMessage.Section} Section
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Section.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListMessage.Section();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.title = reader.string();
                            break;
                        case 2:
                            if (!(message.rows && message.rows.length))
                                message.rows = [];
                            message.rows.push($root.proto.Message.ListMessage.Row.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Section message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ListMessage.Section
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ListMessage.Section} Section
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Section.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Section message.
                 * @function verify
                 * @memberof proto.Message.ListMessage.Section
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Section.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.rows != null && message.hasOwnProperty("rows")) {
                        if (!Array.isArray(message.rows))
                            return "rows: array expected";
                        for (var i = 0; i < message.rows.length; ++i) {
                            var error = $root.proto.Message.ListMessage.Row.verify(message.rows[i]);
                            if (error)
                                return "rows." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Section message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ListMessage.Section
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ListMessage.Section} Section
                 */
                Section.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ListMessage.Section)
                        return object;
                    var message = new $root.proto.Message.ListMessage.Section();
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.rows) {
                        if (!Array.isArray(object.rows))
                            throw TypeError(".proto.Message.ListMessage.Section.rows: array expected");
                        message.rows = [];
                        for (var i = 0; i < object.rows.length; ++i) {
                            if (typeof object.rows[i] !== "object")
                                throw TypeError(".proto.Message.ListMessage.Section.rows: object expected");
                            message.rows[i] = $root.proto.Message.ListMessage.Row.fromObject(object.rows[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Section message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ListMessage.Section
                 * @static
                 * @param {proto.Message.ListMessage.Section} message Section
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Section.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rows = [];
                    if (options.defaults)
                        object.title = "";
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.rows && message.rows.length) {
                        object.rows = [];
                        for (var j = 0; j < message.rows.length; ++j)
                            object.rows[j] = $root.proto.Message.ListMessage.Row.toObject(message.rows[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Section to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ListMessage.Section
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Section.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Section;
            })();

            return ListMessage;
        })();

        Message.ListResponseMessage = (function() {

            /**
             * Properties of a ListResponseMessage.
             * @memberof proto.Message
             * @interface IListResponseMessage
             * @property {string|null} [title] ListResponseMessage title
             * @property {proto.Message.ListResponseMessage.ListType|null} [listType] ListResponseMessage listType
             * @property {proto.Message.ListResponseMessage.ISingleSelectReply|null} [singleSelectReply] ListResponseMessage singleSelectReply
             * @property {proto.IContextInfo|null} [contextInfo] ListResponseMessage contextInfo
             * @property {string|null} [description] ListResponseMessage description
             */

            /**
             * Constructs a new ListResponseMessage.
             * @memberof proto.Message
             * @classdesc Represents a ListResponseMessage.
             * @implements IListResponseMessage
             * @constructor
             * @param {proto.Message.IListResponseMessage=} [properties] Properties to set
             */
            function ListResponseMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListResponseMessage title.
             * @member {string} title
             * @memberof proto.Message.ListResponseMessage
             * @instance
             */
            ListResponseMessage.prototype.title = "";

            /**
             * ListResponseMessage listType.
             * @member {proto.Message.ListResponseMessage.ListType} listType
             * @memberof proto.Message.ListResponseMessage
             * @instance
             */
            ListResponseMessage.prototype.listType = 0;

            /**
             * ListResponseMessage singleSelectReply.
             * @member {proto.Message.ListResponseMessage.ISingleSelectReply|null|undefined} singleSelectReply
             * @memberof proto.Message.ListResponseMessage
             * @instance
             */
            ListResponseMessage.prototype.singleSelectReply = null;

            /**
             * ListResponseMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ListResponseMessage
             * @instance
             */
            ListResponseMessage.prototype.contextInfo = null;

            /**
             * ListResponseMessage description.
             * @member {string} description
             * @memberof proto.Message.ListResponseMessage
             * @instance
             */
            ListResponseMessage.prototype.description = "";

            /**
             * Creates a new ListResponseMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ListResponseMessage
             * @static
             * @param {proto.Message.IListResponseMessage=} [properties] Properties to set
             * @returns {proto.Message.ListResponseMessage} ListResponseMessage instance
             */
            ListResponseMessage.create = function create(properties) {
                return new ListResponseMessage(properties);
            };

            /**
             * Encodes the specified ListResponseMessage message. Does not implicitly {@link proto.Message.ListResponseMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ListResponseMessage
             * @static
             * @param {proto.Message.IListResponseMessage} message ListResponseMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListResponseMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                if (message.listType != null && Object.hasOwnProperty.call(message, "listType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.listType);
                if (message.singleSelectReply != null && Object.hasOwnProperty.call(message, "singleSelectReply"))
                    $root.proto.Message.ListResponseMessage.SingleSelectReply.encode(message.singleSelectReply, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified ListResponseMessage message, length delimited. Does not implicitly {@link proto.Message.ListResponseMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ListResponseMessage
             * @static
             * @param {proto.Message.IListResponseMessage} message ListResponseMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListResponseMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListResponseMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ListResponseMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ListResponseMessage} ListResponseMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListResponseMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListResponseMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.title = reader.string();
                        break;
                    case 2:
                        message.listType = reader.int32();
                        break;
                    case 3:
                        message.singleSelectReply = $root.proto.Message.ListResponseMessage.SingleSelectReply.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.description = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListResponseMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ListResponseMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ListResponseMessage} ListResponseMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListResponseMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListResponseMessage message.
             * @function verify
             * @memberof proto.Message.ListResponseMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListResponseMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.listType != null && message.hasOwnProperty("listType"))
                    switch (message.listType) {
                    default:
                        return "listType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.singleSelectReply != null && message.hasOwnProperty("singleSelectReply")) {
                    var error = $root.proto.Message.ListResponseMessage.SingleSelectReply.verify(message.singleSelectReply);
                    if (error)
                        return "singleSelectReply." + error;
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates a ListResponseMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ListResponseMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ListResponseMessage} ListResponseMessage
             */
            ListResponseMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ListResponseMessage)
                    return object;
                var message = new $root.proto.Message.ListResponseMessage();
                if (object.title != null)
                    message.title = String(object.title);
                switch (object.listType) {
                case "UNKNOWN":
                case 0:
                    message.listType = 0;
                    break;
                case "SINGLE_SELECT":
                case 1:
                    message.listType = 1;
                    break;
                }
                if (object.singleSelectReply != null) {
                    if (typeof object.singleSelectReply !== "object")
                        throw TypeError(".proto.Message.ListResponseMessage.singleSelectReply: object expected");
                    message.singleSelectReply = $root.proto.Message.ListResponseMessage.SingleSelectReply.fromObject(object.singleSelectReply);
                }
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ListResponseMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from a ListResponseMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ListResponseMessage
             * @static
             * @param {proto.Message.ListResponseMessage} message ListResponseMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListResponseMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.title = "";
                    object.listType = options.enums === String ? "UNKNOWN" : 0;
                    object.singleSelectReply = null;
                    object.contextInfo = null;
                    object.description = "";
                }
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.listType != null && message.hasOwnProperty("listType"))
                    object.listType = options.enums === String ? $root.proto.Message.ListResponseMessage.ListType[message.listType] : message.listType;
                if (message.singleSelectReply != null && message.hasOwnProperty("singleSelectReply"))
                    object.singleSelectReply = $root.proto.Message.ListResponseMessage.SingleSelectReply.toObject(message.singleSelectReply, options);
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this ListResponseMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ListResponseMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListResponseMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ListType enum.
             * @name proto.Message.ListResponseMessage.ListType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SINGLE_SELECT=1 SINGLE_SELECT value
             */
            ListResponseMessage.ListType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SINGLE_SELECT"] = 1;
                return values;
            })();

            ListResponseMessage.SingleSelectReply = (function() {

                /**
                 * Properties of a SingleSelectReply.
                 * @memberof proto.Message.ListResponseMessage
                 * @interface ISingleSelectReply
                 * @property {string|null} [selectedRowId] SingleSelectReply selectedRowId
                 */

                /**
                 * Constructs a new SingleSelectReply.
                 * @memberof proto.Message.ListResponseMessage
                 * @classdesc Represents a SingleSelectReply.
                 * @implements ISingleSelectReply
                 * @constructor
                 * @param {proto.Message.ListResponseMessage.ISingleSelectReply=} [properties] Properties to set
                 */
                function SingleSelectReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SingleSelectReply selectedRowId.
                 * @member {string} selectedRowId
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @instance
                 */
                SingleSelectReply.prototype.selectedRowId = "";

                /**
                 * Creates a new SingleSelectReply instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @static
                 * @param {proto.Message.ListResponseMessage.ISingleSelectReply=} [properties] Properties to set
                 * @returns {proto.Message.ListResponseMessage.SingleSelectReply} SingleSelectReply instance
                 */
                SingleSelectReply.create = function create(properties) {
                    return new SingleSelectReply(properties);
                };

                /**
                 * Encodes the specified SingleSelectReply message. Does not implicitly {@link proto.Message.ListResponseMessage.SingleSelectReply.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @static
                 * @param {proto.Message.ListResponseMessage.ISingleSelectReply} message SingleSelectReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SingleSelectReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.selectedRowId != null && Object.hasOwnProperty.call(message, "selectedRowId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.selectedRowId);
                    return writer;
                };

                /**
                 * Encodes the specified SingleSelectReply message, length delimited. Does not implicitly {@link proto.Message.ListResponseMessage.SingleSelectReply.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @static
                 * @param {proto.Message.ListResponseMessage.ISingleSelectReply} message SingleSelectReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SingleSelectReply.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SingleSelectReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ListResponseMessage.SingleSelectReply} SingleSelectReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SingleSelectReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ListResponseMessage.SingleSelectReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.selectedRowId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SingleSelectReply message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ListResponseMessage.SingleSelectReply} SingleSelectReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SingleSelectReply.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SingleSelectReply message.
                 * @function verify
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SingleSelectReply.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.selectedRowId != null && message.hasOwnProperty("selectedRowId"))
                        if (!$util.isString(message.selectedRowId))
                            return "selectedRowId: string expected";
                    return null;
                };

                /**
                 * Creates a SingleSelectReply message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ListResponseMessage.SingleSelectReply} SingleSelectReply
                 */
                SingleSelectReply.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ListResponseMessage.SingleSelectReply)
                        return object;
                    var message = new $root.proto.Message.ListResponseMessage.SingleSelectReply();
                    if (object.selectedRowId != null)
                        message.selectedRowId = String(object.selectedRowId);
                    return message;
                };

                /**
                 * Creates a plain object from a SingleSelectReply message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @static
                 * @param {proto.Message.ListResponseMessage.SingleSelectReply} message SingleSelectReply
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SingleSelectReply.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.selectedRowId = "";
                    if (message.selectedRowId != null && message.hasOwnProperty("selectedRowId"))
                        object.selectedRowId = message.selectedRowId;
                    return object;
                };

                /**
                 * Converts this SingleSelectReply to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ListResponseMessage.SingleSelectReply
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SingleSelectReply.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SingleSelectReply;
            })();

            return ListResponseMessage;
        })();

        Message.LiveLocationMessage = (function() {

            /**
             * Properties of a LiveLocationMessage.
             * @memberof proto.Message
             * @interface ILiveLocationMessage
             * @property {number|null} [degreesLatitude] LiveLocationMessage degreesLatitude
             * @property {number|null} [degreesLongitude] LiveLocationMessage degreesLongitude
             * @property {number|null} [accuracyInMeters] LiveLocationMessage accuracyInMeters
             * @property {number|null} [speedInMps] LiveLocationMessage speedInMps
             * @property {number|null} [degreesClockwiseFromMagneticNorth] LiveLocationMessage degreesClockwiseFromMagneticNorth
             * @property {string|null} [caption] LiveLocationMessage caption
             * @property {number|Long|null} [sequenceNumber] LiveLocationMessage sequenceNumber
             * @property {number|null} [timeOffset] LiveLocationMessage timeOffset
             * @property {Uint8Array|null} [jpegThumbnail] LiveLocationMessage jpegThumbnail
             * @property {proto.IContextInfo|null} [contextInfo] LiveLocationMessage contextInfo
             */

            /**
             * Constructs a new LiveLocationMessage.
             * @memberof proto.Message
             * @classdesc Represents a LiveLocationMessage.
             * @implements ILiveLocationMessage
             * @constructor
             * @param {proto.Message.ILiveLocationMessage=} [properties] Properties to set
             */
            function LiveLocationMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LiveLocationMessage degreesLatitude.
             * @member {number} degreesLatitude
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.degreesLatitude = 0;

            /**
             * LiveLocationMessage degreesLongitude.
             * @member {number} degreesLongitude
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.degreesLongitude = 0;

            /**
             * LiveLocationMessage accuracyInMeters.
             * @member {number} accuracyInMeters
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.accuracyInMeters = 0;

            /**
             * LiveLocationMessage speedInMps.
             * @member {number} speedInMps
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.speedInMps = 0;

            /**
             * LiveLocationMessage degreesClockwiseFromMagneticNorth.
             * @member {number} degreesClockwiseFromMagneticNorth
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.degreesClockwiseFromMagneticNorth = 0;

            /**
             * LiveLocationMessage caption.
             * @member {string} caption
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.caption = "";

            /**
             * LiveLocationMessage sequenceNumber.
             * @member {number|Long} sequenceNumber
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * LiveLocationMessage timeOffset.
             * @member {number} timeOffset
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.timeOffset = 0;

            /**
             * LiveLocationMessage jpegThumbnail.
             * @member {Uint8Array} jpegThumbnail
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.jpegThumbnail = $util.newBuffer([]);

            /**
             * LiveLocationMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             */
            LiveLocationMessage.prototype.contextInfo = null;

            /**
             * Creates a new LiveLocationMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.LiveLocationMessage
             * @static
             * @param {proto.Message.ILiveLocationMessage=} [properties] Properties to set
             * @returns {proto.Message.LiveLocationMessage} LiveLocationMessage instance
             */
            LiveLocationMessage.create = function create(properties) {
                return new LiveLocationMessage(properties);
            };

            /**
             * Encodes the specified LiveLocationMessage message. Does not implicitly {@link proto.Message.LiveLocationMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.LiveLocationMessage
             * @static
             * @param {proto.Message.ILiveLocationMessage} message LiveLocationMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LiveLocationMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.degreesLatitude != null && Object.hasOwnProperty.call(message, "degreesLatitude"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.degreesLatitude);
                if (message.degreesLongitude != null && Object.hasOwnProperty.call(message, "degreesLongitude"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.degreesLongitude);
                if (message.accuracyInMeters != null && Object.hasOwnProperty.call(message, "accuracyInMeters"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.accuracyInMeters);
                if (message.speedInMps != null && Object.hasOwnProperty.call(message, "speedInMps"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.speedInMps);
                if (message.degreesClockwiseFromMagneticNorth != null && Object.hasOwnProperty.call(message, "degreesClockwiseFromMagneticNorth"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.degreesClockwiseFromMagneticNorth);
                if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.caption);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.sequenceNumber);
                if (message.timeOffset != null && Object.hasOwnProperty.call(message, "timeOffset"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.timeOffset);
                if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LiveLocationMessage message, length delimited. Does not implicitly {@link proto.Message.LiveLocationMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.LiveLocationMessage
             * @static
             * @param {proto.Message.ILiveLocationMessage} message LiveLocationMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LiveLocationMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LiveLocationMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.LiveLocationMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.LiveLocationMessage} LiveLocationMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LiveLocationMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.LiveLocationMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.degreesLatitude = reader.double();
                        break;
                    case 2:
                        message.degreesLongitude = reader.double();
                        break;
                    case 3:
                        message.accuracyInMeters = reader.uint32();
                        break;
                    case 4:
                        message.speedInMps = reader.float();
                        break;
                    case 5:
                        message.degreesClockwiseFromMagneticNorth = reader.uint32();
                        break;
                    case 6:
                        message.caption = reader.string();
                        break;
                    case 7:
                        message.sequenceNumber = reader.int64();
                        break;
                    case 8:
                        message.timeOffset = reader.uint32();
                        break;
                    case 16:
                        message.jpegThumbnail = reader.bytes();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LiveLocationMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.LiveLocationMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.LiveLocationMessage} LiveLocationMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LiveLocationMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LiveLocationMessage message.
             * @function verify
             * @memberof proto.Message.LiveLocationMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LiveLocationMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                    if (typeof message.degreesLatitude !== "number")
                        return "degreesLatitude: number expected";
                if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                    if (typeof message.degreesLongitude !== "number")
                        return "degreesLongitude: number expected";
                if (message.accuracyInMeters != null && message.hasOwnProperty("accuracyInMeters"))
                    if (!$util.isInteger(message.accuracyInMeters))
                        return "accuracyInMeters: integer expected";
                if (message.speedInMps != null && message.hasOwnProperty("speedInMps"))
                    if (typeof message.speedInMps !== "number")
                        return "speedInMps: number expected";
                if (message.degreesClockwiseFromMagneticNorth != null && message.hasOwnProperty("degreesClockwiseFromMagneticNorth"))
                    if (!$util.isInteger(message.degreesClockwiseFromMagneticNorth))
                        return "degreesClockwiseFromMagneticNorth: integer expected";
                if (message.caption != null && message.hasOwnProperty("caption"))
                    if (!$util.isString(message.caption))
                        return "caption: string expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                        return "sequenceNumber: integer|Long expected";
                if (message.timeOffset != null && message.hasOwnProperty("timeOffset"))
                    if (!$util.isInteger(message.timeOffset))
                        return "timeOffset: integer expected";
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                        return "jpegThumbnail: buffer expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates a LiveLocationMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.LiveLocationMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.LiveLocationMessage} LiveLocationMessage
             */
            LiveLocationMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.LiveLocationMessage)
                    return object;
                var message = new $root.proto.Message.LiveLocationMessage();
                if (object.degreesLatitude != null)
                    message.degreesLatitude = Number(object.degreesLatitude);
                if (object.degreesLongitude != null)
                    message.degreesLongitude = Number(object.degreesLongitude);
                if (object.accuracyInMeters != null)
                    message.accuracyInMeters = object.accuracyInMeters >>> 0;
                if (object.speedInMps != null)
                    message.speedInMps = Number(object.speedInMps);
                if (object.degreesClockwiseFromMagneticNorth != null)
                    message.degreesClockwiseFromMagneticNorth = object.degreesClockwiseFromMagneticNorth >>> 0;
                if (object.caption != null)
                    message.caption = String(object.caption);
                if (object.sequenceNumber != null)
                    if ($util.Long)
                        (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = false;
                    else if (typeof object.sequenceNumber === "string")
                        message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                    else if (typeof object.sequenceNumber === "number")
                        message.sequenceNumber = object.sequenceNumber;
                    else if (typeof object.sequenceNumber === "object")
                        message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber();
                if (object.timeOffset != null)
                    message.timeOffset = object.timeOffset >>> 0;
                if (object.jpegThumbnail != null)
                    if (typeof object.jpegThumbnail === "string")
                        $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                    else if (object.jpegThumbnail.length)
                        message.jpegThumbnail = object.jpegThumbnail;
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.LiveLocationMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a LiveLocationMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.LiveLocationMessage
             * @static
             * @param {proto.Message.LiveLocationMessage} message LiveLocationMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LiveLocationMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.degreesLatitude = 0;
                    object.degreesLongitude = 0;
                    object.accuracyInMeters = 0;
                    object.speedInMps = 0;
                    object.degreesClockwiseFromMagneticNorth = 0;
                    object.caption = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequenceNumber = options.longs === String ? "0" : 0;
                    object.timeOffset = 0;
                    if (options.bytes === String)
                        object.jpegThumbnail = "";
                    else {
                        object.jpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                    }
                    object.contextInfo = null;
                }
                if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                    object.degreesLatitude = options.json && !isFinite(message.degreesLatitude) ? String(message.degreesLatitude) : message.degreesLatitude;
                if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                    object.degreesLongitude = options.json && !isFinite(message.degreesLongitude) ? String(message.degreesLongitude) : message.degreesLongitude;
                if (message.accuracyInMeters != null && message.hasOwnProperty("accuracyInMeters"))
                    object.accuracyInMeters = message.accuracyInMeters;
                if (message.speedInMps != null && message.hasOwnProperty("speedInMps"))
                    object.speedInMps = options.json && !isFinite(message.speedInMps) ? String(message.speedInMps) : message.speedInMps;
                if (message.degreesClockwiseFromMagneticNorth != null && message.hasOwnProperty("degreesClockwiseFromMagneticNorth"))
                    object.degreesClockwiseFromMagneticNorth = message.degreesClockwiseFromMagneticNorth;
                if (message.caption != null && message.hasOwnProperty("caption"))
                    object.caption = message.caption;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (typeof message.sequenceNumber === "number")
                        object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                    else
                        object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber() : message.sequenceNumber;
                if (message.timeOffset != null && message.hasOwnProperty("timeOffset"))
                    object.timeOffset = message.timeOffset;
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this LiveLocationMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.LiveLocationMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LiveLocationMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LiveLocationMessage;
        })();

        Message.LocationMessage = (function() {

            /**
             * Properties of a LocationMessage.
             * @memberof proto.Message
             * @interface ILocationMessage
             * @property {number|null} [degreesLatitude] LocationMessage degreesLatitude
             * @property {number|null} [degreesLongitude] LocationMessage degreesLongitude
             * @property {string|null} [name] LocationMessage name
             * @property {string|null} [address] LocationMessage address
             * @property {string|null} [url] LocationMessage url
             * @property {boolean|null} [isLive] LocationMessage isLive
             * @property {number|null} [accuracyInMeters] LocationMessage accuracyInMeters
             * @property {number|null} [speedInMps] LocationMessage speedInMps
             * @property {number|null} [degreesClockwiseFromMagneticNorth] LocationMessage degreesClockwiseFromMagneticNorth
             * @property {string|null} [comment] LocationMessage comment
             * @property {Uint8Array|null} [jpegThumbnail] LocationMessage jpegThumbnail
             * @property {proto.IContextInfo|null} [contextInfo] LocationMessage contextInfo
             */

            /**
             * Constructs a new LocationMessage.
             * @memberof proto.Message
             * @classdesc Represents a LocationMessage.
             * @implements ILocationMessage
             * @constructor
             * @param {proto.Message.ILocationMessage=} [properties] Properties to set
             */
            function LocationMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationMessage degreesLatitude.
             * @member {number} degreesLatitude
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.degreesLatitude = 0;

            /**
             * LocationMessage degreesLongitude.
             * @member {number} degreesLongitude
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.degreesLongitude = 0;

            /**
             * LocationMessage name.
             * @member {string} name
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.name = "";

            /**
             * LocationMessage address.
             * @member {string} address
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.address = "";

            /**
             * LocationMessage url.
             * @member {string} url
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.url = "";

            /**
             * LocationMessage isLive.
             * @member {boolean} isLive
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.isLive = false;

            /**
             * LocationMessage accuracyInMeters.
             * @member {number} accuracyInMeters
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.accuracyInMeters = 0;

            /**
             * LocationMessage speedInMps.
             * @member {number} speedInMps
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.speedInMps = 0;

            /**
             * LocationMessage degreesClockwiseFromMagneticNorth.
             * @member {number} degreesClockwiseFromMagneticNorth
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.degreesClockwiseFromMagneticNorth = 0;

            /**
             * LocationMessage comment.
             * @member {string} comment
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.comment = "";

            /**
             * LocationMessage jpegThumbnail.
             * @member {Uint8Array} jpegThumbnail
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.jpegThumbnail = $util.newBuffer([]);

            /**
             * LocationMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.LocationMessage
             * @instance
             */
            LocationMessage.prototype.contextInfo = null;

            /**
             * Creates a new LocationMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.LocationMessage
             * @static
             * @param {proto.Message.ILocationMessage=} [properties] Properties to set
             * @returns {proto.Message.LocationMessage} LocationMessage instance
             */
            LocationMessage.create = function create(properties) {
                return new LocationMessage(properties);
            };

            /**
             * Encodes the specified LocationMessage message. Does not implicitly {@link proto.Message.LocationMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.LocationMessage
             * @static
             * @param {proto.Message.ILocationMessage} message LocationMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.degreesLatitude != null && Object.hasOwnProperty.call(message, "degreesLatitude"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.degreesLatitude);
                if (message.degreesLongitude != null && Object.hasOwnProperty.call(message, "degreesLongitude"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.degreesLongitude);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.address);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
                if (message.isLive != null && Object.hasOwnProperty.call(message, "isLive"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isLive);
                if (message.accuracyInMeters != null && Object.hasOwnProperty.call(message, "accuracyInMeters"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.accuracyInMeters);
                if (message.speedInMps != null && Object.hasOwnProperty.call(message, "speedInMps"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.speedInMps);
                if (message.degreesClockwiseFromMagneticNorth != null && Object.hasOwnProperty.call(message, "degreesClockwiseFromMagneticNorth"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.degreesClockwiseFromMagneticNorth);
                if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.comment);
                if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LocationMessage message, length delimited. Does not implicitly {@link proto.Message.LocationMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.LocationMessage
             * @static
             * @param {proto.Message.ILocationMessage} message LocationMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.LocationMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.LocationMessage} LocationMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.LocationMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.degreesLatitude = reader.double();
                        break;
                    case 2:
                        message.degreesLongitude = reader.double();
                        break;
                    case 3:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.address = reader.string();
                        break;
                    case 5:
                        message.url = reader.string();
                        break;
                    case 6:
                        message.isLive = reader.bool();
                        break;
                    case 7:
                        message.accuracyInMeters = reader.uint32();
                        break;
                    case 8:
                        message.speedInMps = reader.float();
                        break;
                    case 9:
                        message.degreesClockwiseFromMagneticNorth = reader.uint32();
                        break;
                    case 11:
                        message.comment = reader.string();
                        break;
                    case 16:
                        message.jpegThumbnail = reader.bytes();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.LocationMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.LocationMessage} LocationMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationMessage message.
             * @function verify
             * @memberof proto.Message.LocationMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                    if (typeof message.degreesLatitude !== "number")
                        return "degreesLatitude: number expected";
                if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                    if (typeof message.degreesLongitude !== "number")
                        return "degreesLongitude: number expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.isLive != null && message.hasOwnProperty("isLive"))
                    if (typeof message.isLive !== "boolean")
                        return "isLive: boolean expected";
                if (message.accuracyInMeters != null && message.hasOwnProperty("accuracyInMeters"))
                    if (!$util.isInteger(message.accuracyInMeters))
                        return "accuracyInMeters: integer expected";
                if (message.speedInMps != null && message.hasOwnProperty("speedInMps"))
                    if (typeof message.speedInMps !== "number")
                        return "speedInMps: number expected";
                if (message.degreesClockwiseFromMagneticNorth != null && message.hasOwnProperty("degreesClockwiseFromMagneticNorth"))
                    if (!$util.isInteger(message.degreesClockwiseFromMagneticNorth))
                        return "degreesClockwiseFromMagneticNorth: integer expected";
                if (message.comment != null && message.hasOwnProperty("comment"))
                    if (!$util.isString(message.comment))
                        return "comment: string expected";
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                        return "jpegThumbnail: buffer expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates a LocationMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.LocationMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.LocationMessage} LocationMessage
             */
            LocationMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.LocationMessage)
                    return object;
                var message = new $root.proto.Message.LocationMessage();
                if (object.degreesLatitude != null)
                    message.degreesLatitude = Number(object.degreesLatitude);
                if (object.degreesLongitude != null)
                    message.degreesLongitude = Number(object.degreesLongitude);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.address != null)
                    message.address = String(object.address);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.isLive != null)
                    message.isLive = Boolean(object.isLive);
                if (object.accuracyInMeters != null)
                    message.accuracyInMeters = object.accuracyInMeters >>> 0;
                if (object.speedInMps != null)
                    message.speedInMps = Number(object.speedInMps);
                if (object.degreesClockwiseFromMagneticNorth != null)
                    message.degreesClockwiseFromMagneticNorth = object.degreesClockwiseFromMagneticNorth >>> 0;
                if (object.comment != null)
                    message.comment = String(object.comment);
                if (object.jpegThumbnail != null)
                    if (typeof object.jpegThumbnail === "string")
                        $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                    else if (object.jpegThumbnail.length)
                        message.jpegThumbnail = object.jpegThumbnail;
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.LocationMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a LocationMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.LocationMessage
             * @static
             * @param {proto.Message.LocationMessage} message LocationMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.degreesLatitude = 0;
                    object.degreesLongitude = 0;
                    object.name = "";
                    object.address = "";
                    object.url = "";
                    object.isLive = false;
                    object.accuracyInMeters = 0;
                    object.speedInMps = 0;
                    object.degreesClockwiseFromMagneticNorth = 0;
                    object.comment = "";
                    if (options.bytes === String)
                        object.jpegThumbnail = "";
                    else {
                        object.jpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                    }
                    object.contextInfo = null;
                }
                if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                    object.degreesLatitude = options.json && !isFinite(message.degreesLatitude) ? String(message.degreesLatitude) : message.degreesLatitude;
                if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                    object.degreesLongitude = options.json && !isFinite(message.degreesLongitude) ? String(message.degreesLongitude) : message.degreesLongitude;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.isLive != null && message.hasOwnProperty("isLive"))
                    object.isLive = message.isLive;
                if (message.accuracyInMeters != null && message.hasOwnProperty("accuracyInMeters"))
                    object.accuracyInMeters = message.accuracyInMeters;
                if (message.speedInMps != null && message.hasOwnProperty("speedInMps"))
                    object.speedInMps = options.json && !isFinite(message.speedInMps) ? String(message.speedInMps) : message.speedInMps;
                if (message.degreesClockwiseFromMagneticNorth != null && message.hasOwnProperty("degreesClockwiseFromMagneticNorth"))
                    object.degreesClockwiseFromMagneticNorth = message.degreesClockwiseFromMagneticNorth;
                if (message.comment != null && message.hasOwnProperty("comment"))
                    object.comment = message.comment;
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this LocationMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.LocationMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationMessage;
        })();

        Message.OrderMessage = (function() {

            /**
             * Properties of an OrderMessage.
             * @memberof proto.Message
             * @interface IOrderMessage
             * @property {string|null} [orderId] OrderMessage orderId
             * @property {Uint8Array|null} [thumbnail] OrderMessage thumbnail
             * @property {number|null} [itemCount] OrderMessage itemCount
             * @property {proto.Message.OrderMessage.OrderStatus|null} [status] OrderMessage status
             * @property {proto.Message.OrderMessage.OrderSurface|null} [surface] OrderMessage surface
             * @property {string|null} [message] OrderMessage message
             * @property {string|null} [orderTitle] OrderMessage orderTitle
             * @property {string|null} [sellerJid] OrderMessage sellerJid
             * @property {string|null} [token] OrderMessage token
             * @property {number|Long|null} [totalAmount1000] OrderMessage totalAmount1000
             * @property {string|null} [totalCurrencyCode] OrderMessage totalCurrencyCode
             * @property {proto.IContextInfo|null} [contextInfo] OrderMessage contextInfo
             */

            /**
             * Constructs a new OrderMessage.
             * @memberof proto.Message
             * @classdesc Represents an OrderMessage.
             * @implements IOrderMessage
             * @constructor
             * @param {proto.Message.IOrderMessage=} [properties] Properties to set
             */
            function OrderMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OrderMessage orderId.
             * @member {string} orderId
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.orderId = "";

            /**
             * OrderMessage thumbnail.
             * @member {Uint8Array} thumbnail
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.thumbnail = $util.newBuffer([]);

            /**
             * OrderMessage itemCount.
             * @member {number} itemCount
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.itemCount = 0;

            /**
             * OrderMessage status.
             * @member {proto.Message.OrderMessage.OrderStatus} status
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.status = 1;

            /**
             * OrderMessage surface.
             * @member {proto.Message.OrderMessage.OrderSurface} surface
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.surface = 1;

            /**
             * OrderMessage message.
             * @member {string} message
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.message = "";

            /**
             * OrderMessage orderTitle.
             * @member {string} orderTitle
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.orderTitle = "";

            /**
             * OrderMessage sellerJid.
             * @member {string} sellerJid
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.sellerJid = "";

            /**
             * OrderMessage token.
             * @member {string} token
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.token = "";

            /**
             * OrderMessage totalAmount1000.
             * @member {number|Long} totalAmount1000
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.totalAmount1000 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * OrderMessage totalCurrencyCode.
             * @member {string} totalCurrencyCode
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.totalCurrencyCode = "";

            /**
             * OrderMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.OrderMessage
             * @instance
             */
            OrderMessage.prototype.contextInfo = null;

            /**
             * Creates a new OrderMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.OrderMessage
             * @static
             * @param {proto.Message.IOrderMessage=} [properties] Properties to set
             * @returns {proto.Message.OrderMessage} OrderMessage instance
             */
            OrderMessage.create = function create(properties) {
                return new OrderMessage(properties);
            };

            /**
             * Encodes the specified OrderMessage message. Does not implicitly {@link proto.Message.OrderMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.OrderMessage
             * @static
             * @param {proto.Message.IOrderMessage} message OrderMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
                if (message.thumbnail != null && Object.hasOwnProperty.call(message, "thumbnail"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.thumbnail);
                if (message.itemCount != null && Object.hasOwnProperty.call(message, "itemCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.itemCount);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
                if (message.surface != null && Object.hasOwnProperty.call(message, "surface"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.surface);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.message);
                if (message.orderTitle != null && Object.hasOwnProperty.call(message, "orderTitle"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.orderTitle);
                if (message.sellerJid != null && Object.hasOwnProperty.call(message, "sellerJid"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.sellerJid);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.token);
                if (message.totalAmount1000 != null && Object.hasOwnProperty.call(message, "totalAmount1000"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.totalAmount1000);
                if (message.totalCurrencyCode != null && Object.hasOwnProperty.call(message, "totalCurrencyCode"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.totalCurrencyCode);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OrderMessage message, length delimited. Does not implicitly {@link proto.Message.OrderMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.OrderMessage
             * @static
             * @param {proto.Message.IOrderMessage} message OrderMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrderMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OrderMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.OrderMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.OrderMessage} OrderMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.OrderMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.orderId = reader.string();
                        break;
                    case 2:
                        message.thumbnail = reader.bytes();
                        break;
                    case 3:
                        message.itemCount = reader.int32();
                        break;
                    case 4:
                        message.status = reader.int32();
                        break;
                    case 5:
                        message.surface = reader.int32();
                        break;
                    case 6:
                        message.message = reader.string();
                        break;
                    case 7:
                        message.orderTitle = reader.string();
                        break;
                    case 8:
                        message.sellerJid = reader.string();
                        break;
                    case 9:
                        message.token = reader.string();
                        break;
                    case 10:
                        message.totalAmount1000 = reader.int64();
                        break;
                    case 11:
                        message.totalCurrencyCode = reader.string();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OrderMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.OrderMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.OrderMessage} OrderMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrderMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OrderMessage message.
             * @function verify
             * @memberof proto.Message.OrderMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrderMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.orderId != null && message.hasOwnProperty("orderId"))
                    if (!$util.isString(message.orderId))
                        return "orderId: string expected";
                if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                    if (!(message.thumbnail && typeof message.thumbnail.length === "number" || $util.isString(message.thumbnail)))
                        return "thumbnail: buffer expected";
                if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                    if (!$util.isInteger(message.itemCount))
                        return "itemCount: integer expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 1:
                        break;
                    }
                if (message.surface != null && message.hasOwnProperty("surface"))
                    switch (message.surface) {
                    default:
                        return "surface: enum value expected";
                    case 1:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.orderTitle != null && message.hasOwnProperty("orderTitle"))
                    if (!$util.isString(message.orderTitle))
                        return "orderTitle: string expected";
                if (message.sellerJid != null && message.hasOwnProperty("sellerJid"))
                    if (!$util.isString(message.sellerJid))
                        return "sellerJid: string expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.totalAmount1000 != null && message.hasOwnProperty("totalAmount1000"))
                    if (!$util.isInteger(message.totalAmount1000) && !(message.totalAmount1000 && $util.isInteger(message.totalAmount1000.low) && $util.isInteger(message.totalAmount1000.high)))
                        return "totalAmount1000: integer|Long expected";
                if (message.totalCurrencyCode != null && message.hasOwnProperty("totalCurrencyCode"))
                    if (!$util.isString(message.totalCurrencyCode))
                        return "totalCurrencyCode: string expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates an OrderMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.OrderMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.OrderMessage} OrderMessage
             */
            OrderMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.OrderMessage)
                    return object;
                var message = new $root.proto.Message.OrderMessage();
                if (object.orderId != null)
                    message.orderId = String(object.orderId);
                if (object.thumbnail != null)
                    if (typeof object.thumbnail === "string")
                        $util.base64.decode(object.thumbnail, message.thumbnail = $util.newBuffer($util.base64.length(object.thumbnail)), 0);
                    else if (object.thumbnail.length)
                        message.thumbnail = object.thumbnail;
                if (object.itemCount != null)
                    message.itemCount = object.itemCount | 0;
                switch (object.status) {
                case "INQUIRY":
                case 1:
                    message.status = 1;
                    break;
                }
                switch (object.surface) {
                case "CATALOG":
                case 1:
                    message.surface = 1;
                    break;
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.orderTitle != null)
                    message.orderTitle = String(object.orderTitle);
                if (object.sellerJid != null)
                    message.sellerJid = String(object.sellerJid);
                if (object.token != null)
                    message.token = String(object.token);
                if (object.totalAmount1000 != null)
                    if ($util.Long)
                        (message.totalAmount1000 = $util.Long.fromValue(object.totalAmount1000)).unsigned = false;
                    else if (typeof object.totalAmount1000 === "string")
                        message.totalAmount1000 = parseInt(object.totalAmount1000, 10);
                    else if (typeof object.totalAmount1000 === "number")
                        message.totalAmount1000 = object.totalAmount1000;
                    else if (typeof object.totalAmount1000 === "object")
                        message.totalAmount1000 = new $util.LongBits(object.totalAmount1000.low >>> 0, object.totalAmount1000.high >>> 0).toNumber();
                if (object.totalCurrencyCode != null)
                    message.totalCurrencyCode = String(object.totalCurrencyCode);
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.OrderMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from an OrderMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.OrderMessage
             * @static
             * @param {proto.Message.OrderMessage} message OrderMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrderMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.orderId = "";
                    if (options.bytes === String)
                        object.thumbnail = "";
                    else {
                        object.thumbnail = [];
                        if (options.bytes !== Array)
                            object.thumbnail = $util.newBuffer(object.thumbnail);
                    }
                    object.itemCount = 0;
                    object.status = options.enums === String ? "INQUIRY" : 1;
                    object.surface = options.enums === String ? "CATALOG" : 1;
                    object.message = "";
                    object.orderTitle = "";
                    object.sellerJid = "";
                    object.token = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.totalAmount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalAmount1000 = options.longs === String ? "0" : 0;
                    object.totalCurrencyCode = "";
                    object.contextInfo = null;
                }
                if (message.orderId != null && message.hasOwnProperty("orderId"))
                    object.orderId = message.orderId;
                if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                    object.thumbnail = options.bytes === String ? $util.base64.encode(message.thumbnail, 0, message.thumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnail) : message.thumbnail;
                if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                    object.itemCount = message.itemCount;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.proto.Message.OrderMessage.OrderStatus[message.status] : message.status;
                if (message.surface != null && message.hasOwnProperty("surface"))
                    object.surface = options.enums === String ? $root.proto.Message.OrderMessage.OrderSurface[message.surface] : message.surface;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.orderTitle != null && message.hasOwnProperty("orderTitle"))
                    object.orderTitle = message.orderTitle;
                if (message.sellerJid != null && message.hasOwnProperty("sellerJid"))
                    object.sellerJid = message.sellerJid;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.totalAmount1000 != null && message.hasOwnProperty("totalAmount1000"))
                    if (typeof message.totalAmount1000 === "number")
                        object.totalAmount1000 = options.longs === String ? String(message.totalAmount1000) : message.totalAmount1000;
                    else
                        object.totalAmount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.totalAmount1000) : options.longs === Number ? new $util.LongBits(message.totalAmount1000.low >>> 0, message.totalAmount1000.high >>> 0).toNumber() : message.totalAmount1000;
                if (message.totalCurrencyCode != null && message.hasOwnProperty("totalCurrencyCode"))
                    object.totalCurrencyCode = message.totalCurrencyCode;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this OrderMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.OrderMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrderMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OrderStatus enum.
             * @name proto.Message.OrderMessage.OrderStatus
             * @enum {number}
             * @property {number} INQUIRY=1 INQUIRY value
             */
            OrderMessage.OrderStatus = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "INQUIRY"] = 1;
                return values;
            })();

            /**
             * OrderSurface enum.
             * @name proto.Message.OrderMessage.OrderSurface
             * @enum {number}
             * @property {number} CATALOG=1 CATALOG value
             */
            OrderMessage.OrderSurface = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "CATALOG"] = 1;
                return values;
            })();

            return OrderMessage;
        })();

        Message.PaymentInviteMessage = (function() {

            /**
             * Properties of a PaymentInviteMessage.
             * @memberof proto.Message
             * @interface IPaymentInviteMessage
             * @property {proto.Message.PaymentInviteMessage.ServiceType|null} [serviceType] PaymentInviteMessage serviceType
             * @property {number|Long|null} [expiryTimestamp] PaymentInviteMessage expiryTimestamp
             */

            /**
             * Constructs a new PaymentInviteMessage.
             * @memberof proto.Message
             * @classdesc Represents a PaymentInviteMessage.
             * @implements IPaymentInviteMessage
             * @constructor
             * @param {proto.Message.IPaymentInviteMessage=} [properties] Properties to set
             */
            function PaymentInviteMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PaymentInviteMessage serviceType.
             * @member {proto.Message.PaymentInviteMessage.ServiceType} serviceType
             * @memberof proto.Message.PaymentInviteMessage
             * @instance
             */
            PaymentInviteMessage.prototype.serviceType = 0;

            /**
             * PaymentInviteMessage expiryTimestamp.
             * @member {number|Long} expiryTimestamp
             * @memberof proto.Message.PaymentInviteMessage
             * @instance
             */
            PaymentInviteMessage.prototype.expiryTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PaymentInviteMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.PaymentInviteMessage
             * @static
             * @param {proto.Message.IPaymentInviteMessage=} [properties] Properties to set
             * @returns {proto.Message.PaymentInviteMessage} PaymentInviteMessage instance
             */
            PaymentInviteMessage.create = function create(properties) {
                return new PaymentInviteMessage(properties);
            };

            /**
             * Encodes the specified PaymentInviteMessage message. Does not implicitly {@link proto.Message.PaymentInviteMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.PaymentInviteMessage
             * @static
             * @param {proto.Message.IPaymentInviteMessage} message PaymentInviteMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PaymentInviteMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serviceType != null && Object.hasOwnProperty.call(message, "serviceType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serviceType);
                if (message.expiryTimestamp != null && Object.hasOwnProperty.call(message, "expiryTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiryTimestamp);
                return writer;
            };

            /**
             * Encodes the specified PaymentInviteMessage message, length delimited. Does not implicitly {@link proto.Message.PaymentInviteMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.PaymentInviteMessage
             * @static
             * @param {proto.Message.IPaymentInviteMessage} message PaymentInviteMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PaymentInviteMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PaymentInviteMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.PaymentInviteMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.PaymentInviteMessage} PaymentInviteMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PaymentInviteMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PaymentInviteMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serviceType = reader.int32();
                        break;
                    case 2:
                        message.expiryTimestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PaymentInviteMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.PaymentInviteMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.PaymentInviteMessage} PaymentInviteMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PaymentInviteMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PaymentInviteMessage message.
             * @function verify
             * @memberof proto.Message.PaymentInviteMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PaymentInviteMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serviceType != null && message.hasOwnProperty("serviceType"))
                    switch (message.serviceType) {
                    default:
                        return "serviceType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                    if (!$util.isInteger(message.expiryTimestamp) && !(message.expiryTimestamp && $util.isInteger(message.expiryTimestamp.low) && $util.isInteger(message.expiryTimestamp.high)))
                        return "expiryTimestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a PaymentInviteMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.PaymentInviteMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.PaymentInviteMessage} PaymentInviteMessage
             */
            PaymentInviteMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.PaymentInviteMessage)
                    return object;
                var message = new $root.proto.Message.PaymentInviteMessage();
                switch (object.serviceType) {
                case "UNKNOWN":
                case 0:
                    message.serviceType = 0;
                    break;
                case "FBPAY":
                case 1:
                    message.serviceType = 1;
                    break;
                case "NOVI":
                case 2:
                    message.serviceType = 2;
                    break;
                case "UPI":
                case 3:
                    message.serviceType = 3;
                    break;
                }
                if (object.expiryTimestamp != null)
                    if ($util.Long)
                        (message.expiryTimestamp = $util.Long.fromValue(object.expiryTimestamp)).unsigned = false;
                    else if (typeof object.expiryTimestamp === "string")
                        message.expiryTimestamp = parseInt(object.expiryTimestamp, 10);
                    else if (typeof object.expiryTimestamp === "number")
                        message.expiryTimestamp = object.expiryTimestamp;
                    else if (typeof object.expiryTimestamp === "object")
                        message.expiryTimestamp = new $util.LongBits(object.expiryTimestamp.low >>> 0, object.expiryTimestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a PaymentInviteMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.PaymentInviteMessage
             * @static
             * @param {proto.Message.PaymentInviteMessage} message PaymentInviteMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PaymentInviteMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.serviceType = options.enums === String ? "UNKNOWN" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expiryTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expiryTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.serviceType != null && message.hasOwnProperty("serviceType"))
                    object.serviceType = options.enums === String ? $root.proto.Message.PaymentInviteMessage.ServiceType[message.serviceType] : message.serviceType;
                if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                    if (typeof message.expiryTimestamp === "number")
                        object.expiryTimestamp = options.longs === String ? String(message.expiryTimestamp) : message.expiryTimestamp;
                    else
                        object.expiryTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expiryTimestamp) : options.longs === Number ? new $util.LongBits(message.expiryTimestamp.low >>> 0, message.expiryTimestamp.high >>> 0).toNumber() : message.expiryTimestamp;
                return object;
            };

            /**
             * Converts this PaymentInviteMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.PaymentInviteMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PaymentInviteMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ServiceType enum.
             * @name proto.Message.PaymentInviteMessage.ServiceType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} FBPAY=1 FBPAY value
             * @property {number} NOVI=2 NOVI value
             * @property {number} UPI=3 UPI value
             */
            PaymentInviteMessage.ServiceType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "FBPAY"] = 1;
                values[valuesById[2] = "NOVI"] = 2;
                values[valuesById[3] = "UPI"] = 3;
                return values;
            })();

            return PaymentInviteMessage;
        })();

        Message.PeerDataOperationRequestMessage = (function() {

            /**
             * Properties of a PeerDataOperationRequestMessage.
             * @memberof proto.Message
             * @interface IPeerDataOperationRequestMessage
             * @property {proto.Message.PeerDataOperationRequestType|null} [peerDataOperationRequestType] PeerDataOperationRequestMessage peerDataOperationRequestType
             * @property {Array.<proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload>|null} [requestStickerReupload] PeerDataOperationRequestMessage requestStickerReupload
             * @property {Array.<proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview>|null} [requestUrlPreview] PeerDataOperationRequestMessage requestUrlPreview
             */

            /**
             * Constructs a new PeerDataOperationRequestMessage.
             * @memberof proto.Message
             * @classdesc Represents a PeerDataOperationRequestMessage.
             * @implements IPeerDataOperationRequestMessage
             * @constructor
             * @param {proto.Message.IPeerDataOperationRequestMessage=} [properties] Properties to set
             */
            function PeerDataOperationRequestMessage(properties) {
                this.requestStickerReupload = [];
                this.requestUrlPreview = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PeerDataOperationRequestMessage peerDataOperationRequestType.
             * @member {proto.Message.PeerDataOperationRequestType} peerDataOperationRequestType
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @instance
             */
            PeerDataOperationRequestMessage.prototype.peerDataOperationRequestType = 0;

            /**
             * PeerDataOperationRequestMessage requestStickerReupload.
             * @member {Array.<proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload>} requestStickerReupload
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @instance
             */
            PeerDataOperationRequestMessage.prototype.requestStickerReupload = $util.emptyArray;

            /**
             * PeerDataOperationRequestMessage requestUrlPreview.
             * @member {Array.<proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview>} requestUrlPreview
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @instance
             */
            PeerDataOperationRequestMessage.prototype.requestUrlPreview = $util.emptyArray;

            /**
             * Creates a new PeerDataOperationRequestMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @static
             * @param {proto.Message.IPeerDataOperationRequestMessage=} [properties] Properties to set
             * @returns {proto.Message.PeerDataOperationRequestMessage} PeerDataOperationRequestMessage instance
             */
            PeerDataOperationRequestMessage.create = function create(properties) {
                return new PeerDataOperationRequestMessage(properties);
            };

            /**
             * Encodes the specified PeerDataOperationRequestMessage message. Does not implicitly {@link proto.Message.PeerDataOperationRequestMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @static
             * @param {proto.Message.IPeerDataOperationRequestMessage} message PeerDataOperationRequestMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerDataOperationRequestMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peerDataOperationRequestType != null && Object.hasOwnProperty.call(message, "peerDataOperationRequestType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.peerDataOperationRequestType);
                if (message.requestStickerReupload != null && message.requestStickerReupload.length)
                    for (var i = 0; i < message.requestStickerReupload.length; ++i)
                        $root.proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.encode(message.requestStickerReupload[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.requestUrlPreview != null && message.requestUrlPreview.length)
                    for (var i = 0; i < message.requestUrlPreview.length; ++i)
                        $root.proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.encode(message.requestUrlPreview[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PeerDataOperationRequestMessage message, length delimited. Does not implicitly {@link proto.Message.PeerDataOperationRequestMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @static
             * @param {proto.Message.IPeerDataOperationRequestMessage} message PeerDataOperationRequestMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerDataOperationRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PeerDataOperationRequestMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.PeerDataOperationRequestMessage} PeerDataOperationRequestMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerDataOperationRequestMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PeerDataOperationRequestMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.peerDataOperationRequestType = reader.int32();
                        break;
                    case 2:
                        if (!(message.requestStickerReupload && message.requestStickerReupload.length))
                            message.requestStickerReupload = [];
                        message.requestStickerReupload.push($root.proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.requestUrlPreview && message.requestUrlPreview.length))
                            message.requestUrlPreview = [];
                        message.requestUrlPreview.push($root.proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PeerDataOperationRequestMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.PeerDataOperationRequestMessage} PeerDataOperationRequestMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerDataOperationRequestMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PeerDataOperationRequestMessage message.
             * @function verify
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerDataOperationRequestMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peerDataOperationRequestType != null && message.hasOwnProperty("peerDataOperationRequestType"))
                    switch (message.peerDataOperationRequestType) {
                    default:
                        return "peerDataOperationRequestType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.requestStickerReupload != null && message.hasOwnProperty("requestStickerReupload")) {
                    if (!Array.isArray(message.requestStickerReupload))
                        return "requestStickerReupload: array expected";
                    for (var i = 0; i < message.requestStickerReupload.length; ++i) {
                        var error = $root.proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.verify(message.requestStickerReupload[i]);
                        if (error)
                            return "requestStickerReupload." + error;
                    }
                }
                if (message.requestUrlPreview != null && message.hasOwnProperty("requestUrlPreview")) {
                    if (!Array.isArray(message.requestUrlPreview))
                        return "requestUrlPreview: array expected";
                    for (var i = 0; i < message.requestUrlPreview.length; ++i) {
                        var error = $root.proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.verify(message.requestUrlPreview[i]);
                        if (error)
                            return "requestUrlPreview." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PeerDataOperationRequestMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.PeerDataOperationRequestMessage} PeerDataOperationRequestMessage
             */
            PeerDataOperationRequestMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.PeerDataOperationRequestMessage)
                    return object;
                var message = new $root.proto.Message.PeerDataOperationRequestMessage();
                switch (object.peerDataOperationRequestType) {
                case "UPLOAD_STICKER":
                case 0:
                    message.peerDataOperationRequestType = 0;
                    break;
                case "SEND_RECENT_STICKER_BOOTSTRAP":
                case 1:
                    message.peerDataOperationRequestType = 1;
                    break;
                case "GENERATE_LINK_PREVIEW":
                case 2:
                    message.peerDataOperationRequestType = 2;
                    break;
                }
                if (object.requestStickerReupload) {
                    if (!Array.isArray(object.requestStickerReupload))
                        throw TypeError(".proto.Message.PeerDataOperationRequestMessage.requestStickerReupload: array expected");
                    message.requestStickerReupload = [];
                    for (var i = 0; i < object.requestStickerReupload.length; ++i) {
                        if (typeof object.requestStickerReupload[i] !== "object")
                            throw TypeError(".proto.Message.PeerDataOperationRequestMessage.requestStickerReupload: object expected");
                        message.requestStickerReupload[i] = $root.proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.fromObject(object.requestStickerReupload[i]);
                    }
                }
                if (object.requestUrlPreview) {
                    if (!Array.isArray(object.requestUrlPreview))
                        throw TypeError(".proto.Message.PeerDataOperationRequestMessage.requestUrlPreview: array expected");
                    message.requestUrlPreview = [];
                    for (var i = 0; i < object.requestUrlPreview.length; ++i) {
                        if (typeof object.requestUrlPreview[i] !== "object")
                            throw TypeError(".proto.Message.PeerDataOperationRequestMessage.requestUrlPreview: object expected");
                        message.requestUrlPreview[i] = $root.proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.fromObject(object.requestUrlPreview[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PeerDataOperationRequestMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @static
             * @param {proto.Message.PeerDataOperationRequestMessage} message PeerDataOperationRequestMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerDataOperationRequestMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.requestStickerReupload = [];
                    object.requestUrlPreview = [];
                }
                if (options.defaults)
                    object.peerDataOperationRequestType = options.enums === String ? "UPLOAD_STICKER" : 0;
                if (message.peerDataOperationRequestType != null && message.hasOwnProperty("peerDataOperationRequestType"))
                    object.peerDataOperationRequestType = options.enums === String ? $root.proto.Message.PeerDataOperationRequestType[message.peerDataOperationRequestType] : message.peerDataOperationRequestType;
                if (message.requestStickerReupload && message.requestStickerReupload.length) {
                    object.requestStickerReupload = [];
                    for (var j = 0; j < message.requestStickerReupload.length; ++j)
                        object.requestStickerReupload[j] = $root.proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.toObject(message.requestStickerReupload[j], options);
                }
                if (message.requestUrlPreview && message.requestUrlPreview.length) {
                    object.requestUrlPreview = [];
                    for (var j = 0; j < message.requestUrlPreview.length; ++j)
                        object.requestUrlPreview[j] = $root.proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.toObject(message.requestUrlPreview[j], options);
                }
                return object;
            };

            /**
             * Converts this PeerDataOperationRequestMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.PeerDataOperationRequestMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerDataOperationRequestMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            PeerDataOperationRequestMessage.RequestStickerReupload = (function() {

                /**
                 * Properties of a RequestStickerReupload.
                 * @memberof proto.Message.PeerDataOperationRequestMessage
                 * @interface IRequestStickerReupload
                 * @property {string|null} [fileSha256] RequestStickerReupload fileSha256
                 */

                /**
                 * Constructs a new RequestStickerReupload.
                 * @memberof proto.Message.PeerDataOperationRequestMessage
                 * @classdesc Represents a RequestStickerReupload.
                 * @implements IRequestStickerReupload
                 * @constructor
                 * @param {proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload=} [properties] Properties to set
                 */
                function RequestStickerReupload(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestStickerReupload fileSha256.
                 * @member {string} fileSha256
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @instance
                 */
                RequestStickerReupload.prototype.fileSha256 = "";

                /**
                 * Creates a new RequestStickerReupload instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload=} [properties] Properties to set
                 * @returns {proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload} RequestStickerReupload instance
                 */
                RequestStickerReupload.create = function create(properties) {
                    return new RequestStickerReupload(properties);
                };

                /**
                 * Encodes the specified RequestStickerReupload message. Does not implicitly {@link proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload} message RequestStickerReupload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestStickerReupload.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileSha256);
                    return writer;
                };

                /**
                 * Encodes the specified RequestStickerReupload message, length delimited. Does not implicitly {@link proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestMessage.IRequestStickerReupload} message RequestStickerReupload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestStickerReupload.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RequestStickerReupload message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload} RequestStickerReupload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestStickerReupload.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.fileSha256 = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RequestStickerReupload message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload} RequestStickerReupload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestStickerReupload.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RequestStickerReupload message.
                 * @function verify
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestStickerReupload.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                        if (!$util.isString(message.fileSha256))
                            return "fileSha256: string expected";
                    return null;
                };

                /**
                 * Creates a RequestStickerReupload message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload} RequestStickerReupload
                 */
                RequestStickerReupload.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload)
                        return object;
                    var message = new $root.proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload();
                    if (object.fileSha256 != null)
                        message.fileSha256 = String(object.fileSha256);
                    return message;
                };

                /**
                 * Creates a plain object from a RequestStickerReupload message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload} message RequestStickerReupload
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestStickerReupload.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.fileSha256 = "";
                    if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                        object.fileSha256 = message.fileSha256;
                    return object;
                };

                /**
                 * Converts this RequestStickerReupload to JSON.
                 * @function toJSON
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestStickerReupload
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestStickerReupload.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestStickerReupload;
            })();

            PeerDataOperationRequestMessage.RequestUrlPreview = (function() {

                /**
                 * Properties of a RequestUrlPreview.
                 * @memberof proto.Message.PeerDataOperationRequestMessage
                 * @interface IRequestUrlPreview
                 * @property {string|null} [url] RequestUrlPreview url
                 */

                /**
                 * Constructs a new RequestUrlPreview.
                 * @memberof proto.Message.PeerDataOperationRequestMessage
                 * @classdesc Represents a RequestUrlPreview.
                 * @implements IRequestUrlPreview
                 * @constructor
                 * @param {proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview=} [properties] Properties to set
                 */
                function RequestUrlPreview(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestUrlPreview url.
                 * @member {string} url
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @instance
                 */
                RequestUrlPreview.prototype.url = "";

                /**
                 * Creates a new RequestUrlPreview instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview=} [properties] Properties to set
                 * @returns {proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview} RequestUrlPreview instance
                 */
                RequestUrlPreview.create = function create(properties) {
                    return new RequestUrlPreview(properties);
                };

                /**
                 * Encodes the specified RequestUrlPreview message. Does not implicitly {@link proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview} message RequestUrlPreview message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestUrlPreview.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                    return writer;
                };

                /**
                 * Encodes the specified RequestUrlPreview message, length delimited. Does not implicitly {@link proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestMessage.IRequestUrlPreview} message RequestUrlPreview message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestUrlPreview.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RequestUrlPreview message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview} RequestUrlPreview
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestUrlPreview.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.url = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RequestUrlPreview message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview} RequestUrlPreview
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestUrlPreview.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RequestUrlPreview message.
                 * @function verify
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestUrlPreview.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    return null;
                };

                /**
                 * Creates a RequestUrlPreview message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview} RequestUrlPreview
                 */
                RequestUrlPreview.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview)
                        return object;
                    var message = new $root.proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview();
                    if (object.url != null)
                        message.url = String(object.url);
                    return message;
                };

                /**
                 * Creates a plain object from a RequestUrlPreview message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview} message RequestUrlPreview
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestUrlPreview.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.url = "";
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    return object;
                };

                /**
                 * Converts this RequestUrlPreview to JSON.
                 * @function toJSON
                 * @memberof proto.Message.PeerDataOperationRequestMessage.RequestUrlPreview
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestUrlPreview.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestUrlPreview;
            })();

            return PeerDataOperationRequestMessage;
        })();

        Message.PeerDataOperationRequestResponseMessage = (function() {

            /**
             * Properties of a PeerDataOperationRequestResponseMessage.
             * @memberof proto.Message
             * @interface IPeerDataOperationRequestResponseMessage
             * @property {proto.Message.PeerDataOperationRequestType|null} [peerDataOperationRequestType] PeerDataOperationRequestResponseMessage peerDataOperationRequestType
             * @property {string|null} [stanzaId] PeerDataOperationRequestResponseMessage stanzaId
             * @property {Array.<proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult>|null} [peerDataOperationResult] PeerDataOperationRequestResponseMessage peerDataOperationResult
             */

            /**
             * Constructs a new PeerDataOperationRequestResponseMessage.
             * @memberof proto.Message
             * @classdesc Represents a PeerDataOperationRequestResponseMessage.
             * @implements IPeerDataOperationRequestResponseMessage
             * @constructor
             * @param {proto.Message.IPeerDataOperationRequestResponseMessage=} [properties] Properties to set
             */
            function PeerDataOperationRequestResponseMessage(properties) {
                this.peerDataOperationResult = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PeerDataOperationRequestResponseMessage peerDataOperationRequestType.
             * @member {proto.Message.PeerDataOperationRequestType} peerDataOperationRequestType
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @instance
             */
            PeerDataOperationRequestResponseMessage.prototype.peerDataOperationRequestType = 0;

            /**
             * PeerDataOperationRequestResponseMessage stanzaId.
             * @member {string} stanzaId
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @instance
             */
            PeerDataOperationRequestResponseMessage.prototype.stanzaId = "";

            /**
             * PeerDataOperationRequestResponseMessage peerDataOperationResult.
             * @member {Array.<proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult>} peerDataOperationResult
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @instance
             */
            PeerDataOperationRequestResponseMessage.prototype.peerDataOperationResult = $util.emptyArray;

            /**
             * Creates a new PeerDataOperationRequestResponseMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @static
             * @param {proto.Message.IPeerDataOperationRequestResponseMessage=} [properties] Properties to set
             * @returns {proto.Message.PeerDataOperationRequestResponseMessage} PeerDataOperationRequestResponseMessage instance
             */
            PeerDataOperationRequestResponseMessage.create = function create(properties) {
                return new PeerDataOperationRequestResponseMessage(properties);
            };

            /**
             * Encodes the specified PeerDataOperationRequestResponseMessage message. Does not implicitly {@link proto.Message.PeerDataOperationRequestResponseMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @static
             * @param {proto.Message.IPeerDataOperationRequestResponseMessage} message PeerDataOperationRequestResponseMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerDataOperationRequestResponseMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peerDataOperationRequestType != null && Object.hasOwnProperty.call(message, "peerDataOperationRequestType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.peerDataOperationRequestType);
                if (message.stanzaId != null && Object.hasOwnProperty.call(message, "stanzaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.stanzaId);
                if (message.peerDataOperationResult != null && message.peerDataOperationResult.length)
                    for (var i = 0; i < message.peerDataOperationResult.length; ++i)
                        $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.encode(message.peerDataOperationResult[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PeerDataOperationRequestResponseMessage message, length delimited. Does not implicitly {@link proto.Message.PeerDataOperationRequestResponseMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @static
             * @param {proto.Message.IPeerDataOperationRequestResponseMessage} message PeerDataOperationRequestResponseMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerDataOperationRequestResponseMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PeerDataOperationRequestResponseMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.PeerDataOperationRequestResponseMessage} PeerDataOperationRequestResponseMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerDataOperationRequestResponseMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PeerDataOperationRequestResponseMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.peerDataOperationRequestType = reader.int32();
                        break;
                    case 2:
                        message.stanzaId = reader.string();
                        break;
                    case 3:
                        if (!(message.peerDataOperationResult && message.peerDataOperationResult.length))
                            message.peerDataOperationResult = [];
                        message.peerDataOperationResult.push($root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PeerDataOperationRequestResponseMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.PeerDataOperationRequestResponseMessage} PeerDataOperationRequestResponseMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerDataOperationRequestResponseMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PeerDataOperationRequestResponseMessage message.
             * @function verify
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerDataOperationRequestResponseMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peerDataOperationRequestType != null && message.hasOwnProperty("peerDataOperationRequestType"))
                    switch (message.peerDataOperationRequestType) {
                    default:
                        return "peerDataOperationRequestType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                    if (!$util.isString(message.stanzaId))
                        return "stanzaId: string expected";
                if (message.peerDataOperationResult != null && message.hasOwnProperty("peerDataOperationResult")) {
                    if (!Array.isArray(message.peerDataOperationResult))
                        return "peerDataOperationResult: array expected";
                    for (var i = 0; i < message.peerDataOperationResult.length; ++i) {
                        var error = $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.verify(message.peerDataOperationResult[i]);
                        if (error)
                            return "peerDataOperationResult." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PeerDataOperationRequestResponseMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.PeerDataOperationRequestResponseMessage} PeerDataOperationRequestResponseMessage
             */
            PeerDataOperationRequestResponseMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.PeerDataOperationRequestResponseMessage)
                    return object;
                var message = new $root.proto.Message.PeerDataOperationRequestResponseMessage();
                switch (object.peerDataOperationRequestType) {
                case "UPLOAD_STICKER":
                case 0:
                    message.peerDataOperationRequestType = 0;
                    break;
                case "SEND_RECENT_STICKER_BOOTSTRAP":
                case 1:
                    message.peerDataOperationRequestType = 1;
                    break;
                case "GENERATE_LINK_PREVIEW":
                case 2:
                    message.peerDataOperationRequestType = 2;
                    break;
                }
                if (object.stanzaId != null)
                    message.stanzaId = String(object.stanzaId);
                if (object.peerDataOperationResult) {
                    if (!Array.isArray(object.peerDataOperationResult))
                        throw TypeError(".proto.Message.PeerDataOperationRequestResponseMessage.peerDataOperationResult: array expected");
                    message.peerDataOperationResult = [];
                    for (var i = 0; i < object.peerDataOperationResult.length; ++i) {
                        if (typeof object.peerDataOperationResult[i] !== "object")
                            throw TypeError(".proto.Message.PeerDataOperationRequestResponseMessage.peerDataOperationResult: object expected");
                        message.peerDataOperationResult[i] = $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.fromObject(object.peerDataOperationResult[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PeerDataOperationRequestResponseMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @static
             * @param {proto.Message.PeerDataOperationRequestResponseMessage} message PeerDataOperationRequestResponseMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerDataOperationRequestResponseMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.peerDataOperationResult = [];
                if (options.defaults) {
                    object.peerDataOperationRequestType = options.enums === String ? "UPLOAD_STICKER" : 0;
                    object.stanzaId = "";
                }
                if (message.peerDataOperationRequestType != null && message.hasOwnProperty("peerDataOperationRequestType"))
                    object.peerDataOperationRequestType = options.enums === String ? $root.proto.Message.PeerDataOperationRequestType[message.peerDataOperationRequestType] : message.peerDataOperationRequestType;
                if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                    object.stanzaId = message.stanzaId;
                if (message.peerDataOperationResult && message.peerDataOperationResult.length) {
                    object.peerDataOperationResult = [];
                    for (var j = 0; j < message.peerDataOperationResult.length; ++j)
                        object.peerDataOperationResult[j] = $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.toObject(message.peerDataOperationResult[j], options);
                }
                return object;
            };

            /**
             * Converts this PeerDataOperationRequestResponseMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.PeerDataOperationRequestResponseMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerDataOperationRequestResponseMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            PeerDataOperationRequestResponseMessage.PeerDataOperationResult = (function() {

                /**
                 * Properties of a PeerDataOperationResult.
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage
                 * @interface IPeerDataOperationResult
                 * @property {proto.MediaRetryNotification.ResultType|null} [mediaUploadResult] PeerDataOperationResult mediaUploadResult
                 * @property {proto.Message.IStickerMessage|null} [stickerMessage] PeerDataOperationResult stickerMessage
                 * @property {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse|null} [linkPreviewResponse] PeerDataOperationResult linkPreviewResponse
                 */

                /**
                 * Constructs a new PeerDataOperationResult.
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage
                 * @classdesc Represents a PeerDataOperationResult.
                 * @implements IPeerDataOperationResult
                 * @constructor
                 * @param {proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult=} [properties] Properties to set
                 */
                function PeerDataOperationResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PeerDataOperationResult mediaUploadResult.
                 * @member {proto.MediaRetryNotification.ResultType} mediaUploadResult
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @instance
                 */
                PeerDataOperationResult.prototype.mediaUploadResult = 0;

                /**
                 * PeerDataOperationResult stickerMessage.
                 * @member {proto.Message.IStickerMessage|null|undefined} stickerMessage
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @instance
                 */
                PeerDataOperationResult.prototype.stickerMessage = null;

                /**
                 * PeerDataOperationResult linkPreviewResponse.
                 * @member {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse|null|undefined} linkPreviewResponse
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @instance
                 */
                PeerDataOperationResult.prototype.linkPreviewResponse = null;

                /**
                 * Creates a new PeerDataOperationResult instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult=} [properties] Properties to set
                 * @returns {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult} PeerDataOperationResult instance
                 */
                PeerDataOperationResult.create = function create(properties) {
                    return new PeerDataOperationResult(properties);
                };

                /**
                 * Encodes the specified PeerDataOperationResult message. Does not implicitly {@link proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult} message PeerDataOperationResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PeerDataOperationResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mediaUploadResult != null && Object.hasOwnProperty.call(message, "mediaUploadResult"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mediaUploadResult);
                    if (message.stickerMessage != null && Object.hasOwnProperty.call(message, "stickerMessage"))
                        $root.proto.Message.StickerMessage.encode(message.stickerMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.linkPreviewResponse != null && Object.hasOwnProperty.call(message, "linkPreviewResponse"))
                        $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.encode(message.linkPreviewResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PeerDataOperationResult message, length delimited. Does not implicitly {@link proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestResponseMessage.IPeerDataOperationResult} message PeerDataOperationResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PeerDataOperationResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PeerDataOperationResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult} PeerDataOperationResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PeerDataOperationResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mediaUploadResult = reader.int32();
                            break;
                        case 2:
                            message.stickerMessage = $root.proto.Message.StickerMessage.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.linkPreviewResponse = $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PeerDataOperationResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult} PeerDataOperationResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PeerDataOperationResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PeerDataOperationResult message.
                 * @function verify
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PeerDataOperationResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mediaUploadResult != null && message.hasOwnProperty("mediaUploadResult"))
                        switch (message.mediaUploadResult) {
                        default:
                            return "mediaUploadResult: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.stickerMessage != null && message.hasOwnProperty("stickerMessage")) {
                        var error = $root.proto.Message.StickerMessage.verify(message.stickerMessage);
                        if (error)
                            return "stickerMessage." + error;
                    }
                    if (message.linkPreviewResponse != null && message.hasOwnProperty("linkPreviewResponse")) {
                        var error = $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.verify(message.linkPreviewResponse);
                        if (error)
                            return "linkPreviewResponse." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PeerDataOperationResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult} PeerDataOperationResult
                 */
                PeerDataOperationResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult)
                        return object;
                    var message = new $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult();
                    switch (object.mediaUploadResult) {
                    case "GENERAL_ERROR":
                    case 0:
                        message.mediaUploadResult = 0;
                        break;
                    case "SUCCESS":
                    case 1:
                        message.mediaUploadResult = 1;
                        break;
                    case "NOT_FOUND":
                    case 2:
                        message.mediaUploadResult = 2;
                        break;
                    case "DECRYPTION_ERROR":
                    case 3:
                        message.mediaUploadResult = 3;
                        break;
                    }
                    if (object.stickerMessage != null) {
                        if (typeof object.stickerMessage !== "object")
                            throw TypeError(".proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.stickerMessage: object expected");
                        message.stickerMessage = $root.proto.Message.StickerMessage.fromObject(object.stickerMessage);
                    }
                    if (object.linkPreviewResponse != null) {
                        if (typeof object.linkPreviewResponse !== "object")
                            throw TypeError(".proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.linkPreviewResponse: object expected");
                        message.linkPreviewResponse = $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.fromObject(object.linkPreviewResponse);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PeerDataOperationResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @static
                 * @param {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult} message PeerDataOperationResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PeerDataOperationResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mediaUploadResult = options.enums === String ? "GENERAL_ERROR" : 0;
                        object.stickerMessage = null;
                        object.linkPreviewResponse = null;
                    }
                    if (message.mediaUploadResult != null && message.hasOwnProperty("mediaUploadResult"))
                        object.mediaUploadResult = options.enums === String ? $root.proto.MediaRetryNotification.ResultType[message.mediaUploadResult] : message.mediaUploadResult;
                    if (message.stickerMessage != null && message.hasOwnProperty("stickerMessage"))
                        object.stickerMessage = $root.proto.Message.StickerMessage.toObject(message.stickerMessage, options);
                    if (message.linkPreviewResponse != null && message.hasOwnProperty("linkPreviewResponse"))
                        object.linkPreviewResponse = $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.toObject(message.linkPreviewResponse, options);
                    return object;
                };

                /**
                 * Converts this PeerDataOperationResult to JSON.
                 * @function toJSON
                 * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PeerDataOperationResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                PeerDataOperationResult.LinkPreviewResponse = (function() {

                    /**
                     * Properties of a LinkPreviewResponse.
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                     * @interface ILinkPreviewResponse
                     * @property {string|null} [url] LinkPreviewResponse url
                     * @property {string|null} [title] LinkPreviewResponse title
                     * @property {string|null} [description] LinkPreviewResponse description
                     * @property {Uint8Array|null} [thumbData] LinkPreviewResponse thumbData
                     * @property {string|null} [canonicalUrl] LinkPreviewResponse canonicalUrl
                     * @property {string|null} [matchText] LinkPreviewResponse matchText
                     * @property {string|null} [previewType] LinkPreviewResponse previewType
                     */

                    /**
                     * Constructs a new LinkPreviewResponse.
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult
                     * @classdesc Represents a LinkPreviewResponse.
                     * @implements ILinkPreviewResponse
                     * @constructor
                     * @param {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse=} [properties] Properties to set
                     */
                    function LinkPreviewResponse(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * LinkPreviewResponse url.
                     * @member {string} url
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @instance
                     */
                    LinkPreviewResponse.prototype.url = "";

                    /**
                     * LinkPreviewResponse title.
                     * @member {string} title
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @instance
                     */
                    LinkPreviewResponse.prototype.title = "";

                    /**
                     * LinkPreviewResponse description.
                     * @member {string} description
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @instance
                     */
                    LinkPreviewResponse.prototype.description = "";

                    /**
                     * LinkPreviewResponse thumbData.
                     * @member {Uint8Array} thumbData
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @instance
                     */
                    LinkPreviewResponse.prototype.thumbData = $util.newBuffer([]);

                    /**
                     * LinkPreviewResponse canonicalUrl.
                     * @member {string} canonicalUrl
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @instance
                     */
                    LinkPreviewResponse.prototype.canonicalUrl = "";

                    /**
                     * LinkPreviewResponse matchText.
                     * @member {string} matchText
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @instance
                     */
                    LinkPreviewResponse.prototype.matchText = "";

                    /**
                     * LinkPreviewResponse previewType.
                     * @member {string} previewType
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @instance
                     */
                    LinkPreviewResponse.prototype.previewType = "";

                    /**
                     * Creates a new LinkPreviewResponse instance using the specified properties.
                     * @function create
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @static
                     * @param {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse=} [properties] Properties to set
                     * @returns {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse} LinkPreviewResponse instance
                     */
                    LinkPreviewResponse.create = function create(properties) {
                        return new LinkPreviewResponse(properties);
                    };

                    /**
                     * Encodes the specified LinkPreviewResponse message. Does not implicitly {@link proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.verify|verify} messages.
                     * @function encode
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @static
                     * @param {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse} message LinkPreviewResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LinkPreviewResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                        if (message.thumbData != null && Object.hasOwnProperty.call(message, "thumbData"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.thumbData);
                        if (message.canonicalUrl != null && Object.hasOwnProperty.call(message, "canonicalUrl"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.canonicalUrl);
                        if (message.matchText != null && Object.hasOwnProperty.call(message, "matchText"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.matchText);
                        if (message.previewType != null && Object.hasOwnProperty.call(message, "previewType"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.previewType);
                        return writer;
                    };

                    /**
                     * Encodes the specified LinkPreviewResponse message, length delimited. Does not implicitly {@link proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @static
                     * @param {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.ILinkPreviewResponse} message LinkPreviewResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LinkPreviewResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a LinkPreviewResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse} LinkPreviewResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LinkPreviewResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.url = reader.string();
                                break;
                            case 2:
                                message.title = reader.string();
                                break;
                            case 3:
                                message.description = reader.string();
                                break;
                            case 4:
                                message.thumbData = reader.bytes();
                                break;
                            case 5:
                                message.canonicalUrl = reader.string();
                                break;
                            case 6:
                                message.matchText = reader.string();
                                break;
                            case 7:
                                message.previewType = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a LinkPreviewResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse} LinkPreviewResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LinkPreviewResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a LinkPreviewResponse message.
                     * @function verify
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LinkPreviewResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.url != null && message.hasOwnProperty("url"))
                            if (!$util.isString(message.url))
                                return "url: string expected";
                        if (message.title != null && message.hasOwnProperty("title"))
                            if (!$util.isString(message.title))
                                return "title: string expected";
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        if (message.thumbData != null && message.hasOwnProperty("thumbData"))
                            if (!(message.thumbData && typeof message.thumbData.length === "number" || $util.isString(message.thumbData)))
                                return "thumbData: buffer expected";
                        if (message.canonicalUrl != null && message.hasOwnProperty("canonicalUrl"))
                            if (!$util.isString(message.canonicalUrl))
                                return "canonicalUrl: string expected";
                        if (message.matchText != null && message.hasOwnProperty("matchText"))
                            if (!$util.isString(message.matchText))
                                return "matchText: string expected";
                        if (message.previewType != null && message.hasOwnProperty("previewType"))
                            if (!$util.isString(message.previewType))
                                return "previewType: string expected";
                        return null;
                    };

                    /**
                     * Creates a LinkPreviewResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse} LinkPreviewResponse
                     */
                    LinkPreviewResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse)
                            return object;
                        var message = new $root.proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse();
                        if (object.url != null)
                            message.url = String(object.url);
                        if (object.title != null)
                            message.title = String(object.title);
                        if (object.description != null)
                            message.description = String(object.description);
                        if (object.thumbData != null)
                            if (typeof object.thumbData === "string")
                                $util.base64.decode(object.thumbData, message.thumbData = $util.newBuffer($util.base64.length(object.thumbData)), 0);
                            else if (object.thumbData.length)
                                message.thumbData = object.thumbData;
                        if (object.canonicalUrl != null)
                            message.canonicalUrl = String(object.canonicalUrl);
                        if (object.matchText != null)
                            message.matchText = String(object.matchText);
                        if (object.previewType != null)
                            message.previewType = String(object.previewType);
                        return message;
                    };

                    /**
                     * Creates a plain object from a LinkPreviewResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @static
                     * @param {proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse} message LinkPreviewResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LinkPreviewResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.url = "";
                            object.title = "";
                            object.description = "";
                            if (options.bytes === String)
                                object.thumbData = "";
                            else {
                                object.thumbData = [];
                                if (options.bytes !== Array)
                                    object.thumbData = $util.newBuffer(object.thumbData);
                            }
                            object.canonicalUrl = "";
                            object.matchText = "";
                            object.previewType = "";
                        }
                        if (message.url != null && message.hasOwnProperty("url"))
                            object.url = message.url;
                        if (message.title != null && message.hasOwnProperty("title"))
                            object.title = message.title;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        if (message.thumbData != null && message.hasOwnProperty("thumbData"))
                            object.thumbData = options.bytes === String ? $util.base64.encode(message.thumbData, 0, message.thumbData.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbData) : message.thumbData;
                        if (message.canonicalUrl != null && message.hasOwnProperty("canonicalUrl"))
                            object.canonicalUrl = message.canonicalUrl;
                        if (message.matchText != null && message.hasOwnProperty("matchText"))
                            object.matchText = message.matchText;
                        if (message.previewType != null && message.hasOwnProperty("previewType"))
                            object.previewType = message.previewType;
                        return object;
                    };

                    /**
                     * Converts this LinkPreviewResponse to JSON.
                     * @function toJSON
                     * @memberof proto.Message.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LinkPreviewResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return LinkPreviewResponse;
                })();

                return PeerDataOperationResult;
            })();

            return PeerDataOperationRequestResponseMessage;
        })();

        /**
         * PeerDataOperationRequestType enum.
         * @name proto.Message.PeerDataOperationRequestType
         * @enum {number}
         * @property {number} UPLOAD_STICKER=0 UPLOAD_STICKER value
         * @property {number} SEND_RECENT_STICKER_BOOTSTRAP=1 SEND_RECENT_STICKER_BOOTSTRAP value
         * @property {number} GENERATE_LINK_PREVIEW=2 GENERATE_LINK_PREVIEW value
         */
        Message.PeerDataOperationRequestType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UPLOAD_STICKER"] = 0;
            values[valuesById[1] = "SEND_RECENT_STICKER_BOOTSTRAP"] = 1;
            values[valuesById[2] = "GENERATE_LINK_PREVIEW"] = 2;
            return values;
        })();

        Message.PollCreationMessage = (function() {

            /**
             * Properties of a PollCreationMessage.
             * @memberof proto.Message
             * @interface IPollCreationMessage
             * @property {Uint8Array|null} [encKey] PollCreationMessage encKey
             * @property {string|null} [name] PollCreationMessage name
             * @property {Array.<proto.Message.PollCreationMessage.IOption>|null} [options] PollCreationMessage options
             * @property {number|null} [selectableOptionsCount] PollCreationMessage selectableOptionsCount
             * @property {proto.IContextInfo|null} [contextInfo] PollCreationMessage contextInfo
             */

            /**
             * Constructs a new PollCreationMessage.
             * @memberof proto.Message
             * @classdesc Represents a PollCreationMessage.
             * @implements IPollCreationMessage
             * @constructor
             * @param {proto.Message.IPollCreationMessage=} [properties] Properties to set
             */
            function PollCreationMessage(properties) {
                this.options = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PollCreationMessage encKey.
             * @member {Uint8Array} encKey
             * @memberof proto.Message.PollCreationMessage
             * @instance
             */
            PollCreationMessage.prototype.encKey = $util.newBuffer([]);

            /**
             * PollCreationMessage name.
             * @member {string} name
             * @memberof proto.Message.PollCreationMessage
             * @instance
             */
            PollCreationMessage.prototype.name = "";

            /**
             * PollCreationMessage options.
             * @member {Array.<proto.Message.PollCreationMessage.IOption>} options
             * @memberof proto.Message.PollCreationMessage
             * @instance
             */
            PollCreationMessage.prototype.options = $util.emptyArray;

            /**
             * PollCreationMessage selectableOptionsCount.
             * @member {number} selectableOptionsCount
             * @memberof proto.Message.PollCreationMessage
             * @instance
             */
            PollCreationMessage.prototype.selectableOptionsCount = 0;

            /**
             * PollCreationMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.PollCreationMessage
             * @instance
             */
            PollCreationMessage.prototype.contextInfo = null;

            /**
             * Creates a new PollCreationMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.PollCreationMessage
             * @static
             * @param {proto.Message.IPollCreationMessage=} [properties] Properties to set
             * @returns {proto.Message.PollCreationMessage} PollCreationMessage instance
             */
            PollCreationMessage.create = function create(properties) {
                return new PollCreationMessage(properties);
            };

            /**
             * Encodes the specified PollCreationMessage message. Does not implicitly {@link proto.Message.PollCreationMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.PollCreationMessage
             * @static
             * @param {proto.Message.IPollCreationMessage} message PollCreationMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollCreationMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.encKey != null && Object.hasOwnProperty.call(message, "encKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encKey);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.options != null && message.options.length)
                    for (var i = 0; i < message.options.length; ++i)
                        $root.proto.Message.PollCreationMessage.Option.encode(message.options[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.selectableOptionsCount != null && Object.hasOwnProperty.call(message, "selectableOptionsCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.selectableOptionsCount);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PollCreationMessage message, length delimited. Does not implicitly {@link proto.Message.PollCreationMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.PollCreationMessage
             * @static
             * @param {proto.Message.IPollCreationMessage} message PollCreationMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollCreationMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PollCreationMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.PollCreationMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.PollCreationMessage} PollCreationMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollCreationMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PollCreationMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.encKey = reader.bytes();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.options && message.options.length))
                            message.options = [];
                        message.options.push($root.proto.Message.PollCreationMessage.Option.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.selectableOptionsCount = reader.uint32();
                        break;
                    case 5:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PollCreationMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.PollCreationMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.PollCreationMessage} PollCreationMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollCreationMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PollCreationMessage message.
             * @function verify
             * @memberof proto.Message.PollCreationMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PollCreationMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.encKey != null && message.hasOwnProperty("encKey"))
                    if (!(message.encKey && typeof message.encKey.length === "number" || $util.isString(message.encKey)))
                        return "encKey: buffer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    if (!Array.isArray(message.options))
                        return "options: array expected";
                    for (var i = 0; i < message.options.length; ++i) {
                        var error = $root.proto.Message.PollCreationMessage.Option.verify(message.options[i]);
                        if (error)
                            return "options." + error;
                    }
                }
                if (message.selectableOptionsCount != null && message.hasOwnProperty("selectableOptionsCount"))
                    if (!$util.isInteger(message.selectableOptionsCount))
                        return "selectableOptionsCount: integer expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates a PollCreationMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.PollCreationMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.PollCreationMessage} PollCreationMessage
             */
            PollCreationMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.PollCreationMessage)
                    return object;
                var message = new $root.proto.Message.PollCreationMessage();
                if (object.encKey != null)
                    if (typeof object.encKey === "string")
                        $util.base64.decode(object.encKey, message.encKey = $util.newBuffer($util.base64.length(object.encKey)), 0);
                    else if (object.encKey.length)
                        message.encKey = object.encKey;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options) {
                    if (!Array.isArray(object.options))
                        throw TypeError(".proto.Message.PollCreationMessage.options: array expected");
                    message.options = [];
                    for (var i = 0; i < object.options.length; ++i) {
                        if (typeof object.options[i] !== "object")
                            throw TypeError(".proto.Message.PollCreationMessage.options: object expected");
                        message.options[i] = $root.proto.Message.PollCreationMessage.Option.fromObject(object.options[i]);
                    }
                }
                if (object.selectableOptionsCount != null)
                    message.selectableOptionsCount = object.selectableOptionsCount >>> 0;
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.PollCreationMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a PollCreationMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.PollCreationMessage
             * @static
             * @param {proto.Message.PollCreationMessage} message PollCreationMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PollCreationMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.options = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.encKey = "";
                    else {
                        object.encKey = [];
                        if (options.bytes !== Array)
                            object.encKey = $util.newBuffer(object.encKey);
                    }
                    object.name = "";
                    object.selectableOptionsCount = 0;
                    object.contextInfo = null;
                }
                if (message.encKey != null && message.hasOwnProperty("encKey"))
                    object.encKey = options.bytes === String ? $util.base64.encode(message.encKey, 0, message.encKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encKey) : message.encKey;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options && message.options.length) {
                    object.options = [];
                    for (var j = 0; j < message.options.length; ++j)
                        object.options[j] = $root.proto.Message.PollCreationMessage.Option.toObject(message.options[j], options);
                }
                if (message.selectableOptionsCount != null && message.hasOwnProperty("selectableOptionsCount"))
                    object.selectableOptionsCount = message.selectableOptionsCount;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this PollCreationMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.PollCreationMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PollCreationMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            PollCreationMessage.Option = (function() {

                /**
                 * Properties of an Option.
                 * @memberof proto.Message.PollCreationMessage
                 * @interface IOption
                 * @property {string|null} [optionName] Option optionName
                 */

                /**
                 * Constructs a new Option.
                 * @memberof proto.Message.PollCreationMessage
                 * @classdesc Represents an Option.
                 * @implements IOption
                 * @constructor
                 * @param {proto.Message.PollCreationMessage.IOption=} [properties] Properties to set
                 */
                function Option(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Option optionName.
                 * @member {string} optionName
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @instance
                 */
                Option.prototype.optionName = "";

                /**
                 * Creates a new Option instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @static
                 * @param {proto.Message.PollCreationMessage.IOption=} [properties] Properties to set
                 * @returns {proto.Message.PollCreationMessage.Option} Option instance
                 */
                Option.create = function create(properties) {
                    return new Option(properties);
                };

                /**
                 * Encodes the specified Option message. Does not implicitly {@link proto.Message.PollCreationMessage.Option.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @static
                 * @param {proto.Message.PollCreationMessage.IOption} message Option message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Option.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.optionName != null && Object.hasOwnProperty.call(message, "optionName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.optionName);
                    return writer;
                };

                /**
                 * Encodes the specified Option message, length delimited. Does not implicitly {@link proto.Message.PollCreationMessage.Option.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @static
                 * @param {proto.Message.PollCreationMessage.IOption} message Option message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Option.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Option message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.PollCreationMessage.Option} Option
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Option.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PollCreationMessage.Option();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.optionName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Option message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.PollCreationMessage.Option} Option
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Option.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Option message.
                 * @function verify
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Option.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.optionName != null && message.hasOwnProperty("optionName"))
                        if (!$util.isString(message.optionName))
                            return "optionName: string expected";
                    return null;
                };

                /**
                 * Creates an Option message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.PollCreationMessage.Option} Option
                 */
                Option.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.PollCreationMessage.Option)
                        return object;
                    var message = new $root.proto.Message.PollCreationMessage.Option();
                    if (object.optionName != null)
                        message.optionName = String(object.optionName);
                    return message;
                };

                /**
                 * Creates a plain object from an Option message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @static
                 * @param {proto.Message.PollCreationMessage.Option} message Option
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Option.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.optionName = "";
                    if (message.optionName != null && message.hasOwnProperty("optionName"))
                        object.optionName = message.optionName;
                    return object;
                };

                /**
                 * Converts this Option to JSON.
                 * @function toJSON
                 * @memberof proto.Message.PollCreationMessage.Option
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Option.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Option;
            })();

            return PollCreationMessage;
        })();

        Message.PollEncValue = (function() {

            /**
             * Properties of a PollEncValue.
             * @memberof proto.Message
             * @interface IPollEncValue
             * @property {Uint8Array|null} [encPayload] PollEncValue encPayload
             * @property {Uint8Array|null} [encIv] PollEncValue encIv
             */

            /**
             * Constructs a new PollEncValue.
             * @memberof proto.Message
             * @classdesc Represents a PollEncValue.
             * @implements IPollEncValue
             * @constructor
             * @param {proto.Message.IPollEncValue=} [properties] Properties to set
             */
            function PollEncValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PollEncValue encPayload.
             * @member {Uint8Array} encPayload
             * @memberof proto.Message.PollEncValue
             * @instance
             */
            PollEncValue.prototype.encPayload = $util.newBuffer([]);

            /**
             * PollEncValue encIv.
             * @member {Uint8Array} encIv
             * @memberof proto.Message.PollEncValue
             * @instance
             */
            PollEncValue.prototype.encIv = $util.newBuffer([]);

            /**
             * Creates a new PollEncValue instance using the specified properties.
             * @function create
             * @memberof proto.Message.PollEncValue
             * @static
             * @param {proto.Message.IPollEncValue=} [properties] Properties to set
             * @returns {proto.Message.PollEncValue} PollEncValue instance
             */
            PollEncValue.create = function create(properties) {
                return new PollEncValue(properties);
            };

            /**
             * Encodes the specified PollEncValue message. Does not implicitly {@link proto.Message.PollEncValue.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.PollEncValue
             * @static
             * @param {proto.Message.IPollEncValue} message PollEncValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollEncValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encPayload);
                if (message.encIv != null && Object.hasOwnProperty.call(message, "encIv"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encIv);
                return writer;
            };

            /**
             * Encodes the specified PollEncValue message, length delimited. Does not implicitly {@link proto.Message.PollEncValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.PollEncValue
             * @static
             * @param {proto.Message.IPollEncValue} message PollEncValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollEncValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PollEncValue message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.PollEncValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.PollEncValue} PollEncValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollEncValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PollEncValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.encPayload = reader.bytes();
                        break;
                    case 2:
                        message.encIv = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PollEncValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.PollEncValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.PollEncValue} PollEncValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollEncValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PollEncValue message.
             * @function verify
             * @memberof proto.Message.PollEncValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PollEncValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                    if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                        return "encPayload: buffer expected";
                if (message.encIv != null && message.hasOwnProperty("encIv"))
                    if (!(message.encIv && typeof message.encIv.length === "number" || $util.isString(message.encIv)))
                        return "encIv: buffer expected";
                return null;
            };

            /**
             * Creates a PollEncValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.PollEncValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.PollEncValue} PollEncValue
             */
            PollEncValue.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.PollEncValue)
                    return object;
                var message = new $root.proto.Message.PollEncValue();
                if (object.encPayload != null)
                    if (typeof object.encPayload === "string")
                        $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                    else if (object.encPayload.length)
                        message.encPayload = object.encPayload;
                if (object.encIv != null)
                    if (typeof object.encIv === "string")
                        $util.base64.decode(object.encIv, message.encIv = $util.newBuffer($util.base64.length(object.encIv)), 0);
                    else if (object.encIv.length)
                        message.encIv = object.encIv;
                return message;
            };

            /**
             * Creates a plain object from a PollEncValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.PollEncValue
             * @static
             * @param {proto.Message.PollEncValue} message PollEncValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PollEncValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.encPayload = "";
                    else {
                        object.encPayload = [];
                        if (options.bytes !== Array)
                            object.encPayload = $util.newBuffer(object.encPayload);
                    }
                    if (options.bytes === String)
                        object.encIv = "";
                    else {
                        object.encIv = [];
                        if (options.bytes !== Array)
                            object.encIv = $util.newBuffer(object.encIv);
                    }
                }
                if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                    object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
                if (message.encIv != null && message.hasOwnProperty("encIv"))
                    object.encIv = options.bytes === String ? $util.base64.encode(message.encIv, 0, message.encIv.length) : options.bytes === Array ? Array.prototype.slice.call(message.encIv) : message.encIv;
                return object;
            };

            /**
             * Converts this PollEncValue to JSON.
             * @function toJSON
             * @memberof proto.Message.PollEncValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PollEncValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PollEncValue;
        })();

        Message.PollUpdateMessage = (function() {

            /**
             * Properties of a PollUpdateMessage.
             * @memberof proto.Message
             * @interface IPollUpdateMessage
             * @property {proto.IMessageKey|null} [pollCreationMessageKey] PollUpdateMessage pollCreationMessageKey
             * @property {proto.Message.IPollEncValue|null} [vote] PollUpdateMessage vote
             * @property {proto.Message.IPollUpdateMessageMetadata|null} [metadata] PollUpdateMessage metadata
             * @property {number|Long|null} [senderTimestampMs] PollUpdateMessage senderTimestampMs
             */

            /**
             * Constructs a new PollUpdateMessage.
             * @memberof proto.Message
             * @classdesc Represents a PollUpdateMessage.
             * @implements IPollUpdateMessage
             * @constructor
             * @param {proto.Message.IPollUpdateMessage=} [properties] Properties to set
             */
            function PollUpdateMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PollUpdateMessage pollCreationMessageKey.
             * @member {proto.IMessageKey|null|undefined} pollCreationMessageKey
             * @memberof proto.Message.PollUpdateMessage
             * @instance
             */
            PollUpdateMessage.prototype.pollCreationMessageKey = null;

            /**
             * PollUpdateMessage vote.
             * @member {proto.Message.IPollEncValue|null|undefined} vote
             * @memberof proto.Message.PollUpdateMessage
             * @instance
             */
            PollUpdateMessage.prototype.vote = null;

            /**
             * PollUpdateMessage metadata.
             * @member {proto.Message.IPollUpdateMessageMetadata|null|undefined} metadata
             * @memberof proto.Message.PollUpdateMessage
             * @instance
             */
            PollUpdateMessage.prototype.metadata = null;

            /**
             * PollUpdateMessage senderTimestampMs.
             * @member {number|Long} senderTimestampMs
             * @memberof proto.Message.PollUpdateMessage
             * @instance
             */
            PollUpdateMessage.prototype.senderTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PollUpdateMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.PollUpdateMessage
             * @static
             * @param {proto.Message.IPollUpdateMessage=} [properties] Properties to set
             * @returns {proto.Message.PollUpdateMessage} PollUpdateMessage instance
             */
            PollUpdateMessage.create = function create(properties) {
                return new PollUpdateMessage(properties);
            };

            /**
             * Encodes the specified PollUpdateMessage message. Does not implicitly {@link proto.Message.PollUpdateMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.PollUpdateMessage
             * @static
             * @param {proto.Message.IPollUpdateMessage} message PollUpdateMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollUpdateMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pollCreationMessageKey != null && Object.hasOwnProperty.call(message, "pollCreationMessageKey"))
                    $root.proto.MessageKey.encode(message.pollCreationMessageKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.vote != null && Object.hasOwnProperty.call(message, "vote"))
                    $root.proto.Message.PollEncValue.encode(message.vote, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.proto.Message.PollUpdateMessageMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.senderTimestampMs != null && Object.hasOwnProperty.call(message, "senderTimestampMs"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.senderTimestampMs);
                return writer;
            };

            /**
             * Encodes the specified PollUpdateMessage message, length delimited. Does not implicitly {@link proto.Message.PollUpdateMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.PollUpdateMessage
             * @static
             * @param {proto.Message.IPollUpdateMessage} message PollUpdateMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollUpdateMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PollUpdateMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.PollUpdateMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.PollUpdateMessage} PollUpdateMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollUpdateMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PollUpdateMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pollCreationMessageKey = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.vote = $root.proto.Message.PollEncValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.metadata = $root.proto.Message.PollUpdateMessageMetadata.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.senderTimestampMs = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PollUpdateMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.PollUpdateMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.PollUpdateMessage} PollUpdateMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollUpdateMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PollUpdateMessage message.
             * @function verify
             * @memberof proto.Message.PollUpdateMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PollUpdateMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pollCreationMessageKey != null && message.hasOwnProperty("pollCreationMessageKey")) {
                    var error = $root.proto.MessageKey.verify(message.pollCreationMessageKey);
                    if (error)
                        return "pollCreationMessageKey." + error;
                }
                if (message.vote != null && message.hasOwnProperty("vote")) {
                    var error = $root.proto.Message.PollEncValue.verify(message.vote);
                    if (error)
                        return "vote." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    var error = $root.proto.Message.PollUpdateMessageMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                    if (!$util.isInteger(message.senderTimestampMs) && !(message.senderTimestampMs && $util.isInteger(message.senderTimestampMs.low) && $util.isInteger(message.senderTimestampMs.high)))
                        return "senderTimestampMs: integer|Long expected";
                return null;
            };

            /**
             * Creates a PollUpdateMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.PollUpdateMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.PollUpdateMessage} PollUpdateMessage
             */
            PollUpdateMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.PollUpdateMessage)
                    return object;
                var message = new $root.proto.Message.PollUpdateMessage();
                if (object.pollCreationMessageKey != null) {
                    if (typeof object.pollCreationMessageKey !== "object")
                        throw TypeError(".proto.Message.PollUpdateMessage.pollCreationMessageKey: object expected");
                    message.pollCreationMessageKey = $root.proto.MessageKey.fromObject(object.pollCreationMessageKey);
                }
                if (object.vote != null) {
                    if (typeof object.vote !== "object")
                        throw TypeError(".proto.Message.PollUpdateMessage.vote: object expected");
                    message.vote = $root.proto.Message.PollEncValue.fromObject(object.vote);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".proto.Message.PollUpdateMessage.metadata: object expected");
                    message.metadata = $root.proto.Message.PollUpdateMessageMetadata.fromObject(object.metadata);
                }
                if (object.senderTimestampMs != null)
                    if ($util.Long)
                        (message.senderTimestampMs = $util.Long.fromValue(object.senderTimestampMs)).unsigned = false;
                    else if (typeof object.senderTimestampMs === "string")
                        message.senderTimestampMs = parseInt(object.senderTimestampMs, 10);
                    else if (typeof object.senderTimestampMs === "number")
                        message.senderTimestampMs = object.senderTimestampMs;
                    else if (typeof object.senderTimestampMs === "object")
                        message.senderTimestampMs = new $util.LongBits(object.senderTimestampMs.low >>> 0, object.senderTimestampMs.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a PollUpdateMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.PollUpdateMessage
             * @static
             * @param {proto.Message.PollUpdateMessage} message PollUpdateMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PollUpdateMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.pollCreationMessageKey = null;
                    object.vote = null;
                    object.metadata = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.senderTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.senderTimestampMs = options.longs === String ? "0" : 0;
                }
                if (message.pollCreationMessageKey != null && message.hasOwnProperty("pollCreationMessageKey"))
                    object.pollCreationMessageKey = $root.proto.MessageKey.toObject(message.pollCreationMessageKey, options);
                if (message.vote != null && message.hasOwnProperty("vote"))
                    object.vote = $root.proto.Message.PollEncValue.toObject(message.vote, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.proto.Message.PollUpdateMessageMetadata.toObject(message.metadata, options);
                if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                    if (typeof message.senderTimestampMs === "number")
                        object.senderTimestampMs = options.longs === String ? String(message.senderTimestampMs) : message.senderTimestampMs;
                    else
                        object.senderTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.senderTimestampMs) : options.longs === Number ? new $util.LongBits(message.senderTimestampMs.low >>> 0, message.senderTimestampMs.high >>> 0).toNumber() : message.senderTimestampMs;
                return object;
            };

            /**
             * Converts this PollUpdateMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.PollUpdateMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PollUpdateMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PollUpdateMessage;
        })();

        Message.PollUpdateMessageMetadata = (function() {

            /**
             * Properties of a PollUpdateMessageMetadata.
             * @memberof proto.Message
             * @interface IPollUpdateMessageMetadata
             */

            /**
             * Constructs a new PollUpdateMessageMetadata.
             * @memberof proto.Message
             * @classdesc Represents a PollUpdateMessageMetadata.
             * @implements IPollUpdateMessageMetadata
             * @constructor
             * @param {proto.Message.IPollUpdateMessageMetadata=} [properties] Properties to set
             */
            function PollUpdateMessageMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PollUpdateMessageMetadata instance using the specified properties.
             * @function create
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @static
             * @param {proto.Message.IPollUpdateMessageMetadata=} [properties] Properties to set
             * @returns {proto.Message.PollUpdateMessageMetadata} PollUpdateMessageMetadata instance
             */
            PollUpdateMessageMetadata.create = function create(properties) {
                return new PollUpdateMessageMetadata(properties);
            };

            /**
             * Encodes the specified PollUpdateMessageMetadata message. Does not implicitly {@link proto.Message.PollUpdateMessageMetadata.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @static
             * @param {proto.Message.IPollUpdateMessageMetadata} message PollUpdateMessageMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollUpdateMessageMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PollUpdateMessageMetadata message, length delimited. Does not implicitly {@link proto.Message.PollUpdateMessageMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @static
             * @param {proto.Message.IPollUpdateMessageMetadata} message PollUpdateMessageMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollUpdateMessageMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PollUpdateMessageMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.PollUpdateMessageMetadata} PollUpdateMessageMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollUpdateMessageMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PollUpdateMessageMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PollUpdateMessageMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.PollUpdateMessageMetadata} PollUpdateMessageMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollUpdateMessageMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PollUpdateMessageMetadata message.
             * @function verify
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PollUpdateMessageMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a PollUpdateMessageMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.PollUpdateMessageMetadata} PollUpdateMessageMetadata
             */
            PollUpdateMessageMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.PollUpdateMessageMetadata)
                    return object;
                return new $root.proto.Message.PollUpdateMessageMetadata();
            };

            /**
             * Creates a plain object from a PollUpdateMessageMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @static
             * @param {proto.Message.PollUpdateMessageMetadata} message PollUpdateMessageMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PollUpdateMessageMetadata.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this PollUpdateMessageMetadata to JSON.
             * @function toJSON
             * @memberof proto.Message.PollUpdateMessageMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PollUpdateMessageMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PollUpdateMessageMetadata;
        })();

        Message.PollVoteMessage = (function() {

            /**
             * Properties of a PollVoteMessage.
             * @memberof proto.Message
             * @interface IPollVoteMessage
             * @property {Array.<Uint8Array>|null} [selectedOptions] PollVoteMessage selectedOptions
             */

            /**
             * Constructs a new PollVoteMessage.
             * @memberof proto.Message
             * @classdesc Represents a PollVoteMessage.
             * @implements IPollVoteMessage
             * @constructor
             * @param {proto.Message.IPollVoteMessage=} [properties] Properties to set
             */
            function PollVoteMessage(properties) {
                this.selectedOptions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PollVoteMessage selectedOptions.
             * @member {Array.<Uint8Array>} selectedOptions
             * @memberof proto.Message.PollVoteMessage
             * @instance
             */
            PollVoteMessage.prototype.selectedOptions = $util.emptyArray;

            /**
             * Creates a new PollVoteMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.PollVoteMessage
             * @static
             * @param {proto.Message.IPollVoteMessage=} [properties] Properties to set
             * @returns {proto.Message.PollVoteMessage} PollVoteMessage instance
             */
            PollVoteMessage.create = function create(properties) {
                return new PollVoteMessage(properties);
            };

            /**
             * Encodes the specified PollVoteMessage message. Does not implicitly {@link proto.Message.PollVoteMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.PollVoteMessage
             * @static
             * @param {proto.Message.IPollVoteMessage} message PollVoteMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollVoteMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selectedOptions != null && message.selectedOptions.length)
                    for (var i = 0; i < message.selectedOptions.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.selectedOptions[i]);
                return writer;
            };

            /**
             * Encodes the specified PollVoteMessage message, length delimited. Does not implicitly {@link proto.Message.PollVoteMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.PollVoteMessage
             * @static
             * @param {proto.Message.IPollVoteMessage} message PollVoteMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollVoteMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PollVoteMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.PollVoteMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.PollVoteMessage} PollVoteMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollVoteMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.PollVoteMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.selectedOptions && message.selectedOptions.length))
                            message.selectedOptions = [];
                        message.selectedOptions.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PollVoteMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.PollVoteMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.PollVoteMessage} PollVoteMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollVoteMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PollVoteMessage message.
             * @function verify
             * @memberof proto.Message.PollVoteMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PollVoteMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.selectedOptions != null && message.hasOwnProperty("selectedOptions")) {
                    if (!Array.isArray(message.selectedOptions))
                        return "selectedOptions: array expected";
                    for (var i = 0; i < message.selectedOptions.length; ++i)
                        if (!(message.selectedOptions[i] && typeof message.selectedOptions[i].length === "number" || $util.isString(message.selectedOptions[i])))
                            return "selectedOptions: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a PollVoteMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.PollVoteMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.PollVoteMessage} PollVoteMessage
             */
            PollVoteMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.PollVoteMessage)
                    return object;
                var message = new $root.proto.Message.PollVoteMessage();
                if (object.selectedOptions) {
                    if (!Array.isArray(object.selectedOptions))
                        throw TypeError(".proto.Message.PollVoteMessage.selectedOptions: array expected");
                    message.selectedOptions = [];
                    for (var i = 0; i < object.selectedOptions.length; ++i)
                        if (typeof object.selectedOptions[i] === "string")
                            $util.base64.decode(object.selectedOptions[i], message.selectedOptions[i] = $util.newBuffer($util.base64.length(object.selectedOptions[i])), 0);
                        else if (object.selectedOptions[i].length)
                            message.selectedOptions[i] = object.selectedOptions[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a PollVoteMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.PollVoteMessage
             * @static
             * @param {proto.Message.PollVoteMessage} message PollVoteMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PollVoteMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.selectedOptions = [];
                if (message.selectedOptions && message.selectedOptions.length) {
                    object.selectedOptions = [];
                    for (var j = 0; j < message.selectedOptions.length; ++j)
                        object.selectedOptions[j] = options.bytes === String ? $util.base64.encode(message.selectedOptions[j], 0, message.selectedOptions[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.selectedOptions[j]) : message.selectedOptions[j];
                }
                return object;
            };

            /**
             * Converts this PollVoteMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.PollVoteMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PollVoteMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PollVoteMessage;
        })();

        Message.ProductMessage = (function() {

            /**
             * Properties of a ProductMessage.
             * @memberof proto.Message
             * @interface IProductMessage
             * @property {proto.Message.ProductMessage.IProductSnapshot|null} [product] ProductMessage product
             * @property {string|null} [businessOwnerJid] ProductMessage businessOwnerJid
             * @property {proto.Message.ProductMessage.ICatalogSnapshot|null} [catalog] ProductMessage catalog
             * @property {string|null} [body] ProductMessage body
             * @property {string|null} [footer] ProductMessage footer
             * @property {proto.IContextInfo|null} [contextInfo] ProductMessage contextInfo
             */

            /**
             * Constructs a new ProductMessage.
             * @memberof proto.Message
             * @classdesc Represents a ProductMessage.
             * @implements IProductMessage
             * @constructor
             * @param {proto.Message.IProductMessage=} [properties] Properties to set
             */
            function ProductMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProductMessage product.
             * @member {proto.Message.ProductMessage.IProductSnapshot|null|undefined} product
             * @memberof proto.Message.ProductMessage
             * @instance
             */
            ProductMessage.prototype.product = null;

            /**
             * ProductMessage businessOwnerJid.
             * @member {string} businessOwnerJid
             * @memberof proto.Message.ProductMessage
             * @instance
             */
            ProductMessage.prototype.businessOwnerJid = "";

            /**
             * ProductMessage catalog.
             * @member {proto.Message.ProductMessage.ICatalogSnapshot|null|undefined} catalog
             * @memberof proto.Message.ProductMessage
             * @instance
             */
            ProductMessage.prototype.catalog = null;

            /**
             * ProductMessage body.
             * @member {string} body
             * @memberof proto.Message.ProductMessage
             * @instance
             */
            ProductMessage.prototype.body = "";

            /**
             * ProductMessage footer.
             * @member {string} footer
             * @memberof proto.Message.ProductMessage
             * @instance
             */
            ProductMessage.prototype.footer = "";

            /**
             * ProductMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.ProductMessage
             * @instance
             */
            ProductMessage.prototype.contextInfo = null;

            /**
             * Creates a new ProductMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ProductMessage
             * @static
             * @param {proto.Message.IProductMessage=} [properties] Properties to set
             * @returns {proto.Message.ProductMessage} ProductMessage instance
             */
            ProductMessage.create = function create(properties) {
                return new ProductMessage(properties);
            };

            /**
             * Encodes the specified ProductMessage message. Does not implicitly {@link proto.Message.ProductMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ProductMessage
             * @static
             * @param {proto.Message.IProductMessage} message ProductMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProductMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.product != null && Object.hasOwnProperty.call(message, "product"))
                    $root.proto.Message.ProductMessage.ProductSnapshot.encode(message.product, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.businessOwnerJid != null && Object.hasOwnProperty.call(message, "businessOwnerJid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.businessOwnerJid);
                if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
                    $root.proto.Message.ProductMessage.CatalogSnapshot.encode(message.catalog, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.body);
                if (message.footer != null && Object.hasOwnProperty.call(message, "footer"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.footer);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ProductMessage message, length delimited. Does not implicitly {@link proto.Message.ProductMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ProductMessage
             * @static
             * @param {proto.Message.IProductMessage} message ProductMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProductMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProductMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ProductMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ProductMessage} ProductMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProductMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ProductMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.product = $root.proto.Message.ProductMessage.ProductSnapshot.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.businessOwnerJid = reader.string();
                        break;
                    case 4:
                        message.catalog = $root.proto.Message.ProductMessage.CatalogSnapshot.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.body = reader.string();
                        break;
                    case 6:
                        message.footer = reader.string();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProductMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ProductMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ProductMessage} ProductMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProductMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProductMessage message.
             * @function verify
             * @memberof proto.Message.ProductMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProductMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.product != null && message.hasOwnProperty("product")) {
                    var error = $root.proto.Message.ProductMessage.ProductSnapshot.verify(message.product);
                    if (error)
                        return "product." + error;
                }
                if (message.businessOwnerJid != null && message.hasOwnProperty("businessOwnerJid"))
                    if (!$util.isString(message.businessOwnerJid))
                        return "businessOwnerJid: string expected";
                if (message.catalog != null && message.hasOwnProperty("catalog")) {
                    var error = $root.proto.Message.ProductMessage.CatalogSnapshot.verify(message.catalog);
                    if (error)
                        return "catalog." + error;
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.footer != null && message.hasOwnProperty("footer"))
                    if (!$util.isString(message.footer))
                        return "footer: string expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates a ProductMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ProductMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ProductMessage} ProductMessage
             */
            ProductMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ProductMessage)
                    return object;
                var message = new $root.proto.Message.ProductMessage();
                if (object.product != null) {
                    if (typeof object.product !== "object")
                        throw TypeError(".proto.Message.ProductMessage.product: object expected");
                    message.product = $root.proto.Message.ProductMessage.ProductSnapshot.fromObject(object.product);
                }
                if (object.businessOwnerJid != null)
                    message.businessOwnerJid = String(object.businessOwnerJid);
                if (object.catalog != null) {
                    if (typeof object.catalog !== "object")
                        throw TypeError(".proto.Message.ProductMessage.catalog: object expected");
                    message.catalog = $root.proto.Message.ProductMessage.CatalogSnapshot.fromObject(object.catalog);
                }
                if (object.body != null)
                    message.body = String(object.body);
                if (object.footer != null)
                    message.footer = String(object.footer);
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.ProductMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProductMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ProductMessage
             * @static
             * @param {proto.Message.ProductMessage} message ProductMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProductMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.product = null;
                    object.businessOwnerJid = "";
                    object.catalog = null;
                    object.body = "";
                    object.footer = "";
                    object.contextInfo = null;
                }
                if (message.product != null && message.hasOwnProperty("product"))
                    object.product = $root.proto.Message.ProductMessage.ProductSnapshot.toObject(message.product, options);
                if (message.businessOwnerJid != null && message.hasOwnProperty("businessOwnerJid"))
                    object.businessOwnerJid = message.businessOwnerJid;
                if (message.catalog != null && message.hasOwnProperty("catalog"))
                    object.catalog = $root.proto.Message.ProductMessage.CatalogSnapshot.toObject(message.catalog, options);
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.footer != null && message.hasOwnProperty("footer"))
                    object.footer = message.footer;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this ProductMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ProductMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProductMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ProductMessage.CatalogSnapshot = (function() {

                /**
                 * Properties of a CatalogSnapshot.
                 * @memberof proto.Message.ProductMessage
                 * @interface ICatalogSnapshot
                 * @property {proto.Message.IImageMessage|null} [catalogImage] CatalogSnapshot catalogImage
                 * @property {string|null} [title] CatalogSnapshot title
                 * @property {string|null} [description] CatalogSnapshot description
                 */

                /**
                 * Constructs a new CatalogSnapshot.
                 * @memberof proto.Message.ProductMessage
                 * @classdesc Represents a CatalogSnapshot.
                 * @implements ICatalogSnapshot
                 * @constructor
                 * @param {proto.Message.ProductMessage.ICatalogSnapshot=} [properties] Properties to set
                 */
                function CatalogSnapshot(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CatalogSnapshot catalogImage.
                 * @member {proto.Message.IImageMessage|null|undefined} catalogImage
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @instance
                 */
                CatalogSnapshot.prototype.catalogImage = null;

                /**
                 * CatalogSnapshot title.
                 * @member {string} title
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @instance
                 */
                CatalogSnapshot.prototype.title = "";

                /**
                 * CatalogSnapshot description.
                 * @member {string} description
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @instance
                 */
                CatalogSnapshot.prototype.description = "";

                /**
                 * Creates a new CatalogSnapshot instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @static
                 * @param {proto.Message.ProductMessage.ICatalogSnapshot=} [properties] Properties to set
                 * @returns {proto.Message.ProductMessage.CatalogSnapshot} CatalogSnapshot instance
                 */
                CatalogSnapshot.create = function create(properties) {
                    return new CatalogSnapshot(properties);
                };

                /**
                 * Encodes the specified CatalogSnapshot message. Does not implicitly {@link proto.Message.ProductMessage.CatalogSnapshot.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @static
                 * @param {proto.Message.ProductMessage.ICatalogSnapshot} message CatalogSnapshot message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CatalogSnapshot.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.catalogImage != null && Object.hasOwnProperty.call(message, "catalogImage"))
                        $root.proto.Message.ImageMessage.encode(message.catalogImage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                    return writer;
                };

                /**
                 * Encodes the specified CatalogSnapshot message, length delimited. Does not implicitly {@link proto.Message.ProductMessage.CatalogSnapshot.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @static
                 * @param {proto.Message.ProductMessage.ICatalogSnapshot} message CatalogSnapshot message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CatalogSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CatalogSnapshot message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ProductMessage.CatalogSnapshot} CatalogSnapshot
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CatalogSnapshot.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ProductMessage.CatalogSnapshot();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.catalogImage = $root.proto.Message.ImageMessage.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.title = reader.string();
                            break;
                        case 3:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CatalogSnapshot message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ProductMessage.CatalogSnapshot} CatalogSnapshot
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CatalogSnapshot.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CatalogSnapshot message.
                 * @function verify
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CatalogSnapshot.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.catalogImage != null && message.hasOwnProperty("catalogImage")) {
                        var error = $root.proto.Message.ImageMessage.verify(message.catalogImage);
                        if (error)
                            return "catalogImage." + error;
                    }
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };

                /**
                 * Creates a CatalogSnapshot message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ProductMessage.CatalogSnapshot} CatalogSnapshot
                 */
                CatalogSnapshot.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ProductMessage.CatalogSnapshot)
                        return object;
                    var message = new $root.proto.Message.ProductMessage.CatalogSnapshot();
                    if (object.catalogImage != null) {
                        if (typeof object.catalogImage !== "object")
                            throw TypeError(".proto.Message.ProductMessage.CatalogSnapshot.catalogImage: object expected");
                        message.catalogImage = $root.proto.Message.ImageMessage.fromObject(object.catalogImage);
                    }
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };

                /**
                 * Creates a plain object from a CatalogSnapshot message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @static
                 * @param {proto.Message.ProductMessage.CatalogSnapshot} message CatalogSnapshot
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CatalogSnapshot.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.catalogImage = null;
                        object.title = "";
                        object.description = "";
                    }
                    if (message.catalogImage != null && message.hasOwnProperty("catalogImage"))
                        object.catalogImage = $root.proto.Message.ImageMessage.toObject(message.catalogImage, options);
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };

                /**
                 * Converts this CatalogSnapshot to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ProductMessage.CatalogSnapshot
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CatalogSnapshot.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CatalogSnapshot;
            })();

            ProductMessage.ProductSnapshot = (function() {

                /**
                 * Properties of a ProductSnapshot.
                 * @memberof proto.Message.ProductMessage
                 * @interface IProductSnapshot
                 * @property {proto.Message.IImageMessage|null} [productImage] ProductSnapshot productImage
                 * @property {string|null} [productId] ProductSnapshot productId
                 * @property {string|null} [title] ProductSnapshot title
                 * @property {string|null} [description] ProductSnapshot description
                 * @property {string|null} [currencyCode] ProductSnapshot currencyCode
                 * @property {number|Long|null} [priceAmount1000] ProductSnapshot priceAmount1000
                 * @property {string|null} [retailerId] ProductSnapshot retailerId
                 * @property {string|null} [url] ProductSnapshot url
                 * @property {number|null} [productImageCount] ProductSnapshot productImageCount
                 * @property {string|null} [firstImageId] ProductSnapshot firstImageId
                 * @property {number|Long|null} [salePriceAmount1000] ProductSnapshot salePriceAmount1000
                 */

                /**
                 * Constructs a new ProductSnapshot.
                 * @memberof proto.Message.ProductMessage
                 * @classdesc Represents a ProductSnapshot.
                 * @implements IProductSnapshot
                 * @constructor
                 * @param {proto.Message.ProductMessage.IProductSnapshot=} [properties] Properties to set
                 */
                function ProductSnapshot(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProductSnapshot productImage.
                 * @member {proto.Message.IImageMessage|null|undefined} productImage
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.productImage = null;

                /**
                 * ProductSnapshot productId.
                 * @member {string} productId
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.productId = "";

                /**
                 * ProductSnapshot title.
                 * @member {string} title
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.title = "";

                /**
                 * ProductSnapshot description.
                 * @member {string} description
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.description = "";

                /**
                 * ProductSnapshot currencyCode.
                 * @member {string} currencyCode
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.currencyCode = "";

                /**
                 * ProductSnapshot priceAmount1000.
                 * @member {number|Long} priceAmount1000
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.priceAmount1000 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ProductSnapshot retailerId.
                 * @member {string} retailerId
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.retailerId = "";

                /**
                 * ProductSnapshot url.
                 * @member {string} url
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.url = "";

                /**
                 * ProductSnapshot productImageCount.
                 * @member {number} productImageCount
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.productImageCount = 0;

                /**
                 * ProductSnapshot firstImageId.
                 * @member {string} firstImageId
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.firstImageId = "";

                /**
                 * ProductSnapshot salePriceAmount1000.
                 * @member {number|Long} salePriceAmount1000
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 */
                ProductSnapshot.prototype.salePriceAmount1000 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new ProductSnapshot instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @static
                 * @param {proto.Message.ProductMessage.IProductSnapshot=} [properties] Properties to set
                 * @returns {proto.Message.ProductMessage.ProductSnapshot} ProductSnapshot instance
                 */
                ProductSnapshot.create = function create(properties) {
                    return new ProductSnapshot(properties);
                };

                /**
                 * Encodes the specified ProductSnapshot message. Does not implicitly {@link proto.Message.ProductMessage.ProductSnapshot.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @static
                 * @param {proto.Message.ProductMessage.IProductSnapshot} message ProductSnapshot message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProductSnapshot.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.productImage != null && Object.hasOwnProperty.call(message, "productImage"))
                        $root.proto.Message.ImageMessage.encode(message.productImage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.productId != null && Object.hasOwnProperty.call(message, "productId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.productId);
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                    if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.currencyCode);
                    if (message.priceAmount1000 != null && Object.hasOwnProperty.call(message, "priceAmount1000"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.priceAmount1000);
                    if (message.retailerId != null && Object.hasOwnProperty.call(message, "retailerId"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.retailerId);
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.url);
                    if (message.productImageCount != null && Object.hasOwnProperty.call(message, "productImageCount"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.productImageCount);
                    if (message.firstImageId != null && Object.hasOwnProperty.call(message, "firstImageId"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.firstImageId);
                    if (message.salePriceAmount1000 != null && Object.hasOwnProperty.call(message, "salePriceAmount1000"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int64(message.salePriceAmount1000);
                    return writer;
                };

                /**
                 * Encodes the specified ProductSnapshot message, length delimited. Does not implicitly {@link proto.Message.ProductMessage.ProductSnapshot.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @static
                 * @param {proto.Message.ProductMessage.IProductSnapshot} message ProductSnapshot message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProductSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProductSnapshot message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.ProductMessage.ProductSnapshot} ProductSnapshot
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProductSnapshot.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ProductMessage.ProductSnapshot();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.productImage = $root.proto.Message.ImageMessage.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.productId = reader.string();
                            break;
                        case 3:
                            message.title = reader.string();
                            break;
                        case 4:
                            message.description = reader.string();
                            break;
                        case 5:
                            message.currencyCode = reader.string();
                            break;
                        case 6:
                            message.priceAmount1000 = reader.int64();
                            break;
                        case 7:
                            message.retailerId = reader.string();
                            break;
                        case 8:
                            message.url = reader.string();
                            break;
                        case 9:
                            message.productImageCount = reader.uint32();
                            break;
                        case 11:
                            message.firstImageId = reader.string();
                            break;
                        case 12:
                            message.salePriceAmount1000 = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProductSnapshot message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.ProductMessage.ProductSnapshot} ProductSnapshot
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProductSnapshot.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProductSnapshot message.
                 * @function verify
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProductSnapshot.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.productImage != null && message.hasOwnProperty("productImage")) {
                        var error = $root.proto.Message.ImageMessage.verify(message.productImage);
                        if (error)
                            return "productImage." + error;
                    }
                    if (message.productId != null && message.hasOwnProperty("productId"))
                        if (!$util.isString(message.productId))
                            return "productId: string expected";
                    if (message.title != null && message.hasOwnProperty("title"))
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                        if (!$util.isString(message.currencyCode))
                            return "currencyCode: string expected";
                    if (message.priceAmount1000 != null && message.hasOwnProperty("priceAmount1000"))
                        if (!$util.isInteger(message.priceAmount1000) && !(message.priceAmount1000 && $util.isInteger(message.priceAmount1000.low) && $util.isInteger(message.priceAmount1000.high)))
                            return "priceAmount1000: integer|Long expected";
                    if (message.retailerId != null && message.hasOwnProperty("retailerId"))
                        if (!$util.isString(message.retailerId))
                            return "retailerId: string expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    if (message.productImageCount != null && message.hasOwnProperty("productImageCount"))
                        if (!$util.isInteger(message.productImageCount))
                            return "productImageCount: integer expected";
                    if (message.firstImageId != null && message.hasOwnProperty("firstImageId"))
                        if (!$util.isString(message.firstImageId))
                            return "firstImageId: string expected";
                    if (message.salePriceAmount1000 != null && message.hasOwnProperty("salePriceAmount1000"))
                        if (!$util.isInteger(message.salePriceAmount1000) && !(message.salePriceAmount1000 && $util.isInteger(message.salePriceAmount1000.low) && $util.isInteger(message.salePriceAmount1000.high)))
                            return "salePriceAmount1000: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ProductSnapshot message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.ProductMessage.ProductSnapshot} ProductSnapshot
                 */
                ProductSnapshot.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.ProductMessage.ProductSnapshot)
                        return object;
                    var message = new $root.proto.Message.ProductMessage.ProductSnapshot();
                    if (object.productImage != null) {
                        if (typeof object.productImage !== "object")
                            throw TypeError(".proto.Message.ProductMessage.ProductSnapshot.productImage: object expected");
                        message.productImage = $root.proto.Message.ImageMessage.fromObject(object.productImage);
                    }
                    if (object.productId != null)
                        message.productId = String(object.productId);
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.currencyCode != null)
                        message.currencyCode = String(object.currencyCode);
                    if (object.priceAmount1000 != null)
                        if ($util.Long)
                            (message.priceAmount1000 = $util.Long.fromValue(object.priceAmount1000)).unsigned = false;
                        else if (typeof object.priceAmount1000 === "string")
                            message.priceAmount1000 = parseInt(object.priceAmount1000, 10);
                        else if (typeof object.priceAmount1000 === "number")
                            message.priceAmount1000 = object.priceAmount1000;
                        else if (typeof object.priceAmount1000 === "object")
                            message.priceAmount1000 = new $util.LongBits(object.priceAmount1000.low >>> 0, object.priceAmount1000.high >>> 0).toNumber();
                    if (object.retailerId != null)
                        message.retailerId = String(object.retailerId);
                    if (object.url != null)
                        message.url = String(object.url);
                    if (object.productImageCount != null)
                        message.productImageCount = object.productImageCount >>> 0;
                    if (object.firstImageId != null)
                        message.firstImageId = String(object.firstImageId);
                    if (object.salePriceAmount1000 != null)
                        if ($util.Long)
                            (message.salePriceAmount1000 = $util.Long.fromValue(object.salePriceAmount1000)).unsigned = false;
                        else if (typeof object.salePriceAmount1000 === "string")
                            message.salePriceAmount1000 = parseInt(object.salePriceAmount1000, 10);
                        else if (typeof object.salePriceAmount1000 === "number")
                            message.salePriceAmount1000 = object.salePriceAmount1000;
                        else if (typeof object.salePriceAmount1000 === "object")
                            message.salePriceAmount1000 = new $util.LongBits(object.salePriceAmount1000.low >>> 0, object.salePriceAmount1000.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a ProductSnapshot message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @static
                 * @param {proto.Message.ProductMessage.ProductSnapshot} message ProductSnapshot
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProductSnapshot.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.productImage = null;
                        object.productId = "";
                        object.title = "";
                        object.description = "";
                        object.currencyCode = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.priceAmount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.priceAmount1000 = options.longs === String ? "0" : 0;
                        object.retailerId = "";
                        object.url = "";
                        object.productImageCount = 0;
                        object.firstImageId = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.salePriceAmount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.salePriceAmount1000 = options.longs === String ? "0" : 0;
                    }
                    if (message.productImage != null && message.hasOwnProperty("productImage"))
                        object.productImage = $root.proto.Message.ImageMessage.toObject(message.productImage, options);
                    if (message.productId != null && message.hasOwnProperty("productId"))
                        object.productId = message.productId;
                    if (message.title != null && message.hasOwnProperty("title"))
                        object.title = message.title;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                        object.currencyCode = message.currencyCode;
                    if (message.priceAmount1000 != null && message.hasOwnProperty("priceAmount1000"))
                        if (typeof message.priceAmount1000 === "number")
                            object.priceAmount1000 = options.longs === String ? String(message.priceAmount1000) : message.priceAmount1000;
                        else
                            object.priceAmount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.priceAmount1000) : options.longs === Number ? new $util.LongBits(message.priceAmount1000.low >>> 0, message.priceAmount1000.high >>> 0).toNumber() : message.priceAmount1000;
                    if (message.retailerId != null && message.hasOwnProperty("retailerId"))
                        object.retailerId = message.retailerId;
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    if (message.productImageCount != null && message.hasOwnProperty("productImageCount"))
                        object.productImageCount = message.productImageCount;
                    if (message.firstImageId != null && message.hasOwnProperty("firstImageId"))
                        object.firstImageId = message.firstImageId;
                    if (message.salePriceAmount1000 != null && message.hasOwnProperty("salePriceAmount1000"))
                        if (typeof message.salePriceAmount1000 === "number")
                            object.salePriceAmount1000 = options.longs === String ? String(message.salePriceAmount1000) : message.salePriceAmount1000;
                        else
                            object.salePriceAmount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.salePriceAmount1000) : options.longs === Number ? new $util.LongBits(message.salePriceAmount1000.low >>> 0, message.salePriceAmount1000.high >>> 0).toNumber() : message.salePriceAmount1000;
                    return object;
                };

                /**
                 * Converts this ProductSnapshot to JSON.
                 * @function toJSON
                 * @memberof proto.Message.ProductMessage.ProductSnapshot
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProductSnapshot.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProductSnapshot;
            })();

            return ProductMessage;
        })();

        Message.ProtocolMessage = (function() {

            /**
             * Properties of a ProtocolMessage.
             * @memberof proto.Message
             * @interface IProtocolMessage
             * @property {proto.IMessageKey|null} [key] ProtocolMessage key
             * @property {proto.Message.ProtocolMessage.Type|null} [type] ProtocolMessage type
             * @property {number|null} [ephemeralExpiration] ProtocolMessage ephemeralExpiration
             * @property {number|Long|null} [ephemeralSettingTimestamp] ProtocolMessage ephemeralSettingTimestamp
             * @property {proto.Message.IHistorySyncNotification|null} [historySyncNotification] ProtocolMessage historySyncNotification
             * @property {proto.Message.IAppStateSyncKeyShare|null} [appStateSyncKeyShare] ProtocolMessage appStateSyncKeyShare
             * @property {proto.Message.IAppStateSyncKeyRequest|null} [appStateSyncKeyRequest] ProtocolMessage appStateSyncKeyRequest
             * @property {proto.Message.IInitialSecurityNotificationSettingSync|null} [initialSecurityNotificationSettingSync] ProtocolMessage initialSecurityNotificationSettingSync
             * @property {proto.Message.IAppStateFatalExceptionNotification|null} [appStateFatalExceptionNotification] ProtocolMessage appStateFatalExceptionNotification
             * @property {proto.IDisappearingMode|null} [disappearingMode] ProtocolMessage disappearingMode
             * @property {proto.IMessage|null} [editedMessage] ProtocolMessage editedMessage
             * @property {number|Long|null} [timestampMs] ProtocolMessage timestampMs
             * @property {proto.Message.IPeerDataOperationRequestMessage|null} [peerDataOperationRequestMessage] ProtocolMessage peerDataOperationRequestMessage
             * @property {proto.Message.IPeerDataOperationRequestResponseMessage|null} [peerDataOperationRequestResponseMessage] ProtocolMessage peerDataOperationRequestResponseMessage
             */

            /**
             * Constructs a new ProtocolMessage.
             * @memberof proto.Message
             * @classdesc Represents a ProtocolMessage.
             * @implements IProtocolMessage
             * @constructor
             * @param {proto.Message.IProtocolMessage=} [properties] Properties to set
             */
            function ProtocolMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProtocolMessage key.
             * @member {proto.IMessageKey|null|undefined} key
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.key = null;

            /**
             * ProtocolMessage type.
             * @member {proto.Message.ProtocolMessage.Type} type
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.type = 0;

            /**
             * ProtocolMessage ephemeralExpiration.
             * @member {number} ephemeralExpiration
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.ephemeralExpiration = 0;

            /**
             * ProtocolMessage ephemeralSettingTimestamp.
             * @member {number|Long} ephemeralSettingTimestamp
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.ephemeralSettingTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ProtocolMessage historySyncNotification.
             * @member {proto.Message.IHistorySyncNotification|null|undefined} historySyncNotification
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.historySyncNotification = null;

            /**
             * ProtocolMessage appStateSyncKeyShare.
             * @member {proto.Message.IAppStateSyncKeyShare|null|undefined} appStateSyncKeyShare
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.appStateSyncKeyShare = null;

            /**
             * ProtocolMessage appStateSyncKeyRequest.
             * @member {proto.Message.IAppStateSyncKeyRequest|null|undefined} appStateSyncKeyRequest
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.appStateSyncKeyRequest = null;

            /**
             * ProtocolMessage initialSecurityNotificationSettingSync.
             * @member {proto.Message.IInitialSecurityNotificationSettingSync|null|undefined} initialSecurityNotificationSettingSync
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.initialSecurityNotificationSettingSync = null;

            /**
             * ProtocolMessage appStateFatalExceptionNotification.
             * @member {proto.Message.IAppStateFatalExceptionNotification|null|undefined} appStateFatalExceptionNotification
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.appStateFatalExceptionNotification = null;

            /**
             * ProtocolMessage disappearingMode.
             * @member {proto.IDisappearingMode|null|undefined} disappearingMode
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.disappearingMode = null;

            /**
             * ProtocolMessage editedMessage.
             * @member {proto.IMessage|null|undefined} editedMessage
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.editedMessage = null;

            /**
             * ProtocolMessage timestampMs.
             * @member {number|Long} timestampMs
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ProtocolMessage peerDataOperationRequestMessage.
             * @member {proto.Message.IPeerDataOperationRequestMessage|null|undefined} peerDataOperationRequestMessage
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.peerDataOperationRequestMessage = null;

            /**
             * ProtocolMessage peerDataOperationRequestResponseMessage.
             * @member {proto.Message.IPeerDataOperationRequestResponseMessage|null|undefined} peerDataOperationRequestResponseMessage
             * @memberof proto.Message.ProtocolMessage
             * @instance
             */
            ProtocolMessage.prototype.peerDataOperationRequestResponseMessage = null;

            /**
             * Creates a new ProtocolMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ProtocolMessage
             * @static
             * @param {proto.Message.IProtocolMessage=} [properties] Properties to set
             * @returns {proto.Message.ProtocolMessage} ProtocolMessage instance
             */
            ProtocolMessage.create = function create(properties) {
                return new ProtocolMessage(properties);
            };

            /**
             * Encodes the specified ProtocolMessage message. Does not implicitly {@link proto.Message.ProtocolMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ProtocolMessage
             * @static
             * @param {proto.Message.IProtocolMessage} message ProtocolMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtocolMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.ephemeralExpiration != null && Object.hasOwnProperty.call(message, "ephemeralExpiration"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.ephemeralExpiration);
                if (message.ephemeralSettingTimestamp != null && Object.hasOwnProperty.call(message, "ephemeralSettingTimestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.ephemeralSettingTimestamp);
                if (message.historySyncNotification != null && Object.hasOwnProperty.call(message, "historySyncNotification"))
                    $root.proto.Message.HistorySyncNotification.encode(message.historySyncNotification, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.appStateSyncKeyShare != null && Object.hasOwnProperty.call(message, "appStateSyncKeyShare"))
                    $root.proto.Message.AppStateSyncKeyShare.encode(message.appStateSyncKeyShare, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.appStateSyncKeyRequest != null && Object.hasOwnProperty.call(message, "appStateSyncKeyRequest"))
                    $root.proto.Message.AppStateSyncKeyRequest.encode(message.appStateSyncKeyRequest, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.initialSecurityNotificationSettingSync != null && Object.hasOwnProperty.call(message, "initialSecurityNotificationSettingSync"))
                    $root.proto.Message.InitialSecurityNotificationSettingSync.encode(message.initialSecurityNotificationSettingSync, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.appStateFatalExceptionNotification != null && Object.hasOwnProperty.call(message, "appStateFatalExceptionNotification"))
                    $root.proto.Message.AppStateFatalExceptionNotification.encode(message.appStateFatalExceptionNotification, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.disappearingMode != null && Object.hasOwnProperty.call(message, "disappearingMode"))
                    $root.proto.DisappearingMode.encode(message.disappearingMode, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.editedMessage != null && Object.hasOwnProperty.call(message, "editedMessage"))
                    $root.proto.Message.encode(message.editedMessage, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int64(message.timestampMs);
                if (message.peerDataOperationRequestMessage != null && Object.hasOwnProperty.call(message, "peerDataOperationRequestMessage"))
                    $root.proto.Message.PeerDataOperationRequestMessage.encode(message.peerDataOperationRequestMessage, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.peerDataOperationRequestResponseMessage != null && Object.hasOwnProperty.call(message, "peerDataOperationRequestResponseMessage"))
                    $root.proto.Message.PeerDataOperationRequestResponseMessage.encode(message.peerDataOperationRequestResponseMessage, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ProtocolMessage message, length delimited. Does not implicitly {@link proto.Message.ProtocolMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ProtocolMessage
             * @static
             * @param {proto.Message.IProtocolMessage} message ProtocolMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtocolMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtocolMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ProtocolMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ProtocolMessage} ProtocolMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtocolMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ProtocolMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.ephemeralExpiration = reader.uint32();
                        break;
                    case 5:
                        message.ephemeralSettingTimestamp = reader.int64();
                        break;
                    case 6:
                        message.historySyncNotification = $root.proto.Message.HistorySyncNotification.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.appStateSyncKeyShare = $root.proto.Message.AppStateSyncKeyShare.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.appStateSyncKeyRequest = $root.proto.Message.AppStateSyncKeyRequest.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.initialSecurityNotificationSettingSync = $root.proto.Message.InitialSecurityNotificationSettingSync.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.appStateFatalExceptionNotification = $root.proto.Message.AppStateFatalExceptionNotification.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.disappearingMode = $root.proto.DisappearingMode.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.editedMessage = $root.proto.Message.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.timestampMs = reader.int64();
                        break;
                    case 16:
                        message.peerDataOperationRequestMessage = $root.proto.Message.PeerDataOperationRequestMessage.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.peerDataOperationRequestResponseMessage = $root.proto.Message.PeerDataOperationRequestResponseMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtocolMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ProtocolMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ProtocolMessage} ProtocolMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtocolMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtocolMessage message.
             * @function verify
             * @memberof proto.Message.ProtocolMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtocolMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key")) {
                    var error = $root.proto.MessageKey.verify(message.key);
                    if (error)
                        return "key." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 14:
                    case 16:
                    case 17:
                        break;
                    }
                if (message.ephemeralExpiration != null && message.hasOwnProperty("ephemeralExpiration"))
                    if (!$util.isInteger(message.ephemeralExpiration))
                        return "ephemeralExpiration: integer expected";
                if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                    if (!$util.isInteger(message.ephemeralSettingTimestamp) && !(message.ephemeralSettingTimestamp && $util.isInteger(message.ephemeralSettingTimestamp.low) && $util.isInteger(message.ephemeralSettingTimestamp.high)))
                        return "ephemeralSettingTimestamp: integer|Long expected";
                if (message.historySyncNotification != null && message.hasOwnProperty("historySyncNotification")) {
                    var error = $root.proto.Message.HistorySyncNotification.verify(message.historySyncNotification);
                    if (error)
                        return "historySyncNotification." + error;
                }
                if (message.appStateSyncKeyShare != null && message.hasOwnProperty("appStateSyncKeyShare")) {
                    var error = $root.proto.Message.AppStateSyncKeyShare.verify(message.appStateSyncKeyShare);
                    if (error)
                        return "appStateSyncKeyShare." + error;
                }
                if (message.appStateSyncKeyRequest != null && message.hasOwnProperty("appStateSyncKeyRequest")) {
                    var error = $root.proto.Message.AppStateSyncKeyRequest.verify(message.appStateSyncKeyRequest);
                    if (error)
                        return "appStateSyncKeyRequest." + error;
                }
                if (message.initialSecurityNotificationSettingSync != null && message.hasOwnProperty("initialSecurityNotificationSettingSync")) {
                    var error = $root.proto.Message.InitialSecurityNotificationSettingSync.verify(message.initialSecurityNotificationSettingSync);
                    if (error)
                        return "initialSecurityNotificationSettingSync." + error;
                }
                if (message.appStateFatalExceptionNotification != null && message.hasOwnProperty("appStateFatalExceptionNotification")) {
                    var error = $root.proto.Message.AppStateFatalExceptionNotification.verify(message.appStateFatalExceptionNotification);
                    if (error)
                        return "appStateFatalExceptionNotification." + error;
                }
                if (message.disappearingMode != null && message.hasOwnProperty("disappearingMode")) {
                    var error = $root.proto.DisappearingMode.verify(message.disappearingMode);
                    if (error)
                        return "disappearingMode." + error;
                }
                if (message.editedMessage != null && message.hasOwnProperty("editedMessage")) {
                    var error = $root.proto.Message.verify(message.editedMessage);
                    if (error)
                        return "editedMessage." + error;
                }
                if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                    if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                        return "timestampMs: integer|Long expected";
                if (message.peerDataOperationRequestMessage != null && message.hasOwnProperty("peerDataOperationRequestMessage")) {
                    var error = $root.proto.Message.PeerDataOperationRequestMessage.verify(message.peerDataOperationRequestMessage);
                    if (error)
                        return "peerDataOperationRequestMessage." + error;
                }
                if (message.peerDataOperationRequestResponseMessage != null && message.hasOwnProperty("peerDataOperationRequestResponseMessage")) {
                    var error = $root.proto.Message.PeerDataOperationRequestResponseMessage.verify(message.peerDataOperationRequestResponseMessage);
                    if (error)
                        return "peerDataOperationRequestResponseMessage." + error;
                }
                return null;
            };

            /**
             * Creates a ProtocolMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ProtocolMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ProtocolMessage} ProtocolMessage
             */
            ProtocolMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ProtocolMessage)
                    return object;
                var message = new $root.proto.Message.ProtocolMessage();
                if (object.key != null) {
                    if (typeof object.key !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.key: object expected");
                    message.key = $root.proto.MessageKey.fromObject(object.key);
                }
                switch (object.type) {
                case "REVOKE":
                case 0:
                    message.type = 0;
                    break;
                case "EPHEMERAL_SETTING":
                case 3:
                    message.type = 3;
                    break;
                case "EPHEMERAL_SYNC_RESPONSE":
                case 4:
                    message.type = 4;
                    break;
                case "HISTORY_SYNC_NOTIFICATION":
                case 5:
                    message.type = 5;
                    break;
                case "APP_STATE_SYNC_KEY_SHARE":
                case 6:
                    message.type = 6;
                    break;
                case "APP_STATE_SYNC_KEY_REQUEST":
                case 7:
                    message.type = 7;
                    break;
                case "MSG_FANOUT_BACKFILL_REQUEST":
                case 8:
                    message.type = 8;
                    break;
                case "INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC":
                case 9:
                    message.type = 9;
                    break;
                case "APP_STATE_FATAL_EXCEPTION_NOTIFICATION":
                case 10:
                    message.type = 10;
                    break;
                case "SHARE_PHONE_NUMBER":
                case 11:
                    message.type = 11;
                    break;
                case "MESSAGE_EDIT":
                case 14:
                    message.type = 14;
                    break;
                case "PEER_DATA_OPERATION_REQUEST_MESSAGE":
                case 16:
                    message.type = 16;
                    break;
                case "PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE":
                case 17:
                    message.type = 17;
                    break;
                }
                if (object.ephemeralExpiration != null)
                    message.ephemeralExpiration = object.ephemeralExpiration >>> 0;
                if (object.ephemeralSettingTimestamp != null)
                    if ($util.Long)
                        (message.ephemeralSettingTimestamp = $util.Long.fromValue(object.ephemeralSettingTimestamp)).unsigned = false;
                    else if (typeof object.ephemeralSettingTimestamp === "string")
                        message.ephemeralSettingTimestamp = parseInt(object.ephemeralSettingTimestamp, 10);
                    else if (typeof object.ephemeralSettingTimestamp === "number")
                        message.ephemeralSettingTimestamp = object.ephemeralSettingTimestamp;
                    else if (typeof object.ephemeralSettingTimestamp === "object")
                        message.ephemeralSettingTimestamp = new $util.LongBits(object.ephemeralSettingTimestamp.low >>> 0, object.ephemeralSettingTimestamp.high >>> 0).toNumber();
                if (object.historySyncNotification != null) {
                    if (typeof object.historySyncNotification !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.historySyncNotification: object expected");
                    message.historySyncNotification = $root.proto.Message.HistorySyncNotification.fromObject(object.historySyncNotification);
                }
                if (object.appStateSyncKeyShare != null) {
                    if (typeof object.appStateSyncKeyShare !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.appStateSyncKeyShare: object expected");
                    message.appStateSyncKeyShare = $root.proto.Message.AppStateSyncKeyShare.fromObject(object.appStateSyncKeyShare);
                }
                if (object.appStateSyncKeyRequest != null) {
                    if (typeof object.appStateSyncKeyRequest !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.appStateSyncKeyRequest: object expected");
                    message.appStateSyncKeyRequest = $root.proto.Message.AppStateSyncKeyRequest.fromObject(object.appStateSyncKeyRequest);
                }
                if (object.initialSecurityNotificationSettingSync != null) {
                    if (typeof object.initialSecurityNotificationSettingSync !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.initialSecurityNotificationSettingSync: object expected");
                    message.initialSecurityNotificationSettingSync = $root.proto.Message.InitialSecurityNotificationSettingSync.fromObject(object.initialSecurityNotificationSettingSync);
                }
                if (object.appStateFatalExceptionNotification != null) {
                    if (typeof object.appStateFatalExceptionNotification !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.appStateFatalExceptionNotification: object expected");
                    message.appStateFatalExceptionNotification = $root.proto.Message.AppStateFatalExceptionNotification.fromObject(object.appStateFatalExceptionNotification);
                }
                if (object.disappearingMode != null) {
                    if (typeof object.disappearingMode !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.disappearingMode: object expected");
                    message.disappearingMode = $root.proto.DisappearingMode.fromObject(object.disappearingMode);
                }
                if (object.editedMessage != null) {
                    if (typeof object.editedMessage !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.editedMessage: object expected");
                    message.editedMessage = $root.proto.Message.fromObject(object.editedMessage);
                }
                if (object.timestampMs != null)
                    if ($util.Long)
                        (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                    else if (typeof object.timestampMs === "string")
                        message.timestampMs = parseInt(object.timestampMs, 10);
                    else if (typeof object.timestampMs === "number")
                        message.timestampMs = object.timestampMs;
                    else if (typeof object.timestampMs === "object")
                        message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
                if (object.peerDataOperationRequestMessage != null) {
                    if (typeof object.peerDataOperationRequestMessage !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.peerDataOperationRequestMessage: object expected");
                    message.peerDataOperationRequestMessage = $root.proto.Message.PeerDataOperationRequestMessage.fromObject(object.peerDataOperationRequestMessage);
                }
                if (object.peerDataOperationRequestResponseMessage != null) {
                    if (typeof object.peerDataOperationRequestResponseMessage !== "object")
                        throw TypeError(".proto.Message.ProtocolMessage.peerDataOperationRequestResponseMessage: object expected");
                    message.peerDataOperationRequestResponseMessage = $root.proto.Message.PeerDataOperationRequestResponseMessage.fromObject(object.peerDataOperationRequestResponseMessage);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProtocolMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ProtocolMessage
             * @static
             * @param {proto.Message.ProtocolMessage} message ProtocolMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtocolMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = null;
                    object.type = options.enums === String ? "REVOKE" : 0;
                    object.ephemeralExpiration = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ephemeralSettingTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ephemeralSettingTimestamp = options.longs === String ? "0" : 0;
                    object.historySyncNotification = null;
                    object.appStateSyncKeyShare = null;
                    object.appStateSyncKeyRequest = null;
                    object.initialSecurityNotificationSettingSync = null;
                    object.appStateFatalExceptionNotification = null;
                    object.disappearingMode = null;
                    object.editedMessage = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestampMs = options.longs === String ? "0" : 0;
                    object.peerDataOperationRequestMessage = null;
                    object.peerDataOperationRequestResponseMessage = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = $root.proto.MessageKey.toObject(message.key, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.proto.Message.ProtocolMessage.Type[message.type] : message.type;
                if (message.ephemeralExpiration != null && message.hasOwnProperty("ephemeralExpiration"))
                    object.ephemeralExpiration = message.ephemeralExpiration;
                if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                    if (typeof message.ephemeralSettingTimestamp === "number")
                        object.ephemeralSettingTimestamp = options.longs === String ? String(message.ephemeralSettingTimestamp) : message.ephemeralSettingTimestamp;
                    else
                        object.ephemeralSettingTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.ephemeralSettingTimestamp) : options.longs === Number ? new $util.LongBits(message.ephemeralSettingTimestamp.low >>> 0, message.ephemeralSettingTimestamp.high >>> 0).toNumber() : message.ephemeralSettingTimestamp;
                if (message.historySyncNotification != null && message.hasOwnProperty("historySyncNotification"))
                    object.historySyncNotification = $root.proto.Message.HistorySyncNotification.toObject(message.historySyncNotification, options);
                if (message.appStateSyncKeyShare != null && message.hasOwnProperty("appStateSyncKeyShare"))
                    object.appStateSyncKeyShare = $root.proto.Message.AppStateSyncKeyShare.toObject(message.appStateSyncKeyShare, options);
                if (message.appStateSyncKeyRequest != null && message.hasOwnProperty("appStateSyncKeyRequest"))
                    object.appStateSyncKeyRequest = $root.proto.Message.AppStateSyncKeyRequest.toObject(message.appStateSyncKeyRequest, options);
                if (message.initialSecurityNotificationSettingSync != null && message.hasOwnProperty("initialSecurityNotificationSettingSync"))
                    object.initialSecurityNotificationSettingSync = $root.proto.Message.InitialSecurityNotificationSettingSync.toObject(message.initialSecurityNotificationSettingSync, options);
                if (message.appStateFatalExceptionNotification != null && message.hasOwnProperty("appStateFatalExceptionNotification"))
                    object.appStateFatalExceptionNotification = $root.proto.Message.AppStateFatalExceptionNotification.toObject(message.appStateFatalExceptionNotification, options);
                if (message.disappearingMode != null && message.hasOwnProperty("disappearingMode"))
                    object.disappearingMode = $root.proto.DisappearingMode.toObject(message.disappearingMode, options);
                if (message.editedMessage != null && message.hasOwnProperty("editedMessage"))
                    object.editedMessage = $root.proto.Message.toObject(message.editedMessage, options);
                if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                    if (typeof message.timestampMs === "number")
                        object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                    else
                        object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
                if (message.peerDataOperationRequestMessage != null && message.hasOwnProperty("peerDataOperationRequestMessage"))
                    object.peerDataOperationRequestMessage = $root.proto.Message.PeerDataOperationRequestMessage.toObject(message.peerDataOperationRequestMessage, options);
                if (message.peerDataOperationRequestResponseMessage != null && message.hasOwnProperty("peerDataOperationRequestResponseMessage"))
                    object.peerDataOperationRequestResponseMessage = $root.proto.Message.PeerDataOperationRequestResponseMessage.toObject(message.peerDataOperationRequestResponseMessage, options);
                return object;
            };

            /**
             * Converts this ProtocolMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ProtocolMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtocolMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name proto.Message.ProtocolMessage.Type
             * @enum {number}
             * @property {number} REVOKE=0 REVOKE value
             * @property {number} EPHEMERAL_SETTING=3 EPHEMERAL_SETTING value
             * @property {number} EPHEMERAL_SYNC_RESPONSE=4 EPHEMERAL_SYNC_RESPONSE value
             * @property {number} HISTORY_SYNC_NOTIFICATION=5 HISTORY_SYNC_NOTIFICATION value
             * @property {number} APP_STATE_SYNC_KEY_SHARE=6 APP_STATE_SYNC_KEY_SHARE value
             * @property {number} APP_STATE_SYNC_KEY_REQUEST=7 APP_STATE_SYNC_KEY_REQUEST value
             * @property {number} MSG_FANOUT_BACKFILL_REQUEST=8 MSG_FANOUT_BACKFILL_REQUEST value
             * @property {number} INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC=9 INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC value
             * @property {number} APP_STATE_FATAL_EXCEPTION_NOTIFICATION=10 APP_STATE_FATAL_EXCEPTION_NOTIFICATION value
             * @property {number} SHARE_PHONE_NUMBER=11 SHARE_PHONE_NUMBER value
             * @property {number} MESSAGE_EDIT=14 MESSAGE_EDIT value
             * @property {number} PEER_DATA_OPERATION_REQUEST_MESSAGE=16 PEER_DATA_OPERATION_REQUEST_MESSAGE value
             * @property {number} PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE=17 PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE value
             */
            ProtocolMessage.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "REVOKE"] = 0;
                values[valuesById[3] = "EPHEMERAL_SETTING"] = 3;
                values[valuesById[4] = "EPHEMERAL_SYNC_RESPONSE"] = 4;
                values[valuesById[5] = "HISTORY_SYNC_NOTIFICATION"] = 5;
                values[valuesById[6] = "APP_STATE_SYNC_KEY_SHARE"] = 6;
                values[valuesById[7] = "APP_STATE_SYNC_KEY_REQUEST"] = 7;
                values[valuesById[8] = "MSG_FANOUT_BACKFILL_REQUEST"] = 8;
                values[valuesById[9] = "INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC"] = 9;
                values[valuesById[10] = "APP_STATE_FATAL_EXCEPTION_NOTIFICATION"] = 10;
                values[valuesById[11] = "SHARE_PHONE_NUMBER"] = 11;
                values[valuesById[14] = "MESSAGE_EDIT"] = 14;
                values[valuesById[16] = "PEER_DATA_OPERATION_REQUEST_MESSAGE"] = 16;
                values[valuesById[17] = "PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE"] = 17;
                return values;
            })();

            return ProtocolMessage;
        })();

        Message.ReactionMessage = (function() {

            /**
             * Properties of a ReactionMessage.
             * @memberof proto.Message
             * @interface IReactionMessage
             * @property {proto.IMessageKey|null} [key] ReactionMessage key
             * @property {string|null} [text] ReactionMessage text
             * @property {string|null} [groupingKey] ReactionMessage groupingKey
             * @property {number|Long|null} [senderTimestampMs] ReactionMessage senderTimestampMs
             */

            /**
             * Constructs a new ReactionMessage.
             * @memberof proto.Message
             * @classdesc Represents a ReactionMessage.
             * @implements IReactionMessage
             * @constructor
             * @param {proto.Message.IReactionMessage=} [properties] Properties to set
             */
            function ReactionMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReactionMessage key.
             * @member {proto.IMessageKey|null|undefined} key
             * @memberof proto.Message.ReactionMessage
             * @instance
             */
            ReactionMessage.prototype.key = null;

            /**
             * ReactionMessage text.
             * @member {string} text
             * @memberof proto.Message.ReactionMessage
             * @instance
             */
            ReactionMessage.prototype.text = "";

            /**
             * ReactionMessage groupingKey.
             * @member {string} groupingKey
             * @memberof proto.Message.ReactionMessage
             * @instance
             */
            ReactionMessage.prototype.groupingKey = "";

            /**
             * ReactionMessage senderTimestampMs.
             * @member {number|Long} senderTimestampMs
             * @memberof proto.Message.ReactionMessage
             * @instance
             */
            ReactionMessage.prototype.senderTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ReactionMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.ReactionMessage
             * @static
             * @param {proto.Message.IReactionMessage=} [properties] Properties to set
             * @returns {proto.Message.ReactionMessage} ReactionMessage instance
             */
            ReactionMessage.create = function create(properties) {
                return new ReactionMessage(properties);
            };

            /**
             * Encodes the specified ReactionMessage message. Does not implicitly {@link proto.Message.ReactionMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.ReactionMessage
             * @static
             * @param {proto.Message.IReactionMessage} message ReactionMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactionMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                if (message.groupingKey != null && Object.hasOwnProperty.call(message, "groupingKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.groupingKey);
                if (message.senderTimestampMs != null && Object.hasOwnProperty.call(message, "senderTimestampMs"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.senderTimestampMs);
                return writer;
            };

            /**
             * Encodes the specified ReactionMessage message, length delimited. Does not implicitly {@link proto.Message.ReactionMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.ReactionMessage
             * @static
             * @param {proto.Message.IReactionMessage} message ReactionMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactionMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReactionMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.ReactionMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.ReactionMessage} ReactionMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactionMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.ReactionMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.text = reader.string();
                        break;
                    case 3:
                        message.groupingKey = reader.string();
                        break;
                    case 4:
                        message.senderTimestampMs = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReactionMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.ReactionMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.ReactionMessage} ReactionMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactionMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReactionMessage message.
             * @function verify
             * @memberof proto.Message.ReactionMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReactionMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key")) {
                    var error = $root.proto.MessageKey.verify(message.key);
                    if (error)
                        return "key." + error;
                }
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                if (message.groupingKey != null && message.hasOwnProperty("groupingKey"))
                    if (!$util.isString(message.groupingKey))
                        return "groupingKey: string expected";
                if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                    if (!$util.isInteger(message.senderTimestampMs) && !(message.senderTimestampMs && $util.isInteger(message.senderTimestampMs.low) && $util.isInteger(message.senderTimestampMs.high)))
                        return "senderTimestampMs: integer|Long expected";
                return null;
            };

            /**
             * Creates a ReactionMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.ReactionMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.ReactionMessage} ReactionMessage
             */
            ReactionMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.ReactionMessage)
                    return object;
                var message = new $root.proto.Message.ReactionMessage();
                if (object.key != null) {
                    if (typeof object.key !== "object")
                        throw TypeError(".proto.Message.ReactionMessage.key: object expected");
                    message.key = $root.proto.MessageKey.fromObject(object.key);
                }
                if (object.text != null)
                    message.text = String(object.text);
                if (object.groupingKey != null)
                    message.groupingKey = String(object.groupingKey);
                if (object.senderTimestampMs != null)
                    if ($util.Long)
                        (message.senderTimestampMs = $util.Long.fromValue(object.senderTimestampMs)).unsigned = false;
                    else if (typeof object.senderTimestampMs === "string")
                        message.senderTimestampMs = parseInt(object.senderTimestampMs, 10);
                    else if (typeof object.senderTimestampMs === "number")
                        message.senderTimestampMs = object.senderTimestampMs;
                    else if (typeof object.senderTimestampMs === "object")
                        message.senderTimestampMs = new $util.LongBits(object.senderTimestampMs.low >>> 0, object.senderTimestampMs.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ReactionMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.ReactionMessage
             * @static
             * @param {proto.Message.ReactionMessage} message ReactionMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReactionMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = null;
                    object.text = "";
                    object.groupingKey = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.senderTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.senderTimestampMs = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = $root.proto.MessageKey.toObject(message.key, options);
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                if (message.groupingKey != null && message.hasOwnProperty("groupingKey"))
                    object.groupingKey = message.groupingKey;
                if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                    if (typeof message.senderTimestampMs === "number")
                        object.senderTimestampMs = options.longs === String ? String(message.senderTimestampMs) : message.senderTimestampMs;
                    else
                        object.senderTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.senderTimestampMs) : options.longs === Number ? new $util.LongBits(message.senderTimestampMs.low >>> 0, message.senderTimestampMs.high >>> 0).toNumber() : message.senderTimestampMs;
                return object;
            };

            /**
             * Converts this ReactionMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.ReactionMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReactionMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReactionMessage;
        })();

        Message.RequestPaymentMessage = (function() {

            /**
             * Properties of a RequestPaymentMessage.
             * @memberof proto.Message
             * @interface IRequestPaymentMessage
             * @property {proto.IMessage|null} [noteMessage] RequestPaymentMessage noteMessage
             * @property {string|null} [currencyCodeIso4217] RequestPaymentMessage currencyCodeIso4217
             * @property {number|Long|null} [amount1000] RequestPaymentMessage amount1000
             * @property {string|null} [requestFrom] RequestPaymentMessage requestFrom
             * @property {number|Long|null} [expiryTimestamp] RequestPaymentMessage expiryTimestamp
             * @property {proto.IMoney|null} [amount] RequestPaymentMessage amount
             * @property {proto.IPaymentBackground|null} [background] RequestPaymentMessage background
             */

            /**
             * Constructs a new RequestPaymentMessage.
             * @memberof proto.Message
             * @classdesc Represents a RequestPaymentMessage.
             * @implements IRequestPaymentMessage
             * @constructor
             * @param {proto.Message.IRequestPaymentMessage=} [properties] Properties to set
             */
            function RequestPaymentMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestPaymentMessage noteMessage.
             * @member {proto.IMessage|null|undefined} noteMessage
             * @memberof proto.Message.RequestPaymentMessage
             * @instance
             */
            RequestPaymentMessage.prototype.noteMessage = null;

            /**
             * RequestPaymentMessage currencyCodeIso4217.
             * @member {string} currencyCodeIso4217
             * @memberof proto.Message.RequestPaymentMessage
             * @instance
             */
            RequestPaymentMessage.prototype.currencyCodeIso4217 = "";

            /**
             * RequestPaymentMessage amount1000.
             * @member {number|Long} amount1000
             * @memberof proto.Message.RequestPaymentMessage
             * @instance
             */
            RequestPaymentMessage.prototype.amount1000 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RequestPaymentMessage requestFrom.
             * @member {string} requestFrom
             * @memberof proto.Message.RequestPaymentMessage
             * @instance
             */
            RequestPaymentMessage.prototype.requestFrom = "";

            /**
             * RequestPaymentMessage expiryTimestamp.
             * @member {number|Long} expiryTimestamp
             * @memberof proto.Message.RequestPaymentMessage
             * @instance
             */
            RequestPaymentMessage.prototype.expiryTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RequestPaymentMessage amount.
             * @member {proto.IMoney|null|undefined} amount
             * @memberof proto.Message.RequestPaymentMessage
             * @instance
             */
            RequestPaymentMessage.prototype.amount = null;

            /**
             * RequestPaymentMessage background.
             * @member {proto.IPaymentBackground|null|undefined} background
             * @memberof proto.Message.RequestPaymentMessage
             * @instance
             */
            RequestPaymentMessage.prototype.background = null;

            /**
             * Creates a new RequestPaymentMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.RequestPaymentMessage
             * @static
             * @param {proto.Message.IRequestPaymentMessage=} [properties] Properties to set
             * @returns {proto.Message.RequestPaymentMessage} RequestPaymentMessage instance
             */
            RequestPaymentMessage.create = function create(properties) {
                return new RequestPaymentMessage(properties);
            };

            /**
             * Encodes the specified RequestPaymentMessage message. Does not implicitly {@link proto.Message.RequestPaymentMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.RequestPaymentMessage
             * @static
             * @param {proto.Message.IRequestPaymentMessage} message RequestPaymentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPaymentMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.currencyCodeIso4217 != null && Object.hasOwnProperty.call(message, "currencyCodeIso4217"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.currencyCodeIso4217);
                if (message.amount1000 != null && Object.hasOwnProperty.call(message, "amount1000"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount1000);
                if (message.requestFrom != null && Object.hasOwnProperty.call(message, "requestFrom"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.requestFrom);
                if (message.noteMessage != null && Object.hasOwnProperty.call(message, "noteMessage"))
                    $root.proto.Message.encode(message.noteMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.expiryTimestamp != null && Object.hasOwnProperty.call(message, "expiryTimestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expiryTimestamp);
                if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                    $root.proto.Money.encode(message.amount, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                    $root.proto.PaymentBackground.encode(message.background, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RequestPaymentMessage message, length delimited. Does not implicitly {@link proto.Message.RequestPaymentMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.RequestPaymentMessage
             * @static
             * @param {proto.Message.IRequestPaymentMessage} message RequestPaymentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPaymentMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestPaymentMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.RequestPaymentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.RequestPaymentMessage} RequestPaymentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPaymentMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.RequestPaymentMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 4:
                        message.noteMessage = $root.proto.Message.decode(reader, reader.uint32());
                        break;
                    case 1:
                        message.currencyCodeIso4217 = reader.string();
                        break;
                    case 2:
                        message.amount1000 = reader.uint64();
                        break;
                    case 3:
                        message.requestFrom = reader.string();
                        break;
                    case 5:
                        message.expiryTimestamp = reader.int64();
                        break;
                    case 6:
                        message.amount = $root.proto.Money.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.background = $root.proto.PaymentBackground.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestPaymentMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.RequestPaymentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.RequestPaymentMessage} RequestPaymentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPaymentMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestPaymentMessage message.
             * @function verify
             * @memberof proto.Message.RequestPaymentMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestPaymentMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.noteMessage != null && message.hasOwnProperty("noteMessage")) {
                    var error = $root.proto.Message.verify(message.noteMessage);
                    if (error)
                        return "noteMessage." + error;
                }
                if (message.currencyCodeIso4217 != null && message.hasOwnProperty("currencyCodeIso4217"))
                    if (!$util.isString(message.currencyCodeIso4217))
                        return "currencyCodeIso4217: string expected";
                if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                    if (!$util.isInteger(message.amount1000) && !(message.amount1000 && $util.isInteger(message.amount1000.low) && $util.isInteger(message.amount1000.high)))
                        return "amount1000: integer|Long expected";
                if (message.requestFrom != null && message.hasOwnProperty("requestFrom"))
                    if (!$util.isString(message.requestFrom))
                        return "requestFrom: string expected";
                if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                    if (!$util.isInteger(message.expiryTimestamp) && !(message.expiryTimestamp && $util.isInteger(message.expiryTimestamp.low) && $util.isInteger(message.expiryTimestamp.high)))
                        return "expiryTimestamp: integer|Long expected";
                if (message.amount != null && message.hasOwnProperty("amount")) {
                    var error = $root.proto.Money.verify(message.amount);
                    if (error)
                        return "amount." + error;
                }
                if (message.background != null && message.hasOwnProperty("background")) {
                    var error = $root.proto.PaymentBackground.verify(message.background);
                    if (error)
                        return "background." + error;
                }
                return null;
            };

            /**
             * Creates a RequestPaymentMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.RequestPaymentMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.RequestPaymentMessage} RequestPaymentMessage
             */
            RequestPaymentMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.RequestPaymentMessage)
                    return object;
                var message = new $root.proto.Message.RequestPaymentMessage();
                if (object.noteMessage != null) {
                    if (typeof object.noteMessage !== "object")
                        throw TypeError(".proto.Message.RequestPaymentMessage.noteMessage: object expected");
                    message.noteMessage = $root.proto.Message.fromObject(object.noteMessage);
                }
                if (object.currencyCodeIso4217 != null)
                    message.currencyCodeIso4217 = String(object.currencyCodeIso4217);
                if (object.amount1000 != null)
                    if ($util.Long)
                        (message.amount1000 = $util.Long.fromValue(object.amount1000)).unsigned = true;
                    else if (typeof object.amount1000 === "string")
                        message.amount1000 = parseInt(object.amount1000, 10);
                    else if (typeof object.amount1000 === "number")
                        message.amount1000 = object.amount1000;
                    else if (typeof object.amount1000 === "object")
                        message.amount1000 = new $util.LongBits(object.amount1000.low >>> 0, object.amount1000.high >>> 0).toNumber(true);
                if (object.requestFrom != null)
                    message.requestFrom = String(object.requestFrom);
                if (object.expiryTimestamp != null)
                    if ($util.Long)
                        (message.expiryTimestamp = $util.Long.fromValue(object.expiryTimestamp)).unsigned = false;
                    else if (typeof object.expiryTimestamp === "string")
                        message.expiryTimestamp = parseInt(object.expiryTimestamp, 10);
                    else if (typeof object.expiryTimestamp === "number")
                        message.expiryTimestamp = object.expiryTimestamp;
                    else if (typeof object.expiryTimestamp === "object")
                        message.expiryTimestamp = new $util.LongBits(object.expiryTimestamp.low >>> 0, object.expiryTimestamp.high >>> 0).toNumber();
                if (object.amount != null) {
                    if (typeof object.amount !== "object")
                        throw TypeError(".proto.Message.RequestPaymentMessage.amount: object expected");
                    message.amount = $root.proto.Money.fromObject(object.amount);
                }
                if (object.background != null) {
                    if (typeof object.background !== "object")
                        throw TypeError(".proto.Message.RequestPaymentMessage.background: object expected");
                    message.background = $root.proto.PaymentBackground.fromObject(object.background);
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestPaymentMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.RequestPaymentMessage
             * @static
             * @param {proto.Message.RequestPaymentMessage} message RequestPaymentMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestPaymentMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.currencyCodeIso4217 = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.amount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.amount1000 = options.longs === String ? "0" : 0;
                    object.requestFrom = "";
                    object.noteMessage = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expiryTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expiryTimestamp = options.longs === String ? "0" : 0;
                    object.amount = null;
                    object.background = null;
                }
                if (message.currencyCodeIso4217 != null && message.hasOwnProperty("currencyCodeIso4217"))
                    object.currencyCodeIso4217 = message.currencyCodeIso4217;
                if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                    if (typeof message.amount1000 === "number")
                        object.amount1000 = options.longs === String ? String(message.amount1000) : message.amount1000;
                    else
                        object.amount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.amount1000) : options.longs === Number ? new $util.LongBits(message.amount1000.low >>> 0, message.amount1000.high >>> 0).toNumber(true) : message.amount1000;
                if (message.requestFrom != null && message.hasOwnProperty("requestFrom"))
                    object.requestFrom = message.requestFrom;
                if (message.noteMessage != null && message.hasOwnProperty("noteMessage"))
                    object.noteMessage = $root.proto.Message.toObject(message.noteMessage, options);
                if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                    if (typeof message.expiryTimestamp === "number")
                        object.expiryTimestamp = options.longs === String ? String(message.expiryTimestamp) : message.expiryTimestamp;
                    else
                        object.expiryTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expiryTimestamp) : options.longs === Number ? new $util.LongBits(message.expiryTimestamp.low >>> 0, message.expiryTimestamp.high >>> 0).toNumber() : message.expiryTimestamp;
                if (message.amount != null && message.hasOwnProperty("amount"))
                    object.amount = $root.proto.Money.toObject(message.amount, options);
                if (message.background != null && message.hasOwnProperty("background"))
                    object.background = $root.proto.PaymentBackground.toObject(message.background, options);
                return object;
            };

            /**
             * Converts this RequestPaymentMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.RequestPaymentMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestPaymentMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RequestPaymentMessage;
        })();

        Message.RequestPhoneNumberMessage = (function() {

            /**
             * Properties of a RequestPhoneNumberMessage.
             * @memberof proto.Message
             * @interface IRequestPhoneNumberMessage
             * @property {proto.IContextInfo|null} [contextInfo] RequestPhoneNumberMessage contextInfo
             */

            /**
             * Constructs a new RequestPhoneNumberMessage.
             * @memberof proto.Message
             * @classdesc Represents a RequestPhoneNumberMessage.
             * @implements IRequestPhoneNumberMessage
             * @constructor
             * @param {proto.Message.IRequestPhoneNumberMessage=} [properties] Properties to set
             */
            function RequestPhoneNumberMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestPhoneNumberMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @instance
             */
            RequestPhoneNumberMessage.prototype.contextInfo = null;

            /**
             * Creates a new RequestPhoneNumberMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @static
             * @param {proto.Message.IRequestPhoneNumberMessage=} [properties] Properties to set
             * @returns {proto.Message.RequestPhoneNumberMessage} RequestPhoneNumberMessage instance
             */
            RequestPhoneNumberMessage.create = function create(properties) {
                return new RequestPhoneNumberMessage(properties);
            };

            /**
             * Encodes the specified RequestPhoneNumberMessage message. Does not implicitly {@link proto.Message.RequestPhoneNumberMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @static
             * @param {proto.Message.IRequestPhoneNumberMessage} message RequestPhoneNumberMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPhoneNumberMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RequestPhoneNumberMessage message, length delimited. Does not implicitly {@link proto.Message.RequestPhoneNumberMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @static
             * @param {proto.Message.IRequestPhoneNumberMessage} message RequestPhoneNumberMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPhoneNumberMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestPhoneNumberMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.RequestPhoneNumberMessage} RequestPhoneNumberMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPhoneNumberMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.RequestPhoneNumberMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestPhoneNumberMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.RequestPhoneNumberMessage} RequestPhoneNumberMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPhoneNumberMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestPhoneNumberMessage message.
             * @function verify
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestPhoneNumberMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                return null;
            };

            /**
             * Creates a RequestPhoneNumberMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.RequestPhoneNumberMessage} RequestPhoneNumberMessage
             */
            RequestPhoneNumberMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.RequestPhoneNumberMessage)
                    return object;
                var message = new $root.proto.Message.RequestPhoneNumberMessage();
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.RequestPhoneNumberMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestPhoneNumberMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @static
             * @param {proto.Message.RequestPhoneNumberMessage} message RequestPhoneNumberMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestPhoneNumberMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.contextInfo = null;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                return object;
            };

            /**
             * Converts this RequestPhoneNumberMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.RequestPhoneNumberMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestPhoneNumberMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RequestPhoneNumberMessage;
        })();

        Message.SendPaymentMessage = (function() {

            /**
             * Properties of a SendPaymentMessage.
             * @memberof proto.Message
             * @interface ISendPaymentMessage
             * @property {proto.IMessage|null} [noteMessage] SendPaymentMessage noteMessage
             * @property {proto.IMessageKey|null} [requestMessageKey] SendPaymentMessage requestMessageKey
             * @property {proto.IPaymentBackground|null} [background] SendPaymentMessage background
             */

            /**
             * Constructs a new SendPaymentMessage.
             * @memberof proto.Message
             * @classdesc Represents a SendPaymentMessage.
             * @implements ISendPaymentMessage
             * @constructor
             * @param {proto.Message.ISendPaymentMessage=} [properties] Properties to set
             */
            function SendPaymentMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendPaymentMessage noteMessage.
             * @member {proto.IMessage|null|undefined} noteMessage
             * @memberof proto.Message.SendPaymentMessage
             * @instance
             */
            SendPaymentMessage.prototype.noteMessage = null;

            /**
             * SendPaymentMessage requestMessageKey.
             * @member {proto.IMessageKey|null|undefined} requestMessageKey
             * @memberof proto.Message.SendPaymentMessage
             * @instance
             */
            SendPaymentMessage.prototype.requestMessageKey = null;

            /**
             * SendPaymentMessage background.
             * @member {proto.IPaymentBackground|null|undefined} background
             * @memberof proto.Message.SendPaymentMessage
             * @instance
             */
            SendPaymentMessage.prototype.background = null;

            /**
             * Creates a new SendPaymentMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.SendPaymentMessage
             * @static
             * @param {proto.Message.ISendPaymentMessage=} [properties] Properties to set
             * @returns {proto.Message.SendPaymentMessage} SendPaymentMessage instance
             */
            SendPaymentMessage.create = function create(properties) {
                return new SendPaymentMessage(properties);
            };

            /**
             * Encodes the specified SendPaymentMessage message. Does not implicitly {@link proto.Message.SendPaymentMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.SendPaymentMessage
             * @static
             * @param {proto.Message.ISendPaymentMessage} message SendPaymentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPaymentMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.noteMessage != null && Object.hasOwnProperty.call(message, "noteMessage"))
                    $root.proto.Message.encode(message.noteMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.requestMessageKey != null && Object.hasOwnProperty.call(message, "requestMessageKey"))
                    $root.proto.MessageKey.encode(message.requestMessageKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                    $root.proto.PaymentBackground.encode(message.background, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SendPaymentMessage message, length delimited. Does not implicitly {@link proto.Message.SendPaymentMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.SendPaymentMessage
             * @static
             * @param {proto.Message.ISendPaymentMessage} message SendPaymentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPaymentMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendPaymentMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.SendPaymentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.SendPaymentMessage} SendPaymentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPaymentMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.SendPaymentMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.noteMessage = $root.proto.Message.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.requestMessageKey = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.background = $root.proto.PaymentBackground.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendPaymentMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.SendPaymentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.SendPaymentMessage} SendPaymentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPaymentMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendPaymentMessage message.
             * @function verify
             * @memberof proto.Message.SendPaymentMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendPaymentMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.noteMessage != null && message.hasOwnProperty("noteMessage")) {
                    var error = $root.proto.Message.verify(message.noteMessage);
                    if (error)
                        return "noteMessage." + error;
                }
                if (message.requestMessageKey != null && message.hasOwnProperty("requestMessageKey")) {
                    var error = $root.proto.MessageKey.verify(message.requestMessageKey);
                    if (error)
                        return "requestMessageKey." + error;
                }
                if (message.background != null && message.hasOwnProperty("background")) {
                    var error = $root.proto.PaymentBackground.verify(message.background);
                    if (error)
                        return "background." + error;
                }
                return null;
            };

            /**
             * Creates a SendPaymentMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.SendPaymentMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.SendPaymentMessage} SendPaymentMessage
             */
            SendPaymentMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.SendPaymentMessage)
                    return object;
                var message = new $root.proto.Message.SendPaymentMessage();
                if (object.noteMessage != null) {
                    if (typeof object.noteMessage !== "object")
                        throw TypeError(".proto.Message.SendPaymentMessage.noteMessage: object expected");
                    message.noteMessage = $root.proto.Message.fromObject(object.noteMessage);
                }
                if (object.requestMessageKey != null) {
                    if (typeof object.requestMessageKey !== "object")
                        throw TypeError(".proto.Message.SendPaymentMessage.requestMessageKey: object expected");
                    message.requestMessageKey = $root.proto.MessageKey.fromObject(object.requestMessageKey);
                }
                if (object.background != null) {
                    if (typeof object.background !== "object")
                        throw TypeError(".proto.Message.SendPaymentMessage.background: object expected");
                    message.background = $root.proto.PaymentBackground.fromObject(object.background);
                }
                return message;
            };

            /**
             * Creates a plain object from a SendPaymentMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.SendPaymentMessage
             * @static
             * @param {proto.Message.SendPaymentMessage} message SendPaymentMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendPaymentMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.noteMessage = null;
                    object.requestMessageKey = null;
                    object.background = null;
                }
                if (message.noteMessage != null && message.hasOwnProperty("noteMessage"))
                    object.noteMessage = $root.proto.Message.toObject(message.noteMessage, options);
                if (message.requestMessageKey != null && message.hasOwnProperty("requestMessageKey"))
                    object.requestMessageKey = $root.proto.MessageKey.toObject(message.requestMessageKey, options);
                if (message.background != null && message.hasOwnProperty("background"))
                    object.background = $root.proto.PaymentBackground.toObject(message.background, options);
                return object;
            };

            /**
             * Converts this SendPaymentMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.SendPaymentMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendPaymentMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SendPaymentMessage;
        })();

        Message.SenderKeyDistributionMessage = (function() {

            /**
             * Properties of a SenderKeyDistributionMessage.
             * @memberof proto.Message
             * @interface ISenderKeyDistributionMessage
             * @property {string|null} [groupId] SenderKeyDistributionMessage groupId
             * @property {Uint8Array|null} [axolotlSenderKeyDistributionMessage] SenderKeyDistributionMessage axolotlSenderKeyDistributionMessage
             */

            /**
             * Constructs a new SenderKeyDistributionMessage.
             * @memberof proto.Message
             * @classdesc Represents a SenderKeyDistributionMessage.
             * @implements ISenderKeyDistributionMessage
             * @constructor
             * @param {proto.Message.ISenderKeyDistributionMessage=} [properties] Properties to set
             */
            function SenderKeyDistributionMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SenderKeyDistributionMessage groupId.
             * @member {string} groupId
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @instance
             */
            SenderKeyDistributionMessage.prototype.groupId = "";

            /**
             * SenderKeyDistributionMessage axolotlSenderKeyDistributionMessage.
             * @member {Uint8Array} axolotlSenderKeyDistributionMessage
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @instance
             */
            SenderKeyDistributionMessage.prototype.axolotlSenderKeyDistributionMessage = $util.newBuffer([]);

            /**
             * Creates a new SenderKeyDistributionMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @static
             * @param {proto.Message.ISenderKeyDistributionMessage=} [properties] Properties to set
             * @returns {proto.Message.SenderKeyDistributionMessage} SenderKeyDistributionMessage instance
             */
            SenderKeyDistributionMessage.create = function create(properties) {
                return new SenderKeyDistributionMessage(properties);
            };

            /**
             * Encodes the specified SenderKeyDistributionMessage message. Does not implicitly {@link proto.Message.SenderKeyDistributionMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @static
             * @param {proto.Message.ISenderKeyDistributionMessage} message SenderKeyDistributionMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SenderKeyDistributionMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
                if (message.axolotlSenderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "axolotlSenderKeyDistributionMessage"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.axolotlSenderKeyDistributionMessage);
                return writer;
            };

            /**
             * Encodes the specified SenderKeyDistributionMessage message, length delimited. Does not implicitly {@link proto.Message.SenderKeyDistributionMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @static
             * @param {proto.Message.ISenderKeyDistributionMessage} message SenderKeyDistributionMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SenderKeyDistributionMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.SenderKeyDistributionMessage} SenderKeyDistributionMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SenderKeyDistributionMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.SenderKeyDistributionMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.groupId = reader.string();
                        break;
                    case 2:
                        message.axolotlSenderKeyDistributionMessage = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.SenderKeyDistributionMessage} SenderKeyDistributionMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SenderKeyDistributionMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SenderKeyDistributionMessage message.
             * @function verify
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SenderKeyDistributionMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isString(message.groupId))
                        return "groupId: string expected";
                if (message.axolotlSenderKeyDistributionMessage != null && message.hasOwnProperty("axolotlSenderKeyDistributionMessage"))
                    if (!(message.axolotlSenderKeyDistributionMessage && typeof message.axolotlSenderKeyDistributionMessage.length === "number" || $util.isString(message.axolotlSenderKeyDistributionMessage)))
                        return "axolotlSenderKeyDistributionMessage: buffer expected";
                return null;
            };

            /**
             * Creates a SenderKeyDistributionMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.SenderKeyDistributionMessage} SenderKeyDistributionMessage
             */
            SenderKeyDistributionMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.SenderKeyDistributionMessage)
                    return object;
                var message = new $root.proto.Message.SenderKeyDistributionMessage();
                if (object.groupId != null)
                    message.groupId = String(object.groupId);
                if (object.axolotlSenderKeyDistributionMessage != null)
                    if (typeof object.axolotlSenderKeyDistributionMessage === "string")
                        $util.base64.decode(object.axolotlSenderKeyDistributionMessage, message.axolotlSenderKeyDistributionMessage = $util.newBuffer($util.base64.length(object.axolotlSenderKeyDistributionMessage)), 0);
                    else if (object.axolotlSenderKeyDistributionMessage.length)
                        message.axolotlSenderKeyDistributionMessage = object.axolotlSenderKeyDistributionMessage;
                return message;
            };

            /**
             * Creates a plain object from a SenderKeyDistributionMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @static
             * @param {proto.Message.SenderKeyDistributionMessage} message SenderKeyDistributionMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SenderKeyDistributionMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.groupId = "";
                    if (options.bytes === String)
                        object.axolotlSenderKeyDistributionMessage = "";
                    else {
                        object.axolotlSenderKeyDistributionMessage = [];
                        if (options.bytes !== Array)
                            object.axolotlSenderKeyDistributionMessage = $util.newBuffer(object.axolotlSenderKeyDistributionMessage);
                    }
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    object.groupId = message.groupId;
                if (message.axolotlSenderKeyDistributionMessage != null && message.hasOwnProperty("axolotlSenderKeyDistributionMessage"))
                    object.axolotlSenderKeyDistributionMessage = options.bytes === String ? $util.base64.encode(message.axolotlSenderKeyDistributionMessage, 0, message.axolotlSenderKeyDistributionMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.axolotlSenderKeyDistributionMessage) : message.axolotlSenderKeyDistributionMessage;
                return object;
            };

            /**
             * Converts this SenderKeyDistributionMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.SenderKeyDistributionMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SenderKeyDistributionMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SenderKeyDistributionMessage;
        })();

        Message.StickerMessage = (function() {

            /**
             * Properties of a StickerMessage.
             * @memberof proto.Message
             * @interface IStickerMessage
             * @property {string|null} [url] StickerMessage url
             * @property {Uint8Array|null} [fileSha256] StickerMessage fileSha256
             * @property {Uint8Array|null} [fileEncSha256] StickerMessage fileEncSha256
             * @property {Uint8Array|null} [mediaKey] StickerMessage mediaKey
             * @property {string|null} [mimetype] StickerMessage mimetype
             * @property {number|null} [height] StickerMessage height
             * @property {number|null} [width] StickerMessage width
             * @property {string|null} [directPath] StickerMessage directPath
             * @property {number|Long|null} [fileLength] StickerMessage fileLength
             * @property {number|Long|null} [mediaKeyTimestamp] StickerMessage mediaKeyTimestamp
             * @property {number|null} [firstFrameLength] StickerMessage firstFrameLength
             * @property {Uint8Array|null} [firstFrameSidecar] StickerMessage firstFrameSidecar
             * @property {boolean|null} [isAnimated] StickerMessage isAnimated
             * @property {Uint8Array|null} [pngThumbnail] StickerMessage pngThumbnail
             * @property {proto.IContextInfo|null} [contextInfo] StickerMessage contextInfo
             * @property {number|Long|null} [stickerSentTs] StickerMessage stickerSentTs
             * @property {boolean|null} [isAvatar] StickerMessage isAvatar
             */

            /**
             * Constructs a new StickerMessage.
             * @memberof proto.Message
             * @classdesc Represents a StickerMessage.
             * @implements IStickerMessage
             * @constructor
             * @param {proto.Message.IStickerMessage=} [properties] Properties to set
             */
            function StickerMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StickerMessage url.
             * @member {string} url
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.url = "";

            /**
             * StickerMessage fileSha256.
             * @member {Uint8Array} fileSha256
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.fileSha256 = $util.newBuffer([]);

            /**
             * StickerMessage fileEncSha256.
             * @member {Uint8Array} fileEncSha256
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.fileEncSha256 = $util.newBuffer([]);

            /**
             * StickerMessage mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.mediaKey = $util.newBuffer([]);

            /**
             * StickerMessage mimetype.
             * @member {string} mimetype
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.mimetype = "";

            /**
             * StickerMessage height.
             * @member {number} height
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.height = 0;

            /**
             * StickerMessage width.
             * @member {number} width
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.width = 0;

            /**
             * StickerMessage directPath.
             * @member {string} directPath
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.directPath = "";

            /**
             * StickerMessage fileLength.
             * @member {number|Long} fileLength
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * StickerMessage mediaKeyTimestamp.
             * @member {number|Long} mediaKeyTimestamp
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * StickerMessage firstFrameLength.
             * @member {number} firstFrameLength
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.firstFrameLength = 0;

            /**
             * StickerMessage firstFrameSidecar.
             * @member {Uint8Array} firstFrameSidecar
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.firstFrameSidecar = $util.newBuffer([]);

            /**
             * StickerMessage isAnimated.
             * @member {boolean} isAnimated
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.isAnimated = false;

            /**
             * StickerMessage pngThumbnail.
             * @member {Uint8Array} pngThumbnail
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.pngThumbnail = $util.newBuffer([]);

            /**
             * StickerMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.contextInfo = null;

            /**
             * StickerMessage stickerSentTs.
             * @member {number|Long} stickerSentTs
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.stickerSentTs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * StickerMessage isAvatar.
             * @member {boolean} isAvatar
             * @memberof proto.Message.StickerMessage
             * @instance
             */
            StickerMessage.prototype.isAvatar = false;

            /**
             * Creates a new StickerMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.StickerMessage
             * @static
             * @param {proto.Message.IStickerMessage=} [properties] Properties to set
             * @returns {proto.Message.StickerMessage} StickerMessage instance
             */
            StickerMessage.create = function create(properties) {
                return new StickerMessage(properties);
            };

            /**
             * Encodes the specified StickerMessage message. Does not implicitly {@link proto.Message.StickerMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.StickerMessage
             * @static
             * @param {proto.Message.IStickerMessage} message StickerMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.fileSha256);
                if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileEncSha256);
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.mediaKey);
                if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.mimetype);
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.height);
                if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.width);
                if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.directPath);
                if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.fileLength);
                if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.mediaKeyTimestamp);
                if (message.firstFrameLength != null && Object.hasOwnProperty.call(message, "firstFrameLength"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.firstFrameLength);
                if (message.firstFrameSidecar != null && Object.hasOwnProperty.call(message, "firstFrameSidecar"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.firstFrameSidecar);
                if (message.isAnimated != null && Object.hasOwnProperty.call(message, "isAnimated"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.isAnimated);
                if (message.pngThumbnail != null && Object.hasOwnProperty.call(message, "pngThumbnail"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.pngThumbnail);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.stickerSentTs != null && Object.hasOwnProperty.call(message, "stickerSentTs"))
                    writer.uint32(/* id 18, wireType 0 =*/144).int64(message.stickerSentTs);
                if (message.isAvatar != null && Object.hasOwnProperty.call(message, "isAvatar"))
                    writer.uint32(/* id 19, wireType 0 =*/152).bool(message.isAvatar);
                return writer;
            };

            /**
             * Encodes the specified StickerMessage message, length delimited. Does not implicitly {@link proto.Message.StickerMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.StickerMessage
             * @static
             * @param {proto.Message.IStickerMessage} message StickerMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StickerMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.StickerMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.StickerMessage} StickerMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.StickerMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        message.fileSha256 = reader.bytes();
                        break;
                    case 3:
                        message.fileEncSha256 = reader.bytes();
                        break;
                    case 4:
                        message.mediaKey = reader.bytes();
                        break;
                    case 5:
                        message.mimetype = reader.string();
                        break;
                    case 6:
                        message.height = reader.uint32();
                        break;
                    case 7:
                        message.width = reader.uint32();
                        break;
                    case 8:
                        message.directPath = reader.string();
                        break;
                    case 9:
                        message.fileLength = reader.uint64();
                        break;
                    case 10:
                        message.mediaKeyTimestamp = reader.int64();
                        break;
                    case 11:
                        message.firstFrameLength = reader.uint32();
                        break;
                    case 12:
                        message.firstFrameSidecar = reader.bytes();
                        break;
                    case 13:
                        message.isAnimated = reader.bool();
                        break;
                    case 16:
                        message.pngThumbnail = reader.bytes();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.stickerSentTs = reader.int64();
                        break;
                    case 19:
                        message.isAvatar = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StickerMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.StickerMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.StickerMessage} StickerMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StickerMessage message.
             * @function verify
             * @memberof proto.Message.StickerMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StickerMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                        return "fileSha256: buffer expected";
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                        return "fileEncSha256: buffer expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    if (!$util.isString(message.mimetype))
                        return "mimetype: string expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height))
                        return "height: integer expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    if (!$util.isString(message.directPath))
                        return "directPath: string expected";
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                        return "fileLength: integer|Long expected";
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                        return "mediaKeyTimestamp: integer|Long expected";
                if (message.firstFrameLength != null && message.hasOwnProperty("firstFrameLength"))
                    if (!$util.isInteger(message.firstFrameLength))
                        return "firstFrameLength: integer expected";
                if (message.firstFrameSidecar != null && message.hasOwnProperty("firstFrameSidecar"))
                    if (!(message.firstFrameSidecar && typeof message.firstFrameSidecar.length === "number" || $util.isString(message.firstFrameSidecar)))
                        return "firstFrameSidecar: buffer expected";
                if (message.isAnimated != null && message.hasOwnProperty("isAnimated"))
                    if (typeof message.isAnimated !== "boolean")
                        return "isAnimated: boolean expected";
                if (message.pngThumbnail != null && message.hasOwnProperty("pngThumbnail"))
                    if (!(message.pngThumbnail && typeof message.pngThumbnail.length === "number" || $util.isString(message.pngThumbnail)))
                        return "pngThumbnail: buffer expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.stickerSentTs != null && message.hasOwnProperty("stickerSentTs"))
                    if (!$util.isInteger(message.stickerSentTs) && !(message.stickerSentTs && $util.isInteger(message.stickerSentTs.low) && $util.isInteger(message.stickerSentTs.high)))
                        return "stickerSentTs: integer|Long expected";
                if (message.isAvatar != null && message.hasOwnProperty("isAvatar"))
                    if (typeof message.isAvatar !== "boolean")
                        return "isAvatar: boolean expected";
                return null;
            };

            /**
             * Creates a StickerMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.StickerMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.StickerMessage} StickerMessage
             */
            StickerMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.StickerMessage)
                    return object;
                var message = new $root.proto.Message.StickerMessage();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.fileSha256 != null)
                    if (typeof object.fileSha256 === "string")
                        $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                    else if (object.fileSha256.length)
                        message.fileSha256 = object.fileSha256;
                if (object.fileEncSha256 != null)
                    if (typeof object.fileEncSha256 === "string")
                        $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                    else if (object.fileEncSha256.length)
                        message.fileEncSha256 = object.fileEncSha256;
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.mimetype != null)
                    message.mimetype = String(object.mimetype);
                if (object.height != null)
                    message.height = object.height >>> 0;
                if (object.width != null)
                    message.width = object.width >>> 0;
                if (object.directPath != null)
                    message.directPath = String(object.directPath);
                if (object.fileLength != null)
                    if ($util.Long)
                        (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                    else if (typeof object.fileLength === "string")
                        message.fileLength = parseInt(object.fileLength, 10);
                    else if (typeof object.fileLength === "number")
                        message.fileLength = object.fileLength;
                    else if (typeof object.fileLength === "object")
                        message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
                if (object.mediaKeyTimestamp != null)
                    if ($util.Long)
                        (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                    else if (typeof object.mediaKeyTimestamp === "string")
                        message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                    else if (typeof object.mediaKeyTimestamp === "number")
                        message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                    else if (typeof object.mediaKeyTimestamp === "object")
                        message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
                if (object.firstFrameLength != null)
                    message.firstFrameLength = object.firstFrameLength >>> 0;
                if (object.firstFrameSidecar != null)
                    if (typeof object.firstFrameSidecar === "string")
                        $util.base64.decode(object.firstFrameSidecar, message.firstFrameSidecar = $util.newBuffer($util.base64.length(object.firstFrameSidecar)), 0);
                    else if (object.firstFrameSidecar.length)
                        message.firstFrameSidecar = object.firstFrameSidecar;
                if (object.isAnimated != null)
                    message.isAnimated = Boolean(object.isAnimated);
                if (object.pngThumbnail != null)
                    if (typeof object.pngThumbnail === "string")
                        $util.base64.decode(object.pngThumbnail, message.pngThumbnail = $util.newBuffer($util.base64.length(object.pngThumbnail)), 0);
                    else if (object.pngThumbnail.length)
                        message.pngThumbnail = object.pngThumbnail;
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.StickerMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.stickerSentTs != null)
                    if ($util.Long)
                        (message.stickerSentTs = $util.Long.fromValue(object.stickerSentTs)).unsigned = false;
                    else if (typeof object.stickerSentTs === "string")
                        message.stickerSentTs = parseInt(object.stickerSentTs, 10);
                    else if (typeof object.stickerSentTs === "number")
                        message.stickerSentTs = object.stickerSentTs;
                    else if (typeof object.stickerSentTs === "object")
                        message.stickerSentTs = new $util.LongBits(object.stickerSentTs.low >>> 0, object.stickerSentTs.high >>> 0).toNumber();
                if (object.isAvatar != null)
                    message.isAvatar = Boolean(object.isAvatar);
                return message;
            };

            /**
             * Creates a plain object from a StickerMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.StickerMessage
             * @static
             * @param {proto.Message.StickerMessage} message StickerMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StickerMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.url = "";
                    if (options.bytes === String)
                        object.fileSha256 = "";
                    else {
                        object.fileSha256 = [];
                        if (options.bytes !== Array)
                            object.fileSha256 = $util.newBuffer(object.fileSha256);
                    }
                    if (options.bytes === String)
                        object.fileEncSha256 = "";
                    else {
                        object.fileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                    }
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    object.mimetype = "";
                    object.height = 0;
                    object.width = 0;
                    object.directPath = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileLength = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                    object.firstFrameLength = 0;
                    if (options.bytes === String)
                        object.firstFrameSidecar = "";
                    else {
                        object.firstFrameSidecar = [];
                        if (options.bytes !== Array)
                            object.firstFrameSidecar = $util.newBuffer(object.firstFrameSidecar);
                    }
                    object.isAnimated = false;
                    if (options.bytes === String)
                        object.pngThumbnail = "";
                    else {
                        object.pngThumbnail = [];
                        if (options.bytes !== Array)
                            object.pngThumbnail = $util.newBuffer(object.pngThumbnail);
                    }
                    object.contextInfo = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.stickerSentTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.stickerSentTs = options.longs === String ? "0" : 0;
                    object.isAvatar = false;
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    object.mimetype = message.mimetype;
                if (message.height != null && message.hasOwnProperty("height"))
                    object.height = message.height;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = message.width;
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    object.directPath = message.directPath;
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (typeof message.fileLength === "number")
                        object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                    else
                        object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (typeof message.mediaKeyTimestamp === "number")
                        object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                    else
                        object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
                if (message.firstFrameLength != null && message.hasOwnProperty("firstFrameLength"))
                    object.firstFrameLength = message.firstFrameLength;
                if (message.firstFrameSidecar != null && message.hasOwnProperty("firstFrameSidecar"))
                    object.firstFrameSidecar = options.bytes === String ? $util.base64.encode(message.firstFrameSidecar, 0, message.firstFrameSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.firstFrameSidecar) : message.firstFrameSidecar;
                if (message.isAnimated != null && message.hasOwnProperty("isAnimated"))
                    object.isAnimated = message.isAnimated;
                if (message.pngThumbnail != null && message.hasOwnProperty("pngThumbnail"))
                    object.pngThumbnail = options.bytes === String ? $util.base64.encode(message.pngThumbnail, 0, message.pngThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.pngThumbnail) : message.pngThumbnail;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.stickerSentTs != null && message.hasOwnProperty("stickerSentTs"))
                    if (typeof message.stickerSentTs === "number")
                        object.stickerSentTs = options.longs === String ? String(message.stickerSentTs) : message.stickerSentTs;
                    else
                        object.stickerSentTs = options.longs === String ? $util.Long.prototype.toString.call(message.stickerSentTs) : options.longs === Number ? new $util.LongBits(message.stickerSentTs.low >>> 0, message.stickerSentTs.high >>> 0).toNumber() : message.stickerSentTs;
                if (message.isAvatar != null && message.hasOwnProperty("isAvatar"))
                    object.isAvatar = message.isAvatar;
                return object;
            };

            /**
             * Converts this StickerMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.StickerMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StickerMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StickerMessage;
        })();

        Message.StickerSyncRMRMessage = (function() {

            /**
             * Properties of a StickerSyncRMRMessage.
             * @memberof proto.Message
             * @interface IStickerSyncRMRMessage
             * @property {Array.<string>|null} [filehash] StickerSyncRMRMessage filehash
             * @property {string|null} [rmrSource] StickerSyncRMRMessage rmrSource
             * @property {number|Long|null} [requestTimestamp] StickerSyncRMRMessage requestTimestamp
             */

            /**
             * Constructs a new StickerSyncRMRMessage.
             * @memberof proto.Message
             * @classdesc Represents a StickerSyncRMRMessage.
             * @implements IStickerSyncRMRMessage
             * @constructor
             * @param {proto.Message.IStickerSyncRMRMessage=} [properties] Properties to set
             */
            function StickerSyncRMRMessage(properties) {
                this.filehash = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StickerSyncRMRMessage filehash.
             * @member {Array.<string>} filehash
             * @memberof proto.Message.StickerSyncRMRMessage
             * @instance
             */
            StickerSyncRMRMessage.prototype.filehash = $util.emptyArray;

            /**
             * StickerSyncRMRMessage rmrSource.
             * @member {string} rmrSource
             * @memberof proto.Message.StickerSyncRMRMessage
             * @instance
             */
            StickerSyncRMRMessage.prototype.rmrSource = "";

            /**
             * StickerSyncRMRMessage requestTimestamp.
             * @member {number|Long} requestTimestamp
             * @memberof proto.Message.StickerSyncRMRMessage
             * @instance
             */
            StickerSyncRMRMessage.prototype.requestTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new StickerSyncRMRMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.StickerSyncRMRMessage
             * @static
             * @param {proto.Message.IStickerSyncRMRMessage=} [properties] Properties to set
             * @returns {proto.Message.StickerSyncRMRMessage} StickerSyncRMRMessage instance
             */
            StickerSyncRMRMessage.create = function create(properties) {
                return new StickerSyncRMRMessage(properties);
            };

            /**
             * Encodes the specified StickerSyncRMRMessage message. Does not implicitly {@link proto.Message.StickerSyncRMRMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.StickerSyncRMRMessage
             * @static
             * @param {proto.Message.IStickerSyncRMRMessage} message StickerSyncRMRMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerSyncRMRMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filehash != null && message.filehash.length)
                    for (var i = 0; i < message.filehash.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.filehash[i]);
                if (message.rmrSource != null && Object.hasOwnProperty.call(message, "rmrSource"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.rmrSource);
                if (message.requestTimestamp != null && Object.hasOwnProperty.call(message, "requestTimestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.requestTimestamp);
                return writer;
            };

            /**
             * Encodes the specified StickerSyncRMRMessage message, length delimited. Does not implicitly {@link proto.Message.StickerSyncRMRMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.StickerSyncRMRMessage
             * @static
             * @param {proto.Message.IStickerSyncRMRMessage} message StickerSyncRMRMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerSyncRMRMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StickerSyncRMRMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.StickerSyncRMRMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.StickerSyncRMRMessage} StickerSyncRMRMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerSyncRMRMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.StickerSyncRMRMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.filehash && message.filehash.length))
                            message.filehash = [];
                        message.filehash.push(reader.string());
                        break;
                    case 2:
                        message.rmrSource = reader.string();
                        break;
                    case 3:
                        message.requestTimestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StickerSyncRMRMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.StickerSyncRMRMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.StickerSyncRMRMessage} StickerSyncRMRMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerSyncRMRMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StickerSyncRMRMessage message.
             * @function verify
             * @memberof proto.Message.StickerSyncRMRMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StickerSyncRMRMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filehash != null && message.hasOwnProperty("filehash")) {
                    if (!Array.isArray(message.filehash))
                        return "filehash: array expected";
                    for (var i = 0; i < message.filehash.length; ++i)
                        if (!$util.isString(message.filehash[i]))
                            return "filehash: string[] expected";
                }
                if (message.rmrSource != null && message.hasOwnProperty("rmrSource"))
                    if (!$util.isString(message.rmrSource))
                        return "rmrSource: string expected";
                if (message.requestTimestamp != null && message.hasOwnProperty("requestTimestamp"))
                    if (!$util.isInteger(message.requestTimestamp) && !(message.requestTimestamp && $util.isInteger(message.requestTimestamp.low) && $util.isInteger(message.requestTimestamp.high)))
                        return "requestTimestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a StickerSyncRMRMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.StickerSyncRMRMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.StickerSyncRMRMessage} StickerSyncRMRMessage
             */
            StickerSyncRMRMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.StickerSyncRMRMessage)
                    return object;
                var message = new $root.proto.Message.StickerSyncRMRMessage();
                if (object.filehash) {
                    if (!Array.isArray(object.filehash))
                        throw TypeError(".proto.Message.StickerSyncRMRMessage.filehash: array expected");
                    message.filehash = [];
                    for (var i = 0; i < object.filehash.length; ++i)
                        message.filehash[i] = String(object.filehash[i]);
                }
                if (object.rmrSource != null)
                    message.rmrSource = String(object.rmrSource);
                if (object.requestTimestamp != null)
                    if ($util.Long)
                        (message.requestTimestamp = $util.Long.fromValue(object.requestTimestamp)).unsigned = false;
                    else if (typeof object.requestTimestamp === "string")
                        message.requestTimestamp = parseInt(object.requestTimestamp, 10);
                    else if (typeof object.requestTimestamp === "number")
                        message.requestTimestamp = object.requestTimestamp;
                    else if (typeof object.requestTimestamp === "object")
                        message.requestTimestamp = new $util.LongBits(object.requestTimestamp.low >>> 0, object.requestTimestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a StickerSyncRMRMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.StickerSyncRMRMessage
             * @static
             * @param {proto.Message.StickerSyncRMRMessage} message StickerSyncRMRMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StickerSyncRMRMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.filehash = [];
                if (options.defaults) {
                    object.rmrSource = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.requestTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.requestTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.filehash && message.filehash.length) {
                    object.filehash = [];
                    for (var j = 0; j < message.filehash.length; ++j)
                        object.filehash[j] = message.filehash[j];
                }
                if (message.rmrSource != null && message.hasOwnProperty("rmrSource"))
                    object.rmrSource = message.rmrSource;
                if (message.requestTimestamp != null && message.hasOwnProperty("requestTimestamp"))
                    if (typeof message.requestTimestamp === "number")
                        object.requestTimestamp = options.longs === String ? String(message.requestTimestamp) : message.requestTimestamp;
                    else
                        object.requestTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.requestTimestamp) : options.longs === Number ? new $util.LongBits(message.requestTimestamp.low >>> 0, message.requestTimestamp.high >>> 0).toNumber() : message.requestTimestamp;
                return object;
            };

            /**
             * Converts this StickerSyncRMRMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.StickerSyncRMRMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StickerSyncRMRMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StickerSyncRMRMessage;
        })();

        Message.TemplateButtonReplyMessage = (function() {

            /**
             * Properties of a TemplateButtonReplyMessage.
             * @memberof proto.Message
             * @interface ITemplateButtonReplyMessage
             * @property {string|null} [selectedId] TemplateButtonReplyMessage selectedId
             * @property {string|null} [selectedDisplayText] TemplateButtonReplyMessage selectedDisplayText
             * @property {proto.IContextInfo|null} [contextInfo] TemplateButtonReplyMessage contextInfo
             * @property {number|null} [selectedIndex] TemplateButtonReplyMessage selectedIndex
             */

            /**
             * Constructs a new TemplateButtonReplyMessage.
             * @memberof proto.Message
             * @classdesc Represents a TemplateButtonReplyMessage.
             * @implements ITemplateButtonReplyMessage
             * @constructor
             * @param {proto.Message.ITemplateButtonReplyMessage=} [properties] Properties to set
             */
            function TemplateButtonReplyMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TemplateButtonReplyMessage selectedId.
             * @member {string} selectedId
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @instance
             */
            TemplateButtonReplyMessage.prototype.selectedId = "";

            /**
             * TemplateButtonReplyMessage selectedDisplayText.
             * @member {string} selectedDisplayText
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @instance
             */
            TemplateButtonReplyMessage.prototype.selectedDisplayText = "";

            /**
             * TemplateButtonReplyMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @instance
             */
            TemplateButtonReplyMessage.prototype.contextInfo = null;

            /**
             * TemplateButtonReplyMessage selectedIndex.
             * @member {number} selectedIndex
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @instance
             */
            TemplateButtonReplyMessage.prototype.selectedIndex = 0;

            /**
             * Creates a new TemplateButtonReplyMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @static
             * @param {proto.Message.ITemplateButtonReplyMessage=} [properties] Properties to set
             * @returns {proto.Message.TemplateButtonReplyMessage} TemplateButtonReplyMessage instance
             */
            TemplateButtonReplyMessage.create = function create(properties) {
                return new TemplateButtonReplyMessage(properties);
            };

            /**
             * Encodes the specified TemplateButtonReplyMessage message. Does not implicitly {@link proto.Message.TemplateButtonReplyMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @static
             * @param {proto.Message.ITemplateButtonReplyMessage} message TemplateButtonReplyMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemplateButtonReplyMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selectedId != null && Object.hasOwnProperty.call(message, "selectedId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selectedId);
                if (message.selectedDisplayText != null && Object.hasOwnProperty.call(message, "selectedDisplayText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.selectedDisplayText);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.selectedIndex != null && Object.hasOwnProperty.call(message, "selectedIndex"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.selectedIndex);
                return writer;
            };

            /**
             * Encodes the specified TemplateButtonReplyMessage message, length delimited. Does not implicitly {@link proto.Message.TemplateButtonReplyMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @static
             * @param {proto.Message.ITemplateButtonReplyMessage} message TemplateButtonReplyMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemplateButtonReplyMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TemplateButtonReplyMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.TemplateButtonReplyMessage} TemplateButtonReplyMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemplateButtonReplyMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.TemplateButtonReplyMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.selectedId = reader.string();
                        break;
                    case 2:
                        message.selectedDisplayText = reader.string();
                        break;
                    case 3:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.selectedIndex = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TemplateButtonReplyMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.TemplateButtonReplyMessage} TemplateButtonReplyMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemplateButtonReplyMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TemplateButtonReplyMessage message.
             * @function verify
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TemplateButtonReplyMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.selectedId != null && message.hasOwnProperty("selectedId"))
                    if (!$util.isString(message.selectedId))
                        return "selectedId: string expected";
                if (message.selectedDisplayText != null && message.hasOwnProperty("selectedDisplayText"))
                    if (!$util.isString(message.selectedDisplayText))
                        return "selectedDisplayText: string expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.selectedIndex != null && message.hasOwnProperty("selectedIndex"))
                    if (!$util.isInteger(message.selectedIndex))
                        return "selectedIndex: integer expected";
                return null;
            };

            /**
             * Creates a TemplateButtonReplyMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.TemplateButtonReplyMessage} TemplateButtonReplyMessage
             */
            TemplateButtonReplyMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.TemplateButtonReplyMessage)
                    return object;
                var message = new $root.proto.Message.TemplateButtonReplyMessage();
                if (object.selectedId != null)
                    message.selectedId = String(object.selectedId);
                if (object.selectedDisplayText != null)
                    message.selectedDisplayText = String(object.selectedDisplayText);
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.TemplateButtonReplyMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.selectedIndex != null)
                    message.selectedIndex = object.selectedIndex >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a TemplateButtonReplyMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @static
             * @param {proto.Message.TemplateButtonReplyMessage} message TemplateButtonReplyMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TemplateButtonReplyMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.selectedId = "";
                    object.selectedDisplayText = "";
                    object.contextInfo = null;
                    object.selectedIndex = 0;
                }
                if (message.selectedId != null && message.hasOwnProperty("selectedId"))
                    object.selectedId = message.selectedId;
                if (message.selectedDisplayText != null && message.hasOwnProperty("selectedDisplayText"))
                    object.selectedDisplayText = message.selectedDisplayText;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.selectedIndex != null && message.hasOwnProperty("selectedIndex"))
                    object.selectedIndex = message.selectedIndex;
                return object;
            };

            /**
             * Converts this TemplateButtonReplyMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.TemplateButtonReplyMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TemplateButtonReplyMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TemplateButtonReplyMessage;
        })();

        Message.TemplateMessage = (function() {

            /**
             * Properties of a TemplateMessage.
             * @memberof proto.Message
             * @interface ITemplateMessage
             * @property {proto.IContextInfo|null} [contextInfo] TemplateMessage contextInfo
             * @property {proto.Message.TemplateMessage.IHydratedFourRowTemplate|null} [hydratedTemplate] TemplateMessage hydratedTemplate
             * @property {string|null} [templateId] TemplateMessage templateId
             * @property {proto.Message.TemplateMessage.IFourRowTemplate|null} [fourRowTemplate] TemplateMessage fourRowTemplate
             * @property {proto.Message.TemplateMessage.IHydratedFourRowTemplate|null} [hydratedFourRowTemplate] TemplateMessage hydratedFourRowTemplate
             * @property {proto.Message.IInteractiveMessage|null} [interactiveMessageTemplate] TemplateMessage interactiveMessageTemplate
             */

            /**
             * Constructs a new TemplateMessage.
             * @memberof proto.Message
             * @classdesc Represents a TemplateMessage.
             * @implements ITemplateMessage
             * @constructor
             * @param {proto.Message.ITemplateMessage=} [properties] Properties to set
             */
            function TemplateMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TemplateMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.TemplateMessage
             * @instance
             */
            TemplateMessage.prototype.contextInfo = null;

            /**
             * TemplateMessage hydratedTemplate.
             * @member {proto.Message.TemplateMessage.IHydratedFourRowTemplate|null|undefined} hydratedTemplate
             * @memberof proto.Message.TemplateMessage
             * @instance
             */
            TemplateMessage.prototype.hydratedTemplate = null;

            /**
             * TemplateMessage templateId.
             * @member {string} templateId
             * @memberof proto.Message.TemplateMessage
             * @instance
             */
            TemplateMessage.prototype.templateId = "";

            /**
             * TemplateMessage fourRowTemplate.
             * @member {proto.Message.TemplateMessage.IFourRowTemplate|null|undefined} fourRowTemplate
             * @memberof proto.Message.TemplateMessage
             * @instance
             */
            TemplateMessage.prototype.fourRowTemplate = null;

            /**
             * TemplateMessage hydratedFourRowTemplate.
             * @member {proto.Message.TemplateMessage.IHydratedFourRowTemplate|null|undefined} hydratedFourRowTemplate
             * @memberof proto.Message.TemplateMessage
             * @instance
             */
            TemplateMessage.prototype.hydratedFourRowTemplate = null;

            /**
             * TemplateMessage interactiveMessageTemplate.
             * @member {proto.Message.IInteractiveMessage|null|undefined} interactiveMessageTemplate
             * @memberof proto.Message.TemplateMessage
             * @instance
             */
            TemplateMessage.prototype.interactiveMessageTemplate = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TemplateMessage format.
             * @member {"fourRowTemplate"|"hydratedFourRowTemplate"|"interactiveMessageTemplate"|undefined} format
             * @memberof proto.Message.TemplateMessage
             * @instance
             */
            Object.defineProperty(TemplateMessage.prototype, "format", {
                get: $util.oneOfGetter($oneOfFields = ["fourRowTemplate", "hydratedFourRowTemplate", "interactiveMessageTemplate"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TemplateMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.TemplateMessage
             * @static
             * @param {proto.Message.ITemplateMessage=} [properties] Properties to set
             * @returns {proto.Message.TemplateMessage} TemplateMessage instance
             */
            TemplateMessage.create = function create(properties) {
                return new TemplateMessage(properties);
            };

            /**
             * Encodes the specified TemplateMessage message. Does not implicitly {@link proto.Message.TemplateMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.TemplateMessage
             * @static
             * @param {proto.Message.ITemplateMessage} message TemplateMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemplateMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fourRowTemplate != null && Object.hasOwnProperty.call(message, "fourRowTemplate"))
                    $root.proto.Message.TemplateMessage.FourRowTemplate.encode(message.fourRowTemplate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.hydratedFourRowTemplate != null && Object.hasOwnProperty.call(message, "hydratedFourRowTemplate"))
                    $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.encode(message.hydratedFourRowTemplate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.hydratedTemplate != null && Object.hasOwnProperty.call(message, "hydratedTemplate"))
                    $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.encode(message.hydratedTemplate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.interactiveMessageTemplate != null && Object.hasOwnProperty.call(message, "interactiveMessageTemplate"))
                    $root.proto.Message.InteractiveMessage.encode(message.interactiveMessageTemplate, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.templateId != null && Object.hasOwnProperty.call(message, "templateId"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.templateId);
                return writer;
            };

            /**
             * Encodes the specified TemplateMessage message, length delimited. Does not implicitly {@link proto.Message.TemplateMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.TemplateMessage
             * @static
             * @param {proto.Message.ITemplateMessage} message TemplateMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemplateMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TemplateMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.TemplateMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.TemplateMessage} TemplateMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemplateMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.TemplateMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.hydratedTemplate = $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.templateId = reader.string();
                        break;
                    case 1:
                        message.fourRowTemplate = $root.proto.Message.TemplateMessage.FourRowTemplate.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.hydratedFourRowTemplate = $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.interactiveMessageTemplate = $root.proto.Message.InteractiveMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TemplateMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.TemplateMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.TemplateMessage} TemplateMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemplateMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TemplateMessage message.
             * @function verify
             * @memberof proto.Message.TemplateMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TemplateMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.hydratedTemplate != null && message.hasOwnProperty("hydratedTemplate")) {
                    var error = $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.verify(message.hydratedTemplate);
                    if (error)
                        return "hydratedTemplate." + error;
                }
                if (message.templateId != null && message.hasOwnProperty("templateId"))
                    if (!$util.isString(message.templateId))
                        return "templateId: string expected";
                if (message.fourRowTemplate != null && message.hasOwnProperty("fourRowTemplate")) {
                    properties.format = 1;
                    {
                        var error = $root.proto.Message.TemplateMessage.FourRowTemplate.verify(message.fourRowTemplate);
                        if (error)
                            return "fourRowTemplate." + error;
                    }
                }
                if (message.hydratedFourRowTemplate != null && message.hasOwnProperty("hydratedFourRowTemplate")) {
                    if (properties.format === 1)
                        return "format: multiple values";
                    properties.format = 1;
                    {
                        var error = $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.verify(message.hydratedFourRowTemplate);
                        if (error)
                            return "hydratedFourRowTemplate." + error;
                    }
                }
                if (message.interactiveMessageTemplate != null && message.hasOwnProperty("interactiveMessageTemplate")) {
                    if (properties.format === 1)
                        return "format: multiple values";
                    properties.format = 1;
                    {
                        var error = $root.proto.Message.InteractiveMessage.verify(message.interactiveMessageTemplate);
                        if (error)
                            return "interactiveMessageTemplate." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TemplateMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.TemplateMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.TemplateMessage} TemplateMessage
             */
            TemplateMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.TemplateMessage)
                    return object;
                var message = new $root.proto.Message.TemplateMessage();
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.TemplateMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.hydratedTemplate != null) {
                    if (typeof object.hydratedTemplate !== "object")
                        throw TypeError(".proto.Message.TemplateMessage.hydratedTemplate: object expected");
                    message.hydratedTemplate = $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.fromObject(object.hydratedTemplate);
                }
                if (object.templateId != null)
                    message.templateId = String(object.templateId);
                if (object.fourRowTemplate != null) {
                    if (typeof object.fourRowTemplate !== "object")
                        throw TypeError(".proto.Message.TemplateMessage.fourRowTemplate: object expected");
                    message.fourRowTemplate = $root.proto.Message.TemplateMessage.FourRowTemplate.fromObject(object.fourRowTemplate);
                }
                if (object.hydratedFourRowTemplate != null) {
                    if (typeof object.hydratedFourRowTemplate !== "object")
                        throw TypeError(".proto.Message.TemplateMessage.hydratedFourRowTemplate: object expected");
                    message.hydratedFourRowTemplate = $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.fromObject(object.hydratedFourRowTemplate);
                }
                if (object.interactiveMessageTemplate != null) {
                    if (typeof object.interactiveMessageTemplate !== "object")
                        throw TypeError(".proto.Message.TemplateMessage.interactiveMessageTemplate: object expected");
                    message.interactiveMessageTemplate = $root.proto.Message.InteractiveMessage.fromObject(object.interactiveMessageTemplate);
                }
                return message;
            };

            /**
             * Creates a plain object from a TemplateMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.TemplateMessage
             * @static
             * @param {proto.Message.TemplateMessage} message TemplateMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TemplateMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.contextInfo = null;
                    object.hydratedTemplate = null;
                    object.templateId = "";
                }
                if (message.fourRowTemplate != null && message.hasOwnProperty("fourRowTemplate")) {
                    object.fourRowTemplate = $root.proto.Message.TemplateMessage.FourRowTemplate.toObject(message.fourRowTemplate, options);
                    if (options.oneofs)
                        object.format = "fourRowTemplate";
                }
                if (message.hydratedFourRowTemplate != null && message.hasOwnProperty("hydratedFourRowTemplate")) {
                    object.hydratedFourRowTemplate = $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.toObject(message.hydratedFourRowTemplate, options);
                    if (options.oneofs)
                        object.format = "hydratedFourRowTemplate";
                }
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.hydratedTemplate != null && message.hasOwnProperty("hydratedTemplate"))
                    object.hydratedTemplate = $root.proto.Message.TemplateMessage.HydratedFourRowTemplate.toObject(message.hydratedTemplate, options);
                if (message.interactiveMessageTemplate != null && message.hasOwnProperty("interactiveMessageTemplate")) {
                    object.interactiveMessageTemplate = $root.proto.Message.InteractiveMessage.toObject(message.interactiveMessageTemplate, options);
                    if (options.oneofs)
                        object.format = "interactiveMessageTemplate";
                }
                if (message.templateId != null && message.hasOwnProperty("templateId"))
                    object.templateId = message.templateId;
                return object;
            };

            /**
             * Converts this TemplateMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.TemplateMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TemplateMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            TemplateMessage.FourRowTemplate = (function() {

                /**
                 * Properties of a FourRowTemplate.
                 * @memberof proto.Message.TemplateMessage
                 * @interface IFourRowTemplate
                 * @property {proto.Message.IHighlyStructuredMessage|null} [content] FourRowTemplate content
                 * @property {proto.Message.IHighlyStructuredMessage|null} [footer] FourRowTemplate footer
                 * @property {Array.<proto.ITemplateButton>|null} [buttons] FourRowTemplate buttons
                 * @property {proto.Message.IDocumentMessage|null} [documentMessage] FourRowTemplate documentMessage
                 * @property {proto.Message.IHighlyStructuredMessage|null} [highlyStructuredMessage] FourRowTemplate highlyStructuredMessage
                 * @property {proto.Message.IImageMessage|null} [imageMessage] FourRowTemplate imageMessage
                 * @property {proto.Message.IVideoMessage|null} [videoMessage] FourRowTemplate videoMessage
                 * @property {proto.Message.ILocationMessage|null} [locationMessage] FourRowTemplate locationMessage
                 */

                /**
                 * Constructs a new FourRowTemplate.
                 * @memberof proto.Message.TemplateMessage
                 * @classdesc Represents a FourRowTemplate.
                 * @implements IFourRowTemplate
                 * @constructor
                 * @param {proto.Message.TemplateMessage.IFourRowTemplate=} [properties] Properties to set
                 */
                function FourRowTemplate(properties) {
                    this.buttons = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FourRowTemplate content.
                 * @member {proto.Message.IHighlyStructuredMessage|null|undefined} content
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                FourRowTemplate.prototype.content = null;

                /**
                 * FourRowTemplate footer.
                 * @member {proto.Message.IHighlyStructuredMessage|null|undefined} footer
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                FourRowTemplate.prototype.footer = null;

                /**
                 * FourRowTemplate buttons.
                 * @member {Array.<proto.ITemplateButton>} buttons
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                FourRowTemplate.prototype.buttons = $util.emptyArray;

                /**
                 * FourRowTemplate documentMessage.
                 * @member {proto.Message.IDocumentMessage|null|undefined} documentMessage
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                FourRowTemplate.prototype.documentMessage = null;

                /**
                 * FourRowTemplate highlyStructuredMessage.
                 * @member {proto.Message.IHighlyStructuredMessage|null|undefined} highlyStructuredMessage
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                FourRowTemplate.prototype.highlyStructuredMessage = null;

                /**
                 * FourRowTemplate imageMessage.
                 * @member {proto.Message.IImageMessage|null|undefined} imageMessage
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                FourRowTemplate.prototype.imageMessage = null;

                /**
                 * FourRowTemplate videoMessage.
                 * @member {proto.Message.IVideoMessage|null|undefined} videoMessage
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                FourRowTemplate.prototype.videoMessage = null;

                /**
                 * FourRowTemplate locationMessage.
                 * @member {proto.Message.ILocationMessage|null|undefined} locationMessage
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                FourRowTemplate.prototype.locationMessage = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * FourRowTemplate title.
                 * @member {"documentMessage"|"highlyStructuredMessage"|"imageMessage"|"videoMessage"|"locationMessage"|undefined} title
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 */
                Object.defineProperty(FourRowTemplate.prototype, "title", {
                    get: $util.oneOfGetter($oneOfFields = ["documentMessage", "highlyStructuredMessage", "imageMessage", "videoMessage", "locationMessage"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new FourRowTemplate instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @static
                 * @param {proto.Message.TemplateMessage.IFourRowTemplate=} [properties] Properties to set
                 * @returns {proto.Message.TemplateMessage.FourRowTemplate} FourRowTemplate instance
                 */
                FourRowTemplate.create = function create(properties) {
                    return new FourRowTemplate(properties);
                };

                /**
                 * Encodes the specified FourRowTemplate message. Does not implicitly {@link proto.Message.TemplateMessage.FourRowTemplate.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @static
                 * @param {proto.Message.TemplateMessage.IFourRowTemplate} message FourRowTemplate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FourRowTemplate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.documentMessage != null && Object.hasOwnProperty.call(message, "documentMessage"))
                        $root.proto.Message.DocumentMessage.encode(message.documentMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.highlyStructuredMessage != null && Object.hasOwnProperty.call(message, "highlyStructuredMessage"))
                        $root.proto.Message.HighlyStructuredMessage.encode(message.highlyStructuredMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.imageMessage != null && Object.hasOwnProperty.call(message, "imageMessage"))
                        $root.proto.Message.ImageMessage.encode(message.imageMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.videoMessage != null && Object.hasOwnProperty.call(message, "videoMessage"))
                        $root.proto.Message.VideoMessage.encode(message.videoMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.locationMessage != null && Object.hasOwnProperty.call(message, "locationMessage"))
                        $root.proto.Message.LocationMessage.encode(message.locationMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                        $root.proto.Message.HighlyStructuredMessage.encode(message.content, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.footer != null && Object.hasOwnProperty.call(message, "footer"))
                        $root.proto.Message.HighlyStructuredMessage.encode(message.footer, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.buttons != null && message.buttons.length)
                        for (var i = 0; i < message.buttons.length; ++i)
                            $root.proto.TemplateButton.encode(message.buttons[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified FourRowTemplate message, length delimited. Does not implicitly {@link proto.Message.TemplateMessage.FourRowTemplate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @static
                 * @param {proto.Message.TemplateMessage.IFourRowTemplate} message FourRowTemplate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FourRowTemplate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FourRowTemplate message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.TemplateMessage.FourRowTemplate} FourRowTemplate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FourRowTemplate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.TemplateMessage.FourRowTemplate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 6:
                            message.content = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.footer = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                            break;
                        case 8:
                            if (!(message.buttons && message.buttons.length))
                                message.buttons = [];
                            message.buttons.push($root.proto.TemplateButton.decode(reader, reader.uint32()));
                            break;
                        case 1:
                            message.documentMessage = $root.proto.Message.DocumentMessage.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.highlyStructuredMessage = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.imageMessage = $root.proto.Message.ImageMessage.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.videoMessage = $root.proto.Message.VideoMessage.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.locationMessage = $root.proto.Message.LocationMessage.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FourRowTemplate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.TemplateMessage.FourRowTemplate} FourRowTemplate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FourRowTemplate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FourRowTemplate message.
                 * @function verify
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FourRowTemplate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.content != null && message.hasOwnProperty("content")) {
                        var error = $root.proto.Message.HighlyStructuredMessage.verify(message.content);
                        if (error)
                            return "content." + error;
                    }
                    if (message.footer != null && message.hasOwnProperty("footer")) {
                        var error = $root.proto.Message.HighlyStructuredMessage.verify(message.footer);
                        if (error)
                            return "footer." + error;
                    }
                    if (message.buttons != null && message.hasOwnProperty("buttons")) {
                        if (!Array.isArray(message.buttons))
                            return "buttons: array expected";
                        for (var i = 0; i < message.buttons.length; ++i) {
                            var error = $root.proto.TemplateButton.verify(message.buttons[i]);
                            if (error)
                                return "buttons." + error;
                        }
                    }
                    if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.DocumentMessage.verify(message.documentMessage);
                            if (error)
                                return "documentMessage." + error;
                        }
                    }
                    if (message.highlyStructuredMessage != null && message.hasOwnProperty("highlyStructuredMessage")) {
                        if (properties.title === 1)
                            return "title: multiple values";
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.HighlyStructuredMessage.verify(message.highlyStructuredMessage);
                            if (error)
                                return "highlyStructuredMessage." + error;
                        }
                    }
                    if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                        if (properties.title === 1)
                            return "title: multiple values";
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.ImageMessage.verify(message.imageMessage);
                            if (error)
                                return "imageMessage." + error;
                        }
                    }
                    if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                        if (properties.title === 1)
                            return "title: multiple values";
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.VideoMessage.verify(message.videoMessage);
                            if (error)
                                return "videoMessage." + error;
                        }
                    }
                    if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                        if (properties.title === 1)
                            return "title: multiple values";
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.LocationMessage.verify(message.locationMessage);
                            if (error)
                                return "locationMessage." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a FourRowTemplate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.TemplateMessage.FourRowTemplate} FourRowTemplate
                 */
                FourRowTemplate.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.TemplateMessage.FourRowTemplate)
                        return object;
                    var message = new $root.proto.Message.TemplateMessage.FourRowTemplate();
                    if (object.content != null) {
                        if (typeof object.content !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.content: object expected");
                        message.content = $root.proto.Message.HighlyStructuredMessage.fromObject(object.content);
                    }
                    if (object.footer != null) {
                        if (typeof object.footer !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.footer: object expected");
                        message.footer = $root.proto.Message.HighlyStructuredMessage.fromObject(object.footer);
                    }
                    if (object.buttons) {
                        if (!Array.isArray(object.buttons))
                            throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.buttons: array expected");
                        message.buttons = [];
                        for (var i = 0; i < object.buttons.length; ++i) {
                            if (typeof object.buttons[i] !== "object")
                                throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.buttons: object expected");
                            message.buttons[i] = $root.proto.TemplateButton.fromObject(object.buttons[i]);
                        }
                    }
                    if (object.documentMessage != null) {
                        if (typeof object.documentMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.documentMessage: object expected");
                        message.documentMessage = $root.proto.Message.DocumentMessage.fromObject(object.documentMessage);
                    }
                    if (object.highlyStructuredMessage != null) {
                        if (typeof object.highlyStructuredMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.highlyStructuredMessage: object expected");
                        message.highlyStructuredMessage = $root.proto.Message.HighlyStructuredMessage.fromObject(object.highlyStructuredMessage);
                    }
                    if (object.imageMessage != null) {
                        if (typeof object.imageMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.imageMessage: object expected");
                        message.imageMessage = $root.proto.Message.ImageMessage.fromObject(object.imageMessage);
                    }
                    if (object.videoMessage != null) {
                        if (typeof object.videoMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.videoMessage: object expected");
                        message.videoMessage = $root.proto.Message.VideoMessage.fromObject(object.videoMessage);
                    }
                    if (object.locationMessage != null) {
                        if (typeof object.locationMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.FourRowTemplate.locationMessage: object expected");
                        message.locationMessage = $root.proto.Message.LocationMessage.fromObject(object.locationMessage);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FourRowTemplate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @static
                 * @param {proto.Message.TemplateMessage.FourRowTemplate} message FourRowTemplate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FourRowTemplate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.buttons = [];
                    if (options.defaults) {
                        object.content = null;
                        object.footer = null;
                    }
                    if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                        object.documentMessage = $root.proto.Message.DocumentMessage.toObject(message.documentMessage, options);
                        if (options.oneofs)
                            object.title = "documentMessage";
                    }
                    if (message.highlyStructuredMessage != null && message.hasOwnProperty("highlyStructuredMessage")) {
                        object.highlyStructuredMessage = $root.proto.Message.HighlyStructuredMessage.toObject(message.highlyStructuredMessage, options);
                        if (options.oneofs)
                            object.title = "highlyStructuredMessage";
                    }
                    if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                        object.imageMessage = $root.proto.Message.ImageMessage.toObject(message.imageMessage, options);
                        if (options.oneofs)
                            object.title = "imageMessage";
                    }
                    if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                        object.videoMessage = $root.proto.Message.VideoMessage.toObject(message.videoMessage, options);
                        if (options.oneofs)
                            object.title = "videoMessage";
                    }
                    if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                        object.locationMessage = $root.proto.Message.LocationMessage.toObject(message.locationMessage, options);
                        if (options.oneofs)
                            object.title = "locationMessage";
                    }
                    if (message.content != null && message.hasOwnProperty("content"))
                        object.content = $root.proto.Message.HighlyStructuredMessage.toObject(message.content, options);
                    if (message.footer != null && message.hasOwnProperty("footer"))
                        object.footer = $root.proto.Message.HighlyStructuredMessage.toObject(message.footer, options);
                    if (message.buttons && message.buttons.length) {
                        object.buttons = [];
                        for (var j = 0; j < message.buttons.length; ++j)
                            object.buttons[j] = $root.proto.TemplateButton.toObject(message.buttons[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this FourRowTemplate to JSON.
                 * @function toJSON
                 * @memberof proto.Message.TemplateMessage.FourRowTemplate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FourRowTemplate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FourRowTemplate;
            })();

            TemplateMessage.HydratedFourRowTemplate = (function() {

                /**
                 * Properties of a HydratedFourRowTemplate.
                 * @memberof proto.Message.TemplateMessage
                 * @interface IHydratedFourRowTemplate
                 * @property {string|null} [hydratedContentText] HydratedFourRowTemplate hydratedContentText
                 * @property {string|null} [hydratedFooterText] HydratedFourRowTemplate hydratedFooterText
                 * @property {Array.<proto.IHydratedTemplateButton>|null} [hydratedButtons] HydratedFourRowTemplate hydratedButtons
                 * @property {string|null} [templateId] HydratedFourRowTemplate templateId
                 * @property {proto.Message.IDocumentMessage|null} [documentMessage] HydratedFourRowTemplate documentMessage
                 * @property {string|null} [hydratedTitleText] HydratedFourRowTemplate hydratedTitleText
                 * @property {proto.Message.IImageMessage|null} [imageMessage] HydratedFourRowTemplate imageMessage
                 * @property {proto.Message.IVideoMessage|null} [videoMessage] HydratedFourRowTemplate videoMessage
                 * @property {proto.Message.ILocationMessage|null} [locationMessage] HydratedFourRowTemplate locationMessage
                 */

                /**
                 * Constructs a new HydratedFourRowTemplate.
                 * @memberof proto.Message.TemplateMessage
                 * @classdesc Represents a HydratedFourRowTemplate.
                 * @implements IHydratedFourRowTemplate
                 * @constructor
                 * @param {proto.Message.TemplateMessage.IHydratedFourRowTemplate=} [properties] Properties to set
                 */
                function HydratedFourRowTemplate(properties) {
                    this.hydratedButtons = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HydratedFourRowTemplate hydratedContentText.
                 * @member {string} hydratedContentText
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.hydratedContentText = "";

                /**
                 * HydratedFourRowTemplate hydratedFooterText.
                 * @member {string} hydratedFooterText
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.hydratedFooterText = "";

                /**
                 * HydratedFourRowTemplate hydratedButtons.
                 * @member {Array.<proto.IHydratedTemplateButton>} hydratedButtons
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.hydratedButtons = $util.emptyArray;

                /**
                 * HydratedFourRowTemplate templateId.
                 * @member {string} templateId
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.templateId = "";

                /**
                 * HydratedFourRowTemplate documentMessage.
                 * @member {proto.Message.IDocumentMessage|null|undefined} documentMessage
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.documentMessage = null;

                /**
                 * HydratedFourRowTemplate hydratedTitleText.
                 * @member {string|null|undefined} hydratedTitleText
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.hydratedTitleText = null;

                /**
                 * HydratedFourRowTemplate imageMessage.
                 * @member {proto.Message.IImageMessage|null|undefined} imageMessage
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.imageMessage = null;

                /**
                 * HydratedFourRowTemplate videoMessage.
                 * @member {proto.Message.IVideoMessage|null|undefined} videoMessage
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.videoMessage = null;

                /**
                 * HydratedFourRowTemplate locationMessage.
                 * @member {proto.Message.ILocationMessage|null|undefined} locationMessage
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                HydratedFourRowTemplate.prototype.locationMessage = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * HydratedFourRowTemplate title.
                 * @member {"documentMessage"|"hydratedTitleText"|"imageMessage"|"videoMessage"|"locationMessage"|undefined} title
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 */
                Object.defineProperty(HydratedFourRowTemplate.prototype, "title", {
                    get: $util.oneOfGetter($oneOfFields = ["documentMessage", "hydratedTitleText", "imageMessage", "videoMessage", "locationMessage"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new HydratedFourRowTemplate instance using the specified properties.
                 * @function create
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @static
                 * @param {proto.Message.TemplateMessage.IHydratedFourRowTemplate=} [properties] Properties to set
                 * @returns {proto.Message.TemplateMessage.HydratedFourRowTemplate} HydratedFourRowTemplate instance
                 */
                HydratedFourRowTemplate.create = function create(properties) {
                    return new HydratedFourRowTemplate(properties);
                };

                /**
                 * Encodes the specified HydratedFourRowTemplate message. Does not implicitly {@link proto.Message.TemplateMessage.HydratedFourRowTemplate.verify|verify} messages.
                 * @function encode
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @static
                 * @param {proto.Message.TemplateMessage.IHydratedFourRowTemplate} message HydratedFourRowTemplate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HydratedFourRowTemplate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.documentMessage != null && Object.hasOwnProperty.call(message, "documentMessage"))
                        $root.proto.Message.DocumentMessage.encode(message.documentMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.hydratedTitleText != null && Object.hasOwnProperty.call(message, "hydratedTitleText"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.hydratedTitleText);
                    if (message.imageMessage != null && Object.hasOwnProperty.call(message, "imageMessage"))
                        $root.proto.Message.ImageMessage.encode(message.imageMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.videoMessage != null && Object.hasOwnProperty.call(message, "videoMessage"))
                        $root.proto.Message.VideoMessage.encode(message.videoMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.locationMessage != null && Object.hasOwnProperty.call(message, "locationMessage"))
                        $root.proto.Message.LocationMessage.encode(message.locationMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.hydratedContentText != null && Object.hasOwnProperty.call(message, "hydratedContentText"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.hydratedContentText);
                    if (message.hydratedFooterText != null && Object.hasOwnProperty.call(message, "hydratedFooterText"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.hydratedFooterText);
                    if (message.hydratedButtons != null && message.hydratedButtons.length)
                        for (var i = 0; i < message.hydratedButtons.length; ++i)
                            $root.proto.HydratedTemplateButton.encode(message.hydratedButtons[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.templateId != null && Object.hasOwnProperty.call(message, "templateId"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.templateId);
                    return writer;
                };

                /**
                 * Encodes the specified HydratedFourRowTemplate message, length delimited. Does not implicitly {@link proto.Message.TemplateMessage.HydratedFourRowTemplate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @static
                 * @param {proto.Message.TemplateMessage.IHydratedFourRowTemplate} message HydratedFourRowTemplate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HydratedFourRowTemplate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a HydratedFourRowTemplate message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.Message.TemplateMessage.HydratedFourRowTemplate} HydratedFourRowTemplate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HydratedFourRowTemplate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.TemplateMessage.HydratedFourRowTemplate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 6:
                            message.hydratedContentText = reader.string();
                            break;
                        case 7:
                            message.hydratedFooterText = reader.string();
                            break;
                        case 8:
                            if (!(message.hydratedButtons && message.hydratedButtons.length))
                                message.hydratedButtons = [];
                            message.hydratedButtons.push($root.proto.HydratedTemplateButton.decode(reader, reader.uint32()));
                            break;
                        case 9:
                            message.templateId = reader.string();
                            break;
                        case 1:
                            message.documentMessage = $root.proto.Message.DocumentMessage.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.hydratedTitleText = reader.string();
                            break;
                        case 3:
                            message.imageMessage = $root.proto.Message.ImageMessage.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.videoMessage = $root.proto.Message.VideoMessage.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.locationMessage = $root.proto.Message.LocationMessage.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a HydratedFourRowTemplate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.Message.TemplateMessage.HydratedFourRowTemplate} HydratedFourRowTemplate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HydratedFourRowTemplate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a HydratedFourRowTemplate message.
                 * @function verify
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HydratedFourRowTemplate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.hydratedContentText != null && message.hasOwnProperty("hydratedContentText"))
                        if (!$util.isString(message.hydratedContentText))
                            return "hydratedContentText: string expected";
                    if (message.hydratedFooterText != null && message.hasOwnProperty("hydratedFooterText"))
                        if (!$util.isString(message.hydratedFooterText))
                            return "hydratedFooterText: string expected";
                    if (message.hydratedButtons != null && message.hasOwnProperty("hydratedButtons")) {
                        if (!Array.isArray(message.hydratedButtons))
                            return "hydratedButtons: array expected";
                        for (var i = 0; i < message.hydratedButtons.length; ++i) {
                            var error = $root.proto.HydratedTemplateButton.verify(message.hydratedButtons[i]);
                            if (error)
                                return "hydratedButtons." + error;
                        }
                    }
                    if (message.templateId != null && message.hasOwnProperty("templateId"))
                        if (!$util.isString(message.templateId))
                            return "templateId: string expected";
                    if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.DocumentMessage.verify(message.documentMessage);
                            if (error)
                                return "documentMessage." + error;
                        }
                    }
                    if (message.hydratedTitleText != null && message.hasOwnProperty("hydratedTitleText")) {
                        if (properties.title === 1)
                            return "title: multiple values";
                        properties.title = 1;
                        if (!$util.isString(message.hydratedTitleText))
                            return "hydratedTitleText: string expected";
                    }
                    if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                        if (properties.title === 1)
                            return "title: multiple values";
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.ImageMessage.verify(message.imageMessage);
                            if (error)
                                return "imageMessage." + error;
                        }
                    }
                    if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                        if (properties.title === 1)
                            return "title: multiple values";
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.VideoMessage.verify(message.videoMessage);
                            if (error)
                                return "videoMessage." + error;
                        }
                    }
                    if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                        if (properties.title === 1)
                            return "title: multiple values";
                        properties.title = 1;
                        {
                            var error = $root.proto.Message.LocationMessage.verify(message.locationMessage);
                            if (error)
                                return "locationMessage." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a HydratedFourRowTemplate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.Message.TemplateMessage.HydratedFourRowTemplate} HydratedFourRowTemplate
                 */
                HydratedFourRowTemplate.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.Message.TemplateMessage.HydratedFourRowTemplate)
                        return object;
                    var message = new $root.proto.Message.TemplateMessage.HydratedFourRowTemplate();
                    if (object.hydratedContentText != null)
                        message.hydratedContentText = String(object.hydratedContentText);
                    if (object.hydratedFooterText != null)
                        message.hydratedFooterText = String(object.hydratedFooterText);
                    if (object.hydratedButtons) {
                        if (!Array.isArray(object.hydratedButtons))
                            throw TypeError(".proto.Message.TemplateMessage.HydratedFourRowTemplate.hydratedButtons: array expected");
                        message.hydratedButtons = [];
                        for (var i = 0; i < object.hydratedButtons.length; ++i) {
                            if (typeof object.hydratedButtons[i] !== "object")
                                throw TypeError(".proto.Message.TemplateMessage.HydratedFourRowTemplate.hydratedButtons: object expected");
                            message.hydratedButtons[i] = $root.proto.HydratedTemplateButton.fromObject(object.hydratedButtons[i]);
                        }
                    }
                    if (object.templateId != null)
                        message.templateId = String(object.templateId);
                    if (object.documentMessage != null) {
                        if (typeof object.documentMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.HydratedFourRowTemplate.documentMessage: object expected");
                        message.documentMessage = $root.proto.Message.DocumentMessage.fromObject(object.documentMessage);
                    }
                    if (object.hydratedTitleText != null)
                        message.hydratedTitleText = String(object.hydratedTitleText);
                    if (object.imageMessage != null) {
                        if (typeof object.imageMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.HydratedFourRowTemplate.imageMessage: object expected");
                        message.imageMessage = $root.proto.Message.ImageMessage.fromObject(object.imageMessage);
                    }
                    if (object.videoMessage != null) {
                        if (typeof object.videoMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.HydratedFourRowTemplate.videoMessage: object expected");
                        message.videoMessage = $root.proto.Message.VideoMessage.fromObject(object.videoMessage);
                    }
                    if (object.locationMessage != null) {
                        if (typeof object.locationMessage !== "object")
                            throw TypeError(".proto.Message.TemplateMessage.HydratedFourRowTemplate.locationMessage: object expected");
                        message.locationMessage = $root.proto.Message.LocationMessage.fromObject(object.locationMessage);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a HydratedFourRowTemplate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @static
                 * @param {proto.Message.TemplateMessage.HydratedFourRowTemplate} message HydratedFourRowTemplate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HydratedFourRowTemplate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.hydratedButtons = [];
                    if (options.defaults) {
                        object.hydratedContentText = "";
                        object.hydratedFooterText = "";
                        object.templateId = "";
                    }
                    if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                        object.documentMessage = $root.proto.Message.DocumentMessage.toObject(message.documentMessage, options);
                        if (options.oneofs)
                            object.title = "documentMessage";
                    }
                    if (message.hydratedTitleText != null && message.hasOwnProperty("hydratedTitleText")) {
                        object.hydratedTitleText = message.hydratedTitleText;
                        if (options.oneofs)
                            object.title = "hydratedTitleText";
                    }
                    if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                        object.imageMessage = $root.proto.Message.ImageMessage.toObject(message.imageMessage, options);
                        if (options.oneofs)
                            object.title = "imageMessage";
                    }
                    if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                        object.videoMessage = $root.proto.Message.VideoMessage.toObject(message.videoMessage, options);
                        if (options.oneofs)
                            object.title = "videoMessage";
                    }
                    if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                        object.locationMessage = $root.proto.Message.LocationMessage.toObject(message.locationMessage, options);
                        if (options.oneofs)
                            object.title = "locationMessage";
                    }
                    if (message.hydratedContentText != null && message.hasOwnProperty("hydratedContentText"))
                        object.hydratedContentText = message.hydratedContentText;
                    if (message.hydratedFooterText != null && message.hasOwnProperty("hydratedFooterText"))
                        object.hydratedFooterText = message.hydratedFooterText;
                    if (message.hydratedButtons && message.hydratedButtons.length) {
                        object.hydratedButtons = [];
                        for (var j = 0; j < message.hydratedButtons.length; ++j)
                            object.hydratedButtons[j] = $root.proto.HydratedTemplateButton.toObject(message.hydratedButtons[j], options);
                    }
                    if (message.templateId != null && message.hasOwnProperty("templateId"))
                        object.templateId = message.templateId;
                    return object;
                };

                /**
                 * Converts this HydratedFourRowTemplate to JSON.
                 * @function toJSON
                 * @memberof proto.Message.TemplateMessage.HydratedFourRowTemplate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HydratedFourRowTemplate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HydratedFourRowTemplate;
            })();

            return TemplateMessage;
        })();

        Message.VideoMessage = (function() {

            /**
             * Properties of a VideoMessage.
             * @memberof proto.Message
             * @interface IVideoMessage
             * @property {string|null} [url] VideoMessage url
             * @property {string|null} [mimetype] VideoMessage mimetype
             * @property {Uint8Array|null} [fileSha256] VideoMessage fileSha256
             * @property {number|Long|null} [fileLength] VideoMessage fileLength
             * @property {number|null} [seconds] VideoMessage seconds
             * @property {Uint8Array|null} [mediaKey] VideoMessage mediaKey
             * @property {string|null} [caption] VideoMessage caption
             * @property {boolean|null} [gifPlayback] VideoMessage gifPlayback
             * @property {number|null} [height] VideoMessage height
             * @property {number|null} [width] VideoMessage width
             * @property {Uint8Array|null} [fileEncSha256] VideoMessage fileEncSha256
             * @property {Array.<proto.IInteractiveAnnotation>|null} [interactiveAnnotations] VideoMessage interactiveAnnotations
             * @property {string|null} [directPath] VideoMessage directPath
             * @property {number|Long|null} [mediaKeyTimestamp] VideoMessage mediaKeyTimestamp
             * @property {Uint8Array|null} [jpegThumbnail] VideoMessage jpegThumbnail
             * @property {proto.IContextInfo|null} [contextInfo] VideoMessage contextInfo
             * @property {Uint8Array|null} [streamingSidecar] VideoMessage streamingSidecar
             * @property {proto.Message.VideoMessage.Attribution|null} [gifAttribution] VideoMessage gifAttribution
             * @property {boolean|null} [viewOnce] VideoMessage viewOnce
             * @property {string|null} [thumbnailDirectPath] VideoMessage thumbnailDirectPath
             * @property {Uint8Array|null} [thumbnailSha256] VideoMessage thumbnailSha256
             * @property {Uint8Array|null} [thumbnailEncSha256] VideoMessage thumbnailEncSha256
             * @property {string|null} [staticUrl] VideoMessage staticUrl
             */

            /**
             * Constructs a new VideoMessage.
             * @memberof proto.Message
             * @classdesc Represents a VideoMessage.
             * @implements IVideoMessage
             * @constructor
             * @param {proto.Message.IVideoMessage=} [properties] Properties to set
             */
            function VideoMessage(properties) {
                this.interactiveAnnotations = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VideoMessage url.
             * @member {string} url
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.url = "";

            /**
             * VideoMessage mimetype.
             * @member {string} mimetype
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.mimetype = "";

            /**
             * VideoMessage fileSha256.
             * @member {Uint8Array} fileSha256
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.fileSha256 = $util.newBuffer([]);

            /**
             * VideoMessage fileLength.
             * @member {number|Long} fileLength
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * VideoMessage seconds.
             * @member {number} seconds
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.seconds = 0;

            /**
             * VideoMessage mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.mediaKey = $util.newBuffer([]);

            /**
             * VideoMessage caption.
             * @member {string} caption
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.caption = "";

            /**
             * VideoMessage gifPlayback.
             * @member {boolean} gifPlayback
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.gifPlayback = false;

            /**
             * VideoMessage height.
             * @member {number} height
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.height = 0;

            /**
             * VideoMessage width.
             * @member {number} width
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.width = 0;

            /**
             * VideoMessage fileEncSha256.
             * @member {Uint8Array} fileEncSha256
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.fileEncSha256 = $util.newBuffer([]);

            /**
             * VideoMessage interactiveAnnotations.
             * @member {Array.<proto.IInteractiveAnnotation>} interactiveAnnotations
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.interactiveAnnotations = $util.emptyArray;

            /**
             * VideoMessage directPath.
             * @member {string} directPath
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.directPath = "";

            /**
             * VideoMessage mediaKeyTimestamp.
             * @member {number|Long} mediaKeyTimestamp
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * VideoMessage jpegThumbnail.
             * @member {Uint8Array} jpegThumbnail
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.jpegThumbnail = $util.newBuffer([]);

            /**
             * VideoMessage contextInfo.
             * @member {proto.IContextInfo|null|undefined} contextInfo
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.contextInfo = null;

            /**
             * VideoMessage streamingSidecar.
             * @member {Uint8Array} streamingSidecar
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.streamingSidecar = $util.newBuffer([]);

            /**
             * VideoMessage gifAttribution.
             * @member {proto.Message.VideoMessage.Attribution} gifAttribution
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.gifAttribution = 0;

            /**
             * VideoMessage viewOnce.
             * @member {boolean} viewOnce
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.viewOnce = false;

            /**
             * VideoMessage thumbnailDirectPath.
             * @member {string} thumbnailDirectPath
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.thumbnailDirectPath = "";

            /**
             * VideoMessage thumbnailSha256.
             * @member {Uint8Array} thumbnailSha256
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.thumbnailSha256 = $util.newBuffer([]);

            /**
             * VideoMessage thumbnailEncSha256.
             * @member {Uint8Array} thumbnailEncSha256
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.thumbnailEncSha256 = $util.newBuffer([]);

            /**
             * VideoMessage staticUrl.
             * @member {string} staticUrl
             * @memberof proto.Message.VideoMessage
             * @instance
             */
            VideoMessage.prototype.staticUrl = "";

            /**
             * Creates a new VideoMessage instance using the specified properties.
             * @function create
             * @memberof proto.Message.VideoMessage
             * @static
             * @param {proto.Message.IVideoMessage=} [properties] Properties to set
             * @returns {proto.Message.VideoMessage} VideoMessage instance
             */
            VideoMessage.create = function create(properties) {
                return new VideoMessage(properties);
            };

            /**
             * Encodes the specified VideoMessage message. Does not implicitly {@link proto.Message.VideoMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.Message.VideoMessage
             * @static
             * @param {proto.Message.IVideoMessage} message VideoMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimetype);
                if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileSha256);
                if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileLength);
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.seconds);
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.mediaKey);
                if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.caption);
                if (message.gifPlayback != null && Object.hasOwnProperty.call(message, "gifPlayback"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.gifPlayback);
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.height);
                if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.width);
                if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.fileEncSha256);
                if (message.interactiveAnnotations != null && message.interactiveAnnotations.length)
                    for (var i = 0; i < message.interactiveAnnotations.length; ++i)
                        $root.proto.InteractiveAnnotation.encode(message.interactiveAnnotations[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.directPath);
                if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.mediaKeyTimestamp);
                if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
                if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                    $root.proto.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.streamingSidecar != null && Object.hasOwnProperty.call(message, "streamingSidecar"))
                    writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.streamingSidecar);
                if (message.gifAttribution != null && Object.hasOwnProperty.call(message, "gifAttribution"))
                    writer.uint32(/* id 19, wireType 0 =*/152).int32(message.gifAttribution);
                if (message.viewOnce != null && Object.hasOwnProperty.call(message, "viewOnce"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.viewOnce);
                if (message.thumbnailDirectPath != null && Object.hasOwnProperty.call(message, "thumbnailDirectPath"))
                    writer.uint32(/* id 21, wireType 2 =*/170).string(message.thumbnailDirectPath);
                if (message.thumbnailSha256 != null && Object.hasOwnProperty.call(message, "thumbnailSha256"))
                    writer.uint32(/* id 22, wireType 2 =*/178).bytes(message.thumbnailSha256);
                if (message.thumbnailEncSha256 != null && Object.hasOwnProperty.call(message, "thumbnailEncSha256"))
                    writer.uint32(/* id 23, wireType 2 =*/186).bytes(message.thumbnailEncSha256);
                if (message.staticUrl != null && Object.hasOwnProperty.call(message, "staticUrl"))
                    writer.uint32(/* id 24, wireType 2 =*/194).string(message.staticUrl);
                return writer;
            };

            /**
             * Encodes the specified VideoMessage message, length delimited. Does not implicitly {@link proto.Message.VideoMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Message.VideoMessage
             * @static
             * @param {proto.Message.IVideoMessage} message VideoMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VideoMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Message.VideoMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Message.VideoMessage} VideoMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Message.VideoMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        message.mimetype = reader.string();
                        break;
                    case 3:
                        message.fileSha256 = reader.bytes();
                        break;
                    case 4:
                        message.fileLength = reader.uint64();
                        break;
                    case 5:
                        message.seconds = reader.uint32();
                        break;
                    case 6:
                        message.mediaKey = reader.bytes();
                        break;
                    case 7:
                        message.caption = reader.string();
                        break;
                    case 8:
                        message.gifPlayback = reader.bool();
                        break;
                    case 9:
                        message.height = reader.uint32();
                        break;
                    case 10:
                        message.width = reader.uint32();
                        break;
                    case 11:
                        message.fileEncSha256 = reader.bytes();
                        break;
                    case 12:
                        if (!(message.interactiveAnnotations && message.interactiveAnnotations.length))
                            message.interactiveAnnotations = [];
                        message.interactiveAnnotations.push($root.proto.InteractiveAnnotation.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        message.directPath = reader.string();
                        break;
                    case 14:
                        message.mediaKeyTimestamp = reader.int64();
                        break;
                    case 16:
                        message.jpegThumbnail = reader.bytes();
                        break;
                    case 17:
                        message.contextInfo = $root.proto.ContextInfo.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.streamingSidecar = reader.bytes();
                        break;
                    case 19:
                        message.gifAttribution = reader.int32();
                        break;
                    case 20:
                        message.viewOnce = reader.bool();
                        break;
                    case 21:
                        message.thumbnailDirectPath = reader.string();
                        break;
                    case 22:
                        message.thumbnailSha256 = reader.bytes();
                        break;
                    case 23:
                        message.thumbnailEncSha256 = reader.bytes();
                        break;
                    case 24:
                        message.staticUrl = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VideoMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Message.VideoMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Message.VideoMessage} VideoMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VideoMessage message.
             * @function verify
             * @memberof proto.Message.VideoMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VideoMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    if (!$util.isString(message.mimetype))
                        return "mimetype: string expected";
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                        return "fileSha256: buffer expected";
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                        return "fileLength: integer|Long expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds))
                        return "seconds: integer expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.caption != null && message.hasOwnProperty("caption"))
                    if (!$util.isString(message.caption))
                        return "caption: string expected";
                if (message.gifPlayback != null && message.hasOwnProperty("gifPlayback"))
                    if (typeof message.gifPlayback !== "boolean")
                        return "gifPlayback: boolean expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height))
                        return "height: integer expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                        return "fileEncSha256: buffer expected";
                if (message.interactiveAnnotations != null && message.hasOwnProperty("interactiveAnnotations")) {
                    if (!Array.isArray(message.interactiveAnnotations))
                        return "interactiveAnnotations: array expected";
                    for (var i = 0; i < message.interactiveAnnotations.length; ++i) {
                        var error = $root.proto.InteractiveAnnotation.verify(message.interactiveAnnotations[i]);
                        if (error)
                            return "interactiveAnnotations." + error;
                    }
                }
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    if (!$util.isString(message.directPath))
                        return "directPath: string expected";
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                        return "mediaKeyTimestamp: integer|Long expected";
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                        return "jpegThumbnail: buffer expected";
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                    var error = $root.proto.ContextInfo.verify(message.contextInfo);
                    if (error)
                        return "contextInfo." + error;
                }
                if (message.streamingSidecar != null && message.hasOwnProperty("streamingSidecar"))
                    if (!(message.streamingSidecar && typeof message.streamingSidecar.length === "number" || $util.isString(message.streamingSidecar)))
                        return "streamingSidecar: buffer expected";
                if (message.gifAttribution != null && message.hasOwnProperty("gifAttribution"))
                    switch (message.gifAttribution) {
                    default:
                        return "gifAttribution: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.viewOnce != null && message.hasOwnProperty("viewOnce"))
                    if (typeof message.viewOnce !== "boolean")
                        return "viewOnce: boolean expected";
                if (message.thumbnailDirectPath != null && message.hasOwnProperty("thumbnailDirectPath"))
                    if (!$util.isString(message.thumbnailDirectPath))
                        return "thumbnailDirectPath: string expected";
                if (message.thumbnailSha256 != null && message.hasOwnProperty("thumbnailSha256"))
                    if (!(message.thumbnailSha256 && typeof message.thumbnailSha256.length === "number" || $util.isString(message.thumbnailSha256)))
                        return "thumbnailSha256: buffer expected";
                if (message.thumbnailEncSha256 != null && message.hasOwnProperty("thumbnailEncSha256"))
                    if (!(message.thumbnailEncSha256 && typeof message.thumbnailEncSha256.length === "number" || $util.isString(message.thumbnailEncSha256)))
                        return "thumbnailEncSha256: buffer expected";
                if (message.staticUrl != null && message.hasOwnProperty("staticUrl"))
                    if (!$util.isString(message.staticUrl))
                        return "staticUrl: string expected";
                return null;
            };

            /**
             * Creates a VideoMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Message.VideoMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Message.VideoMessage} VideoMessage
             */
            VideoMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Message.VideoMessage)
                    return object;
                var message = new $root.proto.Message.VideoMessage();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.mimetype != null)
                    message.mimetype = String(object.mimetype);
                if (object.fileSha256 != null)
                    if (typeof object.fileSha256 === "string")
                        $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                    else if (object.fileSha256.length)
                        message.fileSha256 = object.fileSha256;
                if (object.fileLength != null)
                    if ($util.Long)
                        (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                    else if (typeof object.fileLength === "string")
                        message.fileLength = parseInt(object.fileLength, 10);
                    else if (typeof object.fileLength === "number")
                        message.fileLength = object.fileLength;
                    else if (typeof object.fileLength === "object")
                        message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
                if (object.seconds != null)
                    message.seconds = object.seconds >>> 0;
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.caption != null)
                    message.caption = String(object.caption);
                if (object.gifPlayback != null)
                    message.gifPlayback = Boolean(object.gifPlayback);
                if (object.height != null)
                    message.height = object.height >>> 0;
                if (object.width != null)
                    message.width = object.width >>> 0;
                if (object.fileEncSha256 != null)
                    if (typeof object.fileEncSha256 === "string")
                        $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                    else if (object.fileEncSha256.length)
                        message.fileEncSha256 = object.fileEncSha256;
                if (object.interactiveAnnotations) {
                    if (!Array.isArray(object.interactiveAnnotations))
                        throw TypeError(".proto.Message.VideoMessage.interactiveAnnotations: array expected");
                    message.interactiveAnnotations = [];
                    for (var i = 0; i < object.interactiveAnnotations.length; ++i) {
                        if (typeof object.interactiveAnnotations[i] !== "object")
                            throw TypeError(".proto.Message.VideoMessage.interactiveAnnotations: object expected");
                        message.interactiveAnnotations[i] = $root.proto.InteractiveAnnotation.fromObject(object.interactiveAnnotations[i]);
                    }
                }
                if (object.directPath != null)
                    message.directPath = String(object.directPath);
                if (object.mediaKeyTimestamp != null)
                    if ($util.Long)
                        (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                    else if (typeof object.mediaKeyTimestamp === "string")
                        message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                    else if (typeof object.mediaKeyTimestamp === "number")
                        message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                    else if (typeof object.mediaKeyTimestamp === "object")
                        message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
                if (object.jpegThumbnail != null)
                    if (typeof object.jpegThumbnail === "string")
                        $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                    else if (object.jpegThumbnail.length)
                        message.jpegThumbnail = object.jpegThumbnail;
                if (object.contextInfo != null) {
                    if (typeof object.contextInfo !== "object")
                        throw TypeError(".proto.Message.VideoMessage.contextInfo: object expected");
                    message.contextInfo = $root.proto.ContextInfo.fromObject(object.contextInfo);
                }
                if (object.streamingSidecar != null)
                    if (typeof object.streamingSidecar === "string")
                        $util.base64.decode(object.streamingSidecar, message.streamingSidecar = $util.newBuffer($util.base64.length(object.streamingSidecar)), 0);
                    else if (object.streamingSidecar.length)
                        message.streamingSidecar = object.streamingSidecar;
                switch (object.gifAttribution) {
                case "NONE":
                case 0:
                    message.gifAttribution = 0;
                    break;
                case "GIPHY":
                case 1:
                    message.gifAttribution = 1;
                    break;
                case "TENOR":
                case 2:
                    message.gifAttribution = 2;
                    break;
                }
                if (object.viewOnce != null)
                    message.viewOnce = Boolean(object.viewOnce);
                if (object.thumbnailDirectPath != null)
                    message.thumbnailDirectPath = String(object.thumbnailDirectPath);
                if (object.thumbnailSha256 != null)
                    if (typeof object.thumbnailSha256 === "string")
                        $util.base64.decode(object.thumbnailSha256, message.thumbnailSha256 = $util.newBuffer($util.base64.length(object.thumbnailSha256)), 0);
                    else if (object.thumbnailSha256.length)
                        message.thumbnailSha256 = object.thumbnailSha256;
                if (object.thumbnailEncSha256 != null)
                    if (typeof object.thumbnailEncSha256 === "string")
                        $util.base64.decode(object.thumbnailEncSha256, message.thumbnailEncSha256 = $util.newBuffer($util.base64.length(object.thumbnailEncSha256)), 0);
                    else if (object.thumbnailEncSha256.length)
                        message.thumbnailEncSha256 = object.thumbnailEncSha256;
                if (object.staticUrl != null)
                    message.staticUrl = String(object.staticUrl);
                return message;
            };

            /**
             * Creates a plain object from a VideoMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Message.VideoMessage
             * @static
             * @param {proto.Message.VideoMessage} message VideoMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VideoMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.interactiveAnnotations = [];
                if (options.defaults) {
                    object.url = "";
                    object.mimetype = "";
                    if (options.bytes === String)
                        object.fileSha256 = "";
                    else {
                        object.fileSha256 = [];
                        if (options.bytes !== Array)
                            object.fileSha256 = $util.newBuffer(object.fileSha256);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileLength = options.longs === String ? "0" : 0;
                    object.seconds = 0;
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    object.caption = "";
                    object.gifPlayback = false;
                    object.height = 0;
                    object.width = 0;
                    if (options.bytes === String)
                        object.fileEncSha256 = "";
                    else {
                        object.fileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                    }
                    object.directPath = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.jpegThumbnail = "";
                    else {
                        object.jpegThumbnail = [];
                        if (options.bytes !== Array)
                            object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                    }
                    object.contextInfo = null;
                    if (options.bytes === String)
                        object.streamingSidecar = "";
                    else {
                        object.streamingSidecar = [];
                        if (options.bytes !== Array)
                            object.streamingSidecar = $util.newBuffer(object.streamingSidecar);
                    }
                    object.gifAttribution = options.enums === String ? "NONE" : 0;
                    object.viewOnce = false;
                    object.thumbnailDirectPath = "";
                    if (options.bytes === String)
                        object.thumbnailSha256 = "";
                    else {
                        object.thumbnailSha256 = [];
                        if (options.bytes !== Array)
                            object.thumbnailSha256 = $util.newBuffer(object.thumbnailSha256);
                    }
                    if (options.bytes === String)
                        object.thumbnailEncSha256 = "";
                    else {
                        object.thumbnailEncSha256 = [];
                        if (options.bytes !== Array)
                            object.thumbnailEncSha256 = $util.newBuffer(object.thumbnailEncSha256);
                    }
                    object.staticUrl = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    object.mimetype = message.mimetype;
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (typeof message.fileLength === "number")
                        object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                    else
                        object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    object.seconds = message.seconds;
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.caption != null && message.hasOwnProperty("caption"))
                    object.caption = message.caption;
                if (message.gifPlayback != null && message.hasOwnProperty("gifPlayback"))
                    object.gifPlayback = message.gifPlayback;
                if (message.height != null && message.hasOwnProperty("height"))
                    object.height = message.height;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = message.width;
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
                if (message.interactiveAnnotations && message.interactiveAnnotations.length) {
                    object.interactiveAnnotations = [];
                    for (var j = 0; j < message.interactiveAnnotations.length; ++j)
                        object.interactiveAnnotations[j] = $root.proto.InteractiveAnnotation.toObject(message.interactiveAnnotations[j], options);
                }
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    object.directPath = message.directPath;
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (typeof message.mediaKeyTimestamp === "number")
                        object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                    else
                        object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
                if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                    object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
                if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                    object.contextInfo = $root.proto.ContextInfo.toObject(message.contextInfo, options);
                if (message.streamingSidecar != null && message.hasOwnProperty("streamingSidecar"))
                    object.streamingSidecar = options.bytes === String ? $util.base64.encode(message.streamingSidecar, 0, message.streamingSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.streamingSidecar) : message.streamingSidecar;
                if (message.gifAttribution != null && message.hasOwnProperty("gifAttribution"))
                    object.gifAttribution = options.enums === String ? $root.proto.Message.VideoMessage.Attribution[message.gifAttribution] : message.gifAttribution;
                if (message.viewOnce != null && message.hasOwnProperty("viewOnce"))
                    object.viewOnce = message.viewOnce;
                if (message.thumbnailDirectPath != null && message.hasOwnProperty("thumbnailDirectPath"))
                    object.thumbnailDirectPath = message.thumbnailDirectPath;
                if (message.thumbnailSha256 != null && message.hasOwnProperty("thumbnailSha256"))
                    object.thumbnailSha256 = options.bytes === String ? $util.base64.encode(message.thumbnailSha256, 0, message.thumbnailSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnailSha256) : message.thumbnailSha256;
                if (message.thumbnailEncSha256 != null && message.hasOwnProperty("thumbnailEncSha256"))
                    object.thumbnailEncSha256 = options.bytes === String ? $util.base64.encode(message.thumbnailEncSha256, 0, message.thumbnailEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.thumbnailEncSha256) : message.thumbnailEncSha256;
                if (message.staticUrl != null && message.hasOwnProperty("staticUrl"))
                    object.staticUrl = message.staticUrl;
                return object;
            };

            /**
             * Converts this VideoMessage to JSON.
             * @function toJSON
             * @memberof proto.Message.VideoMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VideoMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Attribution enum.
             * @name proto.Message.VideoMessage.Attribution
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} GIPHY=1 GIPHY value
             * @property {number} TENOR=2 TENOR value
             */
            VideoMessage.Attribution = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "GIPHY"] = 1;
                values[valuesById[2] = "TENOR"] = 2;
                return values;
            })();

            return VideoMessage;
        })();

        return Message;
    })();

    proto.MessageContextInfo = (function() {

        /**
         * Properties of a MessageContextInfo.
         * @memberof proto
         * @interface IMessageContextInfo
         * @property {proto.IDeviceListMetadata|null} [deviceListMetadata] MessageContextInfo deviceListMetadata
         * @property {number|null} [deviceListMetadataVersion] MessageContextInfo deviceListMetadataVersion
         * @property {Uint8Array|null} [messageSecret] MessageContextInfo messageSecret
         * @property {Uint8Array|null} [paddingBytes] MessageContextInfo paddingBytes
         */

        /**
         * Constructs a new MessageContextInfo.
         * @memberof proto
         * @classdesc Represents a MessageContextInfo.
         * @implements IMessageContextInfo
         * @constructor
         * @param {proto.IMessageContextInfo=} [properties] Properties to set
         */
        function MessageContextInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageContextInfo deviceListMetadata.
         * @member {proto.IDeviceListMetadata|null|undefined} deviceListMetadata
         * @memberof proto.MessageContextInfo
         * @instance
         */
        MessageContextInfo.prototype.deviceListMetadata = null;

        /**
         * MessageContextInfo deviceListMetadataVersion.
         * @member {number} deviceListMetadataVersion
         * @memberof proto.MessageContextInfo
         * @instance
         */
        MessageContextInfo.prototype.deviceListMetadataVersion = 0;

        /**
         * MessageContextInfo messageSecret.
         * @member {Uint8Array} messageSecret
         * @memberof proto.MessageContextInfo
         * @instance
         */
        MessageContextInfo.prototype.messageSecret = $util.newBuffer([]);

        /**
         * MessageContextInfo paddingBytes.
         * @member {Uint8Array} paddingBytes
         * @memberof proto.MessageContextInfo
         * @instance
         */
        MessageContextInfo.prototype.paddingBytes = $util.newBuffer([]);

        /**
         * Creates a new MessageContextInfo instance using the specified properties.
         * @function create
         * @memberof proto.MessageContextInfo
         * @static
         * @param {proto.IMessageContextInfo=} [properties] Properties to set
         * @returns {proto.MessageContextInfo} MessageContextInfo instance
         */
        MessageContextInfo.create = function create(properties) {
            return new MessageContextInfo(properties);
        };

        /**
         * Encodes the specified MessageContextInfo message. Does not implicitly {@link proto.MessageContextInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.MessageContextInfo
         * @static
         * @param {proto.IMessageContextInfo} message MessageContextInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageContextInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceListMetadata != null && Object.hasOwnProperty.call(message, "deviceListMetadata"))
                $root.proto.DeviceListMetadata.encode(message.deviceListMetadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.deviceListMetadataVersion != null && Object.hasOwnProperty.call(message, "deviceListMetadataVersion"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.deviceListMetadataVersion);
            if (message.messageSecret != null && Object.hasOwnProperty.call(message, "messageSecret"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.messageSecret);
            if (message.paddingBytes != null && Object.hasOwnProperty.call(message, "paddingBytes"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.paddingBytes);
            return writer;
        };

        /**
         * Encodes the specified MessageContextInfo message, length delimited. Does not implicitly {@link proto.MessageContextInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.MessageContextInfo
         * @static
         * @param {proto.IMessageContextInfo} message MessageContextInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageContextInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageContextInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MessageContextInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MessageContextInfo} MessageContextInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageContextInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MessageContextInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceListMetadata = $root.proto.DeviceListMetadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.deviceListMetadataVersion = reader.int32();
                    break;
                case 3:
                    message.messageSecret = reader.bytes();
                    break;
                case 4:
                    message.paddingBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageContextInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.MessageContextInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.MessageContextInfo} MessageContextInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageContextInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageContextInfo message.
         * @function verify
         * @memberof proto.MessageContextInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageContextInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceListMetadata != null && message.hasOwnProperty("deviceListMetadata")) {
                var error = $root.proto.DeviceListMetadata.verify(message.deviceListMetadata);
                if (error)
                    return "deviceListMetadata." + error;
            }
            if (message.deviceListMetadataVersion != null && message.hasOwnProperty("deviceListMetadataVersion"))
                if (!$util.isInteger(message.deviceListMetadataVersion))
                    return "deviceListMetadataVersion: integer expected";
            if (message.messageSecret != null && message.hasOwnProperty("messageSecret"))
                if (!(message.messageSecret && typeof message.messageSecret.length === "number" || $util.isString(message.messageSecret)))
                    return "messageSecret: buffer expected";
            if (message.paddingBytes != null && message.hasOwnProperty("paddingBytes"))
                if (!(message.paddingBytes && typeof message.paddingBytes.length === "number" || $util.isString(message.paddingBytes)))
                    return "paddingBytes: buffer expected";
            return null;
        };

        /**
         * Creates a MessageContextInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.MessageContextInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.MessageContextInfo} MessageContextInfo
         */
        MessageContextInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.MessageContextInfo)
                return object;
            var message = new $root.proto.MessageContextInfo();
            if (object.deviceListMetadata != null) {
                if (typeof object.deviceListMetadata !== "object")
                    throw TypeError(".proto.MessageContextInfo.deviceListMetadata: object expected");
                message.deviceListMetadata = $root.proto.DeviceListMetadata.fromObject(object.deviceListMetadata);
            }
            if (object.deviceListMetadataVersion != null)
                message.deviceListMetadataVersion = object.deviceListMetadataVersion | 0;
            if (object.messageSecret != null)
                if (typeof object.messageSecret === "string")
                    $util.base64.decode(object.messageSecret, message.messageSecret = $util.newBuffer($util.base64.length(object.messageSecret)), 0);
                else if (object.messageSecret.length)
                    message.messageSecret = object.messageSecret;
            if (object.paddingBytes != null)
                if (typeof object.paddingBytes === "string")
                    $util.base64.decode(object.paddingBytes, message.paddingBytes = $util.newBuffer($util.base64.length(object.paddingBytes)), 0);
                else if (object.paddingBytes.length)
                    message.paddingBytes = object.paddingBytes;
            return message;
        };

        /**
         * Creates a plain object from a MessageContextInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.MessageContextInfo
         * @static
         * @param {proto.MessageContextInfo} message MessageContextInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageContextInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.deviceListMetadata = null;
                object.deviceListMetadataVersion = 0;
                if (options.bytes === String)
                    object.messageSecret = "";
                else {
                    object.messageSecret = [];
                    if (options.bytes !== Array)
                        object.messageSecret = $util.newBuffer(object.messageSecret);
                }
                if (options.bytes === String)
                    object.paddingBytes = "";
                else {
                    object.paddingBytes = [];
                    if (options.bytes !== Array)
                        object.paddingBytes = $util.newBuffer(object.paddingBytes);
                }
            }
            if (message.deviceListMetadata != null && message.hasOwnProperty("deviceListMetadata"))
                object.deviceListMetadata = $root.proto.DeviceListMetadata.toObject(message.deviceListMetadata, options);
            if (message.deviceListMetadataVersion != null && message.hasOwnProperty("deviceListMetadataVersion"))
                object.deviceListMetadataVersion = message.deviceListMetadataVersion;
            if (message.messageSecret != null && message.hasOwnProperty("messageSecret"))
                object.messageSecret = options.bytes === String ? $util.base64.encode(message.messageSecret, 0, message.messageSecret.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSecret) : message.messageSecret;
            if (message.paddingBytes != null && message.hasOwnProperty("paddingBytes"))
                object.paddingBytes = options.bytes === String ? $util.base64.encode(message.paddingBytes, 0, message.paddingBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.paddingBytes) : message.paddingBytes;
            return object;
        };

        /**
         * Converts this MessageContextInfo to JSON.
         * @function toJSON
         * @memberof proto.MessageContextInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageContextInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageContextInfo;
    })();

    proto.MessageKey = (function() {

        /**
         * Properties of a MessageKey.
         * @memberof proto
         * @interface IMessageKey
         * @property {string|null} [remoteJid] MessageKey remoteJid
         * @property {boolean|null} [fromMe] MessageKey fromMe
         * @property {string|null} [id] MessageKey id
         * @property {string|null} [participant] MessageKey participant
         */

        /**
         * Constructs a new MessageKey.
         * @memberof proto
         * @classdesc Represents a MessageKey.
         * @implements IMessageKey
         * @constructor
         * @param {proto.IMessageKey=} [properties] Properties to set
         */
        function MessageKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageKey remoteJid.
         * @member {string} remoteJid
         * @memberof proto.MessageKey
         * @instance
         */
        MessageKey.prototype.remoteJid = "";

        /**
         * MessageKey fromMe.
         * @member {boolean} fromMe
         * @memberof proto.MessageKey
         * @instance
         */
        MessageKey.prototype.fromMe = false;

        /**
         * MessageKey id.
         * @member {string} id
         * @memberof proto.MessageKey
         * @instance
         */
        MessageKey.prototype.id = "";

        /**
         * MessageKey participant.
         * @member {string} participant
         * @memberof proto.MessageKey
         * @instance
         */
        MessageKey.prototype.participant = "";

        /**
         * Creates a new MessageKey instance using the specified properties.
         * @function create
         * @memberof proto.MessageKey
         * @static
         * @param {proto.IMessageKey=} [properties] Properties to set
         * @returns {proto.MessageKey} MessageKey instance
         */
        MessageKey.create = function create(properties) {
            return new MessageKey(properties);
        };

        /**
         * Encodes the specified MessageKey message. Does not implicitly {@link proto.MessageKey.verify|verify} messages.
         * @function encode
         * @memberof proto.MessageKey
         * @static
         * @param {proto.IMessageKey} message MessageKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.remoteJid != null && Object.hasOwnProperty.call(message, "remoteJid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.remoteJid);
            if (message.fromMe != null && Object.hasOwnProperty.call(message, "fromMe"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fromMe);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
            if (message.participant != null && Object.hasOwnProperty.call(message, "participant"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.participant);
            return writer;
        };

        /**
         * Encodes the specified MessageKey message, length delimited. Does not implicitly {@link proto.MessageKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.MessageKey
         * @static
         * @param {proto.IMessageKey} message MessageKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MessageKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MessageKey} MessageKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MessageKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.remoteJid = reader.string();
                    break;
                case 2:
                    message.fromMe = reader.bool();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                case 4:
                    message.participant = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.MessageKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.MessageKey} MessageKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageKey message.
         * @function verify
         * @memberof proto.MessageKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.remoteJid != null && message.hasOwnProperty("remoteJid"))
                if (!$util.isString(message.remoteJid))
                    return "remoteJid: string expected";
            if (message.fromMe != null && message.hasOwnProperty("fromMe"))
                if (typeof message.fromMe !== "boolean")
                    return "fromMe: boolean expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.participant != null && message.hasOwnProperty("participant"))
                if (!$util.isString(message.participant))
                    return "participant: string expected";
            return null;
        };

        /**
         * Creates a MessageKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.MessageKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.MessageKey} MessageKey
         */
        MessageKey.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.MessageKey)
                return object;
            var message = new $root.proto.MessageKey();
            if (object.remoteJid != null)
                message.remoteJid = String(object.remoteJid);
            if (object.fromMe != null)
                message.fromMe = Boolean(object.fromMe);
            if (object.id != null)
                message.id = String(object.id);
            if (object.participant != null)
                message.participant = String(object.participant);
            return message;
        };

        /**
         * Creates a plain object from a MessageKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.MessageKey
         * @static
         * @param {proto.MessageKey} message MessageKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.remoteJid = "";
                object.fromMe = false;
                object.id = "";
                object.participant = "";
            }
            if (message.remoteJid != null && message.hasOwnProperty("remoteJid"))
                object.remoteJid = message.remoteJid;
            if (message.fromMe != null && message.hasOwnProperty("fromMe"))
                object.fromMe = message.fromMe;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.participant != null && message.hasOwnProperty("participant"))
                object.participant = message.participant;
            return object;
        };

        /**
         * Converts this MessageKey to JSON.
         * @function toJSON
         * @memberof proto.MessageKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageKey;
    })();

    proto.Money = (function() {

        /**
         * Properties of a Money.
         * @memberof proto
         * @interface IMoney
         * @property {number|Long|null} [value] Money value
         * @property {number|null} [offset] Money offset
         * @property {string|null} [currencyCode] Money currencyCode
         */

        /**
         * Constructs a new Money.
         * @memberof proto
         * @classdesc Represents a Money.
         * @implements IMoney
         * @constructor
         * @param {proto.IMoney=} [properties] Properties to set
         */
        function Money(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Money value.
         * @member {number|Long} value
         * @memberof proto.Money
         * @instance
         */
        Money.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Money offset.
         * @member {number} offset
         * @memberof proto.Money
         * @instance
         */
        Money.prototype.offset = 0;

        /**
         * Money currencyCode.
         * @member {string} currencyCode
         * @memberof proto.Money
         * @instance
         */
        Money.prototype.currencyCode = "";

        /**
         * Creates a new Money instance using the specified properties.
         * @function create
         * @memberof proto.Money
         * @static
         * @param {proto.IMoney=} [properties] Properties to set
         * @returns {proto.Money} Money instance
         */
        Money.create = function create(properties) {
            return new Money(properties);
        };

        /**
         * Encodes the specified Money message. Does not implicitly {@link proto.Money.verify|verify} messages.
         * @function encode
         * @memberof proto.Money
         * @static
         * @param {proto.IMoney} message Money message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Money.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.offset);
            if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.currencyCode);
            return writer;
        };

        /**
         * Encodes the specified Money message, length delimited. Does not implicitly {@link proto.Money.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Money
         * @static
         * @param {proto.IMoney} message Money message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Money.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Money message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Money
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Money} Money
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Money.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Money();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.int64();
                    break;
                case 2:
                    message.offset = reader.uint32();
                    break;
                case 3:
                    message.currencyCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Money message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Money
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Money} Money
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Money.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Money message.
         * @function verify
         * @memberof proto.Money
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Money.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                if (!$util.isString(message.currencyCode))
                    return "currencyCode: string expected";
            return null;
        };

        /**
         * Creates a Money message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Money
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Money} Money
         */
        Money.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Money)
                return object;
            var message = new $root.proto.Money();
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.offset != null)
                message.offset = object.offset >>> 0;
            if (object.currencyCode != null)
                message.currencyCode = String(object.currencyCode);
            return message;
        };

        /**
         * Creates a plain object from a Money message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Money
         * @static
         * @param {proto.Money} message Money
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Money.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                object.offset = 0;
                object.currencyCode = "";
            }
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                object.currencyCode = message.currencyCode;
            return object;
        };

        /**
         * Converts this Money to JSON.
         * @function toJSON
         * @memberof proto.Money
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Money.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Money;
    })();

    proto.MsgOpaqueData = (function() {

        /**
         * Properties of a MsgOpaqueData.
         * @memberof proto
         * @interface IMsgOpaqueData
         * @property {string|null} [body] MsgOpaqueData body
         * @property {string|null} [caption] MsgOpaqueData caption
         * @property {number|null} [lng] MsgOpaqueData lng
         * @property {boolean|null} [isLive] MsgOpaqueData isLive
         * @property {number|null} [lat] MsgOpaqueData lat
         * @property {number|null} [paymentAmount1000] MsgOpaqueData paymentAmount1000
         * @property {string|null} [paymentNoteMsgBody] MsgOpaqueData paymentNoteMsgBody
         * @property {string|null} [canonicalUrl] MsgOpaqueData canonicalUrl
         * @property {string|null} [matchedText] MsgOpaqueData matchedText
         * @property {string|null} [title] MsgOpaqueData title
         * @property {string|null} [description] MsgOpaqueData description
         * @property {Uint8Array|null} [futureproofBuffer] MsgOpaqueData futureproofBuffer
         * @property {string|null} [clientUrl] MsgOpaqueData clientUrl
         * @property {string|null} [loc] MsgOpaqueData loc
         * @property {string|null} [pollName] MsgOpaqueData pollName
         * @property {Array.<proto.MsgOpaqueData.IPollOption>|null} [pollOptions] MsgOpaqueData pollOptions
         * @property {number|null} [pollSelectableOptionsCount] MsgOpaqueData pollSelectableOptionsCount
         * @property {Uint8Array|null} [messageSecret] MsgOpaqueData messageSecret
         * @property {string|null} [originalSelfAuthor] MsgOpaqueData originalSelfAuthor
         * @property {number|Long|null} [senderTimestampMs] MsgOpaqueData senderTimestampMs
         * @property {string|null} [pollUpdateParentKey] MsgOpaqueData pollUpdateParentKey
         * @property {proto.IPollEncValue|null} [encPollVote] MsgOpaqueData encPollVote
         */

        /**
         * Constructs a new MsgOpaqueData.
         * @memberof proto
         * @classdesc Represents a MsgOpaqueData.
         * @implements IMsgOpaqueData
         * @constructor
         * @param {proto.IMsgOpaqueData=} [properties] Properties to set
         */
        function MsgOpaqueData(properties) {
            this.pollOptions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgOpaqueData body.
         * @member {string} body
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.body = "";

        /**
         * MsgOpaqueData caption.
         * @member {string} caption
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.caption = "";

        /**
         * MsgOpaqueData lng.
         * @member {number} lng
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.lng = 0;

        /**
         * MsgOpaqueData isLive.
         * @member {boolean} isLive
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.isLive = false;

        /**
         * MsgOpaqueData lat.
         * @member {number} lat
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.lat = 0;

        /**
         * MsgOpaqueData paymentAmount1000.
         * @member {number} paymentAmount1000
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.paymentAmount1000 = 0;

        /**
         * MsgOpaqueData paymentNoteMsgBody.
         * @member {string} paymentNoteMsgBody
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.paymentNoteMsgBody = "";

        /**
         * MsgOpaqueData canonicalUrl.
         * @member {string} canonicalUrl
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.canonicalUrl = "";

        /**
         * MsgOpaqueData matchedText.
         * @member {string} matchedText
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.matchedText = "";

        /**
         * MsgOpaqueData title.
         * @member {string} title
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.title = "";

        /**
         * MsgOpaqueData description.
         * @member {string} description
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.description = "";

        /**
         * MsgOpaqueData futureproofBuffer.
         * @member {Uint8Array} futureproofBuffer
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.futureproofBuffer = $util.newBuffer([]);

        /**
         * MsgOpaqueData clientUrl.
         * @member {string} clientUrl
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.clientUrl = "";

        /**
         * MsgOpaqueData loc.
         * @member {string} loc
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.loc = "";

        /**
         * MsgOpaqueData pollName.
         * @member {string} pollName
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.pollName = "";

        /**
         * MsgOpaqueData pollOptions.
         * @member {Array.<proto.MsgOpaqueData.IPollOption>} pollOptions
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.pollOptions = $util.emptyArray;

        /**
         * MsgOpaqueData pollSelectableOptionsCount.
         * @member {number} pollSelectableOptionsCount
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.pollSelectableOptionsCount = 0;

        /**
         * MsgOpaqueData messageSecret.
         * @member {Uint8Array} messageSecret
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.messageSecret = $util.newBuffer([]);

        /**
         * MsgOpaqueData originalSelfAuthor.
         * @member {string} originalSelfAuthor
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.originalSelfAuthor = "";

        /**
         * MsgOpaqueData senderTimestampMs.
         * @member {number|Long} senderTimestampMs
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.senderTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MsgOpaqueData pollUpdateParentKey.
         * @member {string} pollUpdateParentKey
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.pollUpdateParentKey = "";

        /**
         * MsgOpaqueData encPollVote.
         * @member {proto.IPollEncValue|null|undefined} encPollVote
         * @memberof proto.MsgOpaqueData
         * @instance
         */
        MsgOpaqueData.prototype.encPollVote = null;

        /**
         * Creates a new MsgOpaqueData instance using the specified properties.
         * @function create
         * @memberof proto.MsgOpaqueData
         * @static
         * @param {proto.IMsgOpaqueData=} [properties] Properties to set
         * @returns {proto.MsgOpaqueData} MsgOpaqueData instance
         */
        MsgOpaqueData.create = function create(properties) {
            return new MsgOpaqueData(properties);
        };

        /**
         * Encodes the specified MsgOpaqueData message. Does not implicitly {@link proto.MsgOpaqueData.verify|verify} messages.
         * @function encode
         * @memberof proto.MsgOpaqueData
         * @static
         * @param {proto.IMsgOpaqueData} message MsgOpaqueData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgOpaqueData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.body);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.caption);
            if (message.lng != null && Object.hasOwnProperty.call(message, "lng"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.lng);
            if (message.isLive != null && Object.hasOwnProperty.call(message, "isLive"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isLive);
            if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.lat);
            if (message.paymentAmount1000 != null && Object.hasOwnProperty.call(message, "paymentAmount1000"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.paymentAmount1000);
            if (message.paymentNoteMsgBody != null && Object.hasOwnProperty.call(message, "paymentNoteMsgBody"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.paymentNoteMsgBody);
            if (message.canonicalUrl != null && Object.hasOwnProperty.call(message, "canonicalUrl"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.canonicalUrl);
            if (message.matchedText != null && Object.hasOwnProperty.call(message, "matchedText"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.matchedText);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.title);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.description);
            if (message.futureproofBuffer != null && Object.hasOwnProperty.call(message, "futureproofBuffer"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.futureproofBuffer);
            if (message.clientUrl != null && Object.hasOwnProperty.call(message, "clientUrl"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.clientUrl);
            if (message.loc != null && Object.hasOwnProperty.call(message, "loc"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.loc);
            if (message.pollName != null && Object.hasOwnProperty.call(message, "pollName"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.pollName);
            if (message.pollOptions != null && message.pollOptions.length)
                for (var i = 0; i < message.pollOptions.length; ++i)
                    $root.proto.MsgOpaqueData.PollOption.encode(message.pollOptions[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.pollSelectableOptionsCount != null && Object.hasOwnProperty.call(message, "pollSelectableOptionsCount"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.pollSelectableOptionsCount);
            if (message.messageSecret != null && Object.hasOwnProperty.call(message, "messageSecret"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.messageSecret);
            if (message.senderTimestampMs != null && Object.hasOwnProperty.call(message, "senderTimestampMs"))
                writer.uint32(/* id 22, wireType 0 =*/176).int64(message.senderTimestampMs);
            if (message.pollUpdateParentKey != null && Object.hasOwnProperty.call(message, "pollUpdateParentKey"))
                writer.uint32(/* id 23, wireType 2 =*/186).string(message.pollUpdateParentKey);
            if (message.encPollVote != null && Object.hasOwnProperty.call(message, "encPollVote"))
                $root.proto.PollEncValue.encode(message.encPollVote, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.originalSelfAuthor != null && Object.hasOwnProperty.call(message, "originalSelfAuthor"))
                writer.uint32(/* id 51, wireType 2 =*/410).string(message.originalSelfAuthor);
            return writer;
        };

        /**
         * Encodes the specified MsgOpaqueData message, length delimited. Does not implicitly {@link proto.MsgOpaqueData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.MsgOpaqueData
         * @static
         * @param {proto.IMsgOpaqueData} message MsgOpaqueData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgOpaqueData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgOpaqueData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MsgOpaqueData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MsgOpaqueData} MsgOpaqueData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgOpaqueData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MsgOpaqueData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.body = reader.string();
                    break;
                case 3:
                    message.caption = reader.string();
                    break;
                case 5:
                    message.lng = reader.double();
                    break;
                case 6:
                    message.isLive = reader.bool();
                    break;
                case 7:
                    message.lat = reader.double();
                    break;
                case 8:
                    message.paymentAmount1000 = reader.int32();
                    break;
                case 9:
                    message.paymentNoteMsgBody = reader.string();
                    break;
                case 10:
                    message.canonicalUrl = reader.string();
                    break;
                case 11:
                    message.matchedText = reader.string();
                    break;
                case 12:
                    message.title = reader.string();
                    break;
                case 13:
                    message.description = reader.string();
                    break;
                case 14:
                    message.futureproofBuffer = reader.bytes();
                    break;
                case 15:
                    message.clientUrl = reader.string();
                    break;
                case 16:
                    message.loc = reader.string();
                    break;
                case 17:
                    message.pollName = reader.string();
                    break;
                case 18:
                    if (!(message.pollOptions && message.pollOptions.length))
                        message.pollOptions = [];
                    message.pollOptions.push($root.proto.MsgOpaqueData.PollOption.decode(reader, reader.uint32()));
                    break;
                case 20:
                    message.pollSelectableOptionsCount = reader.uint32();
                    break;
                case 21:
                    message.messageSecret = reader.bytes();
                    break;
                case 51:
                    message.originalSelfAuthor = reader.string();
                    break;
                case 22:
                    message.senderTimestampMs = reader.int64();
                    break;
                case 23:
                    message.pollUpdateParentKey = reader.string();
                    break;
                case 24:
                    message.encPollVote = $root.proto.PollEncValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgOpaqueData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.MsgOpaqueData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.MsgOpaqueData} MsgOpaqueData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgOpaqueData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgOpaqueData message.
         * @function verify
         * @memberof proto.MsgOpaqueData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgOpaqueData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.lng != null && message.hasOwnProperty("lng"))
                if (typeof message.lng !== "number")
                    return "lng: number expected";
            if (message.isLive != null && message.hasOwnProperty("isLive"))
                if (typeof message.isLive !== "boolean")
                    return "isLive: boolean expected";
            if (message.lat != null && message.hasOwnProperty("lat"))
                if (typeof message.lat !== "number")
                    return "lat: number expected";
            if (message.paymentAmount1000 != null && message.hasOwnProperty("paymentAmount1000"))
                if (!$util.isInteger(message.paymentAmount1000))
                    return "paymentAmount1000: integer expected";
            if (message.paymentNoteMsgBody != null && message.hasOwnProperty("paymentNoteMsgBody"))
                if (!$util.isString(message.paymentNoteMsgBody))
                    return "paymentNoteMsgBody: string expected";
            if (message.canonicalUrl != null && message.hasOwnProperty("canonicalUrl"))
                if (!$util.isString(message.canonicalUrl))
                    return "canonicalUrl: string expected";
            if (message.matchedText != null && message.hasOwnProperty("matchedText"))
                if (!$util.isString(message.matchedText))
                    return "matchedText: string expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.futureproofBuffer != null && message.hasOwnProperty("futureproofBuffer"))
                if (!(message.futureproofBuffer && typeof message.futureproofBuffer.length === "number" || $util.isString(message.futureproofBuffer)))
                    return "futureproofBuffer: buffer expected";
            if (message.clientUrl != null && message.hasOwnProperty("clientUrl"))
                if (!$util.isString(message.clientUrl))
                    return "clientUrl: string expected";
            if (message.loc != null && message.hasOwnProperty("loc"))
                if (!$util.isString(message.loc))
                    return "loc: string expected";
            if (message.pollName != null && message.hasOwnProperty("pollName"))
                if (!$util.isString(message.pollName))
                    return "pollName: string expected";
            if (message.pollOptions != null && message.hasOwnProperty("pollOptions")) {
                if (!Array.isArray(message.pollOptions))
                    return "pollOptions: array expected";
                for (var i = 0; i < message.pollOptions.length; ++i) {
                    var error = $root.proto.MsgOpaqueData.PollOption.verify(message.pollOptions[i]);
                    if (error)
                        return "pollOptions." + error;
                }
            }
            if (message.pollSelectableOptionsCount != null && message.hasOwnProperty("pollSelectableOptionsCount"))
                if (!$util.isInteger(message.pollSelectableOptionsCount))
                    return "pollSelectableOptionsCount: integer expected";
            if (message.messageSecret != null && message.hasOwnProperty("messageSecret"))
                if (!(message.messageSecret && typeof message.messageSecret.length === "number" || $util.isString(message.messageSecret)))
                    return "messageSecret: buffer expected";
            if (message.originalSelfAuthor != null && message.hasOwnProperty("originalSelfAuthor"))
                if (!$util.isString(message.originalSelfAuthor))
                    return "originalSelfAuthor: string expected";
            if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                if (!$util.isInteger(message.senderTimestampMs) && !(message.senderTimestampMs && $util.isInteger(message.senderTimestampMs.low) && $util.isInteger(message.senderTimestampMs.high)))
                    return "senderTimestampMs: integer|Long expected";
            if (message.pollUpdateParentKey != null && message.hasOwnProperty("pollUpdateParentKey"))
                if (!$util.isString(message.pollUpdateParentKey))
                    return "pollUpdateParentKey: string expected";
            if (message.encPollVote != null && message.hasOwnProperty("encPollVote")) {
                var error = $root.proto.PollEncValue.verify(message.encPollVote);
                if (error)
                    return "encPollVote." + error;
            }
            return null;
        };

        /**
         * Creates a MsgOpaqueData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.MsgOpaqueData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.MsgOpaqueData} MsgOpaqueData
         */
        MsgOpaqueData.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.MsgOpaqueData)
                return object;
            var message = new $root.proto.MsgOpaqueData();
            if (object.body != null)
                message.body = String(object.body);
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.lng != null)
                message.lng = Number(object.lng);
            if (object.isLive != null)
                message.isLive = Boolean(object.isLive);
            if (object.lat != null)
                message.lat = Number(object.lat);
            if (object.paymentAmount1000 != null)
                message.paymentAmount1000 = object.paymentAmount1000 | 0;
            if (object.paymentNoteMsgBody != null)
                message.paymentNoteMsgBody = String(object.paymentNoteMsgBody);
            if (object.canonicalUrl != null)
                message.canonicalUrl = String(object.canonicalUrl);
            if (object.matchedText != null)
                message.matchedText = String(object.matchedText);
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            if (object.futureproofBuffer != null)
                if (typeof object.futureproofBuffer === "string")
                    $util.base64.decode(object.futureproofBuffer, message.futureproofBuffer = $util.newBuffer($util.base64.length(object.futureproofBuffer)), 0);
                else if (object.futureproofBuffer.length)
                    message.futureproofBuffer = object.futureproofBuffer;
            if (object.clientUrl != null)
                message.clientUrl = String(object.clientUrl);
            if (object.loc != null)
                message.loc = String(object.loc);
            if (object.pollName != null)
                message.pollName = String(object.pollName);
            if (object.pollOptions) {
                if (!Array.isArray(object.pollOptions))
                    throw TypeError(".proto.MsgOpaqueData.pollOptions: array expected");
                message.pollOptions = [];
                for (var i = 0; i < object.pollOptions.length; ++i) {
                    if (typeof object.pollOptions[i] !== "object")
                        throw TypeError(".proto.MsgOpaqueData.pollOptions: object expected");
                    message.pollOptions[i] = $root.proto.MsgOpaqueData.PollOption.fromObject(object.pollOptions[i]);
                }
            }
            if (object.pollSelectableOptionsCount != null)
                message.pollSelectableOptionsCount = object.pollSelectableOptionsCount >>> 0;
            if (object.messageSecret != null)
                if (typeof object.messageSecret === "string")
                    $util.base64.decode(object.messageSecret, message.messageSecret = $util.newBuffer($util.base64.length(object.messageSecret)), 0);
                else if (object.messageSecret.length)
                    message.messageSecret = object.messageSecret;
            if (object.originalSelfAuthor != null)
                message.originalSelfAuthor = String(object.originalSelfAuthor);
            if (object.senderTimestampMs != null)
                if ($util.Long)
                    (message.senderTimestampMs = $util.Long.fromValue(object.senderTimestampMs)).unsigned = false;
                else if (typeof object.senderTimestampMs === "string")
                    message.senderTimestampMs = parseInt(object.senderTimestampMs, 10);
                else if (typeof object.senderTimestampMs === "number")
                    message.senderTimestampMs = object.senderTimestampMs;
                else if (typeof object.senderTimestampMs === "object")
                    message.senderTimestampMs = new $util.LongBits(object.senderTimestampMs.low >>> 0, object.senderTimestampMs.high >>> 0).toNumber();
            if (object.pollUpdateParentKey != null)
                message.pollUpdateParentKey = String(object.pollUpdateParentKey);
            if (object.encPollVote != null) {
                if (typeof object.encPollVote !== "object")
                    throw TypeError(".proto.MsgOpaqueData.encPollVote: object expected");
                message.encPollVote = $root.proto.PollEncValue.fromObject(object.encPollVote);
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgOpaqueData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.MsgOpaqueData
         * @static
         * @param {proto.MsgOpaqueData} message MsgOpaqueData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgOpaqueData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pollOptions = [];
            if (options.defaults) {
                object.body = "";
                object.caption = "";
                object.lng = 0;
                object.isLive = false;
                object.lat = 0;
                object.paymentAmount1000 = 0;
                object.paymentNoteMsgBody = "";
                object.canonicalUrl = "";
                object.matchedText = "";
                object.title = "";
                object.description = "";
                if (options.bytes === String)
                    object.futureproofBuffer = "";
                else {
                    object.futureproofBuffer = [];
                    if (options.bytes !== Array)
                        object.futureproofBuffer = $util.newBuffer(object.futureproofBuffer);
                }
                object.clientUrl = "";
                object.loc = "";
                object.pollName = "";
                object.pollSelectableOptionsCount = 0;
                if (options.bytes === String)
                    object.messageSecret = "";
                else {
                    object.messageSecret = [];
                    if (options.bytes !== Array)
                        object.messageSecret = $util.newBuffer(object.messageSecret);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.senderTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.senderTimestampMs = options.longs === String ? "0" : 0;
                object.pollUpdateParentKey = "";
                object.encPollVote = null;
                object.originalSelfAuthor = "";
            }
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.lng != null && message.hasOwnProperty("lng"))
                object.lng = options.json && !isFinite(message.lng) ? String(message.lng) : message.lng;
            if (message.isLive != null && message.hasOwnProperty("isLive"))
                object.isLive = message.isLive;
            if (message.lat != null && message.hasOwnProperty("lat"))
                object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;
            if (message.paymentAmount1000 != null && message.hasOwnProperty("paymentAmount1000"))
                object.paymentAmount1000 = message.paymentAmount1000;
            if (message.paymentNoteMsgBody != null && message.hasOwnProperty("paymentNoteMsgBody"))
                object.paymentNoteMsgBody = message.paymentNoteMsgBody;
            if (message.canonicalUrl != null && message.hasOwnProperty("canonicalUrl"))
                object.canonicalUrl = message.canonicalUrl;
            if (message.matchedText != null && message.hasOwnProperty("matchedText"))
                object.matchedText = message.matchedText;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.futureproofBuffer != null && message.hasOwnProperty("futureproofBuffer"))
                object.futureproofBuffer = options.bytes === String ? $util.base64.encode(message.futureproofBuffer, 0, message.futureproofBuffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.futureproofBuffer) : message.futureproofBuffer;
            if (message.clientUrl != null && message.hasOwnProperty("clientUrl"))
                object.clientUrl = message.clientUrl;
            if (message.loc != null && message.hasOwnProperty("loc"))
                object.loc = message.loc;
            if (message.pollName != null && message.hasOwnProperty("pollName"))
                object.pollName = message.pollName;
            if (message.pollOptions && message.pollOptions.length) {
                object.pollOptions = [];
                for (var j = 0; j < message.pollOptions.length; ++j)
                    object.pollOptions[j] = $root.proto.MsgOpaqueData.PollOption.toObject(message.pollOptions[j], options);
            }
            if (message.pollSelectableOptionsCount != null && message.hasOwnProperty("pollSelectableOptionsCount"))
                object.pollSelectableOptionsCount = message.pollSelectableOptionsCount;
            if (message.messageSecret != null && message.hasOwnProperty("messageSecret"))
                object.messageSecret = options.bytes === String ? $util.base64.encode(message.messageSecret, 0, message.messageSecret.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSecret) : message.messageSecret;
            if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                if (typeof message.senderTimestampMs === "number")
                    object.senderTimestampMs = options.longs === String ? String(message.senderTimestampMs) : message.senderTimestampMs;
                else
                    object.senderTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.senderTimestampMs) : options.longs === Number ? new $util.LongBits(message.senderTimestampMs.low >>> 0, message.senderTimestampMs.high >>> 0).toNumber() : message.senderTimestampMs;
            if (message.pollUpdateParentKey != null && message.hasOwnProperty("pollUpdateParentKey"))
                object.pollUpdateParentKey = message.pollUpdateParentKey;
            if (message.encPollVote != null && message.hasOwnProperty("encPollVote"))
                object.encPollVote = $root.proto.PollEncValue.toObject(message.encPollVote, options);
            if (message.originalSelfAuthor != null && message.hasOwnProperty("originalSelfAuthor"))
                object.originalSelfAuthor = message.originalSelfAuthor;
            return object;
        };

        /**
         * Converts this MsgOpaqueData to JSON.
         * @function toJSON
         * @memberof proto.MsgOpaqueData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgOpaqueData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        MsgOpaqueData.PollOption = (function() {

            /**
             * Properties of a PollOption.
             * @memberof proto.MsgOpaqueData
             * @interface IPollOption
             * @property {string|null} [name] PollOption name
             */

            /**
             * Constructs a new PollOption.
             * @memberof proto.MsgOpaqueData
             * @classdesc Represents a PollOption.
             * @implements IPollOption
             * @constructor
             * @param {proto.MsgOpaqueData.IPollOption=} [properties] Properties to set
             */
            function PollOption(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PollOption name.
             * @member {string} name
             * @memberof proto.MsgOpaqueData.PollOption
             * @instance
             */
            PollOption.prototype.name = "";

            /**
             * Creates a new PollOption instance using the specified properties.
             * @function create
             * @memberof proto.MsgOpaqueData.PollOption
             * @static
             * @param {proto.MsgOpaqueData.IPollOption=} [properties] Properties to set
             * @returns {proto.MsgOpaqueData.PollOption} PollOption instance
             */
            PollOption.create = function create(properties) {
                return new PollOption(properties);
            };

            /**
             * Encodes the specified PollOption message. Does not implicitly {@link proto.MsgOpaqueData.PollOption.verify|verify} messages.
             * @function encode
             * @memberof proto.MsgOpaqueData.PollOption
             * @static
             * @param {proto.MsgOpaqueData.IPollOption} message PollOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified PollOption message, length delimited. Does not implicitly {@link proto.MsgOpaqueData.PollOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.MsgOpaqueData.PollOption
             * @static
             * @param {proto.MsgOpaqueData.IPollOption} message PollOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PollOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PollOption message from the specified reader or buffer.
             * @function decode
             * @memberof proto.MsgOpaqueData.PollOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.MsgOpaqueData.PollOption} PollOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MsgOpaqueData.PollOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PollOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.MsgOpaqueData.PollOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.MsgOpaqueData.PollOption} PollOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PollOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PollOption message.
             * @function verify
             * @memberof proto.MsgOpaqueData.PollOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PollOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a PollOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.MsgOpaqueData.PollOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.MsgOpaqueData.PollOption} PollOption
             */
            PollOption.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.MsgOpaqueData.PollOption)
                    return object;
                var message = new $root.proto.MsgOpaqueData.PollOption();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a PollOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.MsgOpaqueData.PollOption
             * @static
             * @param {proto.MsgOpaqueData.PollOption} message PollOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PollOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this PollOption to JSON.
             * @function toJSON
             * @memberof proto.MsgOpaqueData.PollOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PollOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PollOption;
        })();

        return MsgOpaqueData;
    })();

    proto.MsgRowOpaqueData = (function() {

        /**
         * Properties of a MsgRowOpaqueData.
         * @memberof proto
         * @interface IMsgRowOpaqueData
         * @property {proto.IMsgOpaqueData|null} [currentMsg] MsgRowOpaqueData currentMsg
         * @property {proto.IMsgOpaqueData|null} [quotedMsg] MsgRowOpaqueData quotedMsg
         */

        /**
         * Constructs a new MsgRowOpaqueData.
         * @memberof proto
         * @classdesc Represents a MsgRowOpaqueData.
         * @implements IMsgRowOpaqueData
         * @constructor
         * @param {proto.IMsgRowOpaqueData=} [properties] Properties to set
         */
        function MsgRowOpaqueData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgRowOpaqueData currentMsg.
         * @member {proto.IMsgOpaqueData|null|undefined} currentMsg
         * @memberof proto.MsgRowOpaqueData
         * @instance
         */
        MsgRowOpaqueData.prototype.currentMsg = null;

        /**
         * MsgRowOpaqueData quotedMsg.
         * @member {proto.IMsgOpaqueData|null|undefined} quotedMsg
         * @memberof proto.MsgRowOpaqueData
         * @instance
         */
        MsgRowOpaqueData.prototype.quotedMsg = null;

        /**
         * Creates a new MsgRowOpaqueData instance using the specified properties.
         * @function create
         * @memberof proto.MsgRowOpaqueData
         * @static
         * @param {proto.IMsgRowOpaqueData=} [properties] Properties to set
         * @returns {proto.MsgRowOpaqueData} MsgRowOpaqueData instance
         */
        MsgRowOpaqueData.create = function create(properties) {
            return new MsgRowOpaqueData(properties);
        };

        /**
         * Encodes the specified MsgRowOpaqueData message. Does not implicitly {@link proto.MsgRowOpaqueData.verify|verify} messages.
         * @function encode
         * @memberof proto.MsgRowOpaqueData
         * @static
         * @param {proto.IMsgRowOpaqueData} message MsgRowOpaqueData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRowOpaqueData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentMsg != null && Object.hasOwnProperty.call(message, "currentMsg"))
                $root.proto.MsgOpaqueData.encode(message.currentMsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.quotedMsg != null && Object.hasOwnProperty.call(message, "quotedMsg"))
                $root.proto.MsgOpaqueData.encode(message.quotedMsg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgRowOpaqueData message, length delimited. Does not implicitly {@link proto.MsgRowOpaqueData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.MsgRowOpaqueData
         * @static
         * @param {proto.IMsgRowOpaqueData} message MsgRowOpaqueData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgRowOpaqueData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgRowOpaqueData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MsgRowOpaqueData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MsgRowOpaqueData} MsgRowOpaqueData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRowOpaqueData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MsgRowOpaqueData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currentMsg = $root.proto.MsgOpaqueData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.quotedMsg = $root.proto.MsgOpaqueData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgRowOpaqueData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.MsgRowOpaqueData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.MsgRowOpaqueData} MsgRowOpaqueData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgRowOpaqueData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgRowOpaqueData message.
         * @function verify
         * @memberof proto.MsgRowOpaqueData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgRowOpaqueData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentMsg != null && message.hasOwnProperty("currentMsg")) {
                var error = $root.proto.MsgOpaqueData.verify(message.currentMsg);
                if (error)
                    return "currentMsg." + error;
            }
            if (message.quotedMsg != null && message.hasOwnProperty("quotedMsg")) {
                var error = $root.proto.MsgOpaqueData.verify(message.quotedMsg);
                if (error)
                    return "quotedMsg." + error;
            }
            return null;
        };

        /**
         * Creates a MsgRowOpaqueData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.MsgRowOpaqueData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.MsgRowOpaqueData} MsgRowOpaqueData
         */
        MsgRowOpaqueData.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.MsgRowOpaqueData)
                return object;
            var message = new $root.proto.MsgRowOpaqueData();
            if (object.currentMsg != null) {
                if (typeof object.currentMsg !== "object")
                    throw TypeError(".proto.MsgRowOpaqueData.currentMsg: object expected");
                message.currentMsg = $root.proto.MsgOpaqueData.fromObject(object.currentMsg);
            }
            if (object.quotedMsg != null) {
                if (typeof object.quotedMsg !== "object")
                    throw TypeError(".proto.MsgRowOpaqueData.quotedMsg: object expected");
                message.quotedMsg = $root.proto.MsgOpaqueData.fromObject(object.quotedMsg);
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgRowOpaqueData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.MsgRowOpaqueData
         * @static
         * @param {proto.MsgRowOpaqueData} message MsgRowOpaqueData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgRowOpaqueData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currentMsg = null;
                object.quotedMsg = null;
            }
            if (message.currentMsg != null && message.hasOwnProperty("currentMsg"))
                object.currentMsg = $root.proto.MsgOpaqueData.toObject(message.currentMsg, options);
            if (message.quotedMsg != null && message.hasOwnProperty("quotedMsg"))
                object.quotedMsg = $root.proto.MsgOpaqueData.toObject(message.quotedMsg, options);
            return object;
        };

        /**
         * Converts this MsgRowOpaqueData to JSON.
         * @function toJSON
         * @memberof proto.MsgRowOpaqueData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgRowOpaqueData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgRowOpaqueData;
    })();

    proto.NoiseCertificate = (function() {

        /**
         * Properties of a NoiseCertificate.
         * @memberof proto
         * @interface INoiseCertificate
         * @property {Uint8Array|null} [details] NoiseCertificate details
         * @property {Uint8Array|null} [signature] NoiseCertificate signature
         */

        /**
         * Constructs a new NoiseCertificate.
         * @memberof proto
         * @classdesc Represents a NoiseCertificate.
         * @implements INoiseCertificate
         * @constructor
         * @param {proto.INoiseCertificate=} [properties] Properties to set
         */
        function NoiseCertificate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoiseCertificate details.
         * @member {Uint8Array} details
         * @memberof proto.NoiseCertificate
         * @instance
         */
        NoiseCertificate.prototype.details = $util.newBuffer([]);

        /**
         * NoiseCertificate signature.
         * @member {Uint8Array} signature
         * @memberof proto.NoiseCertificate
         * @instance
         */
        NoiseCertificate.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new NoiseCertificate instance using the specified properties.
         * @function create
         * @memberof proto.NoiseCertificate
         * @static
         * @param {proto.INoiseCertificate=} [properties] Properties to set
         * @returns {proto.NoiseCertificate} NoiseCertificate instance
         */
        NoiseCertificate.create = function create(properties) {
            return new NoiseCertificate(properties);
        };

        /**
         * Encodes the specified NoiseCertificate message. Does not implicitly {@link proto.NoiseCertificate.verify|verify} messages.
         * @function encode
         * @memberof proto.NoiseCertificate
         * @static
         * @param {proto.INoiseCertificate} message NoiseCertificate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoiseCertificate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.details);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified NoiseCertificate message, length delimited. Does not implicitly {@link proto.NoiseCertificate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.NoiseCertificate
         * @static
         * @param {proto.INoiseCertificate} message NoiseCertificate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoiseCertificate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoiseCertificate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NoiseCertificate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.NoiseCertificate} NoiseCertificate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoiseCertificate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NoiseCertificate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.details = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoiseCertificate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.NoiseCertificate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.NoiseCertificate} NoiseCertificate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoiseCertificate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoiseCertificate message.
         * @function verify
         * @memberof proto.NoiseCertificate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoiseCertificate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.details != null && message.hasOwnProperty("details"))
                if (!(message.details && typeof message.details.length === "number" || $util.isString(message.details)))
                    return "details: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a NoiseCertificate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.NoiseCertificate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.NoiseCertificate} NoiseCertificate
         */
        NoiseCertificate.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.NoiseCertificate)
                return object;
            var message = new $root.proto.NoiseCertificate();
            if (object.details != null)
                if (typeof object.details === "string")
                    $util.base64.decode(object.details, message.details = $util.newBuffer($util.base64.length(object.details)), 0);
                else if (object.details.length)
                    message.details = object.details;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a NoiseCertificate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.NoiseCertificate
         * @static
         * @param {proto.NoiseCertificate} message NoiseCertificate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoiseCertificate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.details = "";
                else {
                    object.details = [];
                    if (options.bytes !== Array)
                        object.details = $util.newBuffer(object.details);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = options.bytes === String ? $util.base64.encode(message.details, 0, message.details.length) : options.bytes === Array ? Array.prototype.slice.call(message.details) : message.details;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this NoiseCertificate to JSON.
         * @function toJSON
         * @memberof proto.NoiseCertificate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoiseCertificate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        NoiseCertificate.Details = (function() {

            /**
             * Properties of a Details.
             * @memberof proto.NoiseCertificate
             * @interface IDetails
             * @property {number|null} [serial] Details serial
             * @property {string|null} [issuer] Details issuer
             * @property {number|Long|null} [expires] Details expires
             * @property {string|null} [subject] Details subject
             * @property {Uint8Array|null} [key] Details key
             */

            /**
             * Constructs a new Details.
             * @memberof proto.NoiseCertificate
             * @classdesc Represents a Details.
             * @implements IDetails
             * @constructor
             * @param {proto.NoiseCertificate.IDetails=} [properties] Properties to set
             */
            function Details(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Details serial.
             * @member {number} serial
             * @memberof proto.NoiseCertificate.Details
             * @instance
             */
            Details.prototype.serial = 0;

            /**
             * Details issuer.
             * @member {string} issuer
             * @memberof proto.NoiseCertificate.Details
             * @instance
             */
            Details.prototype.issuer = "";

            /**
             * Details expires.
             * @member {number|Long} expires
             * @memberof proto.NoiseCertificate.Details
             * @instance
             */
            Details.prototype.expires = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Details subject.
             * @member {string} subject
             * @memberof proto.NoiseCertificate.Details
             * @instance
             */
            Details.prototype.subject = "";

            /**
             * Details key.
             * @member {Uint8Array} key
             * @memberof proto.NoiseCertificate.Details
             * @instance
             */
            Details.prototype.key = $util.newBuffer([]);

            /**
             * Creates a new Details instance using the specified properties.
             * @function create
             * @memberof proto.NoiseCertificate.Details
             * @static
             * @param {proto.NoiseCertificate.IDetails=} [properties] Properties to set
             * @returns {proto.NoiseCertificate.Details} Details instance
             */
            Details.create = function create(properties) {
                return new Details(properties);
            };

            /**
             * Encodes the specified Details message. Does not implicitly {@link proto.NoiseCertificate.Details.verify|verify} messages.
             * @function encode
             * @memberof proto.NoiseCertificate.Details
             * @static
             * @param {proto.NoiseCertificate.IDetails} message Details message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Details.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serial != null && Object.hasOwnProperty.call(message, "serial"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.serial);
                if (message.issuer != null && Object.hasOwnProperty.call(message, "issuer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.issuer);
                if (message.expires != null && Object.hasOwnProperty.call(message, "expires"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.expires);
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.subject);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.key);
                return writer;
            };

            /**
             * Encodes the specified Details message, length delimited. Does not implicitly {@link proto.NoiseCertificate.Details.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.NoiseCertificate.Details
             * @static
             * @param {proto.NoiseCertificate.IDetails} message Details message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Details.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Details message from the specified reader or buffer.
             * @function decode
             * @memberof proto.NoiseCertificate.Details
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.NoiseCertificate.Details} Details
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Details.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NoiseCertificate.Details();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serial = reader.uint32();
                        break;
                    case 2:
                        message.issuer = reader.string();
                        break;
                    case 3:
                        message.expires = reader.uint64();
                        break;
                    case 4:
                        message.subject = reader.string();
                        break;
                    case 5:
                        message.key = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Details message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.NoiseCertificate.Details
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.NoiseCertificate.Details} Details
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Details.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Details message.
             * @function verify
             * @memberof proto.NoiseCertificate.Details
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Details.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serial != null && message.hasOwnProperty("serial"))
                    if (!$util.isInteger(message.serial))
                        return "serial: integer expected";
                if (message.issuer != null && message.hasOwnProperty("issuer"))
                    if (!$util.isString(message.issuer))
                        return "issuer: string expected";
                if (message.expires != null && message.hasOwnProperty("expires"))
                    if (!$util.isInteger(message.expires) && !(message.expires && $util.isInteger(message.expires.low) && $util.isInteger(message.expires.high)))
                        return "expires: integer|Long expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                return null;
            };

            /**
             * Creates a Details message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.NoiseCertificate.Details
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.NoiseCertificate.Details} Details
             */
            Details.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.NoiseCertificate.Details)
                    return object;
                var message = new $root.proto.NoiseCertificate.Details();
                if (object.serial != null)
                    message.serial = object.serial >>> 0;
                if (object.issuer != null)
                    message.issuer = String(object.issuer);
                if (object.expires != null)
                    if ($util.Long)
                        (message.expires = $util.Long.fromValue(object.expires)).unsigned = true;
                    else if (typeof object.expires === "string")
                        message.expires = parseInt(object.expires, 10);
                    else if (typeof object.expires === "number")
                        message.expires = object.expires;
                    else if (typeof object.expires === "object")
                        message.expires = new $util.LongBits(object.expires.low >>> 0, object.expires.high >>> 0).toNumber(true);
                if (object.subject != null)
                    message.subject = String(object.subject);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                return message;
            };

            /**
             * Creates a plain object from a Details message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.NoiseCertificate.Details
             * @static
             * @param {proto.NoiseCertificate.Details} message Details
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Details.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.serial = 0;
                    object.issuer = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.expires = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expires = options.longs === String ? "0" : 0;
                    object.subject = "";
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                }
                if (message.serial != null && message.hasOwnProperty("serial"))
                    object.serial = message.serial;
                if (message.issuer != null && message.hasOwnProperty("issuer"))
                    object.issuer = message.issuer;
                if (message.expires != null && message.hasOwnProperty("expires"))
                    if (typeof message.expires === "number")
                        object.expires = options.longs === String ? String(message.expires) : message.expires;
                    else
                        object.expires = options.longs === String ? $util.Long.prototype.toString.call(message.expires) : options.longs === Number ? new $util.LongBits(message.expires.low >>> 0, message.expires.high >>> 0).toNumber(true) : message.expires;
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                return object;
            };

            /**
             * Converts this Details to JSON.
             * @function toJSON
             * @memberof proto.NoiseCertificate.Details
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Details.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Details;
        })();

        return NoiseCertificate;
    })();

    proto.NotificationMessageInfo = (function() {

        /**
         * Properties of a NotificationMessageInfo.
         * @memberof proto
         * @interface INotificationMessageInfo
         * @property {proto.IMessageKey|null} [key] NotificationMessageInfo key
         * @property {proto.IMessage|null} [message] NotificationMessageInfo message
         * @property {number|Long|null} [messageTimestamp] NotificationMessageInfo messageTimestamp
         * @property {string|null} [participant] NotificationMessageInfo participant
         */

        /**
         * Constructs a new NotificationMessageInfo.
         * @memberof proto
         * @classdesc Represents a NotificationMessageInfo.
         * @implements INotificationMessageInfo
         * @constructor
         * @param {proto.INotificationMessageInfo=} [properties] Properties to set
         */
        function NotificationMessageInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NotificationMessageInfo key.
         * @member {proto.IMessageKey|null|undefined} key
         * @memberof proto.NotificationMessageInfo
         * @instance
         */
        NotificationMessageInfo.prototype.key = null;

        /**
         * NotificationMessageInfo message.
         * @member {proto.IMessage|null|undefined} message
         * @memberof proto.NotificationMessageInfo
         * @instance
         */
        NotificationMessageInfo.prototype.message = null;

        /**
         * NotificationMessageInfo messageTimestamp.
         * @member {number|Long} messageTimestamp
         * @memberof proto.NotificationMessageInfo
         * @instance
         */
        NotificationMessageInfo.prototype.messageTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * NotificationMessageInfo participant.
         * @member {string} participant
         * @memberof proto.NotificationMessageInfo
         * @instance
         */
        NotificationMessageInfo.prototype.participant = "";

        /**
         * Creates a new NotificationMessageInfo instance using the specified properties.
         * @function create
         * @memberof proto.NotificationMessageInfo
         * @static
         * @param {proto.INotificationMessageInfo=} [properties] Properties to set
         * @returns {proto.NotificationMessageInfo} NotificationMessageInfo instance
         */
        NotificationMessageInfo.create = function create(properties) {
            return new NotificationMessageInfo(properties);
        };

        /**
         * Encodes the specified NotificationMessageInfo message. Does not implicitly {@link proto.NotificationMessageInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.NotificationMessageInfo
         * @static
         * @param {proto.INotificationMessageInfo} message NotificationMessageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotificationMessageInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                $root.proto.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.messageTimestamp != null && Object.hasOwnProperty.call(message, "messageTimestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageTimestamp);
            if (message.participant != null && Object.hasOwnProperty.call(message, "participant"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.participant);
            return writer;
        };

        /**
         * Encodes the specified NotificationMessageInfo message, length delimited. Does not implicitly {@link proto.NotificationMessageInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.NotificationMessageInfo
         * @static
         * @param {proto.INotificationMessageInfo} message NotificationMessageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotificationMessageInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NotificationMessageInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NotificationMessageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.NotificationMessageInfo} NotificationMessageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationMessageInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NotificationMessageInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.message = $root.proto.Message.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.messageTimestamp = reader.uint64();
                    break;
                case 4:
                    message.participant = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NotificationMessageInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.NotificationMessageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.NotificationMessageInfo} NotificationMessageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationMessageInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NotificationMessageInfo message.
         * @function verify
         * @memberof proto.NotificationMessageInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NotificationMessageInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.proto.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.message != null && message.hasOwnProperty("message")) {
                var error = $root.proto.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
            if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                if (!$util.isInteger(message.messageTimestamp) && !(message.messageTimestamp && $util.isInteger(message.messageTimestamp.low) && $util.isInteger(message.messageTimestamp.high)))
                    return "messageTimestamp: integer|Long expected";
            if (message.participant != null && message.hasOwnProperty("participant"))
                if (!$util.isString(message.participant))
                    return "participant: string expected";
            return null;
        };

        /**
         * Creates a NotificationMessageInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.NotificationMessageInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.NotificationMessageInfo} NotificationMessageInfo
         */
        NotificationMessageInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.NotificationMessageInfo)
                return object;
            var message = new $root.proto.NotificationMessageInfo();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".proto.NotificationMessageInfo.key: object expected");
                message.key = $root.proto.MessageKey.fromObject(object.key);
            }
            if (object.message != null) {
                if (typeof object.message !== "object")
                    throw TypeError(".proto.NotificationMessageInfo.message: object expected");
                message.message = $root.proto.Message.fromObject(object.message);
            }
            if (object.messageTimestamp != null)
                if ($util.Long)
                    (message.messageTimestamp = $util.Long.fromValue(object.messageTimestamp)).unsigned = true;
                else if (typeof object.messageTimestamp === "string")
                    message.messageTimestamp = parseInt(object.messageTimestamp, 10);
                else if (typeof object.messageTimestamp === "number")
                    message.messageTimestamp = object.messageTimestamp;
                else if (typeof object.messageTimestamp === "object")
                    message.messageTimestamp = new $util.LongBits(object.messageTimestamp.low >>> 0, object.messageTimestamp.high >>> 0).toNumber(true);
            if (object.participant != null)
                message.participant = String(object.participant);
            return message;
        };

        /**
         * Creates a plain object from a NotificationMessageInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.NotificationMessageInfo
         * @static
         * @param {proto.NotificationMessageInfo} message NotificationMessageInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NotificationMessageInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.message = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.messageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.messageTimestamp = options.longs === String ? "0" : 0;
                object.participant = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.proto.MessageKey.toObject(message.key, options);
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = $root.proto.Message.toObject(message.message, options);
            if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                if (typeof message.messageTimestamp === "number")
                    object.messageTimestamp = options.longs === String ? String(message.messageTimestamp) : message.messageTimestamp;
                else
                    object.messageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.messageTimestamp) : options.longs === Number ? new $util.LongBits(message.messageTimestamp.low >>> 0, message.messageTimestamp.high >>> 0).toNumber(true) : message.messageTimestamp;
            if (message.participant != null && message.hasOwnProperty("participant"))
                object.participant = message.participant;
            return object;
        };

        /**
         * Converts this NotificationMessageInfo to JSON.
         * @function toJSON
         * @memberof proto.NotificationMessageInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NotificationMessageInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NotificationMessageInfo;
    })();

    proto.PastParticipant = (function() {

        /**
         * Properties of a PastParticipant.
         * @memberof proto
         * @interface IPastParticipant
         * @property {string|null} [userJid] PastParticipant userJid
         * @property {proto.PastParticipant.LeaveReason|null} [leaveReason] PastParticipant leaveReason
         * @property {number|Long|null} [leaveTs] PastParticipant leaveTs
         */

        /**
         * Constructs a new PastParticipant.
         * @memberof proto
         * @classdesc Represents a PastParticipant.
         * @implements IPastParticipant
         * @constructor
         * @param {proto.IPastParticipant=} [properties] Properties to set
         */
        function PastParticipant(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PastParticipant userJid.
         * @member {string} userJid
         * @memberof proto.PastParticipant
         * @instance
         */
        PastParticipant.prototype.userJid = "";

        /**
         * PastParticipant leaveReason.
         * @member {proto.PastParticipant.LeaveReason} leaveReason
         * @memberof proto.PastParticipant
         * @instance
         */
        PastParticipant.prototype.leaveReason = 0;

        /**
         * PastParticipant leaveTs.
         * @member {number|Long} leaveTs
         * @memberof proto.PastParticipant
         * @instance
         */
        PastParticipant.prototype.leaveTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PastParticipant instance using the specified properties.
         * @function create
         * @memberof proto.PastParticipant
         * @static
         * @param {proto.IPastParticipant=} [properties] Properties to set
         * @returns {proto.PastParticipant} PastParticipant instance
         */
        PastParticipant.create = function create(properties) {
            return new PastParticipant(properties);
        };

        /**
         * Encodes the specified PastParticipant message. Does not implicitly {@link proto.PastParticipant.verify|verify} messages.
         * @function encode
         * @memberof proto.PastParticipant
         * @static
         * @param {proto.IPastParticipant} message PastParticipant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PastParticipant.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userJid != null && Object.hasOwnProperty.call(message, "userJid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userJid);
            if (message.leaveReason != null && Object.hasOwnProperty.call(message, "leaveReason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.leaveReason);
            if (message.leaveTs != null && Object.hasOwnProperty.call(message, "leaveTs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.leaveTs);
            return writer;
        };

        /**
         * Encodes the specified PastParticipant message, length delimited. Does not implicitly {@link proto.PastParticipant.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PastParticipant
         * @static
         * @param {proto.IPastParticipant} message PastParticipant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PastParticipant.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PastParticipant message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PastParticipant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PastParticipant} PastParticipant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PastParticipant.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PastParticipant();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userJid = reader.string();
                    break;
                case 2:
                    message.leaveReason = reader.int32();
                    break;
                case 3:
                    message.leaveTs = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PastParticipant message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PastParticipant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PastParticipant} PastParticipant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PastParticipant.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PastParticipant message.
         * @function verify
         * @memberof proto.PastParticipant
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PastParticipant.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userJid != null && message.hasOwnProperty("userJid"))
                if (!$util.isString(message.userJid))
                    return "userJid: string expected";
            if (message.leaveReason != null && message.hasOwnProperty("leaveReason"))
                switch (message.leaveReason) {
                default:
                    return "leaveReason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.leaveTs != null && message.hasOwnProperty("leaveTs"))
                if (!$util.isInteger(message.leaveTs) && !(message.leaveTs && $util.isInteger(message.leaveTs.low) && $util.isInteger(message.leaveTs.high)))
                    return "leaveTs: integer|Long expected";
            return null;
        };

        /**
         * Creates a PastParticipant message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PastParticipant
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PastParticipant} PastParticipant
         */
        PastParticipant.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PastParticipant)
                return object;
            var message = new $root.proto.PastParticipant();
            if (object.userJid != null)
                message.userJid = String(object.userJid);
            switch (object.leaveReason) {
            case "LEFT":
            case 0:
                message.leaveReason = 0;
                break;
            case "REMOVED":
            case 1:
                message.leaveReason = 1;
                break;
            }
            if (object.leaveTs != null)
                if ($util.Long)
                    (message.leaveTs = $util.Long.fromValue(object.leaveTs)).unsigned = true;
                else if (typeof object.leaveTs === "string")
                    message.leaveTs = parseInt(object.leaveTs, 10);
                else if (typeof object.leaveTs === "number")
                    message.leaveTs = object.leaveTs;
                else if (typeof object.leaveTs === "object")
                    message.leaveTs = new $util.LongBits(object.leaveTs.low >>> 0, object.leaveTs.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PastParticipant message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PastParticipant
         * @static
         * @param {proto.PastParticipant} message PastParticipant
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PastParticipant.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.userJid = "";
                object.leaveReason = options.enums === String ? "LEFT" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.leaveTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.leaveTs = options.longs === String ? "0" : 0;
            }
            if (message.userJid != null && message.hasOwnProperty("userJid"))
                object.userJid = message.userJid;
            if (message.leaveReason != null && message.hasOwnProperty("leaveReason"))
                object.leaveReason = options.enums === String ? $root.proto.PastParticipant.LeaveReason[message.leaveReason] : message.leaveReason;
            if (message.leaveTs != null && message.hasOwnProperty("leaveTs"))
                if (typeof message.leaveTs === "number")
                    object.leaveTs = options.longs === String ? String(message.leaveTs) : message.leaveTs;
                else
                    object.leaveTs = options.longs === String ? $util.Long.prototype.toString.call(message.leaveTs) : options.longs === Number ? new $util.LongBits(message.leaveTs.low >>> 0, message.leaveTs.high >>> 0).toNumber(true) : message.leaveTs;
            return object;
        };

        /**
         * Converts this PastParticipant to JSON.
         * @function toJSON
         * @memberof proto.PastParticipant
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PastParticipant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * LeaveReason enum.
         * @name proto.PastParticipant.LeaveReason
         * @enum {number}
         * @property {number} LEFT=0 LEFT value
         * @property {number} REMOVED=1 REMOVED value
         */
        PastParticipant.LeaveReason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LEFT"] = 0;
            values[valuesById[1] = "REMOVED"] = 1;
            return values;
        })();

        return PastParticipant;
    })();

    proto.PastParticipants = (function() {

        /**
         * Properties of a PastParticipants.
         * @memberof proto
         * @interface IPastParticipants
         * @property {string|null} [groupJid] PastParticipants groupJid
         * @property {Array.<proto.IPastParticipant>|null} [pastParticipants] PastParticipants pastParticipants
         */

        /**
         * Constructs a new PastParticipants.
         * @memberof proto
         * @classdesc Represents a PastParticipants.
         * @implements IPastParticipants
         * @constructor
         * @param {proto.IPastParticipants=} [properties] Properties to set
         */
        function PastParticipants(properties) {
            this.pastParticipants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PastParticipants groupJid.
         * @member {string} groupJid
         * @memberof proto.PastParticipants
         * @instance
         */
        PastParticipants.prototype.groupJid = "";

        /**
         * PastParticipants pastParticipants.
         * @member {Array.<proto.IPastParticipant>} pastParticipants
         * @memberof proto.PastParticipants
         * @instance
         */
        PastParticipants.prototype.pastParticipants = $util.emptyArray;

        /**
         * Creates a new PastParticipants instance using the specified properties.
         * @function create
         * @memberof proto.PastParticipants
         * @static
         * @param {proto.IPastParticipants=} [properties] Properties to set
         * @returns {proto.PastParticipants} PastParticipants instance
         */
        PastParticipants.create = function create(properties) {
            return new PastParticipants(properties);
        };

        /**
         * Encodes the specified PastParticipants message. Does not implicitly {@link proto.PastParticipants.verify|verify} messages.
         * @function encode
         * @memberof proto.PastParticipants
         * @static
         * @param {proto.IPastParticipants} message PastParticipants message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PastParticipants.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupJid != null && Object.hasOwnProperty.call(message, "groupJid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupJid);
            if (message.pastParticipants != null && message.pastParticipants.length)
                for (var i = 0; i < message.pastParticipants.length; ++i)
                    $root.proto.PastParticipant.encode(message.pastParticipants[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PastParticipants message, length delimited. Does not implicitly {@link proto.PastParticipants.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PastParticipants
         * @static
         * @param {proto.IPastParticipants} message PastParticipants message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PastParticipants.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PastParticipants message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PastParticipants
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PastParticipants} PastParticipants
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PastParticipants.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PastParticipants();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupJid = reader.string();
                    break;
                case 2:
                    if (!(message.pastParticipants && message.pastParticipants.length))
                        message.pastParticipants = [];
                    message.pastParticipants.push($root.proto.PastParticipant.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PastParticipants message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PastParticipants
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PastParticipants} PastParticipants
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PastParticipants.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PastParticipants message.
         * @function verify
         * @memberof proto.PastParticipants
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PastParticipants.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupJid != null && message.hasOwnProperty("groupJid"))
                if (!$util.isString(message.groupJid))
                    return "groupJid: string expected";
            if (message.pastParticipants != null && message.hasOwnProperty("pastParticipants")) {
                if (!Array.isArray(message.pastParticipants))
                    return "pastParticipants: array expected";
                for (var i = 0; i < message.pastParticipants.length; ++i) {
                    var error = $root.proto.PastParticipant.verify(message.pastParticipants[i]);
                    if (error)
                        return "pastParticipants." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PastParticipants message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PastParticipants
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PastParticipants} PastParticipants
         */
        PastParticipants.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PastParticipants)
                return object;
            var message = new $root.proto.PastParticipants();
            if (object.groupJid != null)
                message.groupJid = String(object.groupJid);
            if (object.pastParticipants) {
                if (!Array.isArray(object.pastParticipants))
                    throw TypeError(".proto.PastParticipants.pastParticipants: array expected");
                message.pastParticipants = [];
                for (var i = 0; i < object.pastParticipants.length; ++i) {
                    if (typeof object.pastParticipants[i] !== "object")
                        throw TypeError(".proto.PastParticipants.pastParticipants: object expected");
                    message.pastParticipants[i] = $root.proto.PastParticipant.fromObject(object.pastParticipants[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PastParticipants message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PastParticipants
         * @static
         * @param {proto.PastParticipants} message PastParticipants
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PastParticipants.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pastParticipants = [];
            if (options.defaults)
                object.groupJid = "";
            if (message.groupJid != null && message.hasOwnProperty("groupJid"))
                object.groupJid = message.groupJid;
            if (message.pastParticipants && message.pastParticipants.length) {
                object.pastParticipants = [];
                for (var j = 0; j < message.pastParticipants.length; ++j)
                    object.pastParticipants[j] = $root.proto.PastParticipant.toObject(message.pastParticipants[j], options);
            }
            return object;
        };

        /**
         * Converts this PastParticipants to JSON.
         * @function toJSON
         * @memberof proto.PastParticipants
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PastParticipants.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PastParticipants;
    })();

    proto.PaymentBackground = (function() {

        /**
         * Properties of a PaymentBackground.
         * @memberof proto
         * @interface IPaymentBackground
         * @property {string|null} [id] PaymentBackground id
         * @property {number|Long|null} [fileLength] PaymentBackground fileLength
         * @property {number|null} [width] PaymentBackground width
         * @property {number|null} [height] PaymentBackground height
         * @property {string|null} [mimetype] PaymentBackground mimetype
         * @property {number|null} [placeholderArgb] PaymentBackground placeholderArgb
         * @property {number|null} [textArgb] PaymentBackground textArgb
         * @property {number|null} [subtextArgb] PaymentBackground subtextArgb
         * @property {proto.PaymentBackground.IMediaData|null} [mediaData] PaymentBackground mediaData
         * @property {proto.PaymentBackground.Type|null} [type] PaymentBackground type
         */

        /**
         * Constructs a new PaymentBackground.
         * @memberof proto
         * @classdesc Represents a PaymentBackground.
         * @implements IPaymentBackground
         * @constructor
         * @param {proto.IPaymentBackground=} [properties] Properties to set
         */
        function PaymentBackground(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentBackground id.
         * @member {string} id
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.id = "";

        /**
         * PaymentBackground fileLength.
         * @member {number|Long} fileLength
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentBackground width.
         * @member {number} width
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.width = 0;

        /**
         * PaymentBackground height.
         * @member {number} height
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.height = 0;

        /**
         * PaymentBackground mimetype.
         * @member {string} mimetype
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.mimetype = "";

        /**
         * PaymentBackground placeholderArgb.
         * @member {number} placeholderArgb
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.placeholderArgb = 0;

        /**
         * PaymentBackground textArgb.
         * @member {number} textArgb
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.textArgb = 0;

        /**
         * PaymentBackground subtextArgb.
         * @member {number} subtextArgb
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.subtextArgb = 0;

        /**
         * PaymentBackground mediaData.
         * @member {proto.PaymentBackground.IMediaData|null|undefined} mediaData
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.mediaData = null;

        /**
         * PaymentBackground type.
         * @member {proto.PaymentBackground.Type} type
         * @memberof proto.PaymentBackground
         * @instance
         */
        PaymentBackground.prototype.type = 0;

        /**
         * Creates a new PaymentBackground instance using the specified properties.
         * @function create
         * @memberof proto.PaymentBackground
         * @static
         * @param {proto.IPaymentBackground=} [properties] Properties to set
         * @returns {proto.PaymentBackground} PaymentBackground instance
         */
        PaymentBackground.create = function create(properties) {
            return new PaymentBackground(properties);
        };

        /**
         * Encodes the specified PaymentBackground message. Does not implicitly {@link proto.PaymentBackground.verify|verify} messages.
         * @function encode
         * @memberof proto.PaymentBackground
         * @static
         * @param {proto.IPaymentBackground} message PaymentBackground message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentBackground.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.fileLength);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.height);
            if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.mimetype);
            if (message.placeholderArgb != null && Object.hasOwnProperty.call(message, "placeholderArgb"))
                writer.uint32(/* id 6, wireType 5 =*/53).fixed32(message.placeholderArgb);
            if (message.textArgb != null && Object.hasOwnProperty.call(message, "textArgb"))
                writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.textArgb);
            if (message.subtextArgb != null && Object.hasOwnProperty.call(message, "subtextArgb"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.subtextArgb);
            if (message.mediaData != null && Object.hasOwnProperty.call(message, "mediaData"))
                $root.proto.PaymentBackground.MediaData.encode(message.mediaData, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified PaymentBackground message, length delimited. Does not implicitly {@link proto.PaymentBackground.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PaymentBackground
         * @static
         * @param {proto.IPaymentBackground} message PaymentBackground message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentBackground.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentBackground message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PaymentBackground
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PaymentBackground} PaymentBackground
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentBackground.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PaymentBackground();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.fileLength = reader.uint64();
                    break;
                case 3:
                    message.width = reader.uint32();
                    break;
                case 4:
                    message.height = reader.uint32();
                    break;
                case 5:
                    message.mimetype = reader.string();
                    break;
                case 6:
                    message.placeholderArgb = reader.fixed32();
                    break;
                case 7:
                    message.textArgb = reader.fixed32();
                    break;
                case 8:
                    message.subtextArgb = reader.fixed32();
                    break;
                case 9:
                    message.mediaData = $root.proto.PaymentBackground.MediaData.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentBackground message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PaymentBackground
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PaymentBackground} PaymentBackground
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentBackground.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentBackground message.
         * @function verify
         * @memberof proto.PaymentBackground
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentBackground.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                    return "fileLength: integer|Long expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                if (!$util.isString(message.mimetype))
                    return "mimetype: string expected";
            if (message.placeholderArgb != null && message.hasOwnProperty("placeholderArgb"))
                if (!$util.isInteger(message.placeholderArgb))
                    return "placeholderArgb: integer expected";
            if (message.textArgb != null && message.hasOwnProperty("textArgb"))
                if (!$util.isInteger(message.textArgb))
                    return "textArgb: integer expected";
            if (message.subtextArgb != null && message.hasOwnProperty("subtextArgb"))
                if (!$util.isInteger(message.subtextArgb))
                    return "subtextArgb: integer expected";
            if (message.mediaData != null && message.hasOwnProperty("mediaData")) {
                var error = $root.proto.PaymentBackground.MediaData.verify(message.mediaData);
                if (error)
                    return "mediaData." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a PaymentBackground message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PaymentBackground
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PaymentBackground} PaymentBackground
         */
        PaymentBackground.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PaymentBackground)
                return object;
            var message = new $root.proto.PaymentBackground();
            if (object.id != null)
                message.id = String(object.id);
            if (object.fileLength != null)
                if ($util.Long)
                    (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                else if (typeof object.fileLength === "string")
                    message.fileLength = parseInt(object.fileLength, 10);
                else if (typeof object.fileLength === "number")
                    message.fileLength = object.fileLength;
                else if (typeof object.fileLength === "object")
                    message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.mimetype != null)
                message.mimetype = String(object.mimetype);
            if (object.placeholderArgb != null)
                message.placeholderArgb = object.placeholderArgb >>> 0;
            if (object.textArgb != null)
                message.textArgb = object.textArgb >>> 0;
            if (object.subtextArgb != null)
                message.subtextArgb = object.subtextArgb >>> 0;
            if (object.mediaData != null) {
                if (typeof object.mediaData !== "object")
                    throw TypeError(".proto.PaymentBackground.mediaData: object expected");
                message.mediaData = $root.proto.PaymentBackground.MediaData.fromObject(object.mediaData);
            }
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "DEFAULT":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PaymentBackground message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PaymentBackground
         * @static
         * @param {proto.PaymentBackground} message PaymentBackground
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentBackground.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileLength = options.longs === String ? "0" : 0;
                object.width = 0;
                object.height = 0;
                object.mimetype = "";
                object.placeholderArgb = 0;
                object.textArgb = 0;
                object.subtextArgb = 0;
                object.mediaData = null;
                object.type = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (typeof message.fileLength === "number")
                    object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                else
                    object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                object.mimetype = message.mimetype;
            if (message.placeholderArgb != null && message.hasOwnProperty("placeholderArgb"))
                object.placeholderArgb = message.placeholderArgb;
            if (message.textArgb != null && message.hasOwnProperty("textArgb"))
                object.textArgb = message.textArgb;
            if (message.subtextArgb != null && message.hasOwnProperty("subtextArgb"))
                object.subtextArgb = message.subtextArgb;
            if (message.mediaData != null && message.hasOwnProperty("mediaData"))
                object.mediaData = $root.proto.PaymentBackground.MediaData.toObject(message.mediaData, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.proto.PaymentBackground.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this PaymentBackground to JSON.
         * @function toJSON
         * @memberof proto.PaymentBackground
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentBackground.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        PaymentBackground.MediaData = (function() {

            /**
             * Properties of a MediaData.
             * @memberof proto.PaymentBackground
             * @interface IMediaData
             * @property {Uint8Array|null} [mediaKey] MediaData mediaKey
             * @property {number|Long|null} [mediaKeyTimestamp] MediaData mediaKeyTimestamp
             * @property {Uint8Array|null} [fileSha256] MediaData fileSha256
             * @property {Uint8Array|null} [fileEncSha256] MediaData fileEncSha256
             * @property {string|null} [directPath] MediaData directPath
             */

            /**
             * Constructs a new MediaData.
             * @memberof proto.PaymentBackground
             * @classdesc Represents a MediaData.
             * @implements IMediaData
             * @constructor
             * @param {proto.PaymentBackground.IMediaData=} [properties] Properties to set
             */
            function MediaData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MediaData mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.PaymentBackground.MediaData
             * @instance
             */
            MediaData.prototype.mediaKey = $util.newBuffer([]);

            /**
             * MediaData mediaKeyTimestamp.
             * @member {number|Long} mediaKeyTimestamp
             * @memberof proto.PaymentBackground.MediaData
             * @instance
             */
            MediaData.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MediaData fileSha256.
             * @member {Uint8Array} fileSha256
             * @memberof proto.PaymentBackground.MediaData
             * @instance
             */
            MediaData.prototype.fileSha256 = $util.newBuffer([]);

            /**
             * MediaData fileEncSha256.
             * @member {Uint8Array} fileEncSha256
             * @memberof proto.PaymentBackground.MediaData
             * @instance
             */
            MediaData.prototype.fileEncSha256 = $util.newBuffer([]);

            /**
             * MediaData directPath.
             * @member {string} directPath
             * @memberof proto.PaymentBackground.MediaData
             * @instance
             */
            MediaData.prototype.directPath = "";

            /**
             * Creates a new MediaData instance using the specified properties.
             * @function create
             * @memberof proto.PaymentBackground.MediaData
             * @static
             * @param {proto.PaymentBackground.IMediaData=} [properties] Properties to set
             * @returns {proto.PaymentBackground.MediaData} MediaData instance
             */
            MediaData.create = function create(properties) {
                return new MediaData(properties);
            };

            /**
             * Encodes the specified MediaData message. Does not implicitly {@link proto.PaymentBackground.MediaData.verify|verify} messages.
             * @function encode
             * @memberof proto.PaymentBackground.MediaData
             * @static
             * @param {proto.PaymentBackground.IMediaData} message MediaData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MediaData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.mediaKey);
                if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.mediaKeyTimestamp);
                if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileSha256);
                if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fileEncSha256);
                if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.directPath);
                return writer;
            };

            /**
             * Encodes the specified MediaData message, length delimited. Does not implicitly {@link proto.PaymentBackground.MediaData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.PaymentBackground.MediaData
             * @static
             * @param {proto.PaymentBackground.IMediaData} message MediaData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MediaData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MediaData message from the specified reader or buffer.
             * @function decode
             * @memberof proto.PaymentBackground.MediaData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.PaymentBackground.MediaData} MediaData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MediaData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PaymentBackground.MediaData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mediaKey = reader.bytes();
                        break;
                    case 2:
                        message.mediaKeyTimestamp = reader.int64();
                        break;
                    case 3:
                        message.fileSha256 = reader.bytes();
                        break;
                    case 4:
                        message.fileEncSha256 = reader.bytes();
                        break;
                    case 5:
                        message.directPath = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MediaData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.PaymentBackground.MediaData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.PaymentBackground.MediaData} MediaData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MediaData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MediaData message.
             * @function verify
             * @memberof proto.PaymentBackground.MediaData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MediaData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                        return "mediaKeyTimestamp: integer|Long expected";
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                        return "fileSha256: buffer expected";
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                        return "fileEncSha256: buffer expected";
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    if (!$util.isString(message.directPath))
                        return "directPath: string expected";
                return null;
            };

            /**
             * Creates a MediaData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.PaymentBackground.MediaData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.PaymentBackground.MediaData} MediaData
             */
            MediaData.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.PaymentBackground.MediaData)
                    return object;
                var message = new $root.proto.PaymentBackground.MediaData();
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.mediaKeyTimestamp != null)
                    if ($util.Long)
                        (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                    else if (typeof object.mediaKeyTimestamp === "string")
                        message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                    else if (typeof object.mediaKeyTimestamp === "number")
                        message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                    else if (typeof object.mediaKeyTimestamp === "object")
                        message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
                if (object.fileSha256 != null)
                    if (typeof object.fileSha256 === "string")
                        $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                    else if (object.fileSha256.length)
                        message.fileSha256 = object.fileSha256;
                if (object.fileEncSha256 != null)
                    if (typeof object.fileEncSha256 === "string")
                        $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                    else if (object.fileEncSha256.length)
                        message.fileEncSha256 = object.fileEncSha256;
                if (object.directPath != null)
                    message.directPath = String(object.directPath);
                return message;
            };

            /**
             * Creates a plain object from a MediaData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.PaymentBackground.MediaData
             * @static
             * @param {proto.PaymentBackground.MediaData} message MediaData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MediaData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.fileSha256 = "";
                    else {
                        object.fileSha256 = [];
                        if (options.bytes !== Array)
                            object.fileSha256 = $util.newBuffer(object.fileSha256);
                    }
                    if (options.bytes === String)
                        object.fileEncSha256 = "";
                    else {
                        object.fileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                    }
                    object.directPath = "";
                }
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                    if (typeof message.mediaKeyTimestamp === "number")
                        object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                    else
                        object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
                if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                    object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    object.directPath = message.directPath;
                return object;
            };

            /**
             * Converts this MediaData to JSON.
             * @function toJSON
             * @memberof proto.PaymentBackground.MediaData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MediaData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MediaData;
        })();

        /**
         * Type enum.
         * @name proto.PaymentBackground.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} DEFAULT=1 DEFAULT value
         */
        PaymentBackground.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "DEFAULT"] = 1;
            return values;
        })();

        return PaymentBackground;
    })();

    proto.PaymentInfo = (function() {

        /**
         * Properties of a PaymentInfo.
         * @memberof proto
         * @interface IPaymentInfo
         * @property {proto.PaymentInfo.Currency|null} [currencyDeprecated] PaymentInfo currencyDeprecated
         * @property {number|Long|null} [amount1000] PaymentInfo amount1000
         * @property {string|null} [receiverJid] PaymentInfo receiverJid
         * @property {proto.PaymentInfo.Status|null} [status] PaymentInfo status
         * @property {number|Long|null} [transactionTimestamp] PaymentInfo transactionTimestamp
         * @property {proto.IMessageKey|null} [requestMessageKey] PaymentInfo requestMessageKey
         * @property {number|Long|null} [expiryTimestamp] PaymentInfo expiryTimestamp
         * @property {boolean|null} [futureproofed] PaymentInfo futureproofed
         * @property {string|null} [currency] PaymentInfo currency
         * @property {proto.PaymentInfo.TxnStatus|null} [txnStatus] PaymentInfo txnStatus
         * @property {boolean|null} [useNoviFiatFormat] PaymentInfo useNoviFiatFormat
         * @property {proto.IMoney|null} [primaryAmount] PaymentInfo primaryAmount
         * @property {proto.IMoney|null} [exchangeAmount] PaymentInfo exchangeAmount
         */

        /**
         * Constructs a new PaymentInfo.
         * @memberof proto
         * @classdesc Represents a PaymentInfo.
         * @implements IPaymentInfo
         * @constructor
         * @param {proto.IPaymentInfo=} [properties] Properties to set
         */
        function PaymentInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentInfo currencyDeprecated.
         * @member {proto.PaymentInfo.Currency} currencyDeprecated
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.currencyDeprecated = 0;

        /**
         * PaymentInfo amount1000.
         * @member {number|Long} amount1000
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.amount1000 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentInfo receiverJid.
         * @member {string} receiverJid
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.receiverJid = "";

        /**
         * PaymentInfo status.
         * @member {proto.PaymentInfo.Status} status
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.status = 0;

        /**
         * PaymentInfo transactionTimestamp.
         * @member {number|Long} transactionTimestamp
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.transactionTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentInfo requestMessageKey.
         * @member {proto.IMessageKey|null|undefined} requestMessageKey
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.requestMessageKey = null;

        /**
         * PaymentInfo expiryTimestamp.
         * @member {number|Long} expiryTimestamp
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.expiryTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentInfo futureproofed.
         * @member {boolean} futureproofed
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.futureproofed = false;

        /**
         * PaymentInfo currency.
         * @member {string} currency
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.currency = "";

        /**
         * PaymentInfo txnStatus.
         * @member {proto.PaymentInfo.TxnStatus} txnStatus
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.txnStatus = 0;

        /**
         * PaymentInfo useNoviFiatFormat.
         * @member {boolean} useNoviFiatFormat
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.useNoviFiatFormat = false;

        /**
         * PaymentInfo primaryAmount.
         * @member {proto.IMoney|null|undefined} primaryAmount
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.primaryAmount = null;

        /**
         * PaymentInfo exchangeAmount.
         * @member {proto.IMoney|null|undefined} exchangeAmount
         * @memberof proto.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.exchangeAmount = null;

        /**
         * Creates a new PaymentInfo instance using the specified properties.
         * @function create
         * @memberof proto.PaymentInfo
         * @static
         * @param {proto.IPaymentInfo=} [properties] Properties to set
         * @returns {proto.PaymentInfo} PaymentInfo instance
         */
        PaymentInfo.create = function create(properties) {
            return new PaymentInfo(properties);
        };

        /**
         * Encodes the specified PaymentInfo message. Does not implicitly {@link proto.PaymentInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.PaymentInfo
         * @static
         * @param {proto.IPaymentInfo} message PaymentInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currencyDeprecated != null && Object.hasOwnProperty.call(message, "currencyDeprecated"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currencyDeprecated);
            if (message.amount1000 != null && Object.hasOwnProperty.call(message, "amount1000"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount1000);
            if (message.receiverJid != null && Object.hasOwnProperty.call(message, "receiverJid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.receiverJid);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            if (message.transactionTimestamp != null && Object.hasOwnProperty.call(message, "transactionTimestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.transactionTimestamp);
            if (message.requestMessageKey != null && Object.hasOwnProperty.call(message, "requestMessageKey"))
                $root.proto.MessageKey.encode(message.requestMessageKey, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.expiryTimestamp != null && Object.hasOwnProperty.call(message, "expiryTimestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.expiryTimestamp);
            if (message.futureproofed != null && Object.hasOwnProperty.call(message, "futureproofed"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.futureproofed);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.currency);
            if (message.txnStatus != null && Object.hasOwnProperty.call(message, "txnStatus"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.txnStatus);
            if (message.useNoviFiatFormat != null && Object.hasOwnProperty.call(message, "useNoviFiatFormat"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.useNoviFiatFormat);
            if (message.primaryAmount != null && Object.hasOwnProperty.call(message, "primaryAmount"))
                $root.proto.Money.encode(message.primaryAmount, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.exchangeAmount != null && Object.hasOwnProperty.call(message, "exchangeAmount"))
                $root.proto.Money.encode(message.exchangeAmount, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PaymentInfo message, length delimited. Does not implicitly {@link proto.PaymentInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PaymentInfo
         * @static
         * @param {proto.IPaymentInfo} message PaymentInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PaymentInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PaymentInfo} PaymentInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PaymentInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currencyDeprecated = reader.int32();
                    break;
                case 2:
                    message.amount1000 = reader.uint64();
                    break;
                case 3:
                    message.receiverJid = reader.string();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                case 5:
                    message.transactionTimestamp = reader.uint64();
                    break;
                case 6:
                    message.requestMessageKey = $root.proto.MessageKey.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.expiryTimestamp = reader.uint64();
                    break;
                case 8:
                    message.futureproofed = reader.bool();
                    break;
                case 9:
                    message.currency = reader.string();
                    break;
                case 10:
                    message.txnStatus = reader.int32();
                    break;
                case 11:
                    message.useNoviFiatFormat = reader.bool();
                    break;
                case 12:
                    message.primaryAmount = $root.proto.Money.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.exchangeAmount = $root.proto.Money.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PaymentInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PaymentInfo} PaymentInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentInfo message.
         * @function verify
         * @memberof proto.PaymentInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currencyDeprecated != null && message.hasOwnProperty("currencyDeprecated"))
                switch (message.currencyDeprecated) {
                default:
                    return "currencyDeprecated: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                if (!$util.isInteger(message.amount1000) && !(message.amount1000 && $util.isInteger(message.amount1000.low) && $util.isInteger(message.amount1000.high)))
                    return "amount1000: integer|Long expected";
            if (message.receiverJid != null && message.hasOwnProperty("receiverJid"))
                if (!$util.isString(message.receiverJid))
                    return "receiverJid: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.transactionTimestamp != null && message.hasOwnProperty("transactionTimestamp"))
                if (!$util.isInteger(message.transactionTimestamp) && !(message.transactionTimestamp && $util.isInteger(message.transactionTimestamp.low) && $util.isInteger(message.transactionTimestamp.high)))
                    return "transactionTimestamp: integer|Long expected";
            if (message.requestMessageKey != null && message.hasOwnProperty("requestMessageKey")) {
                var error = $root.proto.MessageKey.verify(message.requestMessageKey);
                if (error)
                    return "requestMessageKey." + error;
            }
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (!$util.isInteger(message.expiryTimestamp) && !(message.expiryTimestamp && $util.isInteger(message.expiryTimestamp.low) && $util.isInteger(message.expiryTimestamp.high)))
                    return "expiryTimestamp: integer|Long expected";
            if (message.futureproofed != null && message.hasOwnProperty("futureproofed"))
                if (typeof message.futureproofed !== "boolean")
                    return "futureproofed: boolean expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isString(message.currency))
                    return "currency: string expected";
            if (message.txnStatus != null && message.hasOwnProperty("txnStatus"))
                switch (message.txnStatus) {
                default:
                    return "txnStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                    break;
                }
            if (message.useNoviFiatFormat != null && message.hasOwnProperty("useNoviFiatFormat"))
                if (typeof message.useNoviFiatFormat !== "boolean")
                    return "useNoviFiatFormat: boolean expected";
            if (message.primaryAmount != null && message.hasOwnProperty("primaryAmount")) {
                var error = $root.proto.Money.verify(message.primaryAmount);
                if (error)
                    return "primaryAmount." + error;
            }
            if (message.exchangeAmount != null && message.hasOwnProperty("exchangeAmount")) {
                var error = $root.proto.Money.verify(message.exchangeAmount);
                if (error)
                    return "exchangeAmount." + error;
            }
            return null;
        };

        /**
         * Creates a PaymentInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PaymentInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PaymentInfo} PaymentInfo
         */
        PaymentInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PaymentInfo)
                return object;
            var message = new $root.proto.PaymentInfo();
            switch (object.currencyDeprecated) {
            case "UNKNOWN_CURRENCY":
            case 0:
                message.currencyDeprecated = 0;
                break;
            case "INR":
            case 1:
                message.currencyDeprecated = 1;
                break;
            }
            if (object.amount1000 != null)
                if ($util.Long)
                    (message.amount1000 = $util.Long.fromValue(object.amount1000)).unsigned = true;
                else if (typeof object.amount1000 === "string")
                    message.amount1000 = parseInt(object.amount1000, 10);
                else if (typeof object.amount1000 === "number")
                    message.amount1000 = object.amount1000;
                else if (typeof object.amount1000 === "object")
                    message.amount1000 = new $util.LongBits(object.amount1000.low >>> 0, object.amount1000.high >>> 0).toNumber(true);
            if (object.receiverJid != null)
                message.receiverJid = String(object.receiverJid);
            switch (object.status) {
            case "UNKNOWN_STATUS":
            case 0:
                message.status = 0;
                break;
            case "PROCESSING":
            case 1:
                message.status = 1;
                break;
            case "SENT":
            case 2:
                message.status = 2;
                break;
            case "NEED_TO_ACCEPT":
            case 3:
                message.status = 3;
                break;
            case "COMPLETE":
            case 4:
                message.status = 4;
                break;
            case "COULD_NOT_COMPLETE":
            case 5:
                message.status = 5;
                break;
            case "REFUNDED":
            case 6:
                message.status = 6;
                break;
            case "EXPIRED":
            case 7:
                message.status = 7;
                break;
            case "REJECTED":
            case 8:
                message.status = 8;
                break;
            case "CANCELLED":
            case 9:
                message.status = 9;
                break;
            case "WAITING_FOR_PAYER":
            case 10:
                message.status = 10;
                break;
            case "WAITING":
            case 11:
                message.status = 11;
                break;
            }
            if (object.transactionTimestamp != null)
                if ($util.Long)
                    (message.transactionTimestamp = $util.Long.fromValue(object.transactionTimestamp)).unsigned = true;
                else if (typeof object.transactionTimestamp === "string")
                    message.transactionTimestamp = parseInt(object.transactionTimestamp, 10);
                else if (typeof object.transactionTimestamp === "number")
                    message.transactionTimestamp = object.transactionTimestamp;
                else if (typeof object.transactionTimestamp === "object")
                    message.transactionTimestamp = new $util.LongBits(object.transactionTimestamp.low >>> 0, object.transactionTimestamp.high >>> 0).toNumber(true);
            if (object.requestMessageKey != null) {
                if (typeof object.requestMessageKey !== "object")
                    throw TypeError(".proto.PaymentInfo.requestMessageKey: object expected");
                message.requestMessageKey = $root.proto.MessageKey.fromObject(object.requestMessageKey);
            }
            if (object.expiryTimestamp != null)
                if ($util.Long)
                    (message.expiryTimestamp = $util.Long.fromValue(object.expiryTimestamp)).unsigned = true;
                else if (typeof object.expiryTimestamp === "string")
                    message.expiryTimestamp = parseInt(object.expiryTimestamp, 10);
                else if (typeof object.expiryTimestamp === "number")
                    message.expiryTimestamp = object.expiryTimestamp;
                else if (typeof object.expiryTimestamp === "object")
                    message.expiryTimestamp = new $util.LongBits(object.expiryTimestamp.low >>> 0, object.expiryTimestamp.high >>> 0).toNumber(true);
            if (object.futureproofed != null)
                message.futureproofed = Boolean(object.futureproofed);
            if (object.currency != null)
                message.currency = String(object.currency);
            switch (object.txnStatus) {
            case "UNKNOWN":
            case 0:
                message.txnStatus = 0;
                break;
            case "PENDING_SETUP":
            case 1:
                message.txnStatus = 1;
                break;
            case "PENDING_RECEIVER_SETUP":
            case 2:
                message.txnStatus = 2;
                break;
            case "INIT":
            case 3:
                message.txnStatus = 3;
                break;
            case "SUCCESS":
            case 4:
                message.txnStatus = 4;
                break;
            case "COMPLETED":
            case 5:
                message.txnStatus = 5;
                break;
            case "FAILED":
            case 6:
                message.txnStatus = 6;
                break;
            case "FAILED_RISK":
            case 7:
                message.txnStatus = 7;
                break;
            case "FAILED_PROCESSING":
            case 8:
                message.txnStatus = 8;
                break;
            case "FAILED_RECEIVER_PROCESSING":
            case 9:
                message.txnStatus = 9;
                break;
            case "FAILED_DA":
            case 10:
                message.txnStatus = 10;
                break;
            case "FAILED_DA_FINAL":
            case 11:
                message.txnStatus = 11;
                break;
            case "REFUNDED_TXN":
            case 12:
                message.txnStatus = 12;
                break;
            case "REFUND_FAILED":
            case 13:
                message.txnStatus = 13;
                break;
            case "REFUND_FAILED_PROCESSING":
            case 14:
                message.txnStatus = 14;
                break;
            case "REFUND_FAILED_DA":
            case 15:
                message.txnStatus = 15;
                break;
            case "EXPIRED_TXN":
            case 16:
                message.txnStatus = 16;
                break;
            case "AUTH_CANCELED":
            case 17:
                message.txnStatus = 17;
                break;
            case "AUTH_CANCEL_FAILED_PROCESSING":
            case 18:
                message.txnStatus = 18;
                break;
            case "AUTH_CANCEL_FAILED":
            case 19:
                message.txnStatus = 19;
                break;
            case "COLLECT_INIT":
            case 20:
                message.txnStatus = 20;
                break;
            case "COLLECT_SUCCESS":
            case 21:
                message.txnStatus = 21;
                break;
            case "COLLECT_FAILED":
            case 22:
                message.txnStatus = 22;
                break;
            case "COLLECT_FAILED_RISK":
            case 23:
                message.txnStatus = 23;
                break;
            case "COLLECT_REJECTED":
            case 24:
                message.txnStatus = 24;
                break;
            case "COLLECT_EXPIRED":
            case 25:
                message.txnStatus = 25;
                break;
            case "COLLECT_CANCELED":
            case 26:
                message.txnStatus = 26;
                break;
            case "COLLECT_CANCELLING":
            case 27:
                message.txnStatus = 27;
                break;
            case "IN_REVIEW":
            case 28:
                message.txnStatus = 28;
                break;
            case "REVERSAL_SUCCESS":
            case 29:
                message.txnStatus = 29;
                break;
            case "REVERSAL_PENDING":
            case 30:
                message.txnStatus = 30;
                break;
            case "REFUND_PENDING":
            case 31:
                message.txnStatus = 31;
                break;
            }
            if (object.useNoviFiatFormat != null)
                message.useNoviFiatFormat = Boolean(object.useNoviFiatFormat);
            if (object.primaryAmount != null) {
                if (typeof object.primaryAmount !== "object")
                    throw TypeError(".proto.PaymentInfo.primaryAmount: object expected");
                message.primaryAmount = $root.proto.Money.fromObject(object.primaryAmount);
            }
            if (object.exchangeAmount != null) {
                if (typeof object.exchangeAmount !== "object")
                    throw TypeError(".proto.PaymentInfo.exchangeAmount: object expected");
                message.exchangeAmount = $root.proto.Money.fromObject(object.exchangeAmount);
            }
            return message;
        };

        /**
         * Creates a plain object from a PaymentInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PaymentInfo
         * @static
         * @param {proto.PaymentInfo} message PaymentInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currencyDeprecated = options.enums === String ? "UNKNOWN_CURRENCY" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount1000 = options.longs === String ? "0" : 0;
                object.receiverJid = "";
                object.status = options.enums === String ? "UNKNOWN_STATUS" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.transactionTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transactionTimestamp = options.longs === String ? "0" : 0;
                object.requestMessageKey = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.expiryTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiryTimestamp = options.longs === String ? "0" : 0;
                object.futureproofed = false;
                object.currency = "";
                object.txnStatus = options.enums === String ? "UNKNOWN" : 0;
                object.useNoviFiatFormat = false;
                object.primaryAmount = null;
                object.exchangeAmount = null;
            }
            if (message.currencyDeprecated != null && message.hasOwnProperty("currencyDeprecated"))
                object.currencyDeprecated = options.enums === String ? $root.proto.PaymentInfo.Currency[message.currencyDeprecated] : message.currencyDeprecated;
            if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                if (typeof message.amount1000 === "number")
                    object.amount1000 = options.longs === String ? String(message.amount1000) : message.amount1000;
                else
                    object.amount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.amount1000) : options.longs === Number ? new $util.LongBits(message.amount1000.low >>> 0, message.amount1000.high >>> 0).toNumber(true) : message.amount1000;
            if (message.receiverJid != null && message.hasOwnProperty("receiverJid"))
                object.receiverJid = message.receiverJid;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.proto.PaymentInfo.Status[message.status] : message.status;
            if (message.transactionTimestamp != null && message.hasOwnProperty("transactionTimestamp"))
                if (typeof message.transactionTimestamp === "number")
                    object.transactionTimestamp = options.longs === String ? String(message.transactionTimestamp) : message.transactionTimestamp;
                else
                    object.transactionTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.transactionTimestamp) : options.longs === Number ? new $util.LongBits(message.transactionTimestamp.low >>> 0, message.transactionTimestamp.high >>> 0).toNumber(true) : message.transactionTimestamp;
            if (message.requestMessageKey != null && message.hasOwnProperty("requestMessageKey"))
                object.requestMessageKey = $root.proto.MessageKey.toObject(message.requestMessageKey, options);
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (typeof message.expiryTimestamp === "number")
                    object.expiryTimestamp = options.longs === String ? String(message.expiryTimestamp) : message.expiryTimestamp;
                else
                    object.expiryTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expiryTimestamp) : options.longs === Number ? new $util.LongBits(message.expiryTimestamp.low >>> 0, message.expiryTimestamp.high >>> 0).toNumber(true) : message.expiryTimestamp;
            if (message.futureproofed != null && message.hasOwnProperty("futureproofed"))
                object.futureproofed = message.futureproofed;
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = message.currency;
            if (message.txnStatus != null && message.hasOwnProperty("txnStatus"))
                object.txnStatus = options.enums === String ? $root.proto.PaymentInfo.TxnStatus[message.txnStatus] : message.txnStatus;
            if (message.useNoviFiatFormat != null && message.hasOwnProperty("useNoviFiatFormat"))
                object.useNoviFiatFormat = message.useNoviFiatFormat;
            if (message.primaryAmount != null && message.hasOwnProperty("primaryAmount"))
                object.primaryAmount = $root.proto.Money.toObject(message.primaryAmount, options);
            if (message.exchangeAmount != null && message.hasOwnProperty("exchangeAmount"))
                object.exchangeAmount = $root.proto.Money.toObject(message.exchangeAmount, options);
            return object;
        };

        /**
         * Converts this PaymentInfo to JSON.
         * @function toJSON
         * @memberof proto.PaymentInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Currency enum.
         * @name proto.PaymentInfo.Currency
         * @enum {number}
         * @property {number} UNKNOWN_CURRENCY=0 UNKNOWN_CURRENCY value
         * @property {number} INR=1 INR value
         */
        PaymentInfo.Currency = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_CURRENCY"] = 0;
            values[valuesById[1] = "INR"] = 1;
            return values;
        })();

        /**
         * Status enum.
         * @name proto.PaymentInfo.Status
         * @enum {number}
         * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
         * @property {number} PROCESSING=1 PROCESSING value
         * @property {number} SENT=2 SENT value
         * @property {number} NEED_TO_ACCEPT=3 NEED_TO_ACCEPT value
         * @property {number} COMPLETE=4 COMPLETE value
         * @property {number} COULD_NOT_COMPLETE=5 COULD_NOT_COMPLETE value
         * @property {number} REFUNDED=6 REFUNDED value
         * @property {number} EXPIRED=7 EXPIRED value
         * @property {number} REJECTED=8 REJECTED value
         * @property {number} CANCELLED=9 CANCELLED value
         * @property {number} WAITING_FOR_PAYER=10 WAITING_FOR_PAYER value
         * @property {number} WAITING=11 WAITING value
         */
        PaymentInfo.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_STATUS"] = 0;
            values[valuesById[1] = "PROCESSING"] = 1;
            values[valuesById[2] = "SENT"] = 2;
            values[valuesById[3] = "NEED_TO_ACCEPT"] = 3;
            values[valuesById[4] = "COMPLETE"] = 4;
            values[valuesById[5] = "COULD_NOT_COMPLETE"] = 5;
            values[valuesById[6] = "REFUNDED"] = 6;
            values[valuesById[7] = "EXPIRED"] = 7;
            values[valuesById[8] = "REJECTED"] = 8;
            values[valuesById[9] = "CANCELLED"] = 9;
            values[valuesById[10] = "WAITING_FOR_PAYER"] = 10;
            values[valuesById[11] = "WAITING"] = 11;
            return values;
        })();

        /**
         * TxnStatus enum.
         * @name proto.PaymentInfo.TxnStatus
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} PENDING_SETUP=1 PENDING_SETUP value
         * @property {number} PENDING_RECEIVER_SETUP=2 PENDING_RECEIVER_SETUP value
         * @property {number} INIT=3 INIT value
         * @property {number} SUCCESS=4 SUCCESS value
         * @property {number} COMPLETED=5 COMPLETED value
         * @property {number} FAILED=6 FAILED value
         * @property {number} FAILED_RISK=7 FAILED_RISK value
         * @property {number} FAILED_PROCESSING=8 FAILED_PROCESSING value
         * @property {number} FAILED_RECEIVER_PROCESSING=9 FAILED_RECEIVER_PROCESSING value
         * @property {number} FAILED_DA=10 FAILED_DA value
         * @property {number} FAILED_DA_FINAL=11 FAILED_DA_FINAL value
         * @property {number} REFUNDED_TXN=12 REFUNDED_TXN value
         * @property {number} REFUND_FAILED=13 REFUND_FAILED value
         * @property {number} REFUND_FAILED_PROCESSING=14 REFUND_FAILED_PROCESSING value
         * @property {number} REFUND_FAILED_DA=15 REFUND_FAILED_DA value
         * @property {number} EXPIRED_TXN=16 EXPIRED_TXN value
         * @property {number} AUTH_CANCELED=17 AUTH_CANCELED value
         * @property {number} AUTH_CANCEL_FAILED_PROCESSING=18 AUTH_CANCEL_FAILED_PROCESSING value
         * @property {number} AUTH_CANCEL_FAILED=19 AUTH_CANCEL_FAILED value
         * @property {number} COLLECT_INIT=20 COLLECT_INIT value
         * @property {number} COLLECT_SUCCESS=21 COLLECT_SUCCESS value
         * @property {number} COLLECT_FAILED=22 COLLECT_FAILED value
         * @property {number} COLLECT_FAILED_RISK=23 COLLECT_FAILED_RISK value
         * @property {number} COLLECT_REJECTED=24 COLLECT_REJECTED value
         * @property {number} COLLECT_EXPIRED=25 COLLECT_EXPIRED value
         * @property {number} COLLECT_CANCELED=26 COLLECT_CANCELED value
         * @property {number} COLLECT_CANCELLING=27 COLLECT_CANCELLING value
         * @property {number} IN_REVIEW=28 IN_REVIEW value
         * @property {number} REVERSAL_SUCCESS=29 REVERSAL_SUCCESS value
         * @property {number} REVERSAL_PENDING=30 REVERSAL_PENDING value
         * @property {number} REFUND_PENDING=31 REFUND_PENDING value
         */
        PaymentInfo.TxnStatus = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "PENDING_SETUP"] = 1;
            values[valuesById[2] = "PENDING_RECEIVER_SETUP"] = 2;
            values[valuesById[3] = "INIT"] = 3;
            values[valuesById[4] = "SUCCESS"] = 4;
            values[valuesById[5] = "COMPLETED"] = 5;
            values[valuesById[6] = "FAILED"] = 6;
            values[valuesById[7] = "FAILED_RISK"] = 7;
            values[valuesById[8] = "FAILED_PROCESSING"] = 8;
            values[valuesById[9] = "FAILED_RECEIVER_PROCESSING"] = 9;
            values[valuesById[10] = "FAILED_DA"] = 10;
            values[valuesById[11] = "FAILED_DA_FINAL"] = 11;
            values[valuesById[12] = "REFUNDED_TXN"] = 12;
            values[valuesById[13] = "REFUND_FAILED"] = 13;
            values[valuesById[14] = "REFUND_FAILED_PROCESSING"] = 14;
            values[valuesById[15] = "REFUND_FAILED_DA"] = 15;
            values[valuesById[16] = "EXPIRED_TXN"] = 16;
            values[valuesById[17] = "AUTH_CANCELED"] = 17;
            values[valuesById[18] = "AUTH_CANCEL_FAILED_PROCESSING"] = 18;
            values[valuesById[19] = "AUTH_CANCEL_FAILED"] = 19;
            values[valuesById[20] = "COLLECT_INIT"] = 20;
            values[valuesById[21] = "COLLECT_SUCCESS"] = 21;
            values[valuesById[22] = "COLLECT_FAILED"] = 22;
            values[valuesById[23] = "COLLECT_FAILED_RISK"] = 23;
            values[valuesById[24] = "COLLECT_REJECTED"] = 24;
            values[valuesById[25] = "COLLECT_EXPIRED"] = 25;
            values[valuesById[26] = "COLLECT_CANCELED"] = 26;
            values[valuesById[27] = "COLLECT_CANCELLING"] = 27;
            values[valuesById[28] = "IN_REVIEW"] = 28;
            values[valuesById[29] = "REVERSAL_SUCCESS"] = 29;
            values[valuesById[30] = "REVERSAL_PENDING"] = 30;
            values[valuesById[31] = "REFUND_PENDING"] = 31;
            return values;
        })();

        return PaymentInfo;
    })();

    proto.PendingKeyExchange = (function() {

        /**
         * Properties of a PendingKeyExchange.
         * @memberof proto
         * @interface IPendingKeyExchange
         * @property {number|null} [sequence] PendingKeyExchange sequence
         * @property {Uint8Array|null} [localBaseKey] PendingKeyExchange localBaseKey
         * @property {Uint8Array|null} [localBaseKeyPrivate] PendingKeyExchange localBaseKeyPrivate
         * @property {Uint8Array|null} [localRatchetKey] PendingKeyExchange localRatchetKey
         * @property {Uint8Array|null} [localRatchetKeyPrivate] PendingKeyExchange localRatchetKeyPrivate
         * @property {Uint8Array|null} [localIdentityKey] PendingKeyExchange localIdentityKey
         * @property {Uint8Array|null} [localIdentityKeyPrivate] PendingKeyExchange localIdentityKeyPrivate
         */

        /**
         * Constructs a new PendingKeyExchange.
         * @memberof proto
         * @classdesc Represents a PendingKeyExchange.
         * @implements IPendingKeyExchange
         * @constructor
         * @param {proto.IPendingKeyExchange=} [properties] Properties to set
         */
        function PendingKeyExchange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PendingKeyExchange sequence.
         * @member {number} sequence
         * @memberof proto.PendingKeyExchange
         * @instance
         */
        PendingKeyExchange.prototype.sequence = 0;

        /**
         * PendingKeyExchange localBaseKey.
         * @member {Uint8Array} localBaseKey
         * @memberof proto.PendingKeyExchange
         * @instance
         */
        PendingKeyExchange.prototype.localBaseKey = $util.newBuffer([]);

        /**
         * PendingKeyExchange localBaseKeyPrivate.
         * @member {Uint8Array} localBaseKeyPrivate
         * @memberof proto.PendingKeyExchange
         * @instance
         */
        PendingKeyExchange.prototype.localBaseKeyPrivate = $util.newBuffer([]);

        /**
         * PendingKeyExchange localRatchetKey.
         * @member {Uint8Array} localRatchetKey
         * @memberof proto.PendingKeyExchange
         * @instance
         */
        PendingKeyExchange.prototype.localRatchetKey = $util.newBuffer([]);

        /**
         * PendingKeyExchange localRatchetKeyPrivate.
         * @member {Uint8Array} localRatchetKeyPrivate
         * @memberof proto.PendingKeyExchange
         * @instance
         */
        PendingKeyExchange.prototype.localRatchetKeyPrivate = $util.newBuffer([]);

        /**
         * PendingKeyExchange localIdentityKey.
         * @member {Uint8Array} localIdentityKey
         * @memberof proto.PendingKeyExchange
         * @instance
         */
        PendingKeyExchange.prototype.localIdentityKey = $util.newBuffer([]);

        /**
         * PendingKeyExchange localIdentityKeyPrivate.
         * @member {Uint8Array} localIdentityKeyPrivate
         * @memberof proto.PendingKeyExchange
         * @instance
         */
        PendingKeyExchange.prototype.localIdentityKeyPrivate = $util.newBuffer([]);

        /**
         * Creates a new PendingKeyExchange instance using the specified properties.
         * @function create
         * @memberof proto.PendingKeyExchange
         * @static
         * @param {proto.IPendingKeyExchange=} [properties] Properties to set
         * @returns {proto.PendingKeyExchange} PendingKeyExchange instance
         */
        PendingKeyExchange.create = function create(properties) {
            return new PendingKeyExchange(properties);
        };

        /**
         * Encodes the specified PendingKeyExchange message. Does not implicitly {@link proto.PendingKeyExchange.verify|verify} messages.
         * @function encode
         * @memberof proto.PendingKeyExchange
         * @static
         * @param {proto.IPendingKeyExchange} message PendingKeyExchange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingKeyExchange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sequence);
            if (message.localBaseKey != null && Object.hasOwnProperty.call(message, "localBaseKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.localBaseKey);
            if (message.localBaseKeyPrivate != null && Object.hasOwnProperty.call(message, "localBaseKeyPrivate"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.localBaseKeyPrivate);
            if (message.localRatchetKey != null && Object.hasOwnProperty.call(message, "localRatchetKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.localRatchetKey);
            if (message.localRatchetKeyPrivate != null && Object.hasOwnProperty.call(message, "localRatchetKeyPrivate"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.localRatchetKeyPrivate);
            if (message.localIdentityKey != null && Object.hasOwnProperty.call(message, "localIdentityKey"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.localIdentityKey);
            if (message.localIdentityKeyPrivate != null && Object.hasOwnProperty.call(message, "localIdentityKeyPrivate"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.localIdentityKeyPrivate);
            return writer;
        };

        /**
         * Encodes the specified PendingKeyExchange message, length delimited. Does not implicitly {@link proto.PendingKeyExchange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PendingKeyExchange
         * @static
         * @param {proto.IPendingKeyExchange} message PendingKeyExchange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingKeyExchange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingKeyExchange message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PendingKeyExchange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PendingKeyExchange} PendingKeyExchange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingKeyExchange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PendingKeyExchange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sequence = reader.uint32();
                    break;
                case 2:
                    message.localBaseKey = reader.bytes();
                    break;
                case 3:
                    message.localBaseKeyPrivate = reader.bytes();
                    break;
                case 4:
                    message.localRatchetKey = reader.bytes();
                    break;
                case 5:
                    message.localRatchetKeyPrivate = reader.bytes();
                    break;
                case 7:
                    message.localIdentityKey = reader.bytes();
                    break;
                case 8:
                    message.localIdentityKeyPrivate = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingKeyExchange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PendingKeyExchange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PendingKeyExchange} PendingKeyExchange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingKeyExchange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingKeyExchange message.
         * @function verify
         * @memberof proto.PendingKeyExchange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingKeyExchange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (!$util.isInteger(message.sequence))
                    return "sequence: integer expected";
            if (message.localBaseKey != null && message.hasOwnProperty("localBaseKey"))
                if (!(message.localBaseKey && typeof message.localBaseKey.length === "number" || $util.isString(message.localBaseKey)))
                    return "localBaseKey: buffer expected";
            if (message.localBaseKeyPrivate != null && message.hasOwnProperty("localBaseKeyPrivate"))
                if (!(message.localBaseKeyPrivate && typeof message.localBaseKeyPrivate.length === "number" || $util.isString(message.localBaseKeyPrivate)))
                    return "localBaseKeyPrivate: buffer expected";
            if (message.localRatchetKey != null && message.hasOwnProperty("localRatchetKey"))
                if (!(message.localRatchetKey && typeof message.localRatchetKey.length === "number" || $util.isString(message.localRatchetKey)))
                    return "localRatchetKey: buffer expected";
            if (message.localRatchetKeyPrivate != null && message.hasOwnProperty("localRatchetKeyPrivate"))
                if (!(message.localRatchetKeyPrivate && typeof message.localRatchetKeyPrivate.length === "number" || $util.isString(message.localRatchetKeyPrivate)))
                    return "localRatchetKeyPrivate: buffer expected";
            if (message.localIdentityKey != null && message.hasOwnProperty("localIdentityKey"))
                if (!(message.localIdentityKey && typeof message.localIdentityKey.length === "number" || $util.isString(message.localIdentityKey)))
                    return "localIdentityKey: buffer expected";
            if (message.localIdentityKeyPrivate != null && message.hasOwnProperty("localIdentityKeyPrivate"))
                if (!(message.localIdentityKeyPrivate && typeof message.localIdentityKeyPrivate.length === "number" || $util.isString(message.localIdentityKeyPrivate)))
                    return "localIdentityKeyPrivate: buffer expected";
            return null;
        };

        /**
         * Creates a PendingKeyExchange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PendingKeyExchange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PendingKeyExchange} PendingKeyExchange
         */
        PendingKeyExchange.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PendingKeyExchange)
                return object;
            var message = new $root.proto.PendingKeyExchange();
            if (object.sequence != null)
                message.sequence = object.sequence >>> 0;
            if (object.localBaseKey != null)
                if (typeof object.localBaseKey === "string")
                    $util.base64.decode(object.localBaseKey, message.localBaseKey = $util.newBuffer($util.base64.length(object.localBaseKey)), 0);
                else if (object.localBaseKey.length)
                    message.localBaseKey = object.localBaseKey;
            if (object.localBaseKeyPrivate != null)
                if (typeof object.localBaseKeyPrivate === "string")
                    $util.base64.decode(object.localBaseKeyPrivate, message.localBaseKeyPrivate = $util.newBuffer($util.base64.length(object.localBaseKeyPrivate)), 0);
                else if (object.localBaseKeyPrivate.length)
                    message.localBaseKeyPrivate = object.localBaseKeyPrivate;
            if (object.localRatchetKey != null)
                if (typeof object.localRatchetKey === "string")
                    $util.base64.decode(object.localRatchetKey, message.localRatchetKey = $util.newBuffer($util.base64.length(object.localRatchetKey)), 0);
                else if (object.localRatchetKey.length)
                    message.localRatchetKey = object.localRatchetKey;
            if (object.localRatchetKeyPrivate != null)
                if (typeof object.localRatchetKeyPrivate === "string")
                    $util.base64.decode(object.localRatchetKeyPrivate, message.localRatchetKeyPrivate = $util.newBuffer($util.base64.length(object.localRatchetKeyPrivate)), 0);
                else if (object.localRatchetKeyPrivate.length)
                    message.localRatchetKeyPrivate = object.localRatchetKeyPrivate;
            if (object.localIdentityKey != null)
                if (typeof object.localIdentityKey === "string")
                    $util.base64.decode(object.localIdentityKey, message.localIdentityKey = $util.newBuffer($util.base64.length(object.localIdentityKey)), 0);
                else if (object.localIdentityKey.length)
                    message.localIdentityKey = object.localIdentityKey;
            if (object.localIdentityKeyPrivate != null)
                if (typeof object.localIdentityKeyPrivate === "string")
                    $util.base64.decode(object.localIdentityKeyPrivate, message.localIdentityKeyPrivate = $util.newBuffer($util.base64.length(object.localIdentityKeyPrivate)), 0);
                else if (object.localIdentityKeyPrivate.length)
                    message.localIdentityKeyPrivate = object.localIdentityKeyPrivate;
            return message;
        };

        /**
         * Creates a plain object from a PendingKeyExchange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PendingKeyExchange
         * @static
         * @param {proto.PendingKeyExchange} message PendingKeyExchange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingKeyExchange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sequence = 0;
                if (options.bytes === String)
                    object.localBaseKey = "";
                else {
                    object.localBaseKey = [];
                    if (options.bytes !== Array)
                        object.localBaseKey = $util.newBuffer(object.localBaseKey);
                }
                if (options.bytes === String)
                    object.localBaseKeyPrivate = "";
                else {
                    object.localBaseKeyPrivate = [];
                    if (options.bytes !== Array)
                        object.localBaseKeyPrivate = $util.newBuffer(object.localBaseKeyPrivate);
                }
                if (options.bytes === String)
                    object.localRatchetKey = "";
                else {
                    object.localRatchetKey = [];
                    if (options.bytes !== Array)
                        object.localRatchetKey = $util.newBuffer(object.localRatchetKey);
                }
                if (options.bytes === String)
                    object.localRatchetKeyPrivate = "";
                else {
                    object.localRatchetKeyPrivate = [];
                    if (options.bytes !== Array)
                        object.localRatchetKeyPrivate = $util.newBuffer(object.localRatchetKeyPrivate);
                }
                if (options.bytes === String)
                    object.localIdentityKey = "";
                else {
                    object.localIdentityKey = [];
                    if (options.bytes !== Array)
                        object.localIdentityKey = $util.newBuffer(object.localIdentityKey);
                }
                if (options.bytes === String)
                    object.localIdentityKeyPrivate = "";
                else {
                    object.localIdentityKeyPrivate = [];
                    if (options.bytes !== Array)
                        object.localIdentityKeyPrivate = $util.newBuffer(object.localIdentityKeyPrivate);
                }
            }
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                object.sequence = message.sequence;
            if (message.localBaseKey != null && message.hasOwnProperty("localBaseKey"))
                object.localBaseKey = options.bytes === String ? $util.base64.encode(message.localBaseKey, 0, message.localBaseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.localBaseKey) : message.localBaseKey;
            if (message.localBaseKeyPrivate != null && message.hasOwnProperty("localBaseKeyPrivate"))
                object.localBaseKeyPrivate = options.bytes === String ? $util.base64.encode(message.localBaseKeyPrivate, 0, message.localBaseKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.localBaseKeyPrivate) : message.localBaseKeyPrivate;
            if (message.localRatchetKey != null && message.hasOwnProperty("localRatchetKey"))
                object.localRatchetKey = options.bytes === String ? $util.base64.encode(message.localRatchetKey, 0, message.localRatchetKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.localRatchetKey) : message.localRatchetKey;
            if (message.localRatchetKeyPrivate != null && message.hasOwnProperty("localRatchetKeyPrivate"))
                object.localRatchetKeyPrivate = options.bytes === String ? $util.base64.encode(message.localRatchetKeyPrivate, 0, message.localRatchetKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.localRatchetKeyPrivate) : message.localRatchetKeyPrivate;
            if (message.localIdentityKey != null && message.hasOwnProperty("localIdentityKey"))
                object.localIdentityKey = options.bytes === String ? $util.base64.encode(message.localIdentityKey, 0, message.localIdentityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.localIdentityKey) : message.localIdentityKey;
            if (message.localIdentityKeyPrivate != null && message.hasOwnProperty("localIdentityKeyPrivate"))
                object.localIdentityKeyPrivate = options.bytes === String ? $util.base64.encode(message.localIdentityKeyPrivate, 0, message.localIdentityKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.localIdentityKeyPrivate) : message.localIdentityKeyPrivate;
            return object;
        };

        /**
         * Converts this PendingKeyExchange to JSON.
         * @function toJSON
         * @memberof proto.PendingKeyExchange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingKeyExchange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingKeyExchange;
    })();

    proto.PendingPreKey = (function() {

        /**
         * Properties of a PendingPreKey.
         * @memberof proto
         * @interface IPendingPreKey
         * @property {number|null} [preKeyId] PendingPreKey preKeyId
         * @property {number|null} [signedPreKeyId] PendingPreKey signedPreKeyId
         * @property {Uint8Array|null} [baseKey] PendingPreKey baseKey
         */

        /**
         * Constructs a new PendingPreKey.
         * @memberof proto
         * @classdesc Represents a PendingPreKey.
         * @implements IPendingPreKey
         * @constructor
         * @param {proto.IPendingPreKey=} [properties] Properties to set
         */
        function PendingPreKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PendingPreKey preKeyId.
         * @member {number} preKeyId
         * @memberof proto.PendingPreKey
         * @instance
         */
        PendingPreKey.prototype.preKeyId = 0;

        /**
         * PendingPreKey signedPreKeyId.
         * @member {number} signedPreKeyId
         * @memberof proto.PendingPreKey
         * @instance
         */
        PendingPreKey.prototype.signedPreKeyId = 0;

        /**
         * PendingPreKey baseKey.
         * @member {Uint8Array} baseKey
         * @memberof proto.PendingPreKey
         * @instance
         */
        PendingPreKey.prototype.baseKey = $util.newBuffer([]);

        /**
         * Creates a new PendingPreKey instance using the specified properties.
         * @function create
         * @memberof proto.PendingPreKey
         * @static
         * @param {proto.IPendingPreKey=} [properties] Properties to set
         * @returns {proto.PendingPreKey} PendingPreKey instance
         */
        PendingPreKey.create = function create(properties) {
            return new PendingPreKey(properties);
        };

        /**
         * Encodes the specified PendingPreKey message. Does not implicitly {@link proto.PendingPreKey.verify|verify} messages.
         * @function encode
         * @memberof proto.PendingPreKey
         * @static
         * @param {proto.IPendingPreKey} message PendingPreKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingPreKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.preKeyId != null && Object.hasOwnProperty.call(message, "preKeyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.preKeyId);
            if (message.baseKey != null && Object.hasOwnProperty.call(message, "baseKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.baseKey);
            if (message.signedPreKeyId != null && Object.hasOwnProperty.call(message, "signedPreKeyId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.signedPreKeyId);
            return writer;
        };

        /**
         * Encodes the specified PendingPreKey message, length delimited. Does not implicitly {@link proto.PendingPreKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PendingPreKey
         * @static
         * @param {proto.IPendingPreKey} message PendingPreKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingPreKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingPreKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PendingPreKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PendingPreKey} PendingPreKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingPreKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PendingPreKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.preKeyId = reader.uint32();
                    break;
                case 3:
                    message.signedPreKeyId = reader.int32();
                    break;
                case 2:
                    message.baseKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingPreKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PendingPreKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PendingPreKey} PendingPreKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingPreKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingPreKey message.
         * @function verify
         * @memberof proto.PendingPreKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingPreKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.preKeyId != null && message.hasOwnProperty("preKeyId"))
                if (!$util.isInteger(message.preKeyId))
                    return "preKeyId: integer expected";
            if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                if (!$util.isInteger(message.signedPreKeyId))
                    return "signedPreKeyId: integer expected";
            if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                if (!(message.baseKey && typeof message.baseKey.length === "number" || $util.isString(message.baseKey)))
                    return "baseKey: buffer expected";
            return null;
        };

        /**
         * Creates a PendingPreKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PendingPreKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PendingPreKey} PendingPreKey
         */
        PendingPreKey.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PendingPreKey)
                return object;
            var message = new $root.proto.PendingPreKey();
            if (object.preKeyId != null)
                message.preKeyId = object.preKeyId >>> 0;
            if (object.signedPreKeyId != null)
                message.signedPreKeyId = object.signedPreKeyId | 0;
            if (object.baseKey != null)
                if (typeof object.baseKey === "string")
                    $util.base64.decode(object.baseKey, message.baseKey = $util.newBuffer($util.base64.length(object.baseKey)), 0);
                else if (object.baseKey.length)
                    message.baseKey = object.baseKey;
            return message;
        };

        /**
         * Creates a plain object from a PendingPreKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PendingPreKey
         * @static
         * @param {proto.PendingPreKey} message PendingPreKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingPreKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.preKeyId = 0;
                if (options.bytes === String)
                    object.baseKey = "";
                else {
                    object.baseKey = [];
                    if (options.bytes !== Array)
                        object.baseKey = $util.newBuffer(object.baseKey);
                }
                object.signedPreKeyId = 0;
            }
            if (message.preKeyId != null && message.hasOwnProperty("preKeyId"))
                object.preKeyId = message.preKeyId;
            if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                object.baseKey = options.bytes === String ? $util.base64.encode(message.baseKey, 0, message.baseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKey) : message.baseKey;
            if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                object.signedPreKeyId = message.signedPreKeyId;
            return object;
        };

        /**
         * Converts this PendingPreKey to JSON.
         * @function toJSON
         * @memberof proto.PendingPreKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingPreKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingPreKey;
    })();

    proto.PhotoChange = (function() {

        /**
         * Properties of a PhotoChange.
         * @memberof proto
         * @interface IPhotoChange
         * @property {Uint8Array|null} [oldPhoto] PhotoChange oldPhoto
         * @property {Uint8Array|null} [newPhoto] PhotoChange newPhoto
         * @property {number|null} [newPhotoId] PhotoChange newPhotoId
         */

        /**
         * Constructs a new PhotoChange.
         * @memberof proto
         * @classdesc Represents a PhotoChange.
         * @implements IPhotoChange
         * @constructor
         * @param {proto.IPhotoChange=} [properties] Properties to set
         */
        function PhotoChange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PhotoChange oldPhoto.
         * @member {Uint8Array} oldPhoto
         * @memberof proto.PhotoChange
         * @instance
         */
        PhotoChange.prototype.oldPhoto = $util.newBuffer([]);

        /**
         * PhotoChange newPhoto.
         * @member {Uint8Array} newPhoto
         * @memberof proto.PhotoChange
         * @instance
         */
        PhotoChange.prototype.newPhoto = $util.newBuffer([]);

        /**
         * PhotoChange newPhotoId.
         * @member {number} newPhotoId
         * @memberof proto.PhotoChange
         * @instance
         */
        PhotoChange.prototype.newPhotoId = 0;

        /**
         * Creates a new PhotoChange instance using the specified properties.
         * @function create
         * @memberof proto.PhotoChange
         * @static
         * @param {proto.IPhotoChange=} [properties] Properties to set
         * @returns {proto.PhotoChange} PhotoChange instance
         */
        PhotoChange.create = function create(properties) {
            return new PhotoChange(properties);
        };

        /**
         * Encodes the specified PhotoChange message. Does not implicitly {@link proto.PhotoChange.verify|verify} messages.
         * @function encode
         * @memberof proto.PhotoChange
         * @static
         * @param {proto.IPhotoChange} message PhotoChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PhotoChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.oldPhoto != null && Object.hasOwnProperty.call(message, "oldPhoto"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.oldPhoto);
            if (message.newPhoto != null && Object.hasOwnProperty.call(message, "newPhoto"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.newPhoto);
            if (message.newPhotoId != null && Object.hasOwnProperty.call(message, "newPhotoId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.newPhotoId);
            return writer;
        };

        /**
         * Encodes the specified PhotoChange message, length delimited. Does not implicitly {@link proto.PhotoChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PhotoChange
         * @static
         * @param {proto.IPhotoChange} message PhotoChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PhotoChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PhotoChange message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PhotoChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PhotoChange} PhotoChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PhotoChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PhotoChange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.oldPhoto = reader.bytes();
                    break;
                case 2:
                    message.newPhoto = reader.bytes();
                    break;
                case 3:
                    message.newPhotoId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PhotoChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PhotoChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PhotoChange} PhotoChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PhotoChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PhotoChange message.
         * @function verify
         * @memberof proto.PhotoChange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PhotoChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.oldPhoto != null && message.hasOwnProperty("oldPhoto"))
                if (!(message.oldPhoto && typeof message.oldPhoto.length === "number" || $util.isString(message.oldPhoto)))
                    return "oldPhoto: buffer expected";
            if (message.newPhoto != null && message.hasOwnProperty("newPhoto"))
                if (!(message.newPhoto && typeof message.newPhoto.length === "number" || $util.isString(message.newPhoto)))
                    return "newPhoto: buffer expected";
            if (message.newPhotoId != null && message.hasOwnProperty("newPhotoId"))
                if (!$util.isInteger(message.newPhotoId))
                    return "newPhotoId: integer expected";
            return null;
        };

        /**
         * Creates a PhotoChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PhotoChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PhotoChange} PhotoChange
         */
        PhotoChange.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PhotoChange)
                return object;
            var message = new $root.proto.PhotoChange();
            if (object.oldPhoto != null)
                if (typeof object.oldPhoto === "string")
                    $util.base64.decode(object.oldPhoto, message.oldPhoto = $util.newBuffer($util.base64.length(object.oldPhoto)), 0);
                else if (object.oldPhoto.length)
                    message.oldPhoto = object.oldPhoto;
            if (object.newPhoto != null)
                if (typeof object.newPhoto === "string")
                    $util.base64.decode(object.newPhoto, message.newPhoto = $util.newBuffer($util.base64.length(object.newPhoto)), 0);
                else if (object.newPhoto.length)
                    message.newPhoto = object.newPhoto;
            if (object.newPhotoId != null)
                message.newPhotoId = object.newPhotoId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PhotoChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PhotoChange
         * @static
         * @param {proto.PhotoChange} message PhotoChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PhotoChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.oldPhoto = "";
                else {
                    object.oldPhoto = [];
                    if (options.bytes !== Array)
                        object.oldPhoto = $util.newBuffer(object.oldPhoto);
                }
                if (options.bytes === String)
                    object.newPhoto = "";
                else {
                    object.newPhoto = [];
                    if (options.bytes !== Array)
                        object.newPhoto = $util.newBuffer(object.newPhoto);
                }
                object.newPhotoId = 0;
            }
            if (message.oldPhoto != null && message.hasOwnProperty("oldPhoto"))
                object.oldPhoto = options.bytes === String ? $util.base64.encode(message.oldPhoto, 0, message.oldPhoto.length) : options.bytes === Array ? Array.prototype.slice.call(message.oldPhoto) : message.oldPhoto;
            if (message.newPhoto != null && message.hasOwnProperty("newPhoto"))
                object.newPhoto = options.bytes === String ? $util.base64.encode(message.newPhoto, 0, message.newPhoto.length) : options.bytes === Array ? Array.prototype.slice.call(message.newPhoto) : message.newPhoto;
            if (message.newPhotoId != null && message.hasOwnProperty("newPhotoId"))
                object.newPhotoId = message.newPhotoId;
            return object;
        };

        /**
         * Converts this PhotoChange to JSON.
         * @function toJSON
         * @memberof proto.PhotoChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PhotoChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PhotoChange;
    })();

    proto.Point = (function() {

        /**
         * Properties of a Point.
         * @memberof proto
         * @interface IPoint
         * @property {number|null} [xDeprecated] Point xDeprecated
         * @property {number|null} [yDeprecated] Point yDeprecated
         * @property {number|null} [x] Point x
         * @property {number|null} [y] Point y
         */

        /**
         * Constructs a new Point.
         * @memberof proto
         * @classdesc Represents a Point.
         * @implements IPoint
         * @constructor
         * @param {proto.IPoint=} [properties] Properties to set
         */
        function Point(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Point xDeprecated.
         * @member {number} xDeprecated
         * @memberof proto.Point
         * @instance
         */
        Point.prototype.xDeprecated = 0;

        /**
         * Point yDeprecated.
         * @member {number} yDeprecated
         * @memberof proto.Point
         * @instance
         */
        Point.prototype.yDeprecated = 0;

        /**
         * Point x.
         * @member {number} x
         * @memberof proto.Point
         * @instance
         */
        Point.prototype.x = 0;

        /**
         * Point y.
         * @member {number} y
         * @memberof proto.Point
         * @instance
         */
        Point.prototype.y = 0;

        /**
         * Creates a new Point instance using the specified properties.
         * @function create
         * @memberof proto.Point
         * @static
         * @param {proto.IPoint=} [properties] Properties to set
         * @returns {proto.Point} Point instance
         */
        Point.create = function create(properties) {
            return new Point(properties);
        };

        /**
         * Encodes the specified Point message. Does not implicitly {@link proto.Point.verify|verify} messages.
         * @function encode
         * @memberof proto.Point
         * @static
         * @param {proto.IPoint} message Point message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Point.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.xDeprecated != null && Object.hasOwnProperty.call(message, "xDeprecated"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.xDeprecated);
            if (message.yDeprecated != null && Object.hasOwnProperty.call(message, "yDeprecated"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.yDeprecated);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.y);
            return writer;
        };

        /**
         * Encodes the specified Point message, length delimited. Does not implicitly {@link proto.Point.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Point
         * @static
         * @param {proto.IPoint} message Point message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Point.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Point message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Point
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Point} Point
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Point.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Point();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.xDeprecated = reader.int32();
                    break;
                case 2:
                    message.yDeprecated = reader.int32();
                    break;
                case 3:
                    message.x = reader.double();
                    break;
                case 4:
                    message.y = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Point message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Point
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Point} Point
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Point.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Point message.
         * @function verify
         * @memberof proto.Point
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Point.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.xDeprecated != null && message.hasOwnProperty("xDeprecated"))
                if (!$util.isInteger(message.xDeprecated))
                    return "xDeprecated: integer expected";
            if (message.yDeprecated != null && message.hasOwnProperty("yDeprecated"))
                if (!$util.isInteger(message.yDeprecated))
                    return "yDeprecated: integer expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates a Point message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Point
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Point} Point
         */
        Point.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Point)
                return object;
            var message = new $root.proto.Point();
            if (object.xDeprecated != null)
                message.xDeprecated = object.xDeprecated | 0;
            if (object.yDeprecated != null)
                message.yDeprecated = object.yDeprecated | 0;
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a Point message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Point
         * @static
         * @param {proto.Point} message Point
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Point.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.xDeprecated = 0;
                object.yDeprecated = 0;
                object.x = 0;
                object.y = 0;
            }
            if (message.xDeprecated != null && message.hasOwnProperty("xDeprecated"))
                object.xDeprecated = message.xDeprecated;
            if (message.yDeprecated != null && message.hasOwnProperty("yDeprecated"))
                object.yDeprecated = message.yDeprecated;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this Point to JSON.
         * @function toJSON
         * @memberof proto.Point
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Point.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Point;
    })();

    proto.PollAdditionalMetadata = (function() {

        /**
         * Properties of a PollAdditionalMetadata.
         * @memberof proto
         * @interface IPollAdditionalMetadata
         * @property {boolean|null} [pollInvalidated] PollAdditionalMetadata pollInvalidated
         */

        /**
         * Constructs a new PollAdditionalMetadata.
         * @memberof proto
         * @classdesc Represents a PollAdditionalMetadata.
         * @implements IPollAdditionalMetadata
         * @constructor
         * @param {proto.IPollAdditionalMetadata=} [properties] Properties to set
         */
        function PollAdditionalMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PollAdditionalMetadata pollInvalidated.
         * @member {boolean} pollInvalidated
         * @memberof proto.PollAdditionalMetadata
         * @instance
         */
        PollAdditionalMetadata.prototype.pollInvalidated = false;

        /**
         * Creates a new PollAdditionalMetadata instance using the specified properties.
         * @function create
         * @memberof proto.PollAdditionalMetadata
         * @static
         * @param {proto.IPollAdditionalMetadata=} [properties] Properties to set
         * @returns {proto.PollAdditionalMetadata} PollAdditionalMetadata instance
         */
        PollAdditionalMetadata.create = function create(properties) {
            return new PollAdditionalMetadata(properties);
        };

        /**
         * Encodes the specified PollAdditionalMetadata message. Does not implicitly {@link proto.PollAdditionalMetadata.verify|verify} messages.
         * @function encode
         * @memberof proto.PollAdditionalMetadata
         * @static
         * @param {proto.IPollAdditionalMetadata} message PollAdditionalMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollAdditionalMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pollInvalidated != null && Object.hasOwnProperty.call(message, "pollInvalidated"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.pollInvalidated);
            return writer;
        };

        /**
         * Encodes the specified PollAdditionalMetadata message, length delimited. Does not implicitly {@link proto.PollAdditionalMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PollAdditionalMetadata
         * @static
         * @param {proto.IPollAdditionalMetadata} message PollAdditionalMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollAdditionalMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PollAdditionalMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PollAdditionalMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PollAdditionalMetadata} PollAdditionalMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollAdditionalMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PollAdditionalMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pollInvalidated = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PollAdditionalMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PollAdditionalMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PollAdditionalMetadata} PollAdditionalMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollAdditionalMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PollAdditionalMetadata message.
         * @function verify
         * @memberof proto.PollAdditionalMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PollAdditionalMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pollInvalidated != null && message.hasOwnProperty("pollInvalidated"))
                if (typeof message.pollInvalidated !== "boolean")
                    return "pollInvalidated: boolean expected";
            return null;
        };

        /**
         * Creates a PollAdditionalMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PollAdditionalMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PollAdditionalMetadata} PollAdditionalMetadata
         */
        PollAdditionalMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PollAdditionalMetadata)
                return object;
            var message = new $root.proto.PollAdditionalMetadata();
            if (object.pollInvalidated != null)
                message.pollInvalidated = Boolean(object.pollInvalidated);
            return message;
        };

        /**
         * Creates a plain object from a PollAdditionalMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PollAdditionalMetadata
         * @static
         * @param {proto.PollAdditionalMetadata} message PollAdditionalMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PollAdditionalMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pollInvalidated = false;
            if (message.pollInvalidated != null && message.hasOwnProperty("pollInvalidated"))
                object.pollInvalidated = message.pollInvalidated;
            return object;
        };

        /**
         * Converts this PollAdditionalMetadata to JSON.
         * @function toJSON
         * @memberof proto.PollAdditionalMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PollAdditionalMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PollAdditionalMetadata;
    })();

    proto.PollEncValue = (function() {

        /**
         * Properties of a PollEncValue.
         * @memberof proto
         * @interface IPollEncValue
         * @property {Uint8Array|null} [encPayload] PollEncValue encPayload
         * @property {Uint8Array|null} [encIv] PollEncValue encIv
         */

        /**
         * Constructs a new PollEncValue.
         * @memberof proto
         * @classdesc Represents a PollEncValue.
         * @implements IPollEncValue
         * @constructor
         * @param {proto.IPollEncValue=} [properties] Properties to set
         */
        function PollEncValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PollEncValue encPayload.
         * @member {Uint8Array} encPayload
         * @memberof proto.PollEncValue
         * @instance
         */
        PollEncValue.prototype.encPayload = $util.newBuffer([]);

        /**
         * PollEncValue encIv.
         * @member {Uint8Array} encIv
         * @memberof proto.PollEncValue
         * @instance
         */
        PollEncValue.prototype.encIv = $util.newBuffer([]);

        /**
         * Creates a new PollEncValue instance using the specified properties.
         * @function create
         * @memberof proto.PollEncValue
         * @static
         * @param {proto.IPollEncValue=} [properties] Properties to set
         * @returns {proto.PollEncValue} PollEncValue instance
         */
        PollEncValue.create = function create(properties) {
            return new PollEncValue(properties);
        };

        /**
         * Encodes the specified PollEncValue message. Does not implicitly {@link proto.PollEncValue.verify|verify} messages.
         * @function encode
         * @memberof proto.PollEncValue
         * @static
         * @param {proto.IPollEncValue} message PollEncValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollEncValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encPayload);
            if (message.encIv != null && Object.hasOwnProperty.call(message, "encIv"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encIv);
            return writer;
        };

        /**
         * Encodes the specified PollEncValue message, length delimited. Does not implicitly {@link proto.PollEncValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PollEncValue
         * @static
         * @param {proto.IPollEncValue} message PollEncValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollEncValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PollEncValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PollEncValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PollEncValue} PollEncValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollEncValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PollEncValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encPayload = reader.bytes();
                    break;
                case 2:
                    message.encIv = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PollEncValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PollEncValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PollEncValue} PollEncValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollEncValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PollEncValue message.
         * @function verify
         * @memberof proto.PollEncValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PollEncValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.encIv != null && message.hasOwnProperty("encIv"))
                if (!(message.encIv && typeof message.encIv.length === "number" || $util.isString(message.encIv)))
                    return "encIv: buffer expected";
            return null;
        };

        /**
         * Creates a PollEncValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PollEncValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PollEncValue} PollEncValue
         */
        PollEncValue.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PollEncValue)
                return object;
            var message = new $root.proto.PollEncValue();
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.encIv != null)
                if (typeof object.encIv === "string")
                    $util.base64.decode(object.encIv, message.encIv = $util.newBuffer($util.base64.length(object.encIv)), 0);
                else if (object.encIv.length)
                    message.encIv = object.encIv;
            return message;
        };

        /**
         * Creates a plain object from a PollEncValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PollEncValue
         * @static
         * @param {proto.PollEncValue} message PollEncValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PollEncValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                if (options.bytes === String)
                    object.encIv = "";
                else {
                    object.encIv = [];
                    if (options.bytes !== Array)
                        object.encIv = $util.newBuffer(object.encIv);
                }
            }
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.encIv != null && message.hasOwnProperty("encIv"))
                object.encIv = options.bytes === String ? $util.base64.encode(message.encIv, 0, message.encIv.length) : options.bytes === Array ? Array.prototype.slice.call(message.encIv) : message.encIv;
            return object;
        };

        /**
         * Converts this PollEncValue to JSON.
         * @function toJSON
         * @memberof proto.PollEncValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PollEncValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PollEncValue;
    })();

    proto.PollUpdate = (function() {

        /**
         * Properties of a PollUpdate.
         * @memberof proto
         * @interface IPollUpdate
         * @property {proto.IMessageKey|null} [pollUpdateMessageKey] PollUpdate pollUpdateMessageKey
         * @property {proto.Message.IPollVoteMessage|null} [vote] PollUpdate vote
         * @property {number|Long|null} [senderTimestampMs] PollUpdate senderTimestampMs
         */

        /**
         * Constructs a new PollUpdate.
         * @memberof proto
         * @classdesc Represents a PollUpdate.
         * @implements IPollUpdate
         * @constructor
         * @param {proto.IPollUpdate=} [properties] Properties to set
         */
        function PollUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PollUpdate pollUpdateMessageKey.
         * @member {proto.IMessageKey|null|undefined} pollUpdateMessageKey
         * @memberof proto.PollUpdate
         * @instance
         */
        PollUpdate.prototype.pollUpdateMessageKey = null;

        /**
         * PollUpdate vote.
         * @member {proto.Message.IPollVoteMessage|null|undefined} vote
         * @memberof proto.PollUpdate
         * @instance
         */
        PollUpdate.prototype.vote = null;

        /**
         * PollUpdate senderTimestampMs.
         * @member {number|Long} senderTimestampMs
         * @memberof proto.PollUpdate
         * @instance
         */
        PollUpdate.prototype.senderTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PollUpdate instance using the specified properties.
         * @function create
         * @memberof proto.PollUpdate
         * @static
         * @param {proto.IPollUpdate=} [properties] Properties to set
         * @returns {proto.PollUpdate} PollUpdate instance
         */
        PollUpdate.create = function create(properties) {
            return new PollUpdate(properties);
        };

        /**
         * Encodes the specified PollUpdate message. Does not implicitly {@link proto.PollUpdate.verify|verify} messages.
         * @function encode
         * @memberof proto.PollUpdate
         * @static
         * @param {proto.IPollUpdate} message PollUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pollUpdateMessageKey != null && Object.hasOwnProperty.call(message, "pollUpdateMessageKey"))
                $root.proto.MessageKey.encode(message.pollUpdateMessageKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.vote != null && Object.hasOwnProperty.call(message, "vote"))
                $root.proto.Message.PollVoteMessage.encode(message.vote, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.senderTimestampMs != null && Object.hasOwnProperty.call(message, "senderTimestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.senderTimestampMs);
            return writer;
        };

        /**
         * Encodes the specified PollUpdate message, length delimited. Does not implicitly {@link proto.PollUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PollUpdate
         * @static
         * @param {proto.IPollUpdate} message PollUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PollUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PollUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PollUpdate} PollUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PollUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pollUpdateMessageKey = $root.proto.MessageKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.vote = $root.proto.Message.PollVoteMessage.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.senderTimestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PollUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PollUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PollUpdate} PollUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PollUpdate message.
         * @function verify
         * @memberof proto.PollUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PollUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pollUpdateMessageKey != null && message.hasOwnProperty("pollUpdateMessageKey")) {
                var error = $root.proto.MessageKey.verify(message.pollUpdateMessageKey);
                if (error)
                    return "pollUpdateMessageKey." + error;
            }
            if (message.vote != null && message.hasOwnProperty("vote")) {
                var error = $root.proto.Message.PollVoteMessage.verify(message.vote);
                if (error)
                    return "vote." + error;
            }
            if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                if (!$util.isInteger(message.senderTimestampMs) && !(message.senderTimestampMs && $util.isInteger(message.senderTimestampMs.low) && $util.isInteger(message.senderTimestampMs.high)))
                    return "senderTimestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a PollUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PollUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PollUpdate} PollUpdate
         */
        PollUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PollUpdate)
                return object;
            var message = new $root.proto.PollUpdate();
            if (object.pollUpdateMessageKey != null) {
                if (typeof object.pollUpdateMessageKey !== "object")
                    throw TypeError(".proto.PollUpdate.pollUpdateMessageKey: object expected");
                message.pollUpdateMessageKey = $root.proto.MessageKey.fromObject(object.pollUpdateMessageKey);
            }
            if (object.vote != null) {
                if (typeof object.vote !== "object")
                    throw TypeError(".proto.PollUpdate.vote: object expected");
                message.vote = $root.proto.Message.PollVoteMessage.fromObject(object.vote);
            }
            if (object.senderTimestampMs != null)
                if ($util.Long)
                    (message.senderTimestampMs = $util.Long.fromValue(object.senderTimestampMs)).unsigned = false;
                else if (typeof object.senderTimestampMs === "string")
                    message.senderTimestampMs = parseInt(object.senderTimestampMs, 10);
                else if (typeof object.senderTimestampMs === "number")
                    message.senderTimestampMs = object.senderTimestampMs;
                else if (typeof object.senderTimestampMs === "object")
                    message.senderTimestampMs = new $util.LongBits(object.senderTimestampMs.low >>> 0, object.senderTimestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PollUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PollUpdate
         * @static
         * @param {proto.PollUpdate} message PollUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PollUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pollUpdateMessageKey = null;
                object.vote = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.senderTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.senderTimestampMs = options.longs === String ? "0" : 0;
            }
            if (message.pollUpdateMessageKey != null && message.hasOwnProperty("pollUpdateMessageKey"))
                object.pollUpdateMessageKey = $root.proto.MessageKey.toObject(message.pollUpdateMessageKey, options);
            if (message.vote != null && message.hasOwnProperty("vote"))
                object.vote = $root.proto.Message.PollVoteMessage.toObject(message.vote, options);
            if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                if (typeof message.senderTimestampMs === "number")
                    object.senderTimestampMs = options.longs === String ? String(message.senderTimestampMs) : message.senderTimestampMs;
                else
                    object.senderTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.senderTimestampMs) : options.longs === Number ? new $util.LongBits(message.senderTimestampMs.low >>> 0, message.senderTimestampMs.high >>> 0).toNumber() : message.senderTimestampMs;
            return object;
        };

        /**
         * Converts this PollUpdate to JSON.
         * @function toJSON
         * @memberof proto.PollUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PollUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PollUpdate;
    })();

    proto.PreKeyRecordStructure = (function() {

        /**
         * Properties of a PreKeyRecordStructure.
         * @memberof proto
         * @interface IPreKeyRecordStructure
         * @property {number|null} [id] PreKeyRecordStructure id
         * @property {Uint8Array|null} [publicKey] PreKeyRecordStructure publicKey
         * @property {Uint8Array|null} [privateKey] PreKeyRecordStructure privateKey
         */

        /**
         * Constructs a new PreKeyRecordStructure.
         * @memberof proto
         * @classdesc Represents a PreKeyRecordStructure.
         * @implements IPreKeyRecordStructure
         * @constructor
         * @param {proto.IPreKeyRecordStructure=} [properties] Properties to set
         */
        function PreKeyRecordStructure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreKeyRecordStructure id.
         * @member {number} id
         * @memberof proto.PreKeyRecordStructure
         * @instance
         */
        PreKeyRecordStructure.prototype.id = 0;

        /**
         * PreKeyRecordStructure publicKey.
         * @member {Uint8Array} publicKey
         * @memberof proto.PreKeyRecordStructure
         * @instance
         */
        PreKeyRecordStructure.prototype.publicKey = $util.newBuffer([]);

        /**
         * PreKeyRecordStructure privateKey.
         * @member {Uint8Array} privateKey
         * @memberof proto.PreKeyRecordStructure
         * @instance
         */
        PreKeyRecordStructure.prototype.privateKey = $util.newBuffer([]);

        /**
         * Creates a new PreKeyRecordStructure instance using the specified properties.
         * @function create
         * @memberof proto.PreKeyRecordStructure
         * @static
         * @param {proto.IPreKeyRecordStructure=} [properties] Properties to set
         * @returns {proto.PreKeyRecordStructure} PreKeyRecordStructure instance
         */
        PreKeyRecordStructure.create = function create(properties) {
            return new PreKeyRecordStructure(properties);
        };

        /**
         * Encodes the specified PreKeyRecordStructure message. Does not implicitly {@link proto.PreKeyRecordStructure.verify|verify} messages.
         * @function encode
         * @memberof proto.PreKeyRecordStructure
         * @static
         * @param {proto.IPreKeyRecordStructure} message PreKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreKeyRecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateKey);
            return writer;
        };

        /**
         * Encodes the specified PreKeyRecordStructure message, length delimited. Does not implicitly {@link proto.PreKeyRecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PreKeyRecordStructure
         * @static
         * @param {proto.IPreKeyRecordStructure} message PreKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreKeyRecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PreKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PreKeyRecordStructure} PreKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreKeyRecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PreKeyRecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.privateKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreKeyRecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PreKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PreKeyRecordStructure} PreKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreKeyRecordStructure message.
         * @function verify
         * @memberof proto.PreKeyRecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreKeyRecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            return null;
        };

        /**
         * Creates a PreKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PreKeyRecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PreKeyRecordStructure} PreKeyRecordStructure
         */
        PreKeyRecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PreKeyRecordStructure)
                return object;
            var message = new $root.proto.PreKeyRecordStructure();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            return message;
        };

        /**
         * Creates a plain object from a PreKeyRecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PreKeyRecordStructure
         * @static
         * @param {proto.PreKeyRecordStructure} message PreKeyRecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreKeyRecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            return object;
        };

        /**
         * Converts this PreKeyRecordStructure to JSON.
         * @function toJSON
         * @memberof proto.PreKeyRecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreKeyRecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreKeyRecordStructure;
    })();

    proto.Pushname = (function() {

        /**
         * Properties of a Pushname.
         * @memberof proto
         * @interface IPushname
         * @property {string|null} [id] Pushname id
         * @property {string|null} [pushname] Pushname pushname
         */

        /**
         * Constructs a new Pushname.
         * @memberof proto
         * @classdesc Represents a Pushname.
         * @implements IPushname
         * @constructor
         * @param {proto.IPushname=} [properties] Properties to set
         */
        function Pushname(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Pushname id.
         * @member {string} id
         * @memberof proto.Pushname
         * @instance
         */
        Pushname.prototype.id = "";

        /**
         * Pushname pushname.
         * @member {string} pushname
         * @memberof proto.Pushname
         * @instance
         */
        Pushname.prototype.pushname = "";

        /**
         * Creates a new Pushname instance using the specified properties.
         * @function create
         * @memberof proto.Pushname
         * @static
         * @param {proto.IPushname=} [properties] Properties to set
         * @returns {proto.Pushname} Pushname instance
         */
        Pushname.create = function create(properties) {
            return new Pushname(properties);
        };

        /**
         * Encodes the specified Pushname message. Does not implicitly {@link proto.Pushname.verify|verify} messages.
         * @function encode
         * @memberof proto.Pushname
         * @static
         * @param {proto.IPushname} message Pushname message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pushname.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.pushname != null && Object.hasOwnProperty.call(message, "pushname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pushname);
            return writer;
        };

        /**
         * Encodes the specified Pushname message, length delimited. Does not implicitly {@link proto.Pushname.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Pushname
         * @static
         * @param {proto.IPushname} message Pushname message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pushname.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Pushname message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Pushname
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Pushname} Pushname
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pushname.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Pushname();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.pushname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Pushname message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Pushname
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Pushname} Pushname
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pushname.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Pushname message.
         * @function verify
         * @memberof proto.Pushname
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Pushname.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.pushname != null && message.hasOwnProperty("pushname"))
                if (!$util.isString(message.pushname))
                    return "pushname: string expected";
            return null;
        };

        /**
         * Creates a Pushname message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Pushname
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Pushname} Pushname
         */
        Pushname.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Pushname)
                return object;
            var message = new $root.proto.Pushname();
            if (object.id != null)
                message.id = String(object.id);
            if (object.pushname != null)
                message.pushname = String(object.pushname);
            return message;
        };

        /**
         * Creates a plain object from a Pushname message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Pushname
         * @static
         * @param {proto.Pushname} message Pushname
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Pushname.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.pushname = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pushname != null && message.hasOwnProperty("pushname"))
                object.pushname = message.pushname;
            return object;
        };

        /**
         * Converts this Pushname to JSON.
         * @function toJSON
         * @memberof proto.Pushname
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Pushname.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Pushname;
    })();

    proto.Reaction = (function() {

        /**
         * Properties of a Reaction.
         * @memberof proto
         * @interface IReaction
         * @property {proto.IMessageKey|null} [key] Reaction key
         * @property {string|null} [text] Reaction text
         * @property {string|null} [groupingKey] Reaction groupingKey
         * @property {number|Long|null} [senderTimestampMs] Reaction senderTimestampMs
         * @property {boolean|null} [unread] Reaction unread
         */

        /**
         * Constructs a new Reaction.
         * @memberof proto
         * @classdesc Represents a Reaction.
         * @implements IReaction
         * @constructor
         * @param {proto.IReaction=} [properties] Properties to set
         */
        function Reaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Reaction key.
         * @member {proto.IMessageKey|null|undefined} key
         * @memberof proto.Reaction
         * @instance
         */
        Reaction.prototype.key = null;

        /**
         * Reaction text.
         * @member {string} text
         * @memberof proto.Reaction
         * @instance
         */
        Reaction.prototype.text = "";

        /**
         * Reaction groupingKey.
         * @member {string} groupingKey
         * @memberof proto.Reaction
         * @instance
         */
        Reaction.prototype.groupingKey = "";

        /**
         * Reaction senderTimestampMs.
         * @member {number|Long} senderTimestampMs
         * @memberof proto.Reaction
         * @instance
         */
        Reaction.prototype.senderTimestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Reaction unread.
         * @member {boolean} unread
         * @memberof proto.Reaction
         * @instance
         */
        Reaction.prototype.unread = false;

        /**
         * Creates a new Reaction instance using the specified properties.
         * @function create
         * @memberof proto.Reaction
         * @static
         * @param {proto.IReaction=} [properties] Properties to set
         * @returns {proto.Reaction} Reaction instance
         */
        Reaction.create = function create(properties) {
            return new Reaction(properties);
        };

        /**
         * Encodes the specified Reaction message. Does not implicitly {@link proto.Reaction.verify|verify} messages.
         * @function encode
         * @memberof proto.Reaction
         * @static
         * @param {proto.IReaction} message Reaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Reaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.groupingKey != null && Object.hasOwnProperty.call(message, "groupingKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.groupingKey);
            if (message.senderTimestampMs != null && Object.hasOwnProperty.call(message, "senderTimestampMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.senderTimestampMs);
            if (message.unread != null && Object.hasOwnProperty.call(message, "unread"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.unread);
            return writer;
        };

        /**
         * Encodes the specified Reaction message, length delimited. Does not implicitly {@link proto.Reaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Reaction
         * @static
         * @param {proto.IReaction} message Reaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Reaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Reaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Reaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Reaction} Reaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Reaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Reaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.groupingKey = reader.string();
                    break;
                case 4:
                    message.senderTimestampMs = reader.int64();
                    break;
                case 5:
                    message.unread = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Reaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Reaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Reaction} Reaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Reaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Reaction message.
         * @function verify
         * @memberof proto.Reaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Reaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.proto.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.groupingKey != null && message.hasOwnProperty("groupingKey"))
                if (!$util.isString(message.groupingKey))
                    return "groupingKey: string expected";
            if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                if (!$util.isInteger(message.senderTimestampMs) && !(message.senderTimestampMs && $util.isInteger(message.senderTimestampMs.low) && $util.isInteger(message.senderTimestampMs.high)))
                    return "senderTimestampMs: integer|Long expected";
            if (message.unread != null && message.hasOwnProperty("unread"))
                if (typeof message.unread !== "boolean")
                    return "unread: boolean expected";
            return null;
        };

        /**
         * Creates a Reaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Reaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Reaction} Reaction
         */
        Reaction.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Reaction)
                return object;
            var message = new $root.proto.Reaction();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".proto.Reaction.key: object expected");
                message.key = $root.proto.MessageKey.fromObject(object.key);
            }
            if (object.text != null)
                message.text = String(object.text);
            if (object.groupingKey != null)
                message.groupingKey = String(object.groupingKey);
            if (object.senderTimestampMs != null)
                if ($util.Long)
                    (message.senderTimestampMs = $util.Long.fromValue(object.senderTimestampMs)).unsigned = false;
                else if (typeof object.senderTimestampMs === "string")
                    message.senderTimestampMs = parseInt(object.senderTimestampMs, 10);
                else if (typeof object.senderTimestampMs === "number")
                    message.senderTimestampMs = object.senderTimestampMs;
                else if (typeof object.senderTimestampMs === "object")
                    message.senderTimestampMs = new $util.LongBits(object.senderTimestampMs.low >>> 0, object.senderTimestampMs.high >>> 0).toNumber();
            if (object.unread != null)
                message.unread = Boolean(object.unread);
            return message;
        };

        /**
         * Creates a plain object from a Reaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Reaction
         * @static
         * @param {proto.Reaction} message Reaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Reaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.text = "";
                object.groupingKey = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.senderTimestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.senderTimestampMs = options.longs === String ? "0" : 0;
                object.unread = false;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.proto.MessageKey.toObject(message.key, options);
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.groupingKey != null && message.hasOwnProperty("groupingKey"))
                object.groupingKey = message.groupingKey;
            if (message.senderTimestampMs != null && message.hasOwnProperty("senderTimestampMs"))
                if (typeof message.senderTimestampMs === "number")
                    object.senderTimestampMs = options.longs === String ? String(message.senderTimestampMs) : message.senderTimestampMs;
                else
                    object.senderTimestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.senderTimestampMs) : options.longs === Number ? new $util.LongBits(message.senderTimestampMs.low >>> 0, message.senderTimestampMs.high >>> 0).toNumber() : message.senderTimestampMs;
            if (message.unread != null && message.hasOwnProperty("unread"))
                object.unread = message.unread;
            return object;
        };

        /**
         * Converts this Reaction to JSON.
         * @function toJSON
         * @memberof proto.Reaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Reaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Reaction;
    })();

    proto.RecentEmojiWeight = (function() {

        /**
         * Properties of a RecentEmojiWeight.
         * @memberof proto
         * @interface IRecentEmojiWeight
         * @property {string|null} [emoji] RecentEmojiWeight emoji
         * @property {number|null} [weight] RecentEmojiWeight weight
         */

        /**
         * Constructs a new RecentEmojiWeight.
         * @memberof proto
         * @classdesc Represents a RecentEmojiWeight.
         * @implements IRecentEmojiWeight
         * @constructor
         * @param {proto.IRecentEmojiWeight=} [properties] Properties to set
         */
        function RecentEmojiWeight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecentEmojiWeight emoji.
         * @member {string} emoji
         * @memberof proto.RecentEmojiWeight
         * @instance
         */
        RecentEmojiWeight.prototype.emoji = "";

        /**
         * RecentEmojiWeight weight.
         * @member {number} weight
         * @memberof proto.RecentEmojiWeight
         * @instance
         */
        RecentEmojiWeight.prototype.weight = 0;

        /**
         * Creates a new RecentEmojiWeight instance using the specified properties.
         * @function create
         * @memberof proto.RecentEmojiWeight
         * @static
         * @param {proto.IRecentEmojiWeight=} [properties] Properties to set
         * @returns {proto.RecentEmojiWeight} RecentEmojiWeight instance
         */
        RecentEmojiWeight.create = function create(properties) {
            return new RecentEmojiWeight(properties);
        };

        /**
         * Encodes the specified RecentEmojiWeight message. Does not implicitly {@link proto.RecentEmojiWeight.verify|verify} messages.
         * @function encode
         * @memberof proto.RecentEmojiWeight
         * @static
         * @param {proto.IRecentEmojiWeight} message RecentEmojiWeight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecentEmojiWeight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.emoji);
            if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.weight);
            return writer;
        };

        /**
         * Encodes the specified RecentEmojiWeight message, length delimited. Does not implicitly {@link proto.RecentEmojiWeight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RecentEmojiWeight
         * @static
         * @param {proto.IRecentEmojiWeight} message RecentEmojiWeight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecentEmojiWeight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecentEmojiWeight message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RecentEmojiWeight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RecentEmojiWeight} RecentEmojiWeight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecentEmojiWeight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RecentEmojiWeight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.emoji = reader.string();
                    break;
                case 2:
                    message.weight = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecentEmojiWeight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RecentEmojiWeight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RecentEmojiWeight} RecentEmojiWeight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecentEmojiWeight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecentEmojiWeight message.
         * @function verify
         * @memberof proto.RecentEmojiWeight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecentEmojiWeight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.emoji != null && message.hasOwnProperty("emoji"))
                if (!$util.isString(message.emoji))
                    return "emoji: string expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (typeof message.weight !== "number")
                    return "weight: number expected";
            return null;
        };

        /**
         * Creates a RecentEmojiWeight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RecentEmojiWeight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RecentEmojiWeight} RecentEmojiWeight
         */
        RecentEmojiWeight.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RecentEmojiWeight)
                return object;
            var message = new $root.proto.RecentEmojiWeight();
            if (object.emoji != null)
                message.emoji = String(object.emoji);
            if (object.weight != null)
                message.weight = Number(object.weight);
            return message;
        };

        /**
         * Creates a plain object from a RecentEmojiWeight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RecentEmojiWeight
         * @static
         * @param {proto.RecentEmojiWeight} message RecentEmojiWeight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecentEmojiWeight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.emoji = "";
                object.weight = 0;
            }
            if (message.emoji != null && message.hasOwnProperty("emoji"))
                object.emoji = message.emoji;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
            return object;
        };

        /**
         * Converts this RecentEmojiWeight to JSON.
         * @function toJSON
         * @memberof proto.RecentEmojiWeight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecentEmojiWeight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecentEmojiWeight;
    })();

    proto.RecordStructure = (function() {

        /**
         * Properties of a RecordStructure.
         * @memberof proto
         * @interface IRecordStructure
         * @property {proto.ISessionStructure|null} [currentSession] RecordStructure currentSession
         * @property {Array.<proto.ISessionStructure>|null} [previousSessions] RecordStructure previousSessions
         */

        /**
         * Constructs a new RecordStructure.
         * @memberof proto
         * @classdesc Represents a RecordStructure.
         * @implements IRecordStructure
         * @constructor
         * @param {proto.IRecordStructure=} [properties] Properties to set
         */
        function RecordStructure(properties) {
            this.previousSessions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordStructure currentSession.
         * @member {proto.ISessionStructure|null|undefined} currentSession
         * @memberof proto.RecordStructure
         * @instance
         */
        RecordStructure.prototype.currentSession = null;

        /**
         * RecordStructure previousSessions.
         * @member {Array.<proto.ISessionStructure>} previousSessions
         * @memberof proto.RecordStructure
         * @instance
         */
        RecordStructure.prototype.previousSessions = $util.emptyArray;

        /**
         * Creates a new RecordStructure instance using the specified properties.
         * @function create
         * @memberof proto.RecordStructure
         * @static
         * @param {proto.IRecordStructure=} [properties] Properties to set
         * @returns {proto.RecordStructure} RecordStructure instance
         */
        RecordStructure.create = function create(properties) {
            return new RecordStructure(properties);
        };

        /**
         * Encodes the specified RecordStructure message. Does not implicitly {@link proto.RecordStructure.verify|verify} messages.
         * @function encode
         * @memberof proto.RecordStructure
         * @static
         * @param {proto.IRecordStructure} message RecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSession != null && Object.hasOwnProperty.call(message, "currentSession"))
                $root.proto.SessionStructure.encode(message.currentSession, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.previousSessions != null && message.previousSessions.length)
                for (var i = 0; i < message.previousSessions.length; ++i)
                    $root.proto.SessionStructure.encode(message.previousSessions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RecordStructure message, length delimited. Does not implicitly {@link proto.RecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RecordStructure
         * @static
         * @param {proto.IRecordStructure} message RecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RecordStructure} RecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currentSession = $root.proto.SessionStructure.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.previousSessions && message.previousSessions.length))
                        message.previousSessions = [];
                    message.previousSessions.push($root.proto.SessionStructure.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RecordStructure} RecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordStructure message.
         * @function verify
         * @memberof proto.RecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSession != null && message.hasOwnProperty("currentSession")) {
                var error = $root.proto.SessionStructure.verify(message.currentSession);
                if (error)
                    return "currentSession." + error;
            }
            if (message.previousSessions != null && message.hasOwnProperty("previousSessions")) {
                if (!Array.isArray(message.previousSessions))
                    return "previousSessions: array expected";
                for (var i = 0; i < message.previousSessions.length; ++i) {
                    var error = $root.proto.SessionStructure.verify(message.previousSessions[i]);
                    if (error)
                        return "previousSessions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RecordStructure} RecordStructure
         */
        RecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RecordStructure)
                return object;
            var message = new $root.proto.RecordStructure();
            if (object.currentSession != null) {
                if (typeof object.currentSession !== "object")
                    throw TypeError(".proto.RecordStructure.currentSession: object expected");
                message.currentSession = $root.proto.SessionStructure.fromObject(object.currentSession);
            }
            if (object.previousSessions) {
                if (!Array.isArray(object.previousSessions))
                    throw TypeError(".proto.RecordStructure.previousSessions: array expected");
                message.previousSessions = [];
                for (var i = 0; i < object.previousSessions.length; ++i) {
                    if (typeof object.previousSessions[i] !== "object")
                        throw TypeError(".proto.RecordStructure.previousSessions: object expected");
                    message.previousSessions[i] = $root.proto.SessionStructure.fromObject(object.previousSessions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RecordStructure
         * @static
         * @param {proto.RecordStructure} message RecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.previousSessions = [];
            if (options.defaults)
                object.currentSession = null;
            if (message.currentSession != null && message.hasOwnProperty("currentSession"))
                object.currentSession = $root.proto.SessionStructure.toObject(message.currentSession, options);
            if (message.previousSessions && message.previousSessions.length) {
                object.previousSessions = [];
                for (var j = 0; j < message.previousSessions.length; ++j)
                    object.previousSessions[j] = $root.proto.SessionStructure.toObject(message.previousSessions[j], options);
            }
            return object;
        };

        /**
         * Converts this RecordStructure to JSON.
         * @function toJSON
         * @memberof proto.RecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordStructure;
    })();

    proto.SenderChainKey = (function() {

        /**
         * Properties of a SenderChainKey.
         * @memberof proto
         * @interface ISenderChainKey
         * @property {number|null} [iteration] SenderChainKey iteration
         * @property {Uint8Array|null} [seed] SenderChainKey seed
         */

        /**
         * Constructs a new SenderChainKey.
         * @memberof proto
         * @classdesc Represents a SenderChainKey.
         * @implements ISenderChainKey
         * @constructor
         * @param {proto.ISenderChainKey=} [properties] Properties to set
         */
        function SenderChainKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderChainKey iteration.
         * @member {number} iteration
         * @memberof proto.SenderChainKey
         * @instance
         */
        SenderChainKey.prototype.iteration = 0;

        /**
         * SenderChainKey seed.
         * @member {Uint8Array} seed
         * @memberof proto.SenderChainKey
         * @instance
         */
        SenderChainKey.prototype.seed = $util.newBuffer([]);

        /**
         * Creates a new SenderChainKey instance using the specified properties.
         * @function create
         * @memberof proto.SenderChainKey
         * @static
         * @param {proto.ISenderChainKey=} [properties] Properties to set
         * @returns {proto.SenderChainKey} SenderChainKey instance
         */
        SenderChainKey.create = function create(properties) {
            return new SenderChainKey(properties);
        };

        /**
         * Encodes the specified SenderChainKey message. Does not implicitly {@link proto.SenderChainKey.verify|verify} messages.
         * @function encode
         * @memberof proto.SenderChainKey
         * @static
         * @param {proto.ISenderChainKey} message SenderChainKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderChainKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
            if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);
            return writer;
        };

        /**
         * Encodes the specified SenderChainKey message, length delimited. Does not implicitly {@link proto.SenderChainKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SenderChainKey
         * @static
         * @param {proto.ISenderChainKey} message SenderChainKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderChainKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderChainKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SenderChainKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SenderChainKey} SenderChainKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderChainKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SenderChainKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iteration = reader.uint32();
                    break;
                case 2:
                    message.seed = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderChainKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SenderChainKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SenderChainKey} SenderChainKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderChainKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderChainKey message.
         * @function verify
         * @memberof proto.SenderChainKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderChainKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                if (!$util.isInteger(message.iteration))
                    return "iteration: integer expected";
            if (message.seed != null && message.hasOwnProperty("seed"))
                if (!(message.seed && typeof message.seed.length === "number" || $util.isString(message.seed)))
                    return "seed: buffer expected";
            return null;
        };

        /**
         * Creates a SenderChainKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SenderChainKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SenderChainKey} SenderChainKey
         */
        SenderChainKey.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SenderChainKey)
                return object;
            var message = new $root.proto.SenderChainKey();
            if (object.iteration != null)
                message.iteration = object.iteration >>> 0;
            if (object.seed != null)
                if (typeof object.seed === "string")
                    $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                else if (object.seed.length)
                    message.seed = object.seed;
            return message;
        };

        /**
         * Creates a plain object from a SenderChainKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SenderChainKey
         * @static
         * @param {proto.SenderChainKey} message SenderChainKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderChainKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.iteration = 0;
                if (options.bytes === String)
                    object.seed = "";
                else {
                    object.seed = [];
                    if (options.bytes !== Array)
                        object.seed = $util.newBuffer(object.seed);
                }
            }
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                object.iteration = message.iteration;
            if (message.seed != null && message.hasOwnProperty("seed"))
                object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
            return object;
        };

        /**
         * Converts this SenderChainKey to JSON.
         * @function toJSON
         * @memberof proto.SenderChainKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderChainKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderChainKey;
    })();

    proto.SenderKeyRecordStructure = (function() {

        /**
         * Properties of a SenderKeyRecordStructure.
         * @memberof proto
         * @interface ISenderKeyRecordStructure
         * @property {Array.<proto.ISenderKeyStateStructure>|null} [senderKeyStates] SenderKeyRecordStructure senderKeyStates
         */

        /**
         * Constructs a new SenderKeyRecordStructure.
         * @memberof proto
         * @classdesc Represents a SenderKeyRecordStructure.
         * @implements ISenderKeyRecordStructure
         * @constructor
         * @param {proto.ISenderKeyRecordStructure=} [properties] Properties to set
         */
        function SenderKeyRecordStructure(properties) {
            this.senderKeyStates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderKeyRecordStructure senderKeyStates.
         * @member {Array.<proto.ISenderKeyStateStructure>} senderKeyStates
         * @memberof proto.SenderKeyRecordStructure
         * @instance
         */
        SenderKeyRecordStructure.prototype.senderKeyStates = $util.emptyArray;

        /**
         * Creates a new SenderKeyRecordStructure instance using the specified properties.
         * @function create
         * @memberof proto.SenderKeyRecordStructure
         * @static
         * @param {proto.ISenderKeyRecordStructure=} [properties] Properties to set
         * @returns {proto.SenderKeyRecordStructure} SenderKeyRecordStructure instance
         */
        SenderKeyRecordStructure.create = function create(properties) {
            return new SenderKeyRecordStructure(properties);
        };

        /**
         * Encodes the specified SenderKeyRecordStructure message. Does not implicitly {@link proto.SenderKeyRecordStructure.verify|verify} messages.
         * @function encode
         * @memberof proto.SenderKeyRecordStructure
         * @static
         * @param {proto.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyRecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderKeyStates != null && message.senderKeyStates.length)
                for (var i = 0; i < message.senderKeyStates.length; ++i)
                    $root.proto.SenderKeyStateStructure.encode(message.senderKeyStates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SenderKeyRecordStructure message, length delimited. Does not implicitly {@link proto.SenderKeyRecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SenderKeyRecordStructure
         * @static
         * @param {proto.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SenderKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SenderKeyRecordStructure} SenderKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyRecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SenderKeyRecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.senderKeyStates && message.senderKeyStates.length))
                        message.senderKeyStates = [];
                    message.senderKeyStates.push($root.proto.SenderKeyStateStructure.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SenderKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SenderKeyRecordStructure} SenderKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderKeyRecordStructure message.
         * @function verify
         * @memberof proto.SenderKeyRecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderKeyRecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderKeyStates != null && message.hasOwnProperty("senderKeyStates")) {
                if (!Array.isArray(message.senderKeyStates))
                    return "senderKeyStates: array expected";
                for (var i = 0; i < message.senderKeyStates.length; ++i) {
                    var error = $root.proto.SenderKeyStateStructure.verify(message.senderKeyStates[i]);
                    if (error)
                        return "senderKeyStates." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SenderKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SenderKeyRecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SenderKeyRecordStructure} SenderKeyRecordStructure
         */
        SenderKeyRecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SenderKeyRecordStructure)
                return object;
            var message = new $root.proto.SenderKeyRecordStructure();
            if (object.senderKeyStates) {
                if (!Array.isArray(object.senderKeyStates))
                    throw TypeError(".proto.SenderKeyRecordStructure.senderKeyStates: array expected");
                message.senderKeyStates = [];
                for (var i = 0; i < object.senderKeyStates.length; ++i) {
                    if (typeof object.senderKeyStates[i] !== "object")
                        throw TypeError(".proto.SenderKeyRecordStructure.senderKeyStates: object expected");
                    message.senderKeyStates[i] = $root.proto.SenderKeyStateStructure.fromObject(object.senderKeyStates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SenderKeyRecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SenderKeyRecordStructure
         * @static
         * @param {proto.SenderKeyRecordStructure} message SenderKeyRecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderKeyRecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderKeyStates = [];
            if (message.senderKeyStates && message.senderKeyStates.length) {
                object.senderKeyStates = [];
                for (var j = 0; j < message.senderKeyStates.length; ++j)
                    object.senderKeyStates[j] = $root.proto.SenderKeyStateStructure.toObject(message.senderKeyStates[j], options);
            }
            return object;
        };

        /**
         * Converts this SenderKeyRecordStructure to JSON.
         * @function toJSON
         * @memberof proto.SenderKeyRecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderKeyRecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderKeyRecordStructure;
    })();

    proto.SenderKeyStateStructure = (function() {

        /**
         * Properties of a SenderKeyStateStructure.
         * @memberof proto
         * @interface ISenderKeyStateStructure
         * @property {number|null} [senderKeyId] SenderKeyStateStructure senderKeyId
         * @property {proto.ISenderChainKey|null} [senderChainKey] SenderKeyStateStructure senderChainKey
         * @property {proto.ISenderSigningKey|null} [senderSigningKey] SenderKeyStateStructure senderSigningKey
         * @property {Array.<proto.ISenderMessageKey>|null} [senderMessageKeys] SenderKeyStateStructure senderMessageKeys
         */

        /**
         * Constructs a new SenderKeyStateStructure.
         * @memberof proto
         * @classdesc Represents a SenderKeyStateStructure.
         * @implements ISenderKeyStateStructure
         * @constructor
         * @param {proto.ISenderKeyStateStructure=} [properties] Properties to set
         */
        function SenderKeyStateStructure(properties) {
            this.senderMessageKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderKeyStateStructure senderKeyId.
         * @member {number} senderKeyId
         * @memberof proto.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderKeyId = 0;

        /**
         * SenderKeyStateStructure senderChainKey.
         * @member {proto.ISenderChainKey|null|undefined} senderChainKey
         * @memberof proto.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderChainKey = null;

        /**
         * SenderKeyStateStructure senderSigningKey.
         * @member {proto.ISenderSigningKey|null|undefined} senderSigningKey
         * @memberof proto.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderSigningKey = null;

        /**
         * SenderKeyStateStructure senderMessageKeys.
         * @member {Array.<proto.ISenderMessageKey>} senderMessageKeys
         * @memberof proto.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderMessageKeys = $util.emptyArray;

        /**
         * Creates a new SenderKeyStateStructure instance using the specified properties.
         * @function create
         * @memberof proto.SenderKeyStateStructure
         * @static
         * @param {proto.ISenderKeyStateStructure=} [properties] Properties to set
         * @returns {proto.SenderKeyStateStructure} SenderKeyStateStructure instance
         */
        SenderKeyStateStructure.create = function create(properties) {
            return new SenderKeyStateStructure(properties);
        };

        /**
         * Encodes the specified SenderKeyStateStructure message. Does not implicitly {@link proto.SenderKeyStateStructure.verify|verify} messages.
         * @function encode
         * @memberof proto.SenderKeyStateStructure
         * @static
         * @param {proto.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyStateStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderKeyId != null && Object.hasOwnProperty.call(message, "senderKeyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.senderKeyId);
            if (message.senderChainKey != null && Object.hasOwnProperty.call(message, "senderChainKey"))
                $root.proto.SenderChainKey.encode(message.senderChainKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.senderSigningKey != null && Object.hasOwnProperty.call(message, "senderSigningKey"))
                $root.proto.SenderSigningKey.encode(message.senderSigningKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.senderMessageKeys != null && message.senderMessageKeys.length)
                for (var i = 0; i < message.senderMessageKeys.length; ++i)
                    $root.proto.SenderMessageKey.encode(message.senderMessageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SenderKeyStateStructure message, length delimited. Does not implicitly {@link proto.SenderKeyStateStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SenderKeyStateStructure
         * @static
         * @param {proto.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyStateStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderKeyStateStructure message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SenderKeyStateStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SenderKeyStateStructure} SenderKeyStateStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyStateStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SenderKeyStateStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.senderKeyId = reader.uint32();
                    break;
                case 2:
                    message.senderChainKey = $root.proto.SenderChainKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.senderSigningKey = $root.proto.SenderSigningKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.senderMessageKeys && message.senderMessageKeys.length))
                        message.senderMessageKeys = [];
                    message.senderMessageKeys.push($root.proto.SenderMessageKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderKeyStateStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SenderKeyStateStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SenderKeyStateStructure} SenderKeyStateStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyStateStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderKeyStateStructure message.
         * @function verify
         * @memberof proto.SenderKeyStateStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderKeyStateStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderKeyId != null && message.hasOwnProperty("senderKeyId"))
                if (!$util.isInteger(message.senderKeyId))
                    return "senderKeyId: integer expected";
            if (message.senderChainKey != null && message.hasOwnProperty("senderChainKey")) {
                var error = $root.proto.SenderChainKey.verify(message.senderChainKey);
                if (error)
                    return "senderChainKey." + error;
            }
            if (message.senderSigningKey != null && message.hasOwnProperty("senderSigningKey")) {
                var error = $root.proto.SenderSigningKey.verify(message.senderSigningKey);
                if (error)
                    return "senderSigningKey." + error;
            }
            if (message.senderMessageKeys != null && message.hasOwnProperty("senderMessageKeys")) {
                if (!Array.isArray(message.senderMessageKeys))
                    return "senderMessageKeys: array expected";
                for (var i = 0; i < message.senderMessageKeys.length; ++i) {
                    var error = $root.proto.SenderMessageKey.verify(message.senderMessageKeys[i]);
                    if (error)
                        return "senderMessageKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SenderKeyStateStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SenderKeyStateStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SenderKeyStateStructure} SenderKeyStateStructure
         */
        SenderKeyStateStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SenderKeyStateStructure)
                return object;
            var message = new $root.proto.SenderKeyStateStructure();
            if (object.senderKeyId != null)
                message.senderKeyId = object.senderKeyId >>> 0;
            if (object.senderChainKey != null) {
                if (typeof object.senderChainKey !== "object")
                    throw TypeError(".proto.SenderKeyStateStructure.senderChainKey: object expected");
                message.senderChainKey = $root.proto.SenderChainKey.fromObject(object.senderChainKey);
            }
            if (object.senderSigningKey != null) {
                if (typeof object.senderSigningKey !== "object")
                    throw TypeError(".proto.SenderKeyStateStructure.senderSigningKey: object expected");
                message.senderSigningKey = $root.proto.SenderSigningKey.fromObject(object.senderSigningKey);
            }
            if (object.senderMessageKeys) {
                if (!Array.isArray(object.senderMessageKeys))
                    throw TypeError(".proto.SenderKeyStateStructure.senderMessageKeys: array expected");
                message.senderMessageKeys = [];
                for (var i = 0; i < object.senderMessageKeys.length; ++i) {
                    if (typeof object.senderMessageKeys[i] !== "object")
                        throw TypeError(".proto.SenderKeyStateStructure.senderMessageKeys: object expected");
                    message.senderMessageKeys[i] = $root.proto.SenderMessageKey.fromObject(object.senderMessageKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SenderKeyStateStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SenderKeyStateStructure
         * @static
         * @param {proto.SenderKeyStateStructure} message SenderKeyStateStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderKeyStateStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderMessageKeys = [];
            if (options.defaults) {
                object.senderKeyId = 0;
                object.senderChainKey = null;
                object.senderSigningKey = null;
            }
            if (message.senderKeyId != null && message.hasOwnProperty("senderKeyId"))
                object.senderKeyId = message.senderKeyId;
            if (message.senderChainKey != null && message.hasOwnProperty("senderChainKey"))
                object.senderChainKey = $root.proto.SenderChainKey.toObject(message.senderChainKey, options);
            if (message.senderSigningKey != null && message.hasOwnProperty("senderSigningKey"))
                object.senderSigningKey = $root.proto.SenderSigningKey.toObject(message.senderSigningKey, options);
            if (message.senderMessageKeys && message.senderMessageKeys.length) {
                object.senderMessageKeys = [];
                for (var j = 0; j < message.senderMessageKeys.length; ++j)
                    object.senderMessageKeys[j] = $root.proto.SenderMessageKey.toObject(message.senderMessageKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this SenderKeyStateStructure to JSON.
         * @function toJSON
         * @memberof proto.SenderKeyStateStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderKeyStateStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderKeyStateStructure;
    })();

    proto.SenderMessageKey = (function() {

        /**
         * Properties of a SenderMessageKey.
         * @memberof proto
         * @interface ISenderMessageKey
         * @property {number|null} [iteration] SenderMessageKey iteration
         * @property {Uint8Array|null} [seed] SenderMessageKey seed
         */

        /**
         * Constructs a new SenderMessageKey.
         * @memberof proto
         * @classdesc Represents a SenderMessageKey.
         * @implements ISenderMessageKey
         * @constructor
         * @param {proto.ISenderMessageKey=} [properties] Properties to set
         */
        function SenderMessageKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderMessageKey iteration.
         * @member {number} iteration
         * @memberof proto.SenderMessageKey
         * @instance
         */
        SenderMessageKey.prototype.iteration = 0;

        /**
         * SenderMessageKey seed.
         * @member {Uint8Array} seed
         * @memberof proto.SenderMessageKey
         * @instance
         */
        SenderMessageKey.prototype.seed = $util.newBuffer([]);

        /**
         * Creates a new SenderMessageKey instance using the specified properties.
         * @function create
         * @memberof proto.SenderMessageKey
         * @static
         * @param {proto.ISenderMessageKey=} [properties] Properties to set
         * @returns {proto.SenderMessageKey} SenderMessageKey instance
         */
        SenderMessageKey.create = function create(properties) {
            return new SenderMessageKey(properties);
        };

        /**
         * Encodes the specified SenderMessageKey message. Does not implicitly {@link proto.SenderMessageKey.verify|verify} messages.
         * @function encode
         * @memberof proto.SenderMessageKey
         * @static
         * @param {proto.ISenderMessageKey} message SenderMessageKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderMessageKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
            if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);
            return writer;
        };

        /**
         * Encodes the specified SenderMessageKey message, length delimited. Does not implicitly {@link proto.SenderMessageKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SenderMessageKey
         * @static
         * @param {proto.ISenderMessageKey} message SenderMessageKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderMessageKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderMessageKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SenderMessageKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SenderMessageKey} SenderMessageKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderMessageKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SenderMessageKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iteration = reader.uint32();
                    break;
                case 2:
                    message.seed = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderMessageKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SenderMessageKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SenderMessageKey} SenderMessageKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderMessageKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderMessageKey message.
         * @function verify
         * @memberof proto.SenderMessageKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderMessageKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                if (!$util.isInteger(message.iteration))
                    return "iteration: integer expected";
            if (message.seed != null && message.hasOwnProperty("seed"))
                if (!(message.seed && typeof message.seed.length === "number" || $util.isString(message.seed)))
                    return "seed: buffer expected";
            return null;
        };

        /**
         * Creates a SenderMessageKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SenderMessageKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SenderMessageKey} SenderMessageKey
         */
        SenderMessageKey.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SenderMessageKey)
                return object;
            var message = new $root.proto.SenderMessageKey();
            if (object.iteration != null)
                message.iteration = object.iteration >>> 0;
            if (object.seed != null)
                if (typeof object.seed === "string")
                    $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                else if (object.seed.length)
                    message.seed = object.seed;
            return message;
        };

        /**
         * Creates a plain object from a SenderMessageKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SenderMessageKey
         * @static
         * @param {proto.SenderMessageKey} message SenderMessageKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderMessageKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.iteration = 0;
                if (options.bytes === String)
                    object.seed = "";
                else {
                    object.seed = [];
                    if (options.bytes !== Array)
                        object.seed = $util.newBuffer(object.seed);
                }
            }
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                object.iteration = message.iteration;
            if (message.seed != null && message.hasOwnProperty("seed"))
                object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
            return object;
        };

        /**
         * Converts this SenderMessageKey to JSON.
         * @function toJSON
         * @memberof proto.SenderMessageKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderMessageKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderMessageKey;
    })();

    proto.SenderSigningKey = (function() {

        /**
         * Properties of a SenderSigningKey.
         * @memberof proto
         * @interface ISenderSigningKey
         * @property {Uint8Array|null} ["public"] SenderSigningKey public
         * @property {Uint8Array|null} ["private"] SenderSigningKey private
         */

        /**
         * Constructs a new SenderSigningKey.
         * @memberof proto
         * @classdesc Represents a SenderSigningKey.
         * @implements ISenderSigningKey
         * @constructor
         * @param {proto.ISenderSigningKey=} [properties] Properties to set
         */
        function SenderSigningKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderSigningKey public.
         * @member {Uint8Array} public
         * @memberof proto.SenderSigningKey
         * @instance
         */
        SenderSigningKey.prototype["public"] = $util.newBuffer([]);

        /**
         * SenderSigningKey private.
         * @member {Uint8Array} private
         * @memberof proto.SenderSigningKey
         * @instance
         */
        SenderSigningKey.prototype["private"] = $util.newBuffer([]);

        /**
         * Creates a new SenderSigningKey instance using the specified properties.
         * @function create
         * @memberof proto.SenderSigningKey
         * @static
         * @param {proto.ISenderSigningKey=} [properties] Properties to set
         * @returns {proto.SenderSigningKey} SenderSigningKey instance
         */
        SenderSigningKey.create = function create(properties) {
            return new SenderSigningKey(properties);
        };

        /**
         * Encodes the specified SenderSigningKey message. Does not implicitly {@link proto.SenderSigningKey.verify|verify} messages.
         * @function encode
         * @memberof proto.SenderSigningKey
         * @static
         * @param {proto.ISenderSigningKey} message SenderSigningKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderSigningKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["public"] != null && Object.hasOwnProperty.call(message, "public"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message["public"]);
            if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["private"]);
            return writer;
        };

        /**
         * Encodes the specified SenderSigningKey message, length delimited. Does not implicitly {@link proto.SenderSigningKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SenderSigningKey
         * @static
         * @param {proto.ISenderSigningKey} message SenderSigningKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderSigningKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderSigningKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SenderSigningKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SenderSigningKey} SenderSigningKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderSigningKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SenderSigningKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message["public"] = reader.bytes();
                    break;
                case 2:
                    message["private"] = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderSigningKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SenderSigningKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SenderSigningKey} SenderSigningKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderSigningKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderSigningKey message.
         * @function verify
         * @memberof proto.SenderSigningKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderSigningKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["public"] != null && message.hasOwnProperty("public"))
                if (!(message["public"] && typeof message["public"].length === "number" || $util.isString(message["public"])))
                    return "public: buffer expected";
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (!(message["private"] && typeof message["private"].length === "number" || $util.isString(message["private"])))
                    return "private: buffer expected";
            return null;
        };

        /**
         * Creates a SenderSigningKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SenderSigningKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SenderSigningKey} SenderSigningKey
         */
        SenderSigningKey.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SenderSigningKey)
                return object;
            var message = new $root.proto.SenderSigningKey();
            if (object["public"] != null)
                if (typeof object["public"] === "string")
                    $util.base64.decode(object["public"], message["public"] = $util.newBuffer($util.base64.length(object["public"])), 0);
                else if (object["public"].length)
                    message["public"] = object["public"];
            if (object["private"] != null)
                if (typeof object["private"] === "string")
                    $util.base64.decode(object["private"], message["private"] = $util.newBuffer($util.base64.length(object["private"])), 0);
                else if (object["private"].length)
                    message["private"] = object["private"];
            return message;
        };

        /**
         * Creates a plain object from a SenderSigningKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SenderSigningKey
         * @static
         * @param {proto.SenderSigningKey} message SenderSigningKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderSigningKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object["public"] = "";
                else {
                    object["public"] = [];
                    if (options.bytes !== Array)
                        object["public"] = $util.newBuffer(object["public"]);
                }
                if (options.bytes === String)
                    object["private"] = "";
                else {
                    object["private"] = [];
                    if (options.bytes !== Array)
                        object["private"] = $util.newBuffer(object["private"]);
                }
            }
            if (message["public"] != null && message.hasOwnProperty("public"))
                object["public"] = options.bytes === String ? $util.base64.encode(message["public"], 0, message["public"].length) : options.bytes === Array ? Array.prototype.slice.call(message["public"]) : message["public"];
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = options.bytes === String ? $util.base64.encode(message["private"], 0, message["private"].length) : options.bytes === Array ? Array.prototype.slice.call(message["private"]) : message["private"];
            return object;
        };

        /**
         * Converts this SenderSigningKey to JSON.
         * @function toJSON
         * @memberof proto.SenderSigningKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderSigningKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderSigningKey;
    })();

    proto.ServerErrorReceipt = (function() {

        /**
         * Properties of a ServerErrorReceipt.
         * @memberof proto
         * @interface IServerErrorReceipt
         * @property {string|null} [stanzaId] ServerErrorReceipt stanzaId
         */

        /**
         * Constructs a new ServerErrorReceipt.
         * @memberof proto
         * @classdesc Represents a ServerErrorReceipt.
         * @implements IServerErrorReceipt
         * @constructor
         * @param {proto.IServerErrorReceipt=} [properties] Properties to set
         */
        function ServerErrorReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerErrorReceipt stanzaId.
         * @member {string} stanzaId
         * @memberof proto.ServerErrorReceipt
         * @instance
         */
        ServerErrorReceipt.prototype.stanzaId = "";

        /**
         * Creates a new ServerErrorReceipt instance using the specified properties.
         * @function create
         * @memberof proto.ServerErrorReceipt
         * @static
         * @param {proto.IServerErrorReceipt=} [properties] Properties to set
         * @returns {proto.ServerErrorReceipt} ServerErrorReceipt instance
         */
        ServerErrorReceipt.create = function create(properties) {
            return new ServerErrorReceipt(properties);
        };

        /**
         * Encodes the specified ServerErrorReceipt message. Does not implicitly {@link proto.ServerErrorReceipt.verify|verify} messages.
         * @function encode
         * @memberof proto.ServerErrorReceipt
         * @static
         * @param {proto.IServerErrorReceipt} message ServerErrorReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerErrorReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stanzaId != null && Object.hasOwnProperty.call(message, "stanzaId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stanzaId);
            return writer;
        };

        /**
         * Encodes the specified ServerErrorReceipt message, length delimited. Does not implicitly {@link proto.ServerErrorReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ServerErrorReceipt
         * @static
         * @param {proto.IServerErrorReceipt} message ServerErrorReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerErrorReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerErrorReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ServerErrorReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ServerErrorReceipt} ServerErrorReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerErrorReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ServerErrorReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stanzaId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerErrorReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ServerErrorReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ServerErrorReceipt} ServerErrorReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerErrorReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerErrorReceipt message.
         * @function verify
         * @memberof proto.ServerErrorReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerErrorReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                if (!$util.isString(message.stanzaId))
                    return "stanzaId: string expected";
            return null;
        };

        /**
         * Creates a ServerErrorReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ServerErrorReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ServerErrorReceipt} ServerErrorReceipt
         */
        ServerErrorReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ServerErrorReceipt)
                return object;
            var message = new $root.proto.ServerErrorReceipt();
            if (object.stanzaId != null)
                message.stanzaId = String(object.stanzaId);
            return message;
        };

        /**
         * Creates a plain object from a ServerErrorReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ServerErrorReceipt
         * @static
         * @param {proto.ServerErrorReceipt} message ServerErrorReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerErrorReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.stanzaId = "";
            if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                object.stanzaId = message.stanzaId;
            return object;
        };

        /**
         * Converts this ServerErrorReceipt to JSON.
         * @function toJSON
         * @memberof proto.ServerErrorReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerErrorReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServerErrorReceipt;
    })();

    proto.SessionStructure = (function() {

        /**
         * Properties of a SessionStructure.
         * @memberof proto
         * @interface ISessionStructure
         * @property {number|null} [sessionVersion] SessionStructure sessionVersion
         * @property {Uint8Array|null} [localIdentityPublic] SessionStructure localIdentityPublic
         * @property {Uint8Array|null} [remoteIdentityPublic] SessionStructure remoteIdentityPublic
         * @property {Uint8Array|null} [rootKey] SessionStructure rootKey
         * @property {number|null} [previousCounter] SessionStructure previousCounter
         * @property {proto.IChain|null} [senderChain] SessionStructure senderChain
         * @property {Array.<proto.IChain>|null} [receiverChains] SessionStructure receiverChains
         * @property {proto.IPendingKeyExchange|null} [pendingKeyExchange] SessionStructure pendingKeyExchange
         * @property {proto.IPendingPreKey|null} [pendingPreKey] SessionStructure pendingPreKey
         * @property {number|null} [remoteRegistrationId] SessionStructure remoteRegistrationId
         * @property {number|null} [localRegistrationId] SessionStructure localRegistrationId
         * @property {boolean|null} [needsRefresh] SessionStructure needsRefresh
         * @property {Uint8Array|null} [aliceBaseKey] SessionStructure aliceBaseKey
         */

        /**
         * Constructs a new SessionStructure.
         * @memberof proto
         * @classdesc Represents a SessionStructure.
         * @implements ISessionStructure
         * @constructor
         * @param {proto.ISessionStructure=} [properties] Properties to set
         */
        function SessionStructure(properties) {
            this.receiverChains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionStructure sessionVersion.
         * @member {number} sessionVersion
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.sessionVersion = 0;

        /**
         * SessionStructure localIdentityPublic.
         * @member {Uint8Array} localIdentityPublic
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.localIdentityPublic = $util.newBuffer([]);

        /**
         * SessionStructure remoteIdentityPublic.
         * @member {Uint8Array} remoteIdentityPublic
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.remoteIdentityPublic = $util.newBuffer([]);

        /**
         * SessionStructure rootKey.
         * @member {Uint8Array} rootKey
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.rootKey = $util.newBuffer([]);

        /**
         * SessionStructure previousCounter.
         * @member {number} previousCounter
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.previousCounter = 0;

        /**
         * SessionStructure senderChain.
         * @member {proto.IChain|null|undefined} senderChain
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.senderChain = null;

        /**
         * SessionStructure receiverChains.
         * @member {Array.<proto.IChain>} receiverChains
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.receiverChains = $util.emptyArray;

        /**
         * SessionStructure pendingKeyExchange.
         * @member {proto.IPendingKeyExchange|null|undefined} pendingKeyExchange
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.pendingKeyExchange = null;

        /**
         * SessionStructure pendingPreKey.
         * @member {proto.IPendingPreKey|null|undefined} pendingPreKey
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.pendingPreKey = null;

        /**
         * SessionStructure remoteRegistrationId.
         * @member {number} remoteRegistrationId
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.remoteRegistrationId = 0;

        /**
         * SessionStructure localRegistrationId.
         * @member {number} localRegistrationId
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.localRegistrationId = 0;

        /**
         * SessionStructure needsRefresh.
         * @member {boolean} needsRefresh
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.needsRefresh = false;

        /**
         * SessionStructure aliceBaseKey.
         * @member {Uint8Array} aliceBaseKey
         * @memberof proto.SessionStructure
         * @instance
         */
        SessionStructure.prototype.aliceBaseKey = $util.newBuffer([]);

        /**
         * Creates a new SessionStructure instance using the specified properties.
         * @function create
         * @memberof proto.SessionStructure
         * @static
         * @param {proto.ISessionStructure=} [properties] Properties to set
         * @returns {proto.SessionStructure} SessionStructure instance
         */
        SessionStructure.create = function create(properties) {
            return new SessionStructure(properties);
        };

        /**
         * Encodes the specified SessionStructure message. Does not implicitly {@link proto.SessionStructure.verify|verify} messages.
         * @function encode
         * @memberof proto.SessionStructure
         * @static
         * @param {proto.ISessionStructure} message SessionStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionVersion != null && Object.hasOwnProperty.call(message, "sessionVersion"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sessionVersion);
            if (message.localIdentityPublic != null && Object.hasOwnProperty.call(message, "localIdentityPublic"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.localIdentityPublic);
            if (message.remoteIdentityPublic != null && Object.hasOwnProperty.call(message, "remoteIdentityPublic"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.remoteIdentityPublic);
            if (message.rootKey != null && Object.hasOwnProperty.call(message, "rootKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.rootKey);
            if (message.previousCounter != null && Object.hasOwnProperty.call(message, "previousCounter"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.previousCounter);
            if (message.senderChain != null && Object.hasOwnProperty.call(message, "senderChain"))
                $root.proto.Chain.encode(message.senderChain, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.receiverChains != null && message.receiverChains.length)
                for (var i = 0; i < message.receiverChains.length; ++i)
                    $root.proto.Chain.encode(message.receiverChains[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.pendingKeyExchange != null && Object.hasOwnProperty.call(message, "pendingKeyExchange"))
                $root.proto.PendingKeyExchange.encode(message.pendingKeyExchange, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.pendingPreKey != null && Object.hasOwnProperty.call(message, "pendingPreKey"))
                $root.proto.PendingPreKey.encode(message.pendingPreKey, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.remoteRegistrationId != null && Object.hasOwnProperty.call(message, "remoteRegistrationId"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.remoteRegistrationId);
            if (message.localRegistrationId != null && Object.hasOwnProperty.call(message, "localRegistrationId"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.localRegistrationId);
            if (message.needsRefresh != null && Object.hasOwnProperty.call(message, "needsRefresh"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.needsRefresh);
            if (message.aliceBaseKey != null && Object.hasOwnProperty.call(message, "aliceBaseKey"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.aliceBaseKey);
            return writer;
        };

        /**
         * Encodes the specified SessionStructure message, length delimited. Does not implicitly {@link proto.SessionStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SessionStructure
         * @static
         * @param {proto.ISessionStructure} message SessionStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionStructure message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SessionStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SessionStructure} SessionStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SessionStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sessionVersion = reader.uint32();
                    break;
                case 2:
                    message.localIdentityPublic = reader.bytes();
                    break;
                case 3:
                    message.remoteIdentityPublic = reader.bytes();
                    break;
                case 4:
                    message.rootKey = reader.bytes();
                    break;
                case 5:
                    message.previousCounter = reader.uint32();
                    break;
                case 6:
                    message.senderChain = $root.proto.Chain.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.receiverChains && message.receiverChains.length))
                        message.receiverChains = [];
                    message.receiverChains.push($root.proto.Chain.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.pendingKeyExchange = $root.proto.PendingKeyExchange.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.pendingPreKey = $root.proto.PendingPreKey.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.remoteRegistrationId = reader.uint32();
                    break;
                case 11:
                    message.localRegistrationId = reader.uint32();
                    break;
                case 12:
                    message.needsRefresh = reader.bool();
                    break;
                case 13:
                    message.aliceBaseKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SessionStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SessionStructure} SessionStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionStructure message.
         * @function verify
         * @memberof proto.SessionStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionVersion != null && message.hasOwnProperty("sessionVersion"))
                if (!$util.isInteger(message.sessionVersion))
                    return "sessionVersion: integer expected";
            if (message.localIdentityPublic != null && message.hasOwnProperty("localIdentityPublic"))
                if (!(message.localIdentityPublic && typeof message.localIdentityPublic.length === "number" || $util.isString(message.localIdentityPublic)))
                    return "localIdentityPublic: buffer expected";
            if (message.remoteIdentityPublic != null && message.hasOwnProperty("remoteIdentityPublic"))
                if (!(message.remoteIdentityPublic && typeof message.remoteIdentityPublic.length === "number" || $util.isString(message.remoteIdentityPublic)))
                    return "remoteIdentityPublic: buffer expected";
            if (message.rootKey != null && message.hasOwnProperty("rootKey"))
                if (!(message.rootKey && typeof message.rootKey.length === "number" || $util.isString(message.rootKey)))
                    return "rootKey: buffer expected";
            if (message.previousCounter != null && message.hasOwnProperty("previousCounter"))
                if (!$util.isInteger(message.previousCounter))
                    return "previousCounter: integer expected";
            if (message.senderChain != null && message.hasOwnProperty("senderChain")) {
                var error = $root.proto.Chain.verify(message.senderChain);
                if (error)
                    return "senderChain." + error;
            }
            if (message.receiverChains != null && message.hasOwnProperty("receiverChains")) {
                if (!Array.isArray(message.receiverChains))
                    return "receiverChains: array expected";
                for (var i = 0; i < message.receiverChains.length; ++i) {
                    var error = $root.proto.Chain.verify(message.receiverChains[i]);
                    if (error)
                        return "receiverChains." + error;
                }
            }
            if (message.pendingKeyExchange != null && message.hasOwnProperty("pendingKeyExchange")) {
                var error = $root.proto.PendingKeyExchange.verify(message.pendingKeyExchange);
                if (error)
                    return "pendingKeyExchange." + error;
            }
            if (message.pendingPreKey != null && message.hasOwnProperty("pendingPreKey")) {
                var error = $root.proto.PendingPreKey.verify(message.pendingPreKey);
                if (error)
                    return "pendingPreKey." + error;
            }
            if (message.remoteRegistrationId != null && message.hasOwnProperty("remoteRegistrationId"))
                if (!$util.isInteger(message.remoteRegistrationId))
                    return "remoteRegistrationId: integer expected";
            if (message.localRegistrationId != null && message.hasOwnProperty("localRegistrationId"))
                if (!$util.isInteger(message.localRegistrationId))
                    return "localRegistrationId: integer expected";
            if (message.needsRefresh != null && message.hasOwnProperty("needsRefresh"))
                if (typeof message.needsRefresh !== "boolean")
                    return "needsRefresh: boolean expected";
            if (message.aliceBaseKey != null && message.hasOwnProperty("aliceBaseKey"))
                if (!(message.aliceBaseKey && typeof message.aliceBaseKey.length === "number" || $util.isString(message.aliceBaseKey)))
                    return "aliceBaseKey: buffer expected";
            return null;
        };

        /**
         * Creates a SessionStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SessionStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SessionStructure} SessionStructure
         */
        SessionStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SessionStructure)
                return object;
            var message = new $root.proto.SessionStructure();
            if (object.sessionVersion != null)
                message.sessionVersion = object.sessionVersion >>> 0;
            if (object.localIdentityPublic != null)
                if (typeof object.localIdentityPublic === "string")
                    $util.base64.decode(object.localIdentityPublic, message.localIdentityPublic = $util.newBuffer($util.base64.length(object.localIdentityPublic)), 0);
                else if (object.localIdentityPublic.length)
                    message.localIdentityPublic = object.localIdentityPublic;
            if (object.remoteIdentityPublic != null)
                if (typeof object.remoteIdentityPublic === "string")
                    $util.base64.decode(object.remoteIdentityPublic, message.remoteIdentityPublic = $util.newBuffer($util.base64.length(object.remoteIdentityPublic)), 0);
                else if (object.remoteIdentityPublic.length)
                    message.remoteIdentityPublic = object.remoteIdentityPublic;
            if (object.rootKey != null)
                if (typeof object.rootKey === "string")
                    $util.base64.decode(object.rootKey, message.rootKey = $util.newBuffer($util.base64.length(object.rootKey)), 0);
                else if (object.rootKey.length)
                    message.rootKey = object.rootKey;
            if (object.previousCounter != null)
                message.previousCounter = object.previousCounter >>> 0;
            if (object.senderChain != null) {
                if (typeof object.senderChain !== "object")
                    throw TypeError(".proto.SessionStructure.senderChain: object expected");
                message.senderChain = $root.proto.Chain.fromObject(object.senderChain);
            }
            if (object.receiverChains) {
                if (!Array.isArray(object.receiverChains))
                    throw TypeError(".proto.SessionStructure.receiverChains: array expected");
                message.receiverChains = [];
                for (var i = 0; i < object.receiverChains.length; ++i) {
                    if (typeof object.receiverChains[i] !== "object")
                        throw TypeError(".proto.SessionStructure.receiverChains: object expected");
                    message.receiverChains[i] = $root.proto.Chain.fromObject(object.receiverChains[i]);
                }
            }
            if (object.pendingKeyExchange != null) {
                if (typeof object.pendingKeyExchange !== "object")
                    throw TypeError(".proto.SessionStructure.pendingKeyExchange: object expected");
                message.pendingKeyExchange = $root.proto.PendingKeyExchange.fromObject(object.pendingKeyExchange);
            }
            if (object.pendingPreKey != null) {
                if (typeof object.pendingPreKey !== "object")
                    throw TypeError(".proto.SessionStructure.pendingPreKey: object expected");
                message.pendingPreKey = $root.proto.PendingPreKey.fromObject(object.pendingPreKey);
            }
            if (object.remoteRegistrationId != null)
                message.remoteRegistrationId = object.remoteRegistrationId >>> 0;
            if (object.localRegistrationId != null)
                message.localRegistrationId = object.localRegistrationId >>> 0;
            if (object.needsRefresh != null)
                message.needsRefresh = Boolean(object.needsRefresh);
            if (object.aliceBaseKey != null)
                if (typeof object.aliceBaseKey === "string")
                    $util.base64.decode(object.aliceBaseKey, message.aliceBaseKey = $util.newBuffer($util.base64.length(object.aliceBaseKey)), 0);
                else if (object.aliceBaseKey.length)
                    message.aliceBaseKey = object.aliceBaseKey;
            return message;
        };

        /**
         * Creates a plain object from a SessionStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SessionStructure
         * @static
         * @param {proto.SessionStructure} message SessionStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.receiverChains = [];
            if (options.defaults) {
                object.sessionVersion = 0;
                if (options.bytes === String)
                    object.localIdentityPublic = "";
                else {
                    object.localIdentityPublic = [];
                    if (options.bytes !== Array)
                        object.localIdentityPublic = $util.newBuffer(object.localIdentityPublic);
                }
                if (options.bytes === String)
                    object.remoteIdentityPublic = "";
                else {
                    object.remoteIdentityPublic = [];
                    if (options.bytes !== Array)
                        object.remoteIdentityPublic = $util.newBuffer(object.remoteIdentityPublic);
                }
                if (options.bytes === String)
                    object.rootKey = "";
                else {
                    object.rootKey = [];
                    if (options.bytes !== Array)
                        object.rootKey = $util.newBuffer(object.rootKey);
                }
                object.previousCounter = 0;
                object.senderChain = null;
                object.pendingKeyExchange = null;
                object.pendingPreKey = null;
                object.remoteRegistrationId = 0;
                object.localRegistrationId = 0;
                object.needsRefresh = false;
                if (options.bytes === String)
                    object.aliceBaseKey = "";
                else {
                    object.aliceBaseKey = [];
                    if (options.bytes !== Array)
                        object.aliceBaseKey = $util.newBuffer(object.aliceBaseKey);
                }
            }
            if (message.sessionVersion != null && message.hasOwnProperty("sessionVersion"))
                object.sessionVersion = message.sessionVersion;
            if (message.localIdentityPublic != null && message.hasOwnProperty("localIdentityPublic"))
                object.localIdentityPublic = options.bytes === String ? $util.base64.encode(message.localIdentityPublic, 0, message.localIdentityPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.localIdentityPublic) : message.localIdentityPublic;
            if (message.remoteIdentityPublic != null && message.hasOwnProperty("remoteIdentityPublic"))
                object.remoteIdentityPublic = options.bytes === String ? $util.base64.encode(message.remoteIdentityPublic, 0, message.remoteIdentityPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.remoteIdentityPublic) : message.remoteIdentityPublic;
            if (message.rootKey != null && message.hasOwnProperty("rootKey"))
                object.rootKey = options.bytes === String ? $util.base64.encode(message.rootKey, 0, message.rootKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.rootKey) : message.rootKey;
            if (message.previousCounter != null && message.hasOwnProperty("previousCounter"))
                object.previousCounter = message.previousCounter;
            if (message.senderChain != null && message.hasOwnProperty("senderChain"))
                object.senderChain = $root.proto.Chain.toObject(message.senderChain, options);
            if (message.receiverChains && message.receiverChains.length) {
                object.receiverChains = [];
                for (var j = 0; j < message.receiverChains.length; ++j)
                    object.receiverChains[j] = $root.proto.Chain.toObject(message.receiverChains[j], options);
            }
            if (message.pendingKeyExchange != null && message.hasOwnProperty("pendingKeyExchange"))
                object.pendingKeyExchange = $root.proto.PendingKeyExchange.toObject(message.pendingKeyExchange, options);
            if (message.pendingPreKey != null && message.hasOwnProperty("pendingPreKey"))
                object.pendingPreKey = $root.proto.PendingPreKey.toObject(message.pendingPreKey, options);
            if (message.remoteRegistrationId != null && message.hasOwnProperty("remoteRegistrationId"))
                object.remoteRegistrationId = message.remoteRegistrationId;
            if (message.localRegistrationId != null && message.hasOwnProperty("localRegistrationId"))
                object.localRegistrationId = message.localRegistrationId;
            if (message.needsRefresh != null && message.hasOwnProperty("needsRefresh"))
                object.needsRefresh = message.needsRefresh;
            if (message.aliceBaseKey != null && message.hasOwnProperty("aliceBaseKey"))
                object.aliceBaseKey = options.bytes === String ? $util.base64.encode(message.aliceBaseKey, 0, message.aliceBaseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.aliceBaseKey) : message.aliceBaseKey;
            return object;
        };

        /**
         * Converts this SessionStructure to JSON.
         * @function toJSON
         * @memberof proto.SessionStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionStructure;
    })();

    proto.SignedPreKeyRecordStructure = (function() {

        /**
         * Properties of a SignedPreKeyRecordStructure.
         * @memberof proto
         * @interface ISignedPreKeyRecordStructure
         * @property {number|null} [id] SignedPreKeyRecordStructure id
         * @property {Uint8Array|null} [publicKey] SignedPreKeyRecordStructure publicKey
         * @property {Uint8Array|null} [privateKey] SignedPreKeyRecordStructure privateKey
         * @property {Uint8Array|null} [signature] SignedPreKeyRecordStructure signature
         * @property {number|Long|null} [timestamp] SignedPreKeyRecordStructure timestamp
         */

        /**
         * Constructs a new SignedPreKeyRecordStructure.
         * @memberof proto
         * @classdesc Represents a SignedPreKeyRecordStructure.
         * @implements ISignedPreKeyRecordStructure
         * @constructor
         * @param {proto.ISignedPreKeyRecordStructure=} [properties] Properties to set
         */
        function SignedPreKeyRecordStructure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignedPreKeyRecordStructure id.
         * @member {number} id
         * @memberof proto.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.id = 0;

        /**
         * SignedPreKeyRecordStructure publicKey.
         * @member {Uint8Array} publicKey
         * @memberof proto.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.publicKey = $util.newBuffer([]);

        /**
         * SignedPreKeyRecordStructure privateKey.
         * @member {Uint8Array} privateKey
         * @memberof proto.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.privateKey = $util.newBuffer([]);

        /**
         * SignedPreKeyRecordStructure signature.
         * @member {Uint8Array} signature
         * @memberof proto.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.signature = $util.newBuffer([]);

        /**
         * SignedPreKeyRecordStructure timestamp.
         * @member {number|Long} timestamp
         * @memberof proto.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SignedPreKeyRecordStructure instance using the specified properties.
         * @function create
         * @memberof proto.SignedPreKeyRecordStructure
         * @static
         * @param {proto.ISignedPreKeyRecordStructure=} [properties] Properties to set
         * @returns {proto.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure instance
         */
        SignedPreKeyRecordStructure.create = function create(properties) {
            return new SignedPreKeyRecordStructure(properties);
        };

        /**
         * Encodes the specified SignedPreKeyRecordStructure message. Does not implicitly {@link proto.SignedPreKeyRecordStructure.verify|verify} messages.
         * @function encode
         * @memberof proto.SignedPreKeyRecordStructure
         * @static
         * @param {proto.ISignedPreKeyRecordStructure} message SignedPreKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedPreKeyRecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateKey);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified SignedPreKeyRecordStructure message, length delimited. Does not implicitly {@link proto.SignedPreKeyRecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SignedPreKeyRecordStructure
         * @static
         * @param {proto.ISignedPreKeyRecordStructure} message SignedPreKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedPreKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignedPreKeyRecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignedPreKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedPreKeyRecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignedPreKeyRecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.privateKey = reader.bytes();
                    break;
                case 4:
                    message.signature = reader.bytes();
                    break;
                case 5:
                    message.timestamp = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignedPreKeyRecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SignedPreKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedPreKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignedPreKeyRecordStructure message.
         * @function verify
         * @memberof proto.SignedPreKeyRecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignedPreKeyRecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a SignedPreKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SignedPreKeyRecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
         */
        SignedPreKeyRecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SignedPreKeyRecordStructure)
                return object;
            var message = new $root.proto.SignedPreKeyRecordStructure();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SignedPreKeyRecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SignedPreKeyRecordStructure
         * @static
         * @param {proto.SignedPreKeyRecordStructure} message SignedPreKeyRecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignedPreKeyRecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this SignedPreKeyRecordStructure to JSON.
         * @function toJSON
         * @memberof proto.SignedPreKeyRecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignedPreKeyRecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignedPreKeyRecordStructure;
    })();

    proto.StatusPSA = (function() {

        /**
         * Properties of a StatusPSA.
         * @memberof proto
         * @interface IStatusPSA
         * @property {number|Long} campaignId StatusPSA campaignId
         * @property {number|Long|null} [campaignExpirationTimestamp] StatusPSA campaignExpirationTimestamp
         */

        /**
         * Constructs a new StatusPSA.
         * @memberof proto
         * @classdesc Represents a StatusPSA.
         * @implements IStatusPSA
         * @constructor
         * @param {proto.IStatusPSA=} [properties] Properties to set
         */
        function StatusPSA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StatusPSA campaignId.
         * @member {number|Long} campaignId
         * @memberof proto.StatusPSA
         * @instance
         */
        StatusPSA.prototype.campaignId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StatusPSA campaignExpirationTimestamp.
         * @member {number|Long} campaignExpirationTimestamp
         * @memberof proto.StatusPSA
         * @instance
         */
        StatusPSA.prototype.campaignExpirationTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new StatusPSA instance using the specified properties.
         * @function create
         * @memberof proto.StatusPSA
         * @static
         * @param {proto.IStatusPSA=} [properties] Properties to set
         * @returns {proto.StatusPSA} StatusPSA instance
         */
        StatusPSA.create = function create(properties) {
            return new StatusPSA(properties);
        };

        /**
         * Encodes the specified StatusPSA message. Does not implicitly {@link proto.StatusPSA.verify|verify} messages.
         * @function encode
         * @memberof proto.StatusPSA
         * @static
         * @param {proto.IStatusPSA} message StatusPSA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusPSA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 44, wireType 0 =*/352).uint64(message.campaignId);
            if (message.campaignExpirationTimestamp != null && Object.hasOwnProperty.call(message, "campaignExpirationTimestamp"))
                writer.uint32(/* id 45, wireType 0 =*/360).uint64(message.campaignExpirationTimestamp);
            return writer;
        };

        /**
         * Encodes the specified StatusPSA message, length delimited. Does not implicitly {@link proto.StatusPSA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.StatusPSA
         * @static
         * @param {proto.IStatusPSA} message StatusPSA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusPSA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StatusPSA message from the specified reader or buffer.
         * @function decode
         * @memberof proto.StatusPSA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.StatusPSA} StatusPSA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusPSA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.StatusPSA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 44:
                    message.campaignId = reader.uint64();
                    break;
                case 45:
                    message.campaignExpirationTimestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("campaignId"))
                throw $util.ProtocolError("missing required 'campaignId'", { instance: message });
            return message;
        };

        /**
         * Decodes a StatusPSA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.StatusPSA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.StatusPSA} StatusPSA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusPSA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StatusPSA message.
         * @function verify
         * @memberof proto.StatusPSA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StatusPSA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.campaignId) && !(message.campaignId && $util.isInteger(message.campaignId.low) && $util.isInteger(message.campaignId.high)))
                return "campaignId: integer|Long expected";
            if (message.campaignExpirationTimestamp != null && message.hasOwnProperty("campaignExpirationTimestamp"))
                if (!$util.isInteger(message.campaignExpirationTimestamp) && !(message.campaignExpirationTimestamp && $util.isInteger(message.campaignExpirationTimestamp.low) && $util.isInteger(message.campaignExpirationTimestamp.high)))
                    return "campaignExpirationTimestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a StatusPSA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.StatusPSA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.StatusPSA} StatusPSA
         */
        StatusPSA.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.StatusPSA)
                return object;
            var message = new $root.proto.StatusPSA();
            if (object.campaignId != null)
                if ($util.Long)
                    (message.campaignId = $util.Long.fromValue(object.campaignId)).unsigned = true;
                else if (typeof object.campaignId === "string")
                    message.campaignId = parseInt(object.campaignId, 10);
                else if (typeof object.campaignId === "number")
                    message.campaignId = object.campaignId;
                else if (typeof object.campaignId === "object")
                    message.campaignId = new $util.LongBits(object.campaignId.low >>> 0, object.campaignId.high >>> 0).toNumber(true);
            if (object.campaignExpirationTimestamp != null)
                if ($util.Long)
                    (message.campaignExpirationTimestamp = $util.Long.fromValue(object.campaignExpirationTimestamp)).unsigned = true;
                else if (typeof object.campaignExpirationTimestamp === "string")
                    message.campaignExpirationTimestamp = parseInt(object.campaignExpirationTimestamp, 10);
                else if (typeof object.campaignExpirationTimestamp === "number")
                    message.campaignExpirationTimestamp = object.campaignExpirationTimestamp;
                else if (typeof object.campaignExpirationTimestamp === "object")
                    message.campaignExpirationTimestamp = new $util.LongBits(object.campaignExpirationTimestamp.low >>> 0, object.campaignExpirationTimestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a StatusPSA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.StatusPSA
         * @static
         * @param {proto.StatusPSA} message StatusPSA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StatusPSA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.campaignId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.campaignId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.campaignExpirationTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.campaignExpirationTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.campaignId != null && message.hasOwnProperty("campaignId"))
                if (typeof message.campaignId === "number")
                    object.campaignId = options.longs === String ? String(message.campaignId) : message.campaignId;
                else
                    object.campaignId = options.longs === String ? $util.Long.prototype.toString.call(message.campaignId) : options.longs === Number ? new $util.LongBits(message.campaignId.low >>> 0, message.campaignId.high >>> 0).toNumber(true) : message.campaignId;
            if (message.campaignExpirationTimestamp != null && message.hasOwnProperty("campaignExpirationTimestamp"))
                if (typeof message.campaignExpirationTimestamp === "number")
                    object.campaignExpirationTimestamp = options.longs === String ? String(message.campaignExpirationTimestamp) : message.campaignExpirationTimestamp;
                else
                    object.campaignExpirationTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.campaignExpirationTimestamp) : options.longs === Number ? new $util.LongBits(message.campaignExpirationTimestamp.low >>> 0, message.campaignExpirationTimestamp.high >>> 0).toNumber(true) : message.campaignExpirationTimestamp;
            return object;
        };

        /**
         * Converts this StatusPSA to JSON.
         * @function toJSON
         * @memberof proto.StatusPSA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StatusPSA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StatusPSA;
    })();

    proto.StickerMetadata = (function() {

        /**
         * Properties of a StickerMetadata.
         * @memberof proto
         * @interface IStickerMetadata
         * @property {string|null} [url] StickerMetadata url
         * @property {Uint8Array|null} [fileSha256] StickerMetadata fileSha256
         * @property {Uint8Array|null} [fileEncSha256] StickerMetadata fileEncSha256
         * @property {Uint8Array|null} [mediaKey] StickerMetadata mediaKey
         * @property {string|null} [mimetype] StickerMetadata mimetype
         * @property {number|null} [height] StickerMetadata height
         * @property {number|null} [width] StickerMetadata width
         * @property {string|null} [directPath] StickerMetadata directPath
         * @property {number|Long|null} [fileLength] StickerMetadata fileLength
         * @property {number|null} [weight] StickerMetadata weight
         * @property {number|Long|null} [lastStickerSentTs] StickerMetadata lastStickerSentTs
         */

        /**
         * Constructs a new StickerMetadata.
         * @memberof proto
         * @classdesc Represents a StickerMetadata.
         * @implements IStickerMetadata
         * @constructor
         * @param {proto.IStickerMetadata=} [properties] Properties to set
         */
        function StickerMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StickerMetadata url.
         * @member {string} url
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.url = "";

        /**
         * StickerMetadata fileSha256.
         * @member {Uint8Array} fileSha256
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.fileSha256 = $util.newBuffer([]);

        /**
         * StickerMetadata fileEncSha256.
         * @member {Uint8Array} fileEncSha256
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.fileEncSha256 = $util.newBuffer([]);

        /**
         * StickerMetadata mediaKey.
         * @member {Uint8Array} mediaKey
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.mediaKey = $util.newBuffer([]);

        /**
         * StickerMetadata mimetype.
         * @member {string} mimetype
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.mimetype = "";

        /**
         * StickerMetadata height.
         * @member {number} height
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.height = 0;

        /**
         * StickerMetadata width.
         * @member {number} width
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.width = 0;

        /**
         * StickerMetadata directPath.
         * @member {string} directPath
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.directPath = "";

        /**
         * StickerMetadata fileLength.
         * @member {number|Long} fileLength
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StickerMetadata weight.
         * @member {number} weight
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.weight = 0;

        /**
         * StickerMetadata lastStickerSentTs.
         * @member {number|Long} lastStickerSentTs
         * @memberof proto.StickerMetadata
         * @instance
         */
        StickerMetadata.prototype.lastStickerSentTs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StickerMetadata instance using the specified properties.
         * @function create
         * @memberof proto.StickerMetadata
         * @static
         * @param {proto.IStickerMetadata=} [properties] Properties to set
         * @returns {proto.StickerMetadata} StickerMetadata instance
         */
        StickerMetadata.create = function create(properties) {
            return new StickerMetadata(properties);
        };

        /**
         * Encodes the specified StickerMetadata message. Does not implicitly {@link proto.StickerMetadata.verify|verify} messages.
         * @function encode
         * @memberof proto.StickerMetadata
         * @static
         * @param {proto.IStickerMetadata} message StickerMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickerMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.fileSha256);
            if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileEncSha256);
            if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.mediaKey);
            if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.mimetype);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.height);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.width);
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.directPath);
            if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.fileLength);
            if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.weight);
            if (message.lastStickerSentTs != null && Object.hasOwnProperty.call(message, "lastStickerSentTs"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.lastStickerSentTs);
            return writer;
        };

        /**
         * Encodes the specified StickerMetadata message, length delimited. Does not implicitly {@link proto.StickerMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.StickerMetadata
         * @static
         * @param {proto.IStickerMetadata} message StickerMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickerMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StickerMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof proto.StickerMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.StickerMetadata} StickerMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickerMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.StickerMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.fileSha256 = reader.bytes();
                    break;
                case 3:
                    message.fileEncSha256 = reader.bytes();
                    break;
                case 4:
                    message.mediaKey = reader.bytes();
                    break;
                case 5:
                    message.mimetype = reader.string();
                    break;
                case 6:
                    message.height = reader.uint32();
                    break;
                case 7:
                    message.width = reader.uint32();
                    break;
                case 8:
                    message.directPath = reader.string();
                    break;
                case 9:
                    message.fileLength = reader.uint64();
                    break;
                case 10:
                    message.weight = reader.float();
                    break;
                case 11:
                    message.lastStickerSentTs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StickerMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.StickerMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.StickerMetadata} StickerMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickerMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StickerMetadata message.
         * @function verify
         * @memberof proto.StickerMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StickerMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                    return "fileSha256: buffer expected";
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                    return "fileEncSha256: buffer expected";
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                    return "mediaKey: buffer expected";
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                if (!$util.isString(message.mimetype))
                    return "mimetype: string expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                    return "fileLength: integer|Long expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (typeof message.weight !== "number")
                    return "weight: number expected";
            if (message.lastStickerSentTs != null && message.hasOwnProperty("lastStickerSentTs"))
                if (!$util.isInteger(message.lastStickerSentTs) && !(message.lastStickerSentTs && $util.isInteger(message.lastStickerSentTs.low) && $util.isInteger(message.lastStickerSentTs.high)))
                    return "lastStickerSentTs: integer|Long expected";
            return null;
        };

        /**
         * Creates a StickerMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.StickerMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.StickerMetadata} StickerMetadata
         */
        StickerMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.StickerMetadata)
                return object;
            var message = new $root.proto.StickerMetadata();
            if (object.url != null)
                message.url = String(object.url);
            if (object.fileSha256 != null)
                if (typeof object.fileSha256 === "string")
                    $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                else if (object.fileSha256.length)
                    message.fileSha256 = object.fileSha256;
            if (object.fileEncSha256 != null)
                if (typeof object.fileEncSha256 === "string")
                    $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                else if (object.fileEncSha256.length)
                    message.fileEncSha256 = object.fileEncSha256;
            if (object.mediaKey != null)
                if (typeof object.mediaKey === "string")
                    $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                else if (object.mediaKey.length)
                    message.mediaKey = object.mediaKey;
            if (object.mimetype != null)
                message.mimetype = String(object.mimetype);
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            if (object.fileLength != null)
                if ($util.Long)
                    (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                else if (typeof object.fileLength === "string")
                    message.fileLength = parseInt(object.fileLength, 10);
                else if (typeof object.fileLength === "number")
                    message.fileLength = object.fileLength;
                else if (typeof object.fileLength === "object")
                    message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
            if (object.weight != null)
                message.weight = Number(object.weight);
            if (object.lastStickerSentTs != null)
                if ($util.Long)
                    (message.lastStickerSentTs = $util.Long.fromValue(object.lastStickerSentTs)).unsigned = false;
                else if (typeof object.lastStickerSentTs === "string")
                    message.lastStickerSentTs = parseInt(object.lastStickerSentTs, 10);
                else if (typeof object.lastStickerSentTs === "number")
                    message.lastStickerSentTs = object.lastStickerSentTs;
                else if (typeof object.lastStickerSentTs === "object")
                    message.lastStickerSentTs = new $util.LongBits(object.lastStickerSentTs.low >>> 0, object.lastStickerSentTs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a StickerMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.StickerMetadata
         * @static
         * @param {proto.StickerMetadata} message StickerMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StickerMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.url = "";
                if (options.bytes === String)
                    object.fileSha256 = "";
                else {
                    object.fileSha256 = [];
                    if (options.bytes !== Array)
                        object.fileSha256 = $util.newBuffer(object.fileSha256);
                }
                if (options.bytes === String)
                    object.fileEncSha256 = "";
                else {
                    object.fileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                }
                if (options.bytes === String)
                    object.mediaKey = "";
                else {
                    object.mediaKey = [];
                    if (options.bytes !== Array)
                        object.mediaKey = $util.newBuffer(object.mediaKey);
                }
                object.mimetype = "";
                object.height = 0;
                object.width = 0;
                object.directPath = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileLength = options.longs === String ? "0" : 0;
                object.weight = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastStickerSentTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastStickerSentTs = options.longs === String ? "0" : 0;
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                object.mimetype = message.mimetype;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (typeof message.fileLength === "number")
                    object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                else
                    object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
            if (message.lastStickerSentTs != null && message.hasOwnProperty("lastStickerSentTs"))
                if (typeof message.lastStickerSentTs === "number")
                    object.lastStickerSentTs = options.longs === String ? String(message.lastStickerSentTs) : message.lastStickerSentTs;
                else
                    object.lastStickerSentTs = options.longs === String ? $util.Long.prototype.toString.call(message.lastStickerSentTs) : options.longs === Number ? new $util.LongBits(message.lastStickerSentTs.low >>> 0, message.lastStickerSentTs.high >>> 0).toNumber() : message.lastStickerSentTs;
            return object;
        };

        /**
         * Converts this StickerMetadata to JSON.
         * @function toJSON
         * @memberof proto.StickerMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StickerMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StickerMetadata;
    })();

    proto.SyncActionData = (function() {

        /**
         * Properties of a SyncActionData.
         * @memberof proto
         * @interface ISyncActionData
         * @property {Uint8Array|null} [index] SyncActionData index
         * @property {proto.ISyncActionValue|null} [value] SyncActionData value
         * @property {Uint8Array|null} [padding] SyncActionData padding
         * @property {number|null} [version] SyncActionData version
         */

        /**
         * Constructs a new SyncActionData.
         * @memberof proto
         * @classdesc Represents a SyncActionData.
         * @implements ISyncActionData
         * @constructor
         * @param {proto.ISyncActionData=} [properties] Properties to set
         */
        function SyncActionData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncActionData index.
         * @member {Uint8Array} index
         * @memberof proto.SyncActionData
         * @instance
         */
        SyncActionData.prototype.index = $util.newBuffer([]);

        /**
         * SyncActionData value.
         * @member {proto.ISyncActionValue|null|undefined} value
         * @memberof proto.SyncActionData
         * @instance
         */
        SyncActionData.prototype.value = null;

        /**
         * SyncActionData padding.
         * @member {Uint8Array} padding
         * @memberof proto.SyncActionData
         * @instance
         */
        SyncActionData.prototype.padding = $util.newBuffer([]);

        /**
         * SyncActionData version.
         * @member {number} version
         * @memberof proto.SyncActionData
         * @instance
         */
        SyncActionData.prototype.version = 0;

        /**
         * Creates a new SyncActionData instance using the specified properties.
         * @function create
         * @memberof proto.SyncActionData
         * @static
         * @param {proto.ISyncActionData=} [properties] Properties to set
         * @returns {proto.SyncActionData} SyncActionData instance
         */
        SyncActionData.create = function create(properties) {
            return new SyncActionData(properties);
        };

        /**
         * Encodes the specified SyncActionData message. Does not implicitly {@link proto.SyncActionData.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncActionData
         * @static
         * @param {proto.ISyncActionData} message SyncActionData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncActionData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.index);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                $root.proto.SyncActionValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.padding);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.version);
            return writer;
        };

        /**
         * Encodes the specified SyncActionData message, length delimited. Does not implicitly {@link proto.SyncActionData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncActionData
         * @static
         * @param {proto.ISyncActionData} message SyncActionData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncActionData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncActionData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncActionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncActionData} SyncActionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncActionData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.bytes();
                    break;
                case 2:
                    message.value = $root.proto.SyncActionValue.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.padding = reader.bytes();
                    break;
                case 4:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncActionData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncActionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncActionData} SyncActionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncActionData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncActionData message.
         * @function verify
         * @memberof proto.SyncActionData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncActionData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!(message.index && typeof message.index.length === "number" || $util.isString(message.index)))
                    return "index: buffer expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                var error = $root.proto.SyncActionValue.verify(message.value);
                if (error)
                    return "value." + error;
            }
            if (message.padding != null && message.hasOwnProperty("padding"))
                if (!(message.padding && typeof message.padding.length === "number" || $util.isString(message.padding)))
                    return "padding: buffer expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates a SyncActionData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncActionData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncActionData} SyncActionData
         */
        SyncActionData.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncActionData)
                return object;
            var message = new $root.proto.SyncActionData();
            if (object.index != null)
                if (typeof object.index === "string")
                    $util.base64.decode(object.index, message.index = $util.newBuffer($util.base64.length(object.index)), 0);
                else if (object.index.length)
                    message.index = object.index;
            if (object.value != null) {
                if (typeof object.value !== "object")
                    throw TypeError(".proto.SyncActionData.value: object expected");
                message.value = $root.proto.SyncActionValue.fromObject(object.value);
            }
            if (object.padding != null)
                if (typeof object.padding === "string")
                    $util.base64.decode(object.padding, message.padding = $util.newBuffer($util.base64.length(object.padding)), 0);
                else if (object.padding.length)
                    message.padding = object.padding;
            if (object.version != null)
                message.version = object.version | 0;
            return message;
        };

        /**
         * Creates a plain object from a SyncActionData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncActionData
         * @static
         * @param {proto.SyncActionData} message SyncActionData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncActionData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.index = "";
                else {
                    object.index = [];
                    if (options.bytes !== Array)
                        object.index = $util.newBuffer(object.index);
                }
                object.value = null;
                if (options.bytes === String)
                    object.padding = "";
                else {
                    object.padding = [];
                    if (options.bytes !== Array)
                        object.padding = $util.newBuffer(object.padding);
                }
                object.version = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = options.bytes === String ? $util.base64.encode(message.index, 0, message.index.length) : options.bytes === Array ? Array.prototype.slice.call(message.index) : message.index;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = $root.proto.SyncActionValue.toObject(message.value, options);
            if (message.padding != null && message.hasOwnProperty("padding"))
                object.padding = options.bytes === String ? $util.base64.encode(message.padding, 0, message.padding.length) : options.bytes === Array ? Array.prototype.slice.call(message.padding) : message.padding;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this SyncActionData to JSON.
         * @function toJSON
         * @memberof proto.SyncActionData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncActionData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncActionData;
    })();

    proto.SyncActionValue = (function() {

        /**
         * Properties of a SyncActionValue.
         * @memberof proto
         * @interface ISyncActionValue
         * @property {number|Long|null} [timestamp] SyncActionValue timestamp
         * @property {proto.SyncActionValue.IStarAction|null} [starAction] SyncActionValue starAction
         * @property {proto.SyncActionValue.IContactAction|null} [contactAction] SyncActionValue contactAction
         * @property {proto.SyncActionValue.IMuteAction|null} [muteAction] SyncActionValue muteAction
         * @property {proto.SyncActionValue.IPinAction|null} [pinAction] SyncActionValue pinAction
         * @property {proto.SyncActionValue.ISecurityNotificationSetting|null} [securityNotificationSetting] SyncActionValue securityNotificationSetting
         * @property {proto.SyncActionValue.IPushNameSetting|null} [pushNameSetting] SyncActionValue pushNameSetting
         * @property {proto.SyncActionValue.IQuickReplyAction|null} [quickReplyAction] SyncActionValue quickReplyAction
         * @property {proto.SyncActionValue.IRecentEmojiWeightsAction|null} [recentEmojiWeightsAction] SyncActionValue recentEmojiWeightsAction
         * @property {proto.SyncActionValue.ILabelEditAction|null} [labelEditAction] SyncActionValue labelEditAction
         * @property {proto.SyncActionValue.ILabelAssociationAction|null} [labelAssociationAction] SyncActionValue labelAssociationAction
         * @property {proto.SyncActionValue.ILocaleSetting|null} [localeSetting] SyncActionValue localeSetting
         * @property {proto.SyncActionValue.IArchiveChatAction|null} [archiveChatAction] SyncActionValue archiveChatAction
         * @property {proto.SyncActionValue.IDeleteMessageForMeAction|null} [deleteMessageForMeAction] SyncActionValue deleteMessageForMeAction
         * @property {proto.SyncActionValue.IKeyExpiration|null} [keyExpiration] SyncActionValue keyExpiration
         * @property {proto.SyncActionValue.IMarkChatAsReadAction|null} [markChatAsReadAction] SyncActionValue markChatAsReadAction
         * @property {proto.SyncActionValue.IClearChatAction|null} [clearChatAction] SyncActionValue clearChatAction
         * @property {proto.SyncActionValue.IDeleteChatAction|null} [deleteChatAction] SyncActionValue deleteChatAction
         * @property {proto.SyncActionValue.IUnarchiveChatsSetting|null} [unarchiveChatsSetting] SyncActionValue unarchiveChatsSetting
         * @property {proto.SyncActionValue.IPrimaryFeature|null} [primaryFeature] SyncActionValue primaryFeature
         * @property {proto.SyncActionValue.IAndroidUnsupportedActions|null} [androidUnsupportedActions] SyncActionValue androidUnsupportedActions
         * @property {proto.SyncActionValue.IAgentAction|null} [agentAction] SyncActionValue agentAction
         * @property {proto.SyncActionValue.ISubscriptionAction|null} [subscriptionAction] SyncActionValue subscriptionAction
         * @property {proto.SyncActionValue.IUserStatusMuteAction|null} [userStatusMuteAction] SyncActionValue userStatusMuteAction
         * @property {proto.SyncActionValue.ITimeFormatAction|null} [timeFormatAction] SyncActionValue timeFormatAction
         * @property {proto.SyncActionValue.INuxAction|null} [nuxAction] SyncActionValue nuxAction
         * @property {proto.SyncActionValue.IPrimaryVersionAction|null} [primaryVersionAction] SyncActionValue primaryVersionAction
         * @property {proto.SyncActionValue.IStickerAction|null} [stickerAction] SyncActionValue stickerAction
         * @property {proto.SyncActionValue.IRemoveRecentStickerAction|null} [removeRecentStickerAction] SyncActionValue removeRecentStickerAction
         * @property {proto.SyncActionValue.IChatAssignmentAction|null} [chatAssignment] SyncActionValue chatAssignment
         * @property {proto.SyncActionValue.IChatAssignmentOpenedStatusAction|null} [chatAssignmentOpenedStatus] SyncActionValue chatAssignmentOpenedStatus
         */

        /**
         * Constructs a new SyncActionValue.
         * @memberof proto
         * @classdesc Represents a SyncActionValue.
         * @implements ISyncActionValue
         * @constructor
         * @param {proto.ISyncActionValue=} [properties] Properties to set
         */
        function SyncActionValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncActionValue timestamp.
         * @member {number|Long} timestamp
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncActionValue starAction.
         * @member {proto.SyncActionValue.IStarAction|null|undefined} starAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.starAction = null;

        /**
         * SyncActionValue contactAction.
         * @member {proto.SyncActionValue.IContactAction|null|undefined} contactAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.contactAction = null;

        /**
         * SyncActionValue muteAction.
         * @member {proto.SyncActionValue.IMuteAction|null|undefined} muteAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.muteAction = null;

        /**
         * SyncActionValue pinAction.
         * @member {proto.SyncActionValue.IPinAction|null|undefined} pinAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.pinAction = null;

        /**
         * SyncActionValue securityNotificationSetting.
         * @member {proto.SyncActionValue.ISecurityNotificationSetting|null|undefined} securityNotificationSetting
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.securityNotificationSetting = null;

        /**
         * SyncActionValue pushNameSetting.
         * @member {proto.SyncActionValue.IPushNameSetting|null|undefined} pushNameSetting
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.pushNameSetting = null;

        /**
         * SyncActionValue quickReplyAction.
         * @member {proto.SyncActionValue.IQuickReplyAction|null|undefined} quickReplyAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.quickReplyAction = null;

        /**
         * SyncActionValue recentEmojiWeightsAction.
         * @member {proto.SyncActionValue.IRecentEmojiWeightsAction|null|undefined} recentEmojiWeightsAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.recentEmojiWeightsAction = null;

        /**
         * SyncActionValue labelEditAction.
         * @member {proto.SyncActionValue.ILabelEditAction|null|undefined} labelEditAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.labelEditAction = null;

        /**
         * SyncActionValue labelAssociationAction.
         * @member {proto.SyncActionValue.ILabelAssociationAction|null|undefined} labelAssociationAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.labelAssociationAction = null;

        /**
         * SyncActionValue localeSetting.
         * @member {proto.SyncActionValue.ILocaleSetting|null|undefined} localeSetting
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.localeSetting = null;

        /**
         * SyncActionValue archiveChatAction.
         * @member {proto.SyncActionValue.IArchiveChatAction|null|undefined} archiveChatAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.archiveChatAction = null;

        /**
         * SyncActionValue deleteMessageForMeAction.
         * @member {proto.SyncActionValue.IDeleteMessageForMeAction|null|undefined} deleteMessageForMeAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.deleteMessageForMeAction = null;

        /**
         * SyncActionValue keyExpiration.
         * @member {proto.SyncActionValue.IKeyExpiration|null|undefined} keyExpiration
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.keyExpiration = null;

        /**
         * SyncActionValue markChatAsReadAction.
         * @member {proto.SyncActionValue.IMarkChatAsReadAction|null|undefined} markChatAsReadAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.markChatAsReadAction = null;

        /**
         * SyncActionValue clearChatAction.
         * @member {proto.SyncActionValue.IClearChatAction|null|undefined} clearChatAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.clearChatAction = null;

        /**
         * SyncActionValue deleteChatAction.
         * @member {proto.SyncActionValue.IDeleteChatAction|null|undefined} deleteChatAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.deleteChatAction = null;

        /**
         * SyncActionValue unarchiveChatsSetting.
         * @member {proto.SyncActionValue.IUnarchiveChatsSetting|null|undefined} unarchiveChatsSetting
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.unarchiveChatsSetting = null;

        /**
         * SyncActionValue primaryFeature.
         * @member {proto.SyncActionValue.IPrimaryFeature|null|undefined} primaryFeature
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.primaryFeature = null;

        /**
         * SyncActionValue androidUnsupportedActions.
         * @member {proto.SyncActionValue.IAndroidUnsupportedActions|null|undefined} androidUnsupportedActions
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.androidUnsupportedActions = null;

        /**
         * SyncActionValue agentAction.
         * @member {proto.SyncActionValue.IAgentAction|null|undefined} agentAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.agentAction = null;

        /**
         * SyncActionValue subscriptionAction.
         * @member {proto.SyncActionValue.ISubscriptionAction|null|undefined} subscriptionAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.subscriptionAction = null;

        /**
         * SyncActionValue userStatusMuteAction.
         * @member {proto.SyncActionValue.IUserStatusMuteAction|null|undefined} userStatusMuteAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.userStatusMuteAction = null;

        /**
         * SyncActionValue timeFormatAction.
         * @member {proto.SyncActionValue.ITimeFormatAction|null|undefined} timeFormatAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.timeFormatAction = null;

        /**
         * SyncActionValue nuxAction.
         * @member {proto.SyncActionValue.INuxAction|null|undefined} nuxAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.nuxAction = null;

        /**
         * SyncActionValue primaryVersionAction.
         * @member {proto.SyncActionValue.IPrimaryVersionAction|null|undefined} primaryVersionAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.primaryVersionAction = null;

        /**
         * SyncActionValue stickerAction.
         * @member {proto.SyncActionValue.IStickerAction|null|undefined} stickerAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.stickerAction = null;

        /**
         * SyncActionValue removeRecentStickerAction.
         * @member {proto.SyncActionValue.IRemoveRecentStickerAction|null|undefined} removeRecentStickerAction
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.removeRecentStickerAction = null;

        /**
         * SyncActionValue chatAssignment.
         * @member {proto.SyncActionValue.IChatAssignmentAction|null|undefined} chatAssignment
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.chatAssignment = null;

        /**
         * SyncActionValue chatAssignmentOpenedStatus.
         * @member {proto.SyncActionValue.IChatAssignmentOpenedStatusAction|null|undefined} chatAssignmentOpenedStatus
         * @memberof proto.SyncActionValue
         * @instance
         */
        SyncActionValue.prototype.chatAssignmentOpenedStatus = null;

        /**
         * Creates a new SyncActionValue instance using the specified properties.
         * @function create
         * @memberof proto.SyncActionValue
         * @static
         * @param {proto.ISyncActionValue=} [properties] Properties to set
         * @returns {proto.SyncActionValue} SyncActionValue instance
         */
        SyncActionValue.create = function create(properties) {
            return new SyncActionValue(properties);
        };

        /**
         * Encodes the specified SyncActionValue message. Does not implicitly {@link proto.SyncActionValue.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncActionValue
         * @static
         * @param {proto.ISyncActionValue} message SyncActionValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncActionValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            if (message.starAction != null && Object.hasOwnProperty.call(message, "starAction"))
                $root.proto.SyncActionValue.StarAction.encode(message.starAction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.contactAction != null && Object.hasOwnProperty.call(message, "contactAction"))
                $root.proto.SyncActionValue.ContactAction.encode(message.contactAction, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.muteAction != null && Object.hasOwnProperty.call(message, "muteAction"))
                $root.proto.SyncActionValue.MuteAction.encode(message.muteAction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.pinAction != null && Object.hasOwnProperty.call(message, "pinAction"))
                $root.proto.SyncActionValue.PinAction.encode(message.pinAction, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.securityNotificationSetting != null && Object.hasOwnProperty.call(message, "securityNotificationSetting"))
                $root.proto.SyncActionValue.SecurityNotificationSetting.encode(message.securityNotificationSetting, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.pushNameSetting != null && Object.hasOwnProperty.call(message, "pushNameSetting"))
                $root.proto.SyncActionValue.PushNameSetting.encode(message.pushNameSetting, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.quickReplyAction != null && Object.hasOwnProperty.call(message, "quickReplyAction"))
                $root.proto.SyncActionValue.QuickReplyAction.encode(message.quickReplyAction, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.recentEmojiWeightsAction != null && Object.hasOwnProperty.call(message, "recentEmojiWeightsAction"))
                $root.proto.SyncActionValue.RecentEmojiWeightsAction.encode(message.recentEmojiWeightsAction, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.labelEditAction != null && Object.hasOwnProperty.call(message, "labelEditAction"))
                $root.proto.SyncActionValue.LabelEditAction.encode(message.labelEditAction, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.labelAssociationAction != null && Object.hasOwnProperty.call(message, "labelAssociationAction"))
                $root.proto.SyncActionValue.LabelAssociationAction.encode(message.labelAssociationAction, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.localeSetting != null && Object.hasOwnProperty.call(message, "localeSetting"))
                $root.proto.SyncActionValue.LocaleSetting.encode(message.localeSetting, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.archiveChatAction != null && Object.hasOwnProperty.call(message, "archiveChatAction"))
                $root.proto.SyncActionValue.ArchiveChatAction.encode(message.archiveChatAction, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.deleteMessageForMeAction != null && Object.hasOwnProperty.call(message, "deleteMessageForMeAction"))
                $root.proto.SyncActionValue.DeleteMessageForMeAction.encode(message.deleteMessageForMeAction, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.keyExpiration != null && Object.hasOwnProperty.call(message, "keyExpiration"))
                $root.proto.SyncActionValue.KeyExpiration.encode(message.keyExpiration, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.markChatAsReadAction != null && Object.hasOwnProperty.call(message, "markChatAsReadAction"))
                $root.proto.SyncActionValue.MarkChatAsReadAction.encode(message.markChatAsReadAction, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.clearChatAction != null && Object.hasOwnProperty.call(message, "clearChatAction"))
                $root.proto.SyncActionValue.ClearChatAction.encode(message.clearChatAction, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.deleteChatAction != null && Object.hasOwnProperty.call(message, "deleteChatAction"))
                $root.proto.SyncActionValue.DeleteChatAction.encode(message.deleteChatAction, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.unarchiveChatsSetting != null && Object.hasOwnProperty.call(message, "unarchiveChatsSetting"))
                $root.proto.SyncActionValue.UnarchiveChatsSetting.encode(message.unarchiveChatsSetting, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.primaryFeature != null && Object.hasOwnProperty.call(message, "primaryFeature"))
                $root.proto.SyncActionValue.PrimaryFeature.encode(message.primaryFeature, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.androidUnsupportedActions != null && Object.hasOwnProperty.call(message, "androidUnsupportedActions"))
                $root.proto.SyncActionValue.AndroidUnsupportedActions.encode(message.androidUnsupportedActions, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.agentAction != null && Object.hasOwnProperty.call(message, "agentAction"))
                $root.proto.SyncActionValue.AgentAction.encode(message.agentAction, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.subscriptionAction != null && Object.hasOwnProperty.call(message, "subscriptionAction"))
                $root.proto.SyncActionValue.SubscriptionAction.encode(message.subscriptionAction, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.userStatusMuteAction != null && Object.hasOwnProperty.call(message, "userStatusMuteAction"))
                $root.proto.SyncActionValue.UserStatusMuteAction.encode(message.userStatusMuteAction, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.timeFormatAction != null && Object.hasOwnProperty.call(message, "timeFormatAction"))
                $root.proto.SyncActionValue.TimeFormatAction.encode(message.timeFormatAction, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.nuxAction != null && Object.hasOwnProperty.call(message, "nuxAction"))
                $root.proto.SyncActionValue.NuxAction.encode(message.nuxAction, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.primaryVersionAction != null && Object.hasOwnProperty.call(message, "primaryVersionAction"))
                $root.proto.SyncActionValue.PrimaryVersionAction.encode(message.primaryVersionAction, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.stickerAction != null && Object.hasOwnProperty.call(message, "stickerAction"))
                $root.proto.SyncActionValue.StickerAction.encode(message.stickerAction, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.removeRecentStickerAction != null && Object.hasOwnProperty.call(message, "removeRecentStickerAction"))
                $root.proto.SyncActionValue.RemoveRecentStickerAction.encode(message.removeRecentStickerAction, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            if (message.chatAssignment != null && Object.hasOwnProperty.call(message, "chatAssignment"))
                $root.proto.SyncActionValue.ChatAssignmentAction.encode(message.chatAssignment, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.chatAssignmentOpenedStatus != null && Object.hasOwnProperty.call(message, "chatAssignmentOpenedStatus"))
                $root.proto.SyncActionValue.ChatAssignmentOpenedStatusAction.encode(message.chatAssignmentOpenedStatus, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncActionValue message, length delimited. Does not implicitly {@link proto.SyncActionValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncActionValue
         * @static
         * @param {proto.ISyncActionValue} message SyncActionValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncActionValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncActionValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncActionValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncActionValue} SyncActionValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncActionValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                case 2:
                    message.starAction = $root.proto.SyncActionValue.StarAction.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.contactAction = $root.proto.SyncActionValue.ContactAction.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.muteAction = $root.proto.SyncActionValue.MuteAction.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.pinAction = $root.proto.SyncActionValue.PinAction.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.securityNotificationSetting = $root.proto.SyncActionValue.SecurityNotificationSetting.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.pushNameSetting = $root.proto.SyncActionValue.PushNameSetting.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.quickReplyAction = $root.proto.SyncActionValue.QuickReplyAction.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.recentEmojiWeightsAction = $root.proto.SyncActionValue.RecentEmojiWeightsAction.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.labelEditAction = $root.proto.SyncActionValue.LabelEditAction.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.labelAssociationAction = $root.proto.SyncActionValue.LabelAssociationAction.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.localeSetting = $root.proto.SyncActionValue.LocaleSetting.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.archiveChatAction = $root.proto.SyncActionValue.ArchiveChatAction.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.deleteMessageForMeAction = $root.proto.SyncActionValue.DeleteMessageForMeAction.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.keyExpiration = $root.proto.SyncActionValue.KeyExpiration.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.markChatAsReadAction = $root.proto.SyncActionValue.MarkChatAsReadAction.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.clearChatAction = $root.proto.SyncActionValue.ClearChatAction.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.deleteChatAction = $root.proto.SyncActionValue.DeleteChatAction.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.unarchiveChatsSetting = $root.proto.SyncActionValue.UnarchiveChatsSetting.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.primaryFeature = $root.proto.SyncActionValue.PrimaryFeature.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.androidUnsupportedActions = $root.proto.SyncActionValue.AndroidUnsupportedActions.decode(reader, reader.uint32());
                    break;
                case 27:
                    message.agentAction = $root.proto.SyncActionValue.AgentAction.decode(reader, reader.uint32());
                    break;
                case 28:
                    message.subscriptionAction = $root.proto.SyncActionValue.SubscriptionAction.decode(reader, reader.uint32());
                    break;
                case 29:
                    message.userStatusMuteAction = $root.proto.SyncActionValue.UserStatusMuteAction.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.timeFormatAction = $root.proto.SyncActionValue.TimeFormatAction.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.nuxAction = $root.proto.SyncActionValue.NuxAction.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.primaryVersionAction = $root.proto.SyncActionValue.PrimaryVersionAction.decode(reader, reader.uint32());
                    break;
                case 33:
                    message.stickerAction = $root.proto.SyncActionValue.StickerAction.decode(reader, reader.uint32());
                    break;
                case 34:
                    message.removeRecentStickerAction = $root.proto.SyncActionValue.RemoveRecentStickerAction.decode(reader, reader.uint32());
                    break;
                case 35:
                    message.chatAssignment = $root.proto.SyncActionValue.ChatAssignmentAction.decode(reader, reader.uint32());
                    break;
                case 36:
                    message.chatAssignmentOpenedStatus = $root.proto.SyncActionValue.ChatAssignmentOpenedStatusAction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncActionValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncActionValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncActionValue} SyncActionValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncActionValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncActionValue message.
         * @function verify
         * @memberof proto.SyncActionValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncActionValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.starAction != null && message.hasOwnProperty("starAction")) {
                var error = $root.proto.SyncActionValue.StarAction.verify(message.starAction);
                if (error)
                    return "starAction." + error;
            }
            if (message.contactAction != null && message.hasOwnProperty("contactAction")) {
                var error = $root.proto.SyncActionValue.ContactAction.verify(message.contactAction);
                if (error)
                    return "contactAction." + error;
            }
            if (message.muteAction != null && message.hasOwnProperty("muteAction")) {
                var error = $root.proto.SyncActionValue.MuteAction.verify(message.muteAction);
                if (error)
                    return "muteAction." + error;
            }
            if (message.pinAction != null && message.hasOwnProperty("pinAction")) {
                var error = $root.proto.SyncActionValue.PinAction.verify(message.pinAction);
                if (error)
                    return "pinAction." + error;
            }
            if (message.securityNotificationSetting != null && message.hasOwnProperty("securityNotificationSetting")) {
                var error = $root.proto.SyncActionValue.SecurityNotificationSetting.verify(message.securityNotificationSetting);
                if (error)
                    return "securityNotificationSetting." + error;
            }
            if (message.pushNameSetting != null && message.hasOwnProperty("pushNameSetting")) {
                var error = $root.proto.SyncActionValue.PushNameSetting.verify(message.pushNameSetting);
                if (error)
                    return "pushNameSetting." + error;
            }
            if (message.quickReplyAction != null && message.hasOwnProperty("quickReplyAction")) {
                var error = $root.proto.SyncActionValue.QuickReplyAction.verify(message.quickReplyAction);
                if (error)
                    return "quickReplyAction." + error;
            }
            if (message.recentEmojiWeightsAction != null && message.hasOwnProperty("recentEmojiWeightsAction")) {
                var error = $root.proto.SyncActionValue.RecentEmojiWeightsAction.verify(message.recentEmojiWeightsAction);
                if (error)
                    return "recentEmojiWeightsAction." + error;
            }
            if (message.labelEditAction != null && message.hasOwnProperty("labelEditAction")) {
                var error = $root.proto.SyncActionValue.LabelEditAction.verify(message.labelEditAction);
                if (error)
                    return "labelEditAction." + error;
            }
            if (message.labelAssociationAction != null && message.hasOwnProperty("labelAssociationAction")) {
                var error = $root.proto.SyncActionValue.LabelAssociationAction.verify(message.labelAssociationAction);
                if (error)
                    return "labelAssociationAction." + error;
            }
            if (message.localeSetting != null && message.hasOwnProperty("localeSetting")) {
                var error = $root.proto.SyncActionValue.LocaleSetting.verify(message.localeSetting);
                if (error)
                    return "localeSetting." + error;
            }
            if (message.archiveChatAction != null && message.hasOwnProperty("archiveChatAction")) {
                var error = $root.proto.SyncActionValue.ArchiveChatAction.verify(message.archiveChatAction);
                if (error)
                    return "archiveChatAction." + error;
            }
            if (message.deleteMessageForMeAction != null && message.hasOwnProperty("deleteMessageForMeAction")) {
                var error = $root.proto.SyncActionValue.DeleteMessageForMeAction.verify(message.deleteMessageForMeAction);
                if (error)
                    return "deleteMessageForMeAction." + error;
            }
            if (message.keyExpiration != null && message.hasOwnProperty("keyExpiration")) {
                var error = $root.proto.SyncActionValue.KeyExpiration.verify(message.keyExpiration);
                if (error)
                    return "keyExpiration." + error;
            }
            if (message.markChatAsReadAction != null && message.hasOwnProperty("markChatAsReadAction")) {
                var error = $root.proto.SyncActionValue.MarkChatAsReadAction.verify(message.markChatAsReadAction);
                if (error)
                    return "markChatAsReadAction." + error;
            }
            if (message.clearChatAction != null && message.hasOwnProperty("clearChatAction")) {
                var error = $root.proto.SyncActionValue.ClearChatAction.verify(message.clearChatAction);
                if (error)
                    return "clearChatAction." + error;
            }
            if (message.deleteChatAction != null && message.hasOwnProperty("deleteChatAction")) {
                var error = $root.proto.SyncActionValue.DeleteChatAction.verify(message.deleteChatAction);
                if (error)
                    return "deleteChatAction." + error;
            }
            if (message.unarchiveChatsSetting != null && message.hasOwnProperty("unarchiveChatsSetting")) {
                var error = $root.proto.SyncActionValue.UnarchiveChatsSetting.verify(message.unarchiveChatsSetting);
                if (error)
                    return "unarchiveChatsSetting." + error;
            }
            if (message.primaryFeature != null && message.hasOwnProperty("primaryFeature")) {
                var error = $root.proto.SyncActionValue.PrimaryFeature.verify(message.primaryFeature);
                if (error)
                    return "primaryFeature." + error;
            }
            if (message.androidUnsupportedActions != null && message.hasOwnProperty("androidUnsupportedActions")) {
                var error = $root.proto.SyncActionValue.AndroidUnsupportedActions.verify(message.androidUnsupportedActions);
                if (error)
                    return "androidUnsupportedActions." + error;
            }
            if (message.agentAction != null && message.hasOwnProperty("agentAction")) {
                var error = $root.proto.SyncActionValue.AgentAction.verify(message.agentAction);
                if (error)
                    return "agentAction." + error;
            }
            if (message.subscriptionAction != null && message.hasOwnProperty("subscriptionAction")) {
                var error = $root.proto.SyncActionValue.SubscriptionAction.verify(message.subscriptionAction);
                if (error)
                    return "subscriptionAction." + error;
            }
            if (message.userStatusMuteAction != null && message.hasOwnProperty("userStatusMuteAction")) {
                var error = $root.proto.SyncActionValue.UserStatusMuteAction.verify(message.userStatusMuteAction);
                if (error)
                    return "userStatusMuteAction." + error;
            }
            if (message.timeFormatAction != null && message.hasOwnProperty("timeFormatAction")) {
                var error = $root.proto.SyncActionValue.TimeFormatAction.verify(message.timeFormatAction);
                if (error)
                    return "timeFormatAction." + error;
            }
            if (message.nuxAction != null && message.hasOwnProperty("nuxAction")) {
                var error = $root.proto.SyncActionValue.NuxAction.verify(message.nuxAction);
                if (error)
                    return "nuxAction." + error;
            }
            if (message.primaryVersionAction != null && message.hasOwnProperty("primaryVersionAction")) {
                var error = $root.proto.SyncActionValue.PrimaryVersionAction.verify(message.primaryVersionAction);
                if (error)
                    return "primaryVersionAction." + error;
            }
            if (message.stickerAction != null && message.hasOwnProperty("stickerAction")) {
                var error = $root.proto.SyncActionValue.StickerAction.verify(message.stickerAction);
                if (error)
                    return "stickerAction." + error;
            }
            if (message.removeRecentStickerAction != null && message.hasOwnProperty("removeRecentStickerAction")) {
                var error = $root.proto.SyncActionValue.RemoveRecentStickerAction.verify(message.removeRecentStickerAction);
                if (error)
                    return "removeRecentStickerAction." + error;
            }
            if (message.chatAssignment != null && message.hasOwnProperty("chatAssignment")) {
                var error = $root.proto.SyncActionValue.ChatAssignmentAction.verify(message.chatAssignment);
                if (error)
                    return "chatAssignment." + error;
            }
            if (message.chatAssignmentOpenedStatus != null && message.hasOwnProperty("chatAssignmentOpenedStatus")) {
                var error = $root.proto.SyncActionValue.ChatAssignmentOpenedStatusAction.verify(message.chatAssignmentOpenedStatus);
                if (error)
                    return "chatAssignmentOpenedStatus." + error;
            }
            return null;
        };

        /**
         * Creates a SyncActionValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncActionValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncActionValue} SyncActionValue
         */
        SyncActionValue.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncActionValue)
                return object;
            var message = new $root.proto.SyncActionValue();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.starAction != null) {
                if (typeof object.starAction !== "object")
                    throw TypeError(".proto.SyncActionValue.starAction: object expected");
                message.starAction = $root.proto.SyncActionValue.StarAction.fromObject(object.starAction);
            }
            if (object.contactAction != null) {
                if (typeof object.contactAction !== "object")
                    throw TypeError(".proto.SyncActionValue.contactAction: object expected");
                message.contactAction = $root.proto.SyncActionValue.ContactAction.fromObject(object.contactAction);
            }
            if (object.muteAction != null) {
                if (typeof object.muteAction !== "object")
                    throw TypeError(".proto.SyncActionValue.muteAction: object expected");
                message.muteAction = $root.proto.SyncActionValue.MuteAction.fromObject(object.muteAction);
            }
            if (object.pinAction != null) {
                if (typeof object.pinAction !== "object")
                    throw TypeError(".proto.SyncActionValue.pinAction: object expected");
                message.pinAction = $root.proto.SyncActionValue.PinAction.fromObject(object.pinAction);
            }
            if (object.securityNotificationSetting != null) {
                if (typeof object.securityNotificationSetting !== "object")
                    throw TypeError(".proto.SyncActionValue.securityNotificationSetting: object expected");
                message.securityNotificationSetting = $root.proto.SyncActionValue.SecurityNotificationSetting.fromObject(object.securityNotificationSetting);
            }
            if (object.pushNameSetting != null) {
                if (typeof object.pushNameSetting !== "object")
                    throw TypeError(".proto.SyncActionValue.pushNameSetting: object expected");
                message.pushNameSetting = $root.proto.SyncActionValue.PushNameSetting.fromObject(object.pushNameSetting);
            }
            if (object.quickReplyAction != null) {
                if (typeof object.quickReplyAction !== "object")
                    throw TypeError(".proto.SyncActionValue.quickReplyAction: object expected");
                message.quickReplyAction = $root.proto.SyncActionValue.QuickReplyAction.fromObject(object.quickReplyAction);
            }
            if (object.recentEmojiWeightsAction != null) {
                if (typeof object.recentEmojiWeightsAction !== "object")
                    throw TypeError(".proto.SyncActionValue.recentEmojiWeightsAction: object expected");
                message.recentEmojiWeightsAction = $root.proto.SyncActionValue.RecentEmojiWeightsAction.fromObject(object.recentEmojiWeightsAction);
            }
            if (object.labelEditAction != null) {
                if (typeof object.labelEditAction !== "object")
                    throw TypeError(".proto.SyncActionValue.labelEditAction: object expected");
                message.labelEditAction = $root.proto.SyncActionValue.LabelEditAction.fromObject(object.labelEditAction);
            }
            if (object.labelAssociationAction != null) {
                if (typeof object.labelAssociationAction !== "object")
                    throw TypeError(".proto.SyncActionValue.labelAssociationAction: object expected");
                message.labelAssociationAction = $root.proto.SyncActionValue.LabelAssociationAction.fromObject(object.labelAssociationAction);
            }
            if (object.localeSetting != null) {
                if (typeof object.localeSetting !== "object")
                    throw TypeError(".proto.SyncActionValue.localeSetting: object expected");
                message.localeSetting = $root.proto.SyncActionValue.LocaleSetting.fromObject(object.localeSetting);
            }
            if (object.archiveChatAction != null) {
                if (typeof object.archiveChatAction !== "object")
                    throw TypeError(".proto.SyncActionValue.archiveChatAction: object expected");
                message.archiveChatAction = $root.proto.SyncActionValue.ArchiveChatAction.fromObject(object.archiveChatAction);
            }
            if (object.deleteMessageForMeAction != null) {
                if (typeof object.deleteMessageForMeAction !== "object")
                    throw TypeError(".proto.SyncActionValue.deleteMessageForMeAction: object expected");
                message.deleteMessageForMeAction = $root.proto.SyncActionValue.DeleteMessageForMeAction.fromObject(object.deleteMessageForMeAction);
            }
            if (object.keyExpiration != null) {
                if (typeof object.keyExpiration !== "object")
                    throw TypeError(".proto.SyncActionValue.keyExpiration: object expected");
                message.keyExpiration = $root.proto.SyncActionValue.KeyExpiration.fromObject(object.keyExpiration);
            }
            if (object.markChatAsReadAction != null) {
                if (typeof object.markChatAsReadAction !== "object")
                    throw TypeError(".proto.SyncActionValue.markChatAsReadAction: object expected");
                message.markChatAsReadAction = $root.proto.SyncActionValue.MarkChatAsReadAction.fromObject(object.markChatAsReadAction);
            }
            if (object.clearChatAction != null) {
                if (typeof object.clearChatAction !== "object")
                    throw TypeError(".proto.SyncActionValue.clearChatAction: object expected");
                message.clearChatAction = $root.proto.SyncActionValue.ClearChatAction.fromObject(object.clearChatAction);
            }
            if (object.deleteChatAction != null) {
                if (typeof object.deleteChatAction !== "object")
                    throw TypeError(".proto.SyncActionValue.deleteChatAction: object expected");
                message.deleteChatAction = $root.proto.SyncActionValue.DeleteChatAction.fromObject(object.deleteChatAction);
            }
            if (object.unarchiveChatsSetting != null) {
                if (typeof object.unarchiveChatsSetting !== "object")
                    throw TypeError(".proto.SyncActionValue.unarchiveChatsSetting: object expected");
                message.unarchiveChatsSetting = $root.proto.SyncActionValue.UnarchiveChatsSetting.fromObject(object.unarchiveChatsSetting);
            }
            if (object.primaryFeature != null) {
                if (typeof object.primaryFeature !== "object")
                    throw TypeError(".proto.SyncActionValue.primaryFeature: object expected");
                message.primaryFeature = $root.proto.SyncActionValue.PrimaryFeature.fromObject(object.primaryFeature);
            }
            if (object.androidUnsupportedActions != null) {
                if (typeof object.androidUnsupportedActions !== "object")
                    throw TypeError(".proto.SyncActionValue.androidUnsupportedActions: object expected");
                message.androidUnsupportedActions = $root.proto.SyncActionValue.AndroidUnsupportedActions.fromObject(object.androidUnsupportedActions);
            }
            if (object.agentAction != null) {
                if (typeof object.agentAction !== "object")
                    throw TypeError(".proto.SyncActionValue.agentAction: object expected");
                message.agentAction = $root.proto.SyncActionValue.AgentAction.fromObject(object.agentAction);
            }
            if (object.subscriptionAction != null) {
                if (typeof object.subscriptionAction !== "object")
                    throw TypeError(".proto.SyncActionValue.subscriptionAction: object expected");
                message.subscriptionAction = $root.proto.SyncActionValue.SubscriptionAction.fromObject(object.subscriptionAction);
            }
            if (object.userStatusMuteAction != null) {
                if (typeof object.userStatusMuteAction !== "object")
                    throw TypeError(".proto.SyncActionValue.userStatusMuteAction: object expected");
                message.userStatusMuteAction = $root.proto.SyncActionValue.UserStatusMuteAction.fromObject(object.userStatusMuteAction);
            }
            if (object.timeFormatAction != null) {
                if (typeof object.timeFormatAction !== "object")
                    throw TypeError(".proto.SyncActionValue.timeFormatAction: object expected");
                message.timeFormatAction = $root.proto.SyncActionValue.TimeFormatAction.fromObject(object.timeFormatAction);
            }
            if (object.nuxAction != null) {
                if (typeof object.nuxAction !== "object")
                    throw TypeError(".proto.SyncActionValue.nuxAction: object expected");
                message.nuxAction = $root.proto.SyncActionValue.NuxAction.fromObject(object.nuxAction);
            }
            if (object.primaryVersionAction != null) {
                if (typeof object.primaryVersionAction !== "object")
                    throw TypeError(".proto.SyncActionValue.primaryVersionAction: object expected");
                message.primaryVersionAction = $root.proto.SyncActionValue.PrimaryVersionAction.fromObject(object.primaryVersionAction);
            }
            if (object.stickerAction != null) {
                if (typeof object.stickerAction !== "object")
                    throw TypeError(".proto.SyncActionValue.stickerAction: object expected");
                message.stickerAction = $root.proto.SyncActionValue.StickerAction.fromObject(object.stickerAction);
            }
            if (object.removeRecentStickerAction != null) {
                if (typeof object.removeRecentStickerAction !== "object")
                    throw TypeError(".proto.SyncActionValue.removeRecentStickerAction: object expected");
                message.removeRecentStickerAction = $root.proto.SyncActionValue.RemoveRecentStickerAction.fromObject(object.removeRecentStickerAction);
            }
            if (object.chatAssignment != null) {
                if (typeof object.chatAssignment !== "object")
                    throw TypeError(".proto.SyncActionValue.chatAssignment: object expected");
                message.chatAssignment = $root.proto.SyncActionValue.ChatAssignmentAction.fromObject(object.chatAssignment);
            }
            if (object.chatAssignmentOpenedStatus != null) {
                if (typeof object.chatAssignmentOpenedStatus !== "object")
                    throw TypeError(".proto.SyncActionValue.chatAssignmentOpenedStatus: object expected");
                message.chatAssignmentOpenedStatus = $root.proto.SyncActionValue.ChatAssignmentOpenedStatusAction.fromObject(object.chatAssignmentOpenedStatus);
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncActionValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncActionValue
         * @static
         * @param {proto.SyncActionValue} message SyncActionValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncActionValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.starAction = null;
                object.contactAction = null;
                object.muteAction = null;
                object.pinAction = null;
                object.securityNotificationSetting = null;
                object.pushNameSetting = null;
                object.quickReplyAction = null;
                object.recentEmojiWeightsAction = null;
                object.labelEditAction = null;
                object.labelAssociationAction = null;
                object.localeSetting = null;
                object.archiveChatAction = null;
                object.deleteMessageForMeAction = null;
                object.keyExpiration = null;
                object.markChatAsReadAction = null;
                object.clearChatAction = null;
                object.deleteChatAction = null;
                object.unarchiveChatsSetting = null;
                object.primaryFeature = null;
                object.androidUnsupportedActions = null;
                object.agentAction = null;
                object.subscriptionAction = null;
                object.userStatusMuteAction = null;
                object.timeFormatAction = null;
                object.nuxAction = null;
                object.primaryVersionAction = null;
                object.stickerAction = null;
                object.removeRecentStickerAction = null;
                object.chatAssignment = null;
                object.chatAssignmentOpenedStatus = null;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.starAction != null && message.hasOwnProperty("starAction"))
                object.starAction = $root.proto.SyncActionValue.StarAction.toObject(message.starAction, options);
            if (message.contactAction != null && message.hasOwnProperty("contactAction"))
                object.contactAction = $root.proto.SyncActionValue.ContactAction.toObject(message.contactAction, options);
            if (message.muteAction != null && message.hasOwnProperty("muteAction"))
                object.muteAction = $root.proto.SyncActionValue.MuteAction.toObject(message.muteAction, options);
            if (message.pinAction != null && message.hasOwnProperty("pinAction"))
                object.pinAction = $root.proto.SyncActionValue.PinAction.toObject(message.pinAction, options);
            if (message.securityNotificationSetting != null && message.hasOwnProperty("securityNotificationSetting"))
                object.securityNotificationSetting = $root.proto.SyncActionValue.SecurityNotificationSetting.toObject(message.securityNotificationSetting, options);
            if (message.pushNameSetting != null && message.hasOwnProperty("pushNameSetting"))
                object.pushNameSetting = $root.proto.SyncActionValue.PushNameSetting.toObject(message.pushNameSetting, options);
            if (message.quickReplyAction != null && message.hasOwnProperty("quickReplyAction"))
                object.quickReplyAction = $root.proto.SyncActionValue.QuickReplyAction.toObject(message.quickReplyAction, options);
            if (message.recentEmojiWeightsAction != null && message.hasOwnProperty("recentEmojiWeightsAction"))
                object.recentEmojiWeightsAction = $root.proto.SyncActionValue.RecentEmojiWeightsAction.toObject(message.recentEmojiWeightsAction, options);
            if (message.labelEditAction != null && message.hasOwnProperty("labelEditAction"))
                object.labelEditAction = $root.proto.SyncActionValue.LabelEditAction.toObject(message.labelEditAction, options);
            if (message.labelAssociationAction != null && message.hasOwnProperty("labelAssociationAction"))
                object.labelAssociationAction = $root.proto.SyncActionValue.LabelAssociationAction.toObject(message.labelAssociationAction, options);
            if (message.localeSetting != null && message.hasOwnProperty("localeSetting"))
                object.localeSetting = $root.proto.SyncActionValue.LocaleSetting.toObject(message.localeSetting, options);
            if (message.archiveChatAction != null && message.hasOwnProperty("archiveChatAction"))
                object.archiveChatAction = $root.proto.SyncActionValue.ArchiveChatAction.toObject(message.archiveChatAction, options);
            if (message.deleteMessageForMeAction != null && message.hasOwnProperty("deleteMessageForMeAction"))
                object.deleteMessageForMeAction = $root.proto.SyncActionValue.DeleteMessageForMeAction.toObject(message.deleteMessageForMeAction, options);
            if (message.keyExpiration != null && message.hasOwnProperty("keyExpiration"))
                object.keyExpiration = $root.proto.SyncActionValue.KeyExpiration.toObject(message.keyExpiration, options);
            if (message.markChatAsReadAction != null && message.hasOwnProperty("markChatAsReadAction"))
                object.markChatAsReadAction = $root.proto.SyncActionValue.MarkChatAsReadAction.toObject(message.markChatAsReadAction, options);
            if (message.clearChatAction != null && message.hasOwnProperty("clearChatAction"))
                object.clearChatAction = $root.proto.SyncActionValue.ClearChatAction.toObject(message.clearChatAction, options);
            if (message.deleteChatAction != null && message.hasOwnProperty("deleteChatAction"))
                object.deleteChatAction = $root.proto.SyncActionValue.DeleteChatAction.toObject(message.deleteChatAction, options);
            if (message.unarchiveChatsSetting != null && message.hasOwnProperty("unarchiveChatsSetting"))
                object.unarchiveChatsSetting = $root.proto.SyncActionValue.UnarchiveChatsSetting.toObject(message.unarchiveChatsSetting, options);
            if (message.primaryFeature != null && message.hasOwnProperty("primaryFeature"))
                object.primaryFeature = $root.proto.SyncActionValue.PrimaryFeature.toObject(message.primaryFeature, options);
            if (message.androidUnsupportedActions != null && message.hasOwnProperty("androidUnsupportedActions"))
                object.androidUnsupportedActions = $root.proto.SyncActionValue.AndroidUnsupportedActions.toObject(message.androidUnsupportedActions, options);
            if (message.agentAction != null && message.hasOwnProperty("agentAction"))
                object.agentAction = $root.proto.SyncActionValue.AgentAction.toObject(message.agentAction, options);
            if (message.subscriptionAction != null && message.hasOwnProperty("subscriptionAction"))
                object.subscriptionAction = $root.proto.SyncActionValue.SubscriptionAction.toObject(message.subscriptionAction, options);
            if (message.userStatusMuteAction != null && message.hasOwnProperty("userStatusMuteAction"))
                object.userStatusMuteAction = $root.proto.SyncActionValue.UserStatusMuteAction.toObject(message.userStatusMuteAction, options);
            if (message.timeFormatAction != null && message.hasOwnProperty("timeFormatAction"))
                object.timeFormatAction = $root.proto.SyncActionValue.TimeFormatAction.toObject(message.timeFormatAction, options);
            if (message.nuxAction != null && message.hasOwnProperty("nuxAction"))
                object.nuxAction = $root.proto.SyncActionValue.NuxAction.toObject(message.nuxAction, options);
            if (message.primaryVersionAction != null && message.hasOwnProperty("primaryVersionAction"))
                object.primaryVersionAction = $root.proto.SyncActionValue.PrimaryVersionAction.toObject(message.primaryVersionAction, options);
            if (message.stickerAction != null && message.hasOwnProperty("stickerAction"))
                object.stickerAction = $root.proto.SyncActionValue.StickerAction.toObject(message.stickerAction, options);
            if (message.removeRecentStickerAction != null && message.hasOwnProperty("removeRecentStickerAction"))
                object.removeRecentStickerAction = $root.proto.SyncActionValue.RemoveRecentStickerAction.toObject(message.removeRecentStickerAction, options);
            if (message.chatAssignment != null && message.hasOwnProperty("chatAssignment"))
                object.chatAssignment = $root.proto.SyncActionValue.ChatAssignmentAction.toObject(message.chatAssignment, options);
            if (message.chatAssignmentOpenedStatus != null && message.hasOwnProperty("chatAssignmentOpenedStatus"))
                object.chatAssignmentOpenedStatus = $root.proto.SyncActionValue.ChatAssignmentOpenedStatusAction.toObject(message.chatAssignmentOpenedStatus, options);
            return object;
        };

        /**
         * Converts this SyncActionValue to JSON.
         * @function toJSON
         * @memberof proto.SyncActionValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncActionValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SyncActionValue.AgentAction = (function() {

            /**
             * Properties of an AgentAction.
             * @memberof proto.SyncActionValue
             * @interface IAgentAction
             * @property {string|null} [name] AgentAction name
             * @property {number|null} [deviceID] AgentAction deviceID
             * @property {boolean|null} [isDeleted] AgentAction isDeleted
             */

            /**
             * Constructs a new AgentAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents an AgentAction.
             * @implements IAgentAction
             * @constructor
             * @param {proto.SyncActionValue.IAgentAction=} [properties] Properties to set
             */
            function AgentAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AgentAction name.
             * @member {string} name
             * @memberof proto.SyncActionValue.AgentAction
             * @instance
             */
            AgentAction.prototype.name = "";

            /**
             * AgentAction deviceID.
             * @member {number} deviceID
             * @memberof proto.SyncActionValue.AgentAction
             * @instance
             */
            AgentAction.prototype.deviceID = 0;

            /**
             * AgentAction isDeleted.
             * @member {boolean} isDeleted
             * @memberof proto.SyncActionValue.AgentAction
             * @instance
             */
            AgentAction.prototype.isDeleted = false;

            /**
             * Creates a new AgentAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.AgentAction
             * @static
             * @param {proto.SyncActionValue.IAgentAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.AgentAction} AgentAction instance
             */
            AgentAction.create = function create(properties) {
                return new AgentAction(properties);
            };

            /**
             * Encodes the specified AgentAction message. Does not implicitly {@link proto.SyncActionValue.AgentAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.AgentAction
             * @static
             * @param {proto.SyncActionValue.IAgentAction} message AgentAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AgentAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.deviceID != null && Object.hasOwnProperty.call(message, "deviceID"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.deviceID);
                if (message.isDeleted != null && Object.hasOwnProperty.call(message, "isDeleted"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isDeleted);
                return writer;
            };

            /**
             * Encodes the specified AgentAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.AgentAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.AgentAction
             * @static
             * @param {proto.SyncActionValue.IAgentAction} message AgentAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AgentAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AgentAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.AgentAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.AgentAction} AgentAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AgentAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.AgentAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.deviceID = reader.int32();
                        break;
                    case 3:
                        message.isDeleted = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AgentAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.AgentAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.AgentAction} AgentAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AgentAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AgentAction message.
             * @function verify
             * @memberof proto.SyncActionValue.AgentAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AgentAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.deviceID != null && message.hasOwnProperty("deviceID"))
                    if (!$util.isInteger(message.deviceID))
                        return "deviceID: integer expected";
                if (message.isDeleted != null && message.hasOwnProperty("isDeleted"))
                    if (typeof message.isDeleted !== "boolean")
                        return "isDeleted: boolean expected";
                return null;
            };

            /**
             * Creates an AgentAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.AgentAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.AgentAction} AgentAction
             */
            AgentAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.AgentAction)
                    return object;
                var message = new $root.proto.SyncActionValue.AgentAction();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.deviceID != null)
                    message.deviceID = object.deviceID | 0;
                if (object.isDeleted != null)
                    message.isDeleted = Boolean(object.isDeleted);
                return message;
            };

            /**
             * Creates a plain object from an AgentAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.AgentAction
             * @static
             * @param {proto.SyncActionValue.AgentAction} message AgentAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AgentAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.deviceID = 0;
                    object.isDeleted = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.deviceID != null && message.hasOwnProperty("deviceID"))
                    object.deviceID = message.deviceID;
                if (message.isDeleted != null && message.hasOwnProperty("isDeleted"))
                    object.isDeleted = message.isDeleted;
                return object;
            };

            /**
             * Converts this AgentAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.AgentAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AgentAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AgentAction;
        })();

        SyncActionValue.AndroidUnsupportedActions = (function() {

            /**
             * Properties of an AndroidUnsupportedActions.
             * @memberof proto.SyncActionValue
             * @interface IAndroidUnsupportedActions
             * @property {boolean|null} [allowed] AndroidUnsupportedActions allowed
             */

            /**
             * Constructs a new AndroidUnsupportedActions.
             * @memberof proto.SyncActionValue
             * @classdesc Represents an AndroidUnsupportedActions.
             * @implements IAndroidUnsupportedActions
             * @constructor
             * @param {proto.SyncActionValue.IAndroidUnsupportedActions=} [properties] Properties to set
             */
            function AndroidUnsupportedActions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AndroidUnsupportedActions allowed.
             * @member {boolean} allowed
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @instance
             */
            AndroidUnsupportedActions.prototype.allowed = false;

            /**
             * Creates a new AndroidUnsupportedActions instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @static
             * @param {proto.SyncActionValue.IAndroidUnsupportedActions=} [properties] Properties to set
             * @returns {proto.SyncActionValue.AndroidUnsupportedActions} AndroidUnsupportedActions instance
             */
            AndroidUnsupportedActions.create = function create(properties) {
                return new AndroidUnsupportedActions(properties);
            };

            /**
             * Encodes the specified AndroidUnsupportedActions message. Does not implicitly {@link proto.SyncActionValue.AndroidUnsupportedActions.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @static
             * @param {proto.SyncActionValue.IAndroidUnsupportedActions} message AndroidUnsupportedActions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AndroidUnsupportedActions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowed != null && Object.hasOwnProperty.call(message, "allowed"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.allowed);
                return writer;
            };

            /**
             * Encodes the specified AndroidUnsupportedActions message, length delimited. Does not implicitly {@link proto.SyncActionValue.AndroidUnsupportedActions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @static
             * @param {proto.SyncActionValue.IAndroidUnsupportedActions} message AndroidUnsupportedActions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AndroidUnsupportedActions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AndroidUnsupportedActions message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.AndroidUnsupportedActions} AndroidUnsupportedActions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AndroidUnsupportedActions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.AndroidUnsupportedActions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.allowed = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AndroidUnsupportedActions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.AndroidUnsupportedActions} AndroidUnsupportedActions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AndroidUnsupportedActions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AndroidUnsupportedActions message.
             * @function verify
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AndroidUnsupportedActions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowed != null && message.hasOwnProperty("allowed"))
                    if (typeof message.allowed !== "boolean")
                        return "allowed: boolean expected";
                return null;
            };

            /**
             * Creates an AndroidUnsupportedActions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.AndroidUnsupportedActions} AndroidUnsupportedActions
             */
            AndroidUnsupportedActions.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.AndroidUnsupportedActions)
                    return object;
                var message = new $root.proto.SyncActionValue.AndroidUnsupportedActions();
                if (object.allowed != null)
                    message.allowed = Boolean(object.allowed);
                return message;
            };

            /**
             * Creates a plain object from an AndroidUnsupportedActions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @static
             * @param {proto.SyncActionValue.AndroidUnsupportedActions} message AndroidUnsupportedActions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AndroidUnsupportedActions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.allowed = false;
                if (message.allowed != null && message.hasOwnProperty("allowed"))
                    object.allowed = message.allowed;
                return object;
            };

            /**
             * Converts this AndroidUnsupportedActions to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.AndroidUnsupportedActions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AndroidUnsupportedActions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AndroidUnsupportedActions;
        })();

        SyncActionValue.ArchiveChatAction = (function() {

            /**
             * Properties of an ArchiveChatAction.
             * @memberof proto.SyncActionValue
             * @interface IArchiveChatAction
             * @property {boolean|null} [archived] ArchiveChatAction archived
             * @property {proto.SyncActionValue.ISyncActionMessageRange|null} [messageRange] ArchiveChatAction messageRange
             */

            /**
             * Constructs a new ArchiveChatAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents an ArchiveChatAction.
             * @implements IArchiveChatAction
             * @constructor
             * @param {proto.SyncActionValue.IArchiveChatAction=} [properties] Properties to set
             */
            function ArchiveChatAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ArchiveChatAction archived.
             * @member {boolean} archived
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @instance
             */
            ArchiveChatAction.prototype.archived = false;

            /**
             * ArchiveChatAction messageRange.
             * @member {proto.SyncActionValue.ISyncActionMessageRange|null|undefined} messageRange
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @instance
             */
            ArchiveChatAction.prototype.messageRange = null;

            /**
             * Creates a new ArchiveChatAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @static
             * @param {proto.SyncActionValue.IArchiveChatAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.ArchiveChatAction} ArchiveChatAction instance
             */
            ArchiveChatAction.create = function create(properties) {
                return new ArchiveChatAction(properties);
            };

            /**
             * Encodes the specified ArchiveChatAction message. Does not implicitly {@link proto.SyncActionValue.ArchiveChatAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @static
             * @param {proto.SyncActionValue.IArchiveChatAction} message ArchiveChatAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArchiveChatAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.archived != null && Object.hasOwnProperty.call(message, "archived"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.archived);
                if (message.messageRange != null && Object.hasOwnProperty.call(message, "messageRange"))
                    $root.proto.SyncActionValue.SyncActionMessageRange.encode(message.messageRange, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ArchiveChatAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.ArchiveChatAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @static
             * @param {proto.SyncActionValue.IArchiveChatAction} message ArchiveChatAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArchiveChatAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ArchiveChatAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.ArchiveChatAction} ArchiveChatAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArchiveChatAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.ArchiveChatAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.archived = reader.bool();
                        break;
                    case 2:
                        message.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ArchiveChatAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.ArchiveChatAction} ArchiveChatAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArchiveChatAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ArchiveChatAction message.
             * @function verify
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ArchiveChatAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.archived != null && message.hasOwnProperty("archived"))
                    if (typeof message.archived !== "boolean")
                        return "archived: boolean expected";
                if (message.messageRange != null && message.hasOwnProperty("messageRange")) {
                    var error = $root.proto.SyncActionValue.SyncActionMessageRange.verify(message.messageRange);
                    if (error)
                        return "messageRange." + error;
                }
                return null;
            };

            /**
             * Creates an ArchiveChatAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.ArchiveChatAction} ArchiveChatAction
             */
            ArchiveChatAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.ArchiveChatAction)
                    return object;
                var message = new $root.proto.SyncActionValue.ArchiveChatAction();
                if (object.archived != null)
                    message.archived = Boolean(object.archived);
                if (object.messageRange != null) {
                    if (typeof object.messageRange !== "object")
                        throw TypeError(".proto.SyncActionValue.ArchiveChatAction.messageRange: object expected");
                    message.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.fromObject(object.messageRange);
                }
                return message;
            };

            /**
             * Creates a plain object from an ArchiveChatAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @static
             * @param {proto.SyncActionValue.ArchiveChatAction} message ArchiveChatAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ArchiveChatAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.archived = false;
                    object.messageRange = null;
                }
                if (message.archived != null && message.hasOwnProperty("archived"))
                    object.archived = message.archived;
                if (message.messageRange != null && message.hasOwnProperty("messageRange"))
                    object.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.toObject(message.messageRange, options);
                return object;
            };

            /**
             * Converts this ArchiveChatAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.ArchiveChatAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ArchiveChatAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ArchiveChatAction;
        })();

        SyncActionValue.ChatAssignmentAction = (function() {

            /**
             * Properties of a ChatAssignmentAction.
             * @memberof proto.SyncActionValue
             * @interface IChatAssignmentAction
             * @property {string|null} [deviceAgentID] ChatAssignmentAction deviceAgentID
             */

            /**
             * Constructs a new ChatAssignmentAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a ChatAssignmentAction.
             * @implements IChatAssignmentAction
             * @constructor
             * @param {proto.SyncActionValue.IChatAssignmentAction=} [properties] Properties to set
             */
            function ChatAssignmentAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChatAssignmentAction deviceAgentID.
             * @member {string} deviceAgentID
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @instance
             */
            ChatAssignmentAction.prototype.deviceAgentID = "";

            /**
             * Creates a new ChatAssignmentAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @static
             * @param {proto.SyncActionValue.IChatAssignmentAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.ChatAssignmentAction} ChatAssignmentAction instance
             */
            ChatAssignmentAction.create = function create(properties) {
                return new ChatAssignmentAction(properties);
            };

            /**
             * Encodes the specified ChatAssignmentAction message. Does not implicitly {@link proto.SyncActionValue.ChatAssignmentAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @static
             * @param {proto.SyncActionValue.IChatAssignmentAction} message ChatAssignmentAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatAssignmentAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deviceAgentID != null && Object.hasOwnProperty.call(message, "deviceAgentID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.deviceAgentID);
                return writer;
            };

            /**
             * Encodes the specified ChatAssignmentAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.ChatAssignmentAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @static
             * @param {proto.SyncActionValue.IChatAssignmentAction} message ChatAssignmentAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatAssignmentAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChatAssignmentAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.ChatAssignmentAction} ChatAssignmentAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatAssignmentAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.ChatAssignmentAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deviceAgentID = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChatAssignmentAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.ChatAssignmentAction} ChatAssignmentAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatAssignmentAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChatAssignmentAction message.
             * @function verify
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChatAssignmentAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deviceAgentID != null && message.hasOwnProperty("deviceAgentID"))
                    if (!$util.isString(message.deviceAgentID))
                        return "deviceAgentID: string expected";
                return null;
            };

            /**
             * Creates a ChatAssignmentAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.ChatAssignmentAction} ChatAssignmentAction
             */
            ChatAssignmentAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.ChatAssignmentAction)
                    return object;
                var message = new $root.proto.SyncActionValue.ChatAssignmentAction();
                if (object.deviceAgentID != null)
                    message.deviceAgentID = String(object.deviceAgentID);
                return message;
            };

            /**
             * Creates a plain object from a ChatAssignmentAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @static
             * @param {proto.SyncActionValue.ChatAssignmentAction} message ChatAssignmentAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChatAssignmentAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.deviceAgentID = "";
                if (message.deviceAgentID != null && message.hasOwnProperty("deviceAgentID"))
                    object.deviceAgentID = message.deviceAgentID;
                return object;
            };

            /**
             * Converts this ChatAssignmentAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.ChatAssignmentAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChatAssignmentAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChatAssignmentAction;
        })();

        SyncActionValue.ChatAssignmentOpenedStatusAction = (function() {

            /**
             * Properties of a ChatAssignmentOpenedStatusAction.
             * @memberof proto.SyncActionValue
             * @interface IChatAssignmentOpenedStatusAction
             * @property {boolean|null} [chatOpened] ChatAssignmentOpenedStatusAction chatOpened
             */

            /**
             * Constructs a new ChatAssignmentOpenedStatusAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a ChatAssignmentOpenedStatusAction.
             * @implements IChatAssignmentOpenedStatusAction
             * @constructor
             * @param {proto.SyncActionValue.IChatAssignmentOpenedStatusAction=} [properties] Properties to set
             */
            function ChatAssignmentOpenedStatusAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChatAssignmentOpenedStatusAction chatOpened.
             * @member {boolean} chatOpened
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @instance
             */
            ChatAssignmentOpenedStatusAction.prototype.chatOpened = false;

            /**
             * Creates a new ChatAssignmentOpenedStatusAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @static
             * @param {proto.SyncActionValue.IChatAssignmentOpenedStatusAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.ChatAssignmentOpenedStatusAction} ChatAssignmentOpenedStatusAction instance
             */
            ChatAssignmentOpenedStatusAction.create = function create(properties) {
                return new ChatAssignmentOpenedStatusAction(properties);
            };

            /**
             * Encodes the specified ChatAssignmentOpenedStatusAction message. Does not implicitly {@link proto.SyncActionValue.ChatAssignmentOpenedStatusAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @static
             * @param {proto.SyncActionValue.IChatAssignmentOpenedStatusAction} message ChatAssignmentOpenedStatusAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatAssignmentOpenedStatusAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chatOpened != null && Object.hasOwnProperty.call(message, "chatOpened"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.chatOpened);
                return writer;
            };

            /**
             * Encodes the specified ChatAssignmentOpenedStatusAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.ChatAssignmentOpenedStatusAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @static
             * @param {proto.SyncActionValue.IChatAssignmentOpenedStatusAction} message ChatAssignmentOpenedStatusAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatAssignmentOpenedStatusAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChatAssignmentOpenedStatusAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.ChatAssignmentOpenedStatusAction} ChatAssignmentOpenedStatusAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatAssignmentOpenedStatusAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.ChatAssignmentOpenedStatusAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chatOpened = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChatAssignmentOpenedStatusAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.ChatAssignmentOpenedStatusAction} ChatAssignmentOpenedStatusAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatAssignmentOpenedStatusAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChatAssignmentOpenedStatusAction message.
             * @function verify
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChatAssignmentOpenedStatusAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chatOpened != null && message.hasOwnProperty("chatOpened"))
                    if (typeof message.chatOpened !== "boolean")
                        return "chatOpened: boolean expected";
                return null;
            };

            /**
             * Creates a ChatAssignmentOpenedStatusAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.ChatAssignmentOpenedStatusAction} ChatAssignmentOpenedStatusAction
             */
            ChatAssignmentOpenedStatusAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.ChatAssignmentOpenedStatusAction)
                    return object;
                var message = new $root.proto.SyncActionValue.ChatAssignmentOpenedStatusAction();
                if (object.chatOpened != null)
                    message.chatOpened = Boolean(object.chatOpened);
                return message;
            };

            /**
             * Creates a plain object from a ChatAssignmentOpenedStatusAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @static
             * @param {proto.SyncActionValue.ChatAssignmentOpenedStatusAction} message ChatAssignmentOpenedStatusAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChatAssignmentOpenedStatusAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chatOpened = false;
                if (message.chatOpened != null && message.hasOwnProperty("chatOpened"))
                    object.chatOpened = message.chatOpened;
                return object;
            };

            /**
             * Converts this ChatAssignmentOpenedStatusAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.ChatAssignmentOpenedStatusAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChatAssignmentOpenedStatusAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChatAssignmentOpenedStatusAction;
        })();

        SyncActionValue.ClearChatAction = (function() {

            /**
             * Properties of a ClearChatAction.
             * @memberof proto.SyncActionValue
             * @interface IClearChatAction
             * @property {proto.SyncActionValue.ISyncActionMessageRange|null} [messageRange] ClearChatAction messageRange
             */

            /**
             * Constructs a new ClearChatAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a ClearChatAction.
             * @implements IClearChatAction
             * @constructor
             * @param {proto.SyncActionValue.IClearChatAction=} [properties] Properties to set
             */
            function ClearChatAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClearChatAction messageRange.
             * @member {proto.SyncActionValue.ISyncActionMessageRange|null|undefined} messageRange
             * @memberof proto.SyncActionValue.ClearChatAction
             * @instance
             */
            ClearChatAction.prototype.messageRange = null;

            /**
             * Creates a new ClearChatAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.ClearChatAction
             * @static
             * @param {proto.SyncActionValue.IClearChatAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.ClearChatAction} ClearChatAction instance
             */
            ClearChatAction.create = function create(properties) {
                return new ClearChatAction(properties);
            };

            /**
             * Encodes the specified ClearChatAction message. Does not implicitly {@link proto.SyncActionValue.ClearChatAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.ClearChatAction
             * @static
             * @param {proto.SyncActionValue.IClearChatAction} message ClearChatAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearChatAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageRange != null && Object.hasOwnProperty.call(message, "messageRange"))
                    $root.proto.SyncActionValue.SyncActionMessageRange.encode(message.messageRange, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ClearChatAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.ClearChatAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.ClearChatAction
             * @static
             * @param {proto.SyncActionValue.IClearChatAction} message ClearChatAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearChatAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearChatAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.ClearChatAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.ClearChatAction} ClearChatAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearChatAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.ClearChatAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearChatAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.ClearChatAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.ClearChatAction} ClearChatAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearChatAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearChatAction message.
             * @function verify
             * @memberof proto.SyncActionValue.ClearChatAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearChatAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageRange != null && message.hasOwnProperty("messageRange")) {
                    var error = $root.proto.SyncActionValue.SyncActionMessageRange.verify(message.messageRange);
                    if (error)
                        return "messageRange." + error;
                }
                return null;
            };

            /**
             * Creates a ClearChatAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.ClearChatAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.ClearChatAction} ClearChatAction
             */
            ClearChatAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.ClearChatAction)
                    return object;
                var message = new $root.proto.SyncActionValue.ClearChatAction();
                if (object.messageRange != null) {
                    if (typeof object.messageRange !== "object")
                        throw TypeError(".proto.SyncActionValue.ClearChatAction.messageRange: object expected");
                    message.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.fromObject(object.messageRange);
                }
                return message;
            };

            /**
             * Creates a plain object from a ClearChatAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.ClearChatAction
             * @static
             * @param {proto.SyncActionValue.ClearChatAction} message ClearChatAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearChatAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.messageRange = null;
                if (message.messageRange != null && message.hasOwnProperty("messageRange"))
                    object.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.toObject(message.messageRange, options);
                return object;
            };

            /**
             * Converts this ClearChatAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.ClearChatAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearChatAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ClearChatAction;
        })();

        SyncActionValue.ContactAction = (function() {

            /**
             * Properties of a ContactAction.
             * @memberof proto.SyncActionValue
             * @interface IContactAction
             * @property {string|null} [fullName] ContactAction fullName
             * @property {string|null} [firstName] ContactAction firstName
             * @property {string|null} [lidJid] ContactAction lidJid
             */

            /**
             * Constructs a new ContactAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a ContactAction.
             * @implements IContactAction
             * @constructor
             * @param {proto.SyncActionValue.IContactAction=} [properties] Properties to set
             */
            function ContactAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContactAction fullName.
             * @member {string} fullName
             * @memberof proto.SyncActionValue.ContactAction
             * @instance
             */
            ContactAction.prototype.fullName = "";

            /**
             * ContactAction firstName.
             * @member {string} firstName
             * @memberof proto.SyncActionValue.ContactAction
             * @instance
             */
            ContactAction.prototype.firstName = "";

            /**
             * ContactAction lidJid.
             * @member {string} lidJid
             * @memberof proto.SyncActionValue.ContactAction
             * @instance
             */
            ContactAction.prototype.lidJid = "";

            /**
             * Creates a new ContactAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.ContactAction
             * @static
             * @param {proto.SyncActionValue.IContactAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.ContactAction} ContactAction instance
             */
            ContactAction.create = function create(properties) {
                return new ContactAction(properties);
            };

            /**
             * Encodes the specified ContactAction message. Does not implicitly {@link proto.SyncActionValue.ContactAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.ContactAction
             * @static
             * @param {proto.SyncActionValue.IContactAction} message ContactAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fullName);
                if (message.firstName != null && Object.hasOwnProperty.call(message, "firstName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.firstName);
                if (message.lidJid != null && Object.hasOwnProperty.call(message, "lidJid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.lidJid);
                return writer;
            };

            /**
             * Encodes the specified ContactAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.ContactAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.ContactAction
             * @static
             * @param {proto.SyncActionValue.IContactAction} message ContactAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContactAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.ContactAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.ContactAction} ContactAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.ContactAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fullName = reader.string();
                        break;
                    case 2:
                        message.firstName = reader.string();
                        break;
                    case 3:
                        message.lidJid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContactAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.ContactAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.ContactAction} ContactAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContactAction message.
             * @function verify
             * @memberof proto.SyncActionValue.ContactAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContactAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fullName != null && message.hasOwnProperty("fullName"))
                    if (!$util.isString(message.fullName))
                        return "fullName: string expected";
                if (message.firstName != null && message.hasOwnProperty("firstName"))
                    if (!$util.isString(message.firstName))
                        return "firstName: string expected";
                if (message.lidJid != null && message.hasOwnProperty("lidJid"))
                    if (!$util.isString(message.lidJid))
                        return "lidJid: string expected";
                return null;
            };

            /**
             * Creates a ContactAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.ContactAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.ContactAction} ContactAction
             */
            ContactAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.ContactAction)
                    return object;
                var message = new $root.proto.SyncActionValue.ContactAction();
                if (object.fullName != null)
                    message.fullName = String(object.fullName);
                if (object.firstName != null)
                    message.firstName = String(object.firstName);
                if (object.lidJid != null)
                    message.lidJid = String(object.lidJid);
                return message;
            };

            /**
             * Creates a plain object from a ContactAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.ContactAction
             * @static
             * @param {proto.SyncActionValue.ContactAction} message ContactAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContactAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fullName = "";
                    object.firstName = "";
                    object.lidJid = "";
                }
                if (message.fullName != null && message.hasOwnProperty("fullName"))
                    object.fullName = message.fullName;
                if (message.firstName != null && message.hasOwnProperty("firstName"))
                    object.firstName = message.firstName;
                if (message.lidJid != null && message.hasOwnProperty("lidJid"))
                    object.lidJid = message.lidJid;
                return object;
            };

            /**
             * Converts this ContactAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.ContactAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContactAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ContactAction;
        })();

        SyncActionValue.DeleteChatAction = (function() {

            /**
             * Properties of a DeleteChatAction.
             * @memberof proto.SyncActionValue
             * @interface IDeleteChatAction
             * @property {proto.SyncActionValue.ISyncActionMessageRange|null} [messageRange] DeleteChatAction messageRange
             */

            /**
             * Constructs a new DeleteChatAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a DeleteChatAction.
             * @implements IDeleteChatAction
             * @constructor
             * @param {proto.SyncActionValue.IDeleteChatAction=} [properties] Properties to set
             */
            function DeleteChatAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteChatAction messageRange.
             * @member {proto.SyncActionValue.ISyncActionMessageRange|null|undefined} messageRange
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @instance
             */
            DeleteChatAction.prototype.messageRange = null;

            /**
             * Creates a new DeleteChatAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @static
             * @param {proto.SyncActionValue.IDeleteChatAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.DeleteChatAction} DeleteChatAction instance
             */
            DeleteChatAction.create = function create(properties) {
                return new DeleteChatAction(properties);
            };

            /**
             * Encodes the specified DeleteChatAction message. Does not implicitly {@link proto.SyncActionValue.DeleteChatAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @static
             * @param {proto.SyncActionValue.IDeleteChatAction} message DeleteChatAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteChatAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageRange != null && Object.hasOwnProperty.call(message, "messageRange"))
                    $root.proto.SyncActionValue.SyncActionMessageRange.encode(message.messageRange, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeleteChatAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.DeleteChatAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @static
             * @param {proto.SyncActionValue.IDeleteChatAction} message DeleteChatAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteChatAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteChatAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.DeleteChatAction} DeleteChatAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteChatAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.DeleteChatAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteChatAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.DeleteChatAction} DeleteChatAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteChatAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteChatAction message.
             * @function verify
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteChatAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageRange != null && message.hasOwnProperty("messageRange")) {
                    var error = $root.proto.SyncActionValue.SyncActionMessageRange.verify(message.messageRange);
                    if (error)
                        return "messageRange." + error;
                }
                return null;
            };

            /**
             * Creates a DeleteChatAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.DeleteChatAction} DeleteChatAction
             */
            DeleteChatAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.DeleteChatAction)
                    return object;
                var message = new $root.proto.SyncActionValue.DeleteChatAction();
                if (object.messageRange != null) {
                    if (typeof object.messageRange !== "object")
                        throw TypeError(".proto.SyncActionValue.DeleteChatAction.messageRange: object expected");
                    message.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.fromObject(object.messageRange);
                }
                return message;
            };

            /**
             * Creates a plain object from a DeleteChatAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @static
             * @param {proto.SyncActionValue.DeleteChatAction} message DeleteChatAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteChatAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.messageRange = null;
                if (message.messageRange != null && message.hasOwnProperty("messageRange"))
                    object.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.toObject(message.messageRange, options);
                return object;
            };

            /**
             * Converts this DeleteChatAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.DeleteChatAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteChatAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteChatAction;
        })();

        SyncActionValue.DeleteMessageForMeAction = (function() {

            /**
             * Properties of a DeleteMessageForMeAction.
             * @memberof proto.SyncActionValue
             * @interface IDeleteMessageForMeAction
             * @property {boolean|null} [deleteMedia] DeleteMessageForMeAction deleteMedia
             * @property {number|Long|null} [messageTimestamp] DeleteMessageForMeAction messageTimestamp
             */

            /**
             * Constructs a new DeleteMessageForMeAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a DeleteMessageForMeAction.
             * @implements IDeleteMessageForMeAction
             * @constructor
             * @param {proto.SyncActionValue.IDeleteMessageForMeAction=} [properties] Properties to set
             */
            function DeleteMessageForMeAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteMessageForMeAction deleteMedia.
             * @member {boolean} deleteMedia
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @instance
             */
            DeleteMessageForMeAction.prototype.deleteMedia = false;

            /**
             * DeleteMessageForMeAction messageTimestamp.
             * @member {number|Long} messageTimestamp
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @instance
             */
            DeleteMessageForMeAction.prototype.messageTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new DeleteMessageForMeAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @static
             * @param {proto.SyncActionValue.IDeleteMessageForMeAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.DeleteMessageForMeAction} DeleteMessageForMeAction instance
             */
            DeleteMessageForMeAction.create = function create(properties) {
                return new DeleteMessageForMeAction(properties);
            };

            /**
             * Encodes the specified DeleteMessageForMeAction message. Does not implicitly {@link proto.SyncActionValue.DeleteMessageForMeAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @static
             * @param {proto.SyncActionValue.IDeleteMessageForMeAction} message DeleteMessageForMeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteMessageForMeAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deleteMedia != null && Object.hasOwnProperty.call(message, "deleteMedia"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deleteMedia);
                if (message.messageTimestamp != null && Object.hasOwnProperty.call(message, "messageTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.messageTimestamp);
                return writer;
            };

            /**
             * Encodes the specified DeleteMessageForMeAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.DeleteMessageForMeAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @static
             * @param {proto.SyncActionValue.IDeleteMessageForMeAction} message DeleteMessageForMeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteMessageForMeAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteMessageForMeAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.DeleteMessageForMeAction} DeleteMessageForMeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteMessageForMeAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.DeleteMessageForMeAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deleteMedia = reader.bool();
                        break;
                    case 2:
                        message.messageTimestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteMessageForMeAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.DeleteMessageForMeAction} DeleteMessageForMeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteMessageForMeAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteMessageForMeAction message.
             * @function verify
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteMessageForMeAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deleteMedia != null && message.hasOwnProperty("deleteMedia"))
                    if (typeof message.deleteMedia !== "boolean")
                        return "deleteMedia: boolean expected";
                if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                    if (!$util.isInteger(message.messageTimestamp) && !(message.messageTimestamp && $util.isInteger(message.messageTimestamp.low) && $util.isInteger(message.messageTimestamp.high)))
                        return "messageTimestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a DeleteMessageForMeAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.DeleteMessageForMeAction} DeleteMessageForMeAction
             */
            DeleteMessageForMeAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.DeleteMessageForMeAction)
                    return object;
                var message = new $root.proto.SyncActionValue.DeleteMessageForMeAction();
                if (object.deleteMedia != null)
                    message.deleteMedia = Boolean(object.deleteMedia);
                if (object.messageTimestamp != null)
                    if ($util.Long)
                        (message.messageTimestamp = $util.Long.fromValue(object.messageTimestamp)).unsigned = false;
                    else if (typeof object.messageTimestamp === "string")
                        message.messageTimestamp = parseInt(object.messageTimestamp, 10);
                    else if (typeof object.messageTimestamp === "number")
                        message.messageTimestamp = object.messageTimestamp;
                    else if (typeof object.messageTimestamp === "object")
                        message.messageTimestamp = new $util.LongBits(object.messageTimestamp.low >>> 0, object.messageTimestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a DeleteMessageForMeAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @static
             * @param {proto.SyncActionValue.DeleteMessageForMeAction} message DeleteMessageForMeAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteMessageForMeAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.deleteMedia = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.messageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.deleteMedia != null && message.hasOwnProperty("deleteMedia"))
                    object.deleteMedia = message.deleteMedia;
                if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                    if (typeof message.messageTimestamp === "number")
                        object.messageTimestamp = options.longs === String ? String(message.messageTimestamp) : message.messageTimestamp;
                    else
                        object.messageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.messageTimestamp) : options.longs === Number ? new $util.LongBits(message.messageTimestamp.low >>> 0, message.messageTimestamp.high >>> 0).toNumber() : message.messageTimestamp;
                return object;
            };

            /**
             * Converts this DeleteMessageForMeAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.DeleteMessageForMeAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteMessageForMeAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteMessageForMeAction;
        })();

        SyncActionValue.KeyExpiration = (function() {

            /**
             * Properties of a KeyExpiration.
             * @memberof proto.SyncActionValue
             * @interface IKeyExpiration
             * @property {number|null} [expiredKeyEpoch] KeyExpiration expiredKeyEpoch
             */

            /**
             * Constructs a new KeyExpiration.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a KeyExpiration.
             * @implements IKeyExpiration
             * @constructor
             * @param {proto.SyncActionValue.IKeyExpiration=} [properties] Properties to set
             */
            function KeyExpiration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyExpiration expiredKeyEpoch.
             * @member {number} expiredKeyEpoch
             * @memberof proto.SyncActionValue.KeyExpiration
             * @instance
             */
            KeyExpiration.prototype.expiredKeyEpoch = 0;

            /**
             * Creates a new KeyExpiration instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.KeyExpiration
             * @static
             * @param {proto.SyncActionValue.IKeyExpiration=} [properties] Properties to set
             * @returns {proto.SyncActionValue.KeyExpiration} KeyExpiration instance
             */
            KeyExpiration.create = function create(properties) {
                return new KeyExpiration(properties);
            };

            /**
             * Encodes the specified KeyExpiration message. Does not implicitly {@link proto.SyncActionValue.KeyExpiration.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.KeyExpiration
             * @static
             * @param {proto.SyncActionValue.IKeyExpiration} message KeyExpiration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyExpiration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.expiredKeyEpoch != null && Object.hasOwnProperty.call(message, "expiredKeyEpoch"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.expiredKeyEpoch);
                return writer;
            };

            /**
             * Encodes the specified KeyExpiration message, length delimited. Does not implicitly {@link proto.SyncActionValue.KeyExpiration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.KeyExpiration
             * @static
             * @param {proto.SyncActionValue.IKeyExpiration} message KeyExpiration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyExpiration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyExpiration message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.KeyExpiration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.KeyExpiration} KeyExpiration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyExpiration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.KeyExpiration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.expiredKeyEpoch = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyExpiration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.KeyExpiration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.KeyExpiration} KeyExpiration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyExpiration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyExpiration message.
             * @function verify
             * @memberof proto.SyncActionValue.KeyExpiration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyExpiration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.expiredKeyEpoch != null && message.hasOwnProperty("expiredKeyEpoch"))
                    if (!$util.isInteger(message.expiredKeyEpoch))
                        return "expiredKeyEpoch: integer expected";
                return null;
            };

            /**
             * Creates a KeyExpiration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.KeyExpiration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.KeyExpiration} KeyExpiration
             */
            KeyExpiration.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.KeyExpiration)
                    return object;
                var message = new $root.proto.SyncActionValue.KeyExpiration();
                if (object.expiredKeyEpoch != null)
                    message.expiredKeyEpoch = object.expiredKeyEpoch | 0;
                return message;
            };

            /**
             * Creates a plain object from a KeyExpiration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.KeyExpiration
             * @static
             * @param {proto.SyncActionValue.KeyExpiration} message KeyExpiration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyExpiration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.expiredKeyEpoch = 0;
                if (message.expiredKeyEpoch != null && message.hasOwnProperty("expiredKeyEpoch"))
                    object.expiredKeyEpoch = message.expiredKeyEpoch;
                return object;
            };

            /**
             * Converts this KeyExpiration to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.KeyExpiration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyExpiration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeyExpiration;
        })();

        SyncActionValue.LabelAssociationAction = (function() {

            /**
             * Properties of a LabelAssociationAction.
             * @memberof proto.SyncActionValue
             * @interface ILabelAssociationAction
             * @property {boolean|null} [labeled] LabelAssociationAction labeled
             */

            /**
             * Constructs a new LabelAssociationAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a LabelAssociationAction.
             * @implements ILabelAssociationAction
             * @constructor
             * @param {proto.SyncActionValue.ILabelAssociationAction=} [properties] Properties to set
             */
            function LabelAssociationAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LabelAssociationAction labeled.
             * @member {boolean} labeled
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @instance
             */
            LabelAssociationAction.prototype.labeled = false;

            /**
             * Creates a new LabelAssociationAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @static
             * @param {proto.SyncActionValue.ILabelAssociationAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.LabelAssociationAction} LabelAssociationAction instance
             */
            LabelAssociationAction.create = function create(properties) {
                return new LabelAssociationAction(properties);
            };

            /**
             * Encodes the specified LabelAssociationAction message. Does not implicitly {@link proto.SyncActionValue.LabelAssociationAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @static
             * @param {proto.SyncActionValue.ILabelAssociationAction} message LabelAssociationAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelAssociationAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.labeled != null && Object.hasOwnProperty.call(message, "labeled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.labeled);
                return writer;
            };

            /**
             * Encodes the specified LabelAssociationAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.LabelAssociationAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @static
             * @param {proto.SyncActionValue.ILabelAssociationAction} message LabelAssociationAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelAssociationAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LabelAssociationAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.LabelAssociationAction} LabelAssociationAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelAssociationAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.LabelAssociationAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.labeled = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LabelAssociationAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.LabelAssociationAction} LabelAssociationAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelAssociationAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LabelAssociationAction message.
             * @function verify
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LabelAssociationAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.labeled != null && message.hasOwnProperty("labeled"))
                    if (typeof message.labeled !== "boolean")
                        return "labeled: boolean expected";
                return null;
            };

            /**
             * Creates a LabelAssociationAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.LabelAssociationAction} LabelAssociationAction
             */
            LabelAssociationAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.LabelAssociationAction)
                    return object;
                var message = new $root.proto.SyncActionValue.LabelAssociationAction();
                if (object.labeled != null)
                    message.labeled = Boolean(object.labeled);
                return message;
            };

            /**
             * Creates a plain object from a LabelAssociationAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @static
             * @param {proto.SyncActionValue.LabelAssociationAction} message LabelAssociationAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LabelAssociationAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.labeled = false;
                if (message.labeled != null && message.hasOwnProperty("labeled"))
                    object.labeled = message.labeled;
                return object;
            };

            /**
             * Converts this LabelAssociationAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.LabelAssociationAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LabelAssociationAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LabelAssociationAction;
        })();

        SyncActionValue.LabelEditAction = (function() {

            /**
             * Properties of a LabelEditAction.
             * @memberof proto.SyncActionValue
             * @interface ILabelEditAction
             * @property {string|null} [name] LabelEditAction name
             * @property {number|null} [color] LabelEditAction color
             * @property {number|null} [predefinedId] LabelEditAction predefinedId
             * @property {boolean|null} [deleted] LabelEditAction deleted
             */

            /**
             * Constructs a new LabelEditAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a LabelEditAction.
             * @implements ILabelEditAction
             * @constructor
             * @param {proto.SyncActionValue.ILabelEditAction=} [properties] Properties to set
             */
            function LabelEditAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LabelEditAction name.
             * @member {string} name
             * @memberof proto.SyncActionValue.LabelEditAction
             * @instance
             */
            LabelEditAction.prototype.name = "";

            /**
             * LabelEditAction color.
             * @member {number} color
             * @memberof proto.SyncActionValue.LabelEditAction
             * @instance
             */
            LabelEditAction.prototype.color = 0;

            /**
             * LabelEditAction predefinedId.
             * @member {number} predefinedId
             * @memberof proto.SyncActionValue.LabelEditAction
             * @instance
             */
            LabelEditAction.prototype.predefinedId = 0;

            /**
             * LabelEditAction deleted.
             * @member {boolean} deleted
             * @memberof proto.SyncActionValue.LabelEditAction
             * @instance
             */
            LabelEditAction.prototype.deleted = false;

            /**
             * Creates a new LabelEditAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.LabelEditAction
             * @static
             * @param {proto.SyncActionValue.ILabelEditAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.LabelEditAction} LabelEditAction instance
             */
            LabelEditAction.create = function create(properties) {
                return new LabelEditAction(properties);
            };

            /**
             * Encodes the specified LabelEditAction message. Does not implicitly {@link proto.SyncActionValue.LabelEditAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.LabelEditAction
             * @static
             * @param {proto.SyncActionValue.ILabelEditAction} message LabelEditAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelEditAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
                if (message.predefinedId != null && Object.hasOwnProperty.call(message, "predefinedId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.predefinedId);
                if (message.deleted != null && Object.hasOwnProperty.call(message, "deleted"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.deleted);
                return writer;
            };

            /**
             * Encodes the specified LabelEditAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.LabelEditAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.LabelEditAction
             * @static
             * @param {proto.SyncActionValue.ILabelEditAction} message LabelEditAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelEditAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LabelEditAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.LabelEditAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.LabelEditAction} LabelEditAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelEditAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.LabelEditAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.color = reader.int32();
                        break;
                    case 3:
                        message.predefinedId = reader.int32();
                        break;
                    case 4:
                        message.deleted = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LabelEditAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.LabelEditAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.LabelEditAction} LabelEditAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelEditAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LabelEditAction message.
             * @function verify
             * @memberof proto.SyncActionValue.LabelEditAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LabelEditAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color))
                        return "color: integer expected";
                if (message.predefinedId != null && message.hasOwnProperty("predefinedId"))
                    if (!$util.isInteger(message.predefinedId))
                        return "predefinedId: integer expected";
                if (message.deleted != null && message.hasOwnProperty("deleted"))
                    if (typeof message.deleted !== "boolean")
                        return "deleted: boolean expected";
                return null;
            };

            /**
             * Creates a LabelEditAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.LabelEditAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.LabelEditAction} LabelEditAction
             */
            LabelEditAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.LabelEditAction)
                    return object;
                var message = new $root.proto.SyncActionValue.LabelEditAction();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null)
                    message.color = object.color | 0;
                if (object.predefinedId != null)
                    message.predefinedId = object.predefinedId | 0;
                if (object.deleted != null)
                    message.deleted = Boolean(object.deleted);
                return message;
            };

            /**
             * Creates a plain object from a LabelEditAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.LabelEditAction
             * @static
             * @param {proto.SyncActionValue.LabelEditAction} message LabelEditAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LabelEditAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.color = 0;
                    object.predefinedId = 0;
                    object.deleted = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = message.color;
                if (message.predefinedId != null && message.hasOwnProperty("predefinedId"))
                    object.predefinedId = message.predefinedId;
                if (message.deleted != null && message.hasOwnProperty("deleted"))
                    object.deleted = message.deleted;
                return object;
            };

            /**
             * Converts this LabelEditAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.LabelEditAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LabelEditAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LabelEditAction;
        })();

        SyncActionValue.LocaleSetting = (function() {

            /**
             * Properties of a LocaleSetting.
             * @memberof proto.SyncActionValue
             * @interface ILocaleSetting
             * @property {string|null} [locale] LocaleSetting locale
             */

            /**
             * Constructs a new LocaleSetting.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a LocaleSetting.
             * @implements ILocaleSetting
             * @constructor
             * @param {proto.SyncActionValue.ILocaleSetting=} [properties] Properties to set
             */
            function LocaleSetting(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocaleSetting locale.
             * @member {string} locale
             * @memberof proto.SyncActionValue.LocaleSetting
             * @instance
             */
            LocaleSetting.prototype.locale = "";

            /**
             * Creates a new LocaleSetting instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.LocaleSetting
             * @static
             * @param {proto.SyncActionValue.ILocaleSetting=} [properties] Properties to set
             * @returns {proto.SyncActionValue.LocaleSetting} LocaleSetting instance
             */
            LocaleSetting.create = function create(properties) {
                return new LocaleSetting(properties);
            };

            /**
             * Encodes the specified LocaleSetting message. Does not implicitly {@link proto.SyncActionValue.LocaleSetting.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.LocaleSetting
             * @static
             * @param {proto.SyncActionValue.ILocaleSetting} message LocaleSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocaleSetting.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.locale);
                return writer;
            };

            /**
             * Encodes the specified LocaleSetting message, length delimited. Does not implicitly {@link proto.SyncActionValue.LocaleSetting.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.LocaleSetting
             * @static
             * @param {proto.SyncActionValue.ILocaleSetting} message LocaleSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocaleSetting.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocaleSetting message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.LocaleSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.LocaleSetting} LocaleSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocaleSetting.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.LocaleSetting();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.locale = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocaleSetting message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.LocaleSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.LocaleSetting} LocaleSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocaleSetting.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocaleSetting message.
             * @function verify
             * @memberof proto.SyncActionValue.LocaleSetting
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocaleSetting.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.locale != null && message.hasOwnProperty("locale"))
                    if (!$util.isString(message.locale))
                        return "locale: string expected";
                return null;
            };

            /**
             * Creates a LocaleSetting message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.LocaleSetting
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.LocaleSetting} LocaleSetting
             */
            LocaleSetting.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.LocaleSetting)
                    return object;
                var message = new $root.proto.SyncActionValue.LocaleSetting();
                if (object.locale != null)
                    message.locale = String(object.locale);
                return message;
            };

            /**
             * Creates a plain object from a LocaleSetting message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.LocaleSetting
             * @static
             * @param {proto.SyncActionValue.LocaleSetting} message LocaleSetting
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocaleSetting.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.locale = "";
                if (message.locale != null && message.hasOwnProperty("locale"))
                    object.locale = message.locale;
                return object;
            };

            /**
             * Converts this LocaleSetting to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.LocaleSetting
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocaleSetting.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocaleSetting;
        })();

        SyncActionValue.MarkChatAsReadAction = (function() {

            /**
             * Properties of a MarkChatAsReadAction.
             * @memberof proto.SyncActionValue
             * @interface IMarkChatAsReadAction
             * @property {boolean|null} [read] MarkChatAsReadAction read
             * @property {proto.SyncActionValue.ISyncActionMessageRange|null} [messageRange] MarkChatAsReadAction messageRange
             */

            /**
             * Constructs a new MarkChatAsReadAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a MarkChatAsReadAction.
             * @implements IMarkChatAsReadAction
             * @constructor
             * @param {proto.SyncActionValue.IMarkChatAsReadAction=} [properties] Properties to set
             */
            function MarkChatAsReadAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarkChatAsReadAction read.
             * @member {boolean} read
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @instance
             */
            MarkChatAsReadAction.prototype.read = false;

            /**
             * MarkChatAsReadAction messageRange.
             * @member {proto.SyncActionValue.ISyncActionMessageRange|null|undefined} messageRange
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @instance
             */
            MarkChatAsReadAction.prototype.messageRange = null;

            /**
             * Creates a new MarkChatAsReadAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @static
             * @param {proto.SyncActionValue.IMarkChatAsReadAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.MarkChatAsReadAction} MarkChatAsReadAction instance
             */
            MarkChatAsReadAction.create = function create(properties) {
                return new MarkChatAsReadAction(properties);
            };

            /**
             * Encodes the specified MarkChatAsReadAction message. Does not implicitly {@link proto.SyncActionValue.MarkChatAsReadAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @static
             * @param {proto.SyncActionValue.IMarkChatAsReadAction} message MarkChatAsReadAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkChatAsReadAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.read);
                if (message.messageRange != null && Object.hasOwnProperty.call(message, "messageRange"))
                    $root.proto.SyncActionValue.SyncActionMessageRange.encode(message.messageRange, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MarkChatAsReadAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.MarkChatAsReadAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @static
             * @param {proto.SyncActionValue.IMarkChatAsReadAction} message MarkChatAsReadAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkChatAsReadAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarkChatAsReadAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.MarkChatAsReadAction} MarkChatAsReadAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkChatAsReadAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.MarkChatAsReadAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.read = reader.bool();
                        break;
                    case 2:
                        message.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarkChatAsReadAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.MarkChatAsReadAction} MarkChatAsReadAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkChatAsReadAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarkChatAsReadAction message.
             * @function verify
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarkChatAsReadAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.read != null && message.hasOwnProperty("read"))
                    if (typeof message.read !== "boolean")
                        return "read: boolean expected";
                if (message.messageRange != null && message.hasOwnProperty("messageRange")) {
                    var error = $root.proto.SyncActionValue.SyncActionMessageRange.verify(message.messageRange);
                    if (error)
                        return "messageRange." + error;
                }
                return null;
            };

            /**
             * Creates a MarkChatAsReadAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.MarkChatAsReadAction} MarkChatAsReadAction
             */
            MarkChatAsReadAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.MarkChatAsReadAction)
                    return object;
                var message = new $root.proto.SyncActionValue.MarkChatAsReadAction();
                if (object.read != null)
                    message.read = Boolean(object.read);
                if (object.messageRange != null) {
                    if (typeof object.messageRange !== "object")
                        throw TypeError(".proto.SyncActionValue.MarkChatAsReadAction.messageRange: object expected");
                    message.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.fromObject(object.messageRange);
                }
                return message;
            };

            /**
             * Creates a plain object from a MarkChatAsReadAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @static
             * @param {proto.SyncActionValue.MarkChatAsReadAction} message MarkChatAsReadAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarkChatAsReadAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.read = false;
                    object.messageRange = null;
                }
                if (message.read != null && message.hasOwnProperty("read"))
                    object.read = message.read;
                if (message.messageRange != null && message.hasOwnProperty("messageRange"))
                    object.messageRange = $root.proto.SyncActionValue.SyncActionMessageRange.toObject(message.messageRange, options);
                return object;
            };

            /**
             * Converts this MarkChatAsReadAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.MarkChatAsReadAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarkChatAsReadAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MarkChatAsReadAction;
        })();

        SyncActionValue.MuteAction = (function() {

            /**
             * Properties of a MuteAction.
             * @memberof proto.SyncActionValue
             * @interface IMuteAction
             * @property {boolean|null} [muted] MuteAction muted
             * @property {number|Long|null} [muteEndTimestamp] MuteAction muteEndTimestamp
             * @property {boolean|null} [autoMuted] MuteAction autoMuted
             */

            /**
             * Constructs a new MuteAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a MuteAction.
             * @implements IMuteAction
             * @constructor
             * @param {proto.SyncActionValue.IMuteAction=} [properties] Properties to set
             */
            function MuteAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MuteAction muted.
             * @member {boolean} muted
             * @memberof proto.SyncActionValue.MuteAction
             * @instance
             */
            MuteAction.prototype.muted = false;

            /**
             * MuteAction muteEndTimestamp.
             * @member {number|Long} muteEndTimestamp
             * @memberof proto.SyncActionValue.MuteAction
             * @instance
             */
            MuteAction.prototype.muteEndTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MuteAction autoMuted.
             * @member {boolean} autoMuted
             * @memberof proto.SyncActionValue.MuteAction
             * @instance
             */
            MuteAction.prototype.autoMuted = false;

            /**
             * Creates a new MuteAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.MuteAction
             * @static
             * @param {proto.SyncActionValue.IMuteAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.MuteAction} MuteAction instance
             */
            MuteAction.create = function create(properties) {
                return new MuteAction(properties);
            };

            /**
             * Encodes the specified MuteAction message. Does not implicitly {@link proto.SyncActionValue.MuteAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.MuteAction
             * @static
             * @param {proto.SyncActionValue.IMuteAction} message MuteAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MuteAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.muted != null && Object.hasOwnProperty.call(message, "muted"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.muted);
                if (message.muteEndTimestamp != null && Object.hasOwnProperty.call(message, "muteEndTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.muteEndTimestamp);
                if (message.autoMuted != null && Object.hasOwnProperty.call(message, "autoMuted"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.autoMuted);
                return writer;
            };

            /**
             * Encodes the specified MuteAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.MuteAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.MuteAction
             * @static
             * @param {proto.SyncActionValue.IMuteAction} message MuteAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MuteAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MuteAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.MuteAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.MuteAction} MuteAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MuteAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.MuteAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.muted = reader.bool();
                        break;
                    case 2:
                        message.muteEndTimestamp = reader.int64();
                        break;
                    case 3:
                        message.autoMuted = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MuteAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.MuteAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.MuteAction} MuteAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MuteAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MuteAction message.
             * @function verify
             * @memberof proto.SyncActionValue.MuteAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MuteAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.muted != null && message.hasOwnProperty("muted"))
                    if (typeof message.muted !== "boolean")
                        return "muted: boolean expected";
                if (message.muteEndTimestamp != null && message.hasOwnProperty("muteEndTimestamp"))
                    if (!$util.isInteger(message.muteEndTimestamp) && !(message.muteEndTimestamp && $util.isInteger(message.muteEndTimestamp.low) && $util.isInteger(message.muteEndTimestamp.high)))
                        return "muteEndTimestamp: integer|Long expected";
                if (message.autoMuted != null && message.hasOwnProperty("autoMuted"))
                    if (typeof message.autoMuted !== "boolean")
                        return "autoMuted: boolean expected";
                return null;
            };

            /**
             * Creates a MuteAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.MuteAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.MuteAction} MuteAction
             */
            MuteAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.MuteAction)
                    return object;
                var message = new $root.proto.SyncActionValue.MuteAction();
                if (object.muted != null)
                    message.muted = Boolean(object.muted);
                if (object.muteEndTimestamp != null)
                    if ($util.Long)
                        (message.muteEndTimestamp = $util.Long.fromValue(object.muteEndTimestamp)).unsigned = false;
                    else if (typeof object.muteEndTimestamp === "string")
                        message.muteEndTimestamp = parseInt(object.muteEndTimestamp, 10);
                    else if (typeof object.muteEndTimestamp === "number")
                        message.muteEndTimestamp = object.muteEndTimestamp;
                    else if (typeof object.muteEndTimestamp === "object")
                        message.muteEndTimestamp = new $util.LongBits(object.muteEndTimestamp.low >>> 0, object.muteEndTimestamp.high >>> 0).toNumber();
                if (object.autoMuted != null)
                    message.autoMuted = Boolean(object.autoMuted);
                return message;
            };

            /**
             * Creates a plain object from a MuteAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.MuteAction
             * @static
             * @param {proto.SyncActionValue.MuteAction} message MuteAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MuteAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.muted = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.muteEndTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.muteEndTimestamp = options.longs === String ? "0" : 0;
                    object.autoMuted = false;
                }
                if (message.muted != null && message.hasOwnProperty("muted"))
                    object.muted = message.muted;
                if (message.muteEndTimestamp != null && message.hasOwnProperty("muteEndTimestamp"))
                    if (typeof message.muteEndTimestamp === "number")
                        object.muteEndTimestamp = options.longs === String ? String(message.muteEndTimestamp) : message.muteEndTimestamp;
                    else
                        object.muteEndTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.muteEndTimestamp) : options.longs === Number ? new $util.LongBits(message.muteEndTimestamp.low >>> 0, message.muteEndTimestamp.high >>> 0).toNumber() : message.muteEndTimestamp;
                if (message.autoMuted != null && message.hasOwnProperty("autoMuted"))
                    object.autoMuted = message.autoMuted;
                return object;
            };

            /**
             * Converts this MuteAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.MuteAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MuteAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MuteAction;
        })();

        SyncActionValue.NuxAction = (function() {

            /**
             * Properties of a NuxAction.
             * @memberof proto.SyncActionValue
             * @interface INuxAction
             * @property {boolean|null} [acknowledged] NuxAction acknowledged
             */

            /**
             * Constructs a new NuxAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a NuxAction.
             * @implements INuxAction
             * @constructor
             * @param {proto.SyncActionValue.INuxAction=} [properties] Properties to set
             */
            function NuxAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NuxAction acknowledged.
             * @member {boolean} acknowledged
             * @memberof proto.SyncActionValue.NuxAction
             * @instance
             */
            NuxAction.prototype.acknowledged = false;

            /**
             * Creates a new NuxAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.NuxAction
             * @static
             * @param {proto.SyncActionValue.INuxAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.NuxAction} NuxAction instance
             */
            NuxAction.create = function create(properties) {
                return new NuxAction(properties);
            };

            /**
             * Encodes the specified NuxAction message. Does not implicitly {@link proto.SyncActionValue.NuxAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.NuxAction
             * @static
             * @param {proto.SyncActionValue.INuxAction} message NuxAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NuxAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.acknowledged != null && Object.hasOwnProperty.call(message, "acknowledged"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.acknowledged);
                return writer;
            };

            /**
             * Encodes the specified NuxAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.NuxAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.NuxAction
             * @static
             * @param {proto.SyncActionValue.INuxAction} message NuxAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NuxAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NuxAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.NuxAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.NuxAction} NuxAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NuxAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.NuxAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.acknowledged = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NuxAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.NuxAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.NuxAction} NuxAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NuxAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NuxAction message.
             * @function verify
             * @memberof proto.SyncActionValue.NuxAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NuxAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.acknowledged != null && message.hasOwnProperty("acknowledged"))
                    if (typeof message.acknowledged !== "boolean")
                        return "acknowledged: boolean expected";
                return null;
            };

            /**
             * Creates a NuxAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.NuxAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.NuxAction} NuxAction
             */
            NuxAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.NuxAction)
                    return object;
                var message = new $root.proto.SyncActionValue.NuxAction();
                if (object.acknowledged != null)
                    message.acknowledged = Boolean(object.acknowledged);
                return message;
            };

            /**
             * Creates a plain object from a NuxAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.NuxAction
             * @static
             * @param {proto.SyncActionValue.NuxAction} message NuxAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NuxAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.acknowledged = false;
                if (message.acknowledged != null && message.hasOwnProperty("acknowledged"))
                    object.acknowledged = message.acknowledged;
                return object;
            };

            /**
             * Converts this NuxAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.NuxAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NuxAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NuxAction;
        })();

        SyncActionValue.PinAction = (function() {

            /**
             * Properties of a PinAction.
             * @memberof proto.SyncActionValue
             * @interface IPinAction
             * @property {boolean|null} [pinned] PinAction pinned
             */

            /**
             * Constructs a new PinAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a PinAction.
             * @implements IPinAction
             * @constructor
             * @param {proto.SyncActionValue.IPinAction=} [properties] Properties to set
             */
            function PinAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PinAction pinned.
             * @member {boolean} pinned
             * @memberof proto.SyncActionValue.PinAction
             * @instance
             */
            PinAction.prototype.pinned = false;

            /**
             * Creates a new PinAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.PinAction
             * @static
             * @param {proto.SyncActionValue.IPinAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.PinAction} PinAction instance
             */
            PinAction.create = function create(properties) {
                return new PinAction(properties);
            };

            /**
             * Encodes the specified PinAction message. Does not implicitly {@link proto.SyncActionValue.PinAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.PinAction
             * @static
             * @param {proto.SyncActionValue.IPinAction} message PinAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PinAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pinned != null && Object.hasOwnProperty.call(message, "pinned"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.pinned);
                return writer;
            };

            /**
             * Encodes the specified PinAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.PinAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.PinAction
             * @static
             * @param {proto.SyncActionValue.IPinAction} message PinAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PinAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PinAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.PinAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.PinAction} PinAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PinAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.PinAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pinned = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PinAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.PinAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.PinAction} PinAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PinAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PinAction message.
             * @function verify
             * @memberof proto.SyncActionValue.PinAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PinAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pinned != null && message.hasOwnProperty("pinned"))
                    if (typeof message.pinned !== "boolean")
                        return "pinned: boolean expected";
                return null;
            };

            /**
             * Creates a PinAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.PinAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.PinAction} PinAction
             */
            PinAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.PinAction)
                    return object;
                var message = new $root.proto.SyncActionValue.PinAction();
                if (object.pinned != null)
                    message.pinned = Boolean(object.pinned);
                return message;
            };

            /**
             * Creates a plain object from a PinAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.PinAction
             * @static
             * @param {proto.SyncActionValue.PinAction} message PinAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PinAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.pinned = false;
                if (message.pinned != null && message.hasOwnProperty("pinned"))
                    object.pinned = message.pinned;
                return object;
            };

            /**
             * Converts this PinAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.PinAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PinAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PinAction;
        })();

        SyncActionValue.PrimaryFeature = (function() {

            /**
             * Properties of a PrimaryFeature.
             * @memberof proto.SyncActionValue
             * @interface IPrimaryFeature
             * @property {Array.<string>|null} [flags] PrimaryFeature flags
             */

            /**
             * Constructs a new PrimaryFeature.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a PrimaryFeature.
             * @implements IPrimaryFeature
             * @constructor
             * @param {proto.SyncActionValue.IPrimaryFeature=} [properties] Properties to set
             */
            function PrimaryFeature(properties) {
                this.flags = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrimaryFeature flags.
             * @member {Array.<string>} flags
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @instance
             */
            PrimaryFeature.prototype.flags = $util.emptyArray;

            /**
             * Creates a new PrimaryFeature instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @static
             * @param {proto.SyncActionValue.IPrimaryFeature=} [properties] Properties to set
             * @returns {proto.SyncActionValue.PrimaryFeature} PrimaryFeature instance
             */
            PrimaryFeature.create = function create(properties) {
                return new PrimaryFeature(properties);
            };

            /**
             * Encodes the specified PrimaryFeature message. Does not implicitly {@link proto.SyncActionValue.PrimaryFeature.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @static
             * @param {proto.SyncActionValue.IPrimaryFeature} message PrimaryFeature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrimaryFeature.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flags != null && message.flags.length)
                    for (var i = 0; i < message.flags.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.flags[i]);
                return writer;
            };

            /**
             * Encodes the specified PrimaryFeature message, length delimited. Does not implicitly {@link proto.SyncActionValue.PrimaryFeature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @static
             * @param {proto.SyncActionValue.IPrimaryFeature} message PrimaryFeature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrimaryFeature.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrimaryFeature message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.PrimaryFeature} PrimaryFeature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrimaryFeature.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.PrimaryFeature();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.flags && message.flags.length))
                            message.flags = [];
                        message.flags.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrimaryFeature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.PrimaryFeature} PrimaryFeature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrimaryFeature.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrimaryFeature message.
             * @function verify
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrimaryFeature.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flags != null && message.hasOwnProperty("flags")) {
                    if (!Array.isArray(message.flags))
                        return "flags: array expected";
                    for (var i = 0; i < message.flags.length; ++i)
                        if (!$util.isString(message.flags[i]))
                            return "flags: string[] expected";
                }
                return null;
            };

            /**
             * Creates a PrimaryFeature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.PrimaryFeature} PrimaryFeature
             */
            PrimaryFeature.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.PrimaryFeature)
                    return object;
                var message = new $root.proto.SyncActionValue.PrimaryFeature();
                if (object.flags) {
                    if (!Array.isArray(object.flags))
                        throw TypeError(".proto.SyncActionValue.PrimaryFeature.flags: array expected");
                    message.flags = [];
                    for (var i = 0; i < object.flags.length; ++i)
                        message.flags[i] = String(object.flags[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a PrimaryFeature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @static
             * @param {proto.SyncActionValue.PrimaryFeature} message PrimaryFeature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrimaryFeature.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.flags = [];
                if (message.flags && message.flags.length) {
                    object.flags = [];
                    for (var j = 0; j < message.flags.length; ++j)
                        object.flags[j] = message.flags[j];
                }
                return object;
            };

            /**
             * Converts this PrimaryFeature to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.PrimaryFeature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrimaryFeature.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrimaryFeature;
        })();

        SyncActionValue.PrimaryVersionAction = (function() {

            /**
             * Properties of a PrimaryVersionAction.
             * @memberof proto.SyncActionValue
             * @interface IPrimaryVersionAction
             * @property {string|null} [version] PrimaryVersionAction version
             */

            /**
             * Constructs a new PrimaryVersionAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a PrimaryVersionAction.
             * @implements IPrimaryVersionAction
             * @constructor
             * @param {proto.SyncActionValue.IPrimaryVersionAction=} [properties] Properties to set
             */
            function PrimaryVersionAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrimaryVersionAction version.
             * @member {string} version
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @instance
             */
            PrimaryVersionAction.prototype.version = "";

            /**
             * Creates a new PrimaryVersionAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @static
             * @param {proto.SyncActionValue.IPrimaryVersionAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.PrimaryVersionAction} PrimaryVersionAction instance
             */
            PrimaryVersionAction.create = function create(properties) {
                return new PrimaryVersionAction(properties);
            };

            /**
             * Encodes the specified PrimaryVersionAction message. Does not implicitly {@link proto.SyncActionValue.PrimaryVersionAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @static
             * @param {proto.SyncActionValue.IPrimaryVersionAction} message PrimaryVersionAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrimaryVersionAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                return writer;
            };

            /**
             * Encodes the specified PrimaryVersionAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.PrimaryVersionAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @static
             * @param {proto.SyncActionValue.IPrimaryVersionAction} message PrimaryVersionAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrimaryVersionAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrimaryVersionAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.PrimaryVersionAction} PrimaryVersionAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrimaryVersionAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.PrimaryVersionAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrimaryVersionAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.PrimaryVersionAction} PrimaryVersionAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrimaryVersionAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrimaryVersionAction message.
             * @function verify
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrimaryVersionAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                return null;
            };

            /**
             * Creates a PrimaryVersionAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.PrimaryVersionAction} PrimaryVersionAction
             */
            PrimaryVersionAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.PrimaryVersionAction)
                    return object;
                var message = new $root.proto.SyncActionValue.PrimaryVersionAction();
                if (object.version != null)
                    message.version = String(object.version);
                return message;
            };

            /**
             * Creates a plain object from a PrimaryVersionAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @static
             * @param {proto.SyncActionValue.PrimaryVersionAction} message PrimaryVersionAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrimaryVersionAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.version = "";
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };

            /**
             * Converts this PrimaryVersionAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.PrimaryVersionAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrimaryVersionAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrimaryVersionAction;
        })();

        SyncActionValue.PushNameSetting = (function() {

            /**
             * Properties of a PushNameSetting.
             * @memberof proto.SyncActionValue
             * @interface IPushNameSetting
             * @property {string|null} [name] PushNameSetting name
             */

            /**
             * Constructs a new PushNameSetting.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a PushNameSetting.
             * @implements IPushNameSetting
             * @constructor
             * @param {proto.SyncActionValue.IPushNameSetting=} [properties] Properties to set
             */
            function PushNameSetting(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PushNameSetting name.
             * @member {string} name
             * @memberof proto.SyncActionValue.PushNameSetting
             * @instance
             */
            PushNameSetting.prototype.name = "";

            /**
             * Creates a new PushNameSetting instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.PushNameSetting
             * @static
             * @param {proto.SyncActionValue.IPushNameSetting=} [properties] Properties to set
             * @returns {proto.SyncActionValue.PushNameSetting} PushNameSetting instance
             */
            PushNameSetting.create = function create(properties) {
                return new PushNameSetting(properties);
            };

            /**
             * Encodes the specified PushNameSetting message. Does not implicitly {@link proto.SyncActionValue.PushNameSetting.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.PushNameSetting
             * @static
             * @param {proto.SyncActionValue.IPushNameSetting} message PushNameSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushNameSetting.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified PushNameSetting message, length delimited. Does not implicitly {@link proto.SyncActionValue.PushNameSetting.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.PushNameSetting
             * @static
             * @param {proto.SyncActionValue.IPushNameSetting} message PushNameSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushNameSetting.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushNameSetting message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.PushNameSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.PushNameSetting} PushNameSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushNameSetting.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.PushNameSetting();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PushNameSetting message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.PushNameSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.PushNameSetting} PushNameSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushNameSetting.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushNameSetting message.
             * @function verify
             * @memberof proto.SyncActionValue.PushNameSetting
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushNameSetting.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a PushNameSetting message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.PushNameSetting
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.PushNameSetting} PushNameSetting
             */
            PushNameSetting.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.PushNameSetting)
                    return object;
                var message = new $root.proto.SyncActionValue.PushNameSetting();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a PushNameSetting message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.PushNameSetting
             * @static
             * @param {proto.SyncActionValue.PushNameSetting} message PushNameSetting
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PushNameSetting.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this PushNameSetting to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.PushNameSetting
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PushNameSetting.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PushNameSetting;
        })();

        SyncActionValue.QuickReplyAction = (function() {

            /**
             * Properties of a QuickReplyAction.
             * @memberof proto.SyncActionValue
             * @interface IQuickReplyAction
             * @property {string|null} [shortcut] QuickReplyAction shortcut
             * @property {string|null} [message] QuickReplyAction message
             * @property {Array.<string>|null} [keywords] QuickReplyAction keywords
             * @property {number|null} [count] QuickReplyAction count
             * @property {boolean|null} [deleted] QuickReplyAction deleted
             */

            /**
             * Constructs a new QuickReplyAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a QuickReplyAction.
             * @implements IQuickReplyAction
             * @constructor
             * @param {proto.SyncActionValue.IQuickReplyAction=} [properties] Properties to set
             */
            function QuickReplyAction(properties) {
                this.keywords = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QuickReplyAction shortcut.
             * @member {string} shortcut
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @instance
             */
            QuickReplyAction.prototype.shortcut = "";

            /**
             * QuickReplyAction message.
             * @member {string} message
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @instance
             */
            QuickReplyAction.prototype.message = "";

            /**
             * QuickReplyAction keywords.
             * @member {Array.<string>} keywords
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @instance
             */
            QuickReplyAction.prototype.keywords = $util.emptyArray;

            /**
             * QuickReplyAction count.
             * @member {number} count
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @instance
             */
            QuickReplyAction.prototype.count = 0;

            /**
             * QuickReplyAction deleted.
             * @member {boolean} deleted
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @instance
             */
            QuickReplyAction.prototype.deleted = false;

            /**
             * Creates a new QuickReplyAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @static
             * @param {proto.SyncActionValue.IQuickReplyAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.QuickReplyAction} QuickReplyAction instance
             */
            QuickReplyAction.create = function create(properties) {
                return new QuickReplyAction(properties);
            };

            /**
             * Encodes the specified QuickReplyAction message. Does not implicitly {@link proto.SyncActionValue.QuickReplyAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @static
             * @param {proto.SyncActionValue.IQuickReplyAction} message QuickReplyAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuickReplyAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.shortcut != null && Object.hasOwnProperty.call(message, "shortcut"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.shortcut);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.keywords != null && message.keywords.length)
                    for (var i = 0; i < message.keywords.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.keywords[i]);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
                if (message.deleted != null && Object.hasOwnProperty.call(message, "deleted"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.deleted);
                return writer;
            };

            /**
             * Encodes the specified QuickReplyAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.QuickReplyAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @static
             * @param {proto.SyncActionValue.IQuickReplyAction} message QuickReplyAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuickReplyAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QuickReplyAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.QuickReplyAction} QuickReplyAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuickReplyAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.QuickReplyAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.shortcut = reader.string();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        if (!(message.keywords && message.keywords.length))
                            message.keywords = [];
                        message.keywords.push(reader.string());
                        break;
                    case 4:
                        message.count = reader.int32();
                        break;
                    case 5:
                        message.deleted = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QuickReplyAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.QuickReplyAction} QuickReplyAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuickReplyAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QuickReplyAction message.
             * @function verify
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QuickReplyAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.shortcut != null && message.hasOwnProperty("shortcut"))
                    if (!$util.isString(message.shortcut))
                        return "shortcut: string expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.keywords != null && message.hasOwnProperty("keywords")) {
                    if (!Array.isArray(message.keywords))
                        return "keywords: array expected";
                    for (var i = 0; i < message.keywords.length; ++i)
                        if (!$util.isString(message.keywords[i]))
                            return "keywords: string[] expected";
                }
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                if (message.deleted != null && message.hasOwnProperty("deleted"))
                    if (typeof message.deleted !== "boolean")
                        return "deleted: boolean expected";
                return null;
            };

            /**
             * Creates a QuickReplyAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.QuickReplyAction} QuickReplyAction
             */
            QuickReplyAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.QuickReplyAction)
                    return object;
                var message = new $root.proto.SyncActionValue.QuickReplyAction();
                if (object.shortcut != null)
                    message.shortcut = String(object.shortcut);
                if (object.message != null)
                    message.message = String(object.message);
                if (object.keywords) {
                    if (!Array.isArray(object.keywords))
                        throw TypeError(".proto.SyncActionValue.QuickReplyAction.keywords: array expected");
                    message.keywords = [];
                    for (var i = 0; i < object.keywords.length; ++i)
                        message.keywords[i] = String(object.keywords[i]);
                }
                if (object.count != null)
                    message.count = object.count | 0;
                if (object.deleted != null)
                    message.deleted = Boolean(object.deleted);
                return message;
            };

            /**
             * Creates a plain object from a QuickReplyAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @static
             * @param {proto.SyncActionValue.QuickReplyAction} message QuickReplyAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QuickReplyAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.keywords = [];
                if (options.defaults) {
                    object.shortcut = "";
                    object.message = "";
                    object.count = 0;
                    object.deleted = false;
                }
                if (message.shortcut != null && message.hasOwnProperty("shortcut"))
                    object.shortcut = message.shortcut;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.keywords && message.keywords.length) {
                    object.keywords = [];
                    for (var j = 0; j < message.keywords.length; ++j)
                        object.keywords[j] = message.keywords[j];
                }
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                if (message.deleted != null && message.hasOwnProperty("deleted"))
                    object.deleted = message.deleted;
                return object;
            };

            /**
             * Converts this QuickReplyAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.QuickReplyAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QuickReplyAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QuickReplyAction;
        })();

        SyncActionValue.RecentEmojiWeightsAction = (function() {

            /**
             * Properties of a RecentEmojiWeightsAction.
             * @memberof proto.SyncActionValue
             * @interface IRecentEmojiWeightsAction
             * @property {Array.<proto.IRecentEmojiWeight>|null} [weights] RecentEmojiWeightsAction weights
             */

            /**
             * Constructs a new RecentEmojiWeightsAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a RecentEmojiWeightsAction.
             * @implements IRecentEmojiWeightsAction
             * @constructor
             * @param {proto.SyncActionValue.IRecentEmojiWeightsAction=} [properties] Properties to set
             */
            function RecentEmojiWeightsAction(properties) {
                this.weights = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RecentEmojiWeightsAction weights.
             * @member {Array.<proto.IRecentEmojiWeight>} weights
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @instance
             */
            RecentEmojiWeightsAction.prototype.weights = $util.emptyArray;

            /**
             * Creates a new RecentEmojiWeightsAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @static
             * @param {proto.SyncActionValue.IRecentEmojiWeightsAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.RecentEmojiWeightsAction} RecentEmojiWeightsAction instance
             */
            RecentEmojiWeightsAction.create = function create(properties) {
                return new RecentEmojiWeightsAction(properties);
            };

            /**
             * Encodes the specified RecentEmojiWeightsAction message. Does not implicitly {@link proto.SyncActionValue.RecentEmojiWeightsAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @static
             * @param {proto.SyncActionValue.IRecentEmojiWeightsAction} message RecentEmojiWeightsAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecentEmojiWeightsAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.weights != null && message.weights.length)
                    for (var i = 0; i < message.weights.length; ++i)
                        $root.proto.RecentEmojiWeight.encode(message.weights[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RecentEmojiWeightsAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.RecentEmojiWeightsAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @static
             * @param {proto.SyncActionValue.IRecentEmojiWeightsAction} message RecentEmojiWeightsAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecentEmojiWeightsAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecentEmojiWeightsAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.RecentEmojiWeightsAction} RecentEmojiWeightsAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecentEmojiWeightsAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.RecentEmojiWeightsAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.weights && message.weights.length))
                            message.weights = [];
                        message.weights.push($root.proto.RecentEmojiWeight.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RecentEmojiWeightsAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.RecentEmojiWeightsAction} RecentEmojiWeightsAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecentEmojiWeightsAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecentEmojiWeightsAction message.
             * @function verify
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecentEmojiWeightsAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.weights != null && message.hasOwnProperty("weights")) {
                    if (!Array.isArray(message.weights))
                        return "weights: array expected";
                    for (var i = 0; i < message.weights.length; ++i) {
                        var error = $root.proto.RecentEmojiWeight.verify(message.weights[i]);
                        if (error)
                            return "weights." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a RecentEmojiWeightsAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.RecentEmojiWeightsAction} RecentEmojiWeightsAction
             */
            RecentEmojiWeightsAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.RecentEmojiWeightsAction)
                    return object;
                var message = new $root.proto.SyncActionValue.RecentEmojiWeightsAction();
                if (object.weights) {
                    if (!Array.isArray(object.weights))
                        throw TypeError(".proto.SyncActionValue.RecentEmojiWeightsAction.weights: array expected");
                    message.weights = [];
                    for (var i = 0; i < object.weights.length; ++i) {
                        if (typeof object.weights[i] !== "object")
                            throw TypeError(".proto.SyncActionValue.RecentEmojiWeightsAction.weights: object expected");
                        message.weights[i] = $root.proto.RecentEmojiWeight.fromObject(object.weights[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a RecentEmojiWeightsAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @static
             * @param {proto.SyncActionValue.RecentEmojiWeightsAction} message RecentEmojiWeightsAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RecentEmojiWeightsAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.weights = [];
                if (message.weights && message.weights.length) {
                    object.weights = [];
                    for (var j = 0; j < message.weights.length; ++j)
                        object.weights[j] = $root.proto.RecentEmojiWeight.toObject(message.weights[j], options);
                }
                return object;
            };

            /**
             * Converts this RecentEmojiWeightsAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.RecentEmojiWeightsAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RecentEmojiWeightsAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RecentEmojiWeightsAction;
        })();

        SyncActionValue.RemoveRecentStickerAction = (function() {

            /**
             * Properties of a RemoveRecentStickerAction.
             * @memberof proto.SyncActionValue
             * @interface IRemoveRecentStickerAction
             * @property {number|Long|null} [lastStickerSentTs] RemoveRecentStickerAction lastStickerSentTs
             */

            /**
             * Constructs a new RemoveRecentStickerAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a RemoveRecentStickerAction.
             * @implements IRemoveRecentStickerAction
             * @constructor
             * @param {proto.SyncActionValue.IRemoveRecentStickerAction=} [properties] Properties to set
             */
            function RemoveRecentStickerAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RemoveRecentStickerAction lastStickerSentTs.
             * @member {number|Long} lastStickerSentTs
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @instance
             */
            RemoveRecentStickerAction.prototype.lastStickerSentTs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RemoveRecentStickerAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @static
             * @param {proto.SyncActionValue.IRemoveRecentStickerAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.RemoveRecentStickerAction} RemoveRecentStickerAction instance
             */
            RemoveRecentStickerAction.create = function create(properties) {
                return new RemoveRecentStickerAction(properties);
            };

            /**
             * Encodes the specified RemoveRecentStickerAction message. Does not implicitly {@link proto.SyncActionValue.RemoveRecentStickerAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @static
             * @param {proto.SyncActionValue.IRemoveRecentStickerAction} message RemoveRecentStickerAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveRecentStickerAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lastStickerSentTs != null && Object.hasOwnProperty.call(message, "lastStickerSentTs"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lastStickerSentTs);
                return writer;
            };

            /**
             * Encodes the specified RemoveRecentStickerAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.RemoveRecentStickerAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @static
             * @param {proto.SyncActionValue.IRemoveRecentStickerAction} message RemoveRecentStickerAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveRecentStickerAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RemoveRecentStickerAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.RemoveRecentStickerAction} RemoveRecentStickerAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveRecentStickerAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.RemoveRecentStickerAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lastStickerSentTs = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RemoveRecentStickerAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.RemoveRecentStickerAction} RemoveRecentStickerAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveRecentStickerAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RemoveRecentStickerAction message.
             * @function verify
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoveRecentStickerAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lastStickerSentTs != null && message.hasOwnProperty("lastStickerSentTs"))
                    if (!$util.isInteger(message.lastStickerSentTs) && !(message.lastStickerSentTs && $util.isInteger(message.lastStickerSentTs.low) && $util.isInteger(message.lastStickerSentTs.high)))
                        return "lastStickerSentTs: integer|Long expected";
                return null;
            };

            /**
             * Creates a RemoveRecentStickerAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.RemoveRecentStickerAction} RemoveRecentStickerAction
             */
            RemoveRecentStickerAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.RemoveRecentStickerAction)
                    return object;
                var message = new $root.proto.SyncActionValue.RemoveRecentStickerAction();
                if (object.lastStickerSentTs != null)
                    if ($util.Long)
                        (message.lastStickerSentTs = $util.Long.fromValue(object.lastStickerSentTs)).unsigned = false;
                    else if (typeof object.lastStickerSentTs === "string")
                        message.lastStickerSentTs = parseInt(object.lastStickerSentTs, 10);
                    else if (typeof object.lastStickerSentTs === "number")
                        message.lastStickerSentTs = object.lastStickerSentTs;
                    else if (typeof object.lastStickerSentTs === "object")
                        message.lastStickerSentTs = new $util.LongBits(object.lastStickerSentTs.low >>> 0, object.lastStickerSentTs.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a RemoveRecentStickerAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @static
             * @param {proto.SyncActionValue.RemoveRecentStickerAction} message RemoveRecentStickerAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoveRecentStickerAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastStickerSentTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastStickerSentTs = options.longs === String ? "0" : 0;
                if (message.lastStickerSentTs != null && message.hasOwnProperty("lastStickerSentTs"))
                    if (typeof message.lastStickerSentTs === "number")
                        object.lastStickerSentTs = options.longs === String ? String(message.lastStickerSentTs) : message.lastStickerSentTs;
                    else
                        object.lastStickerSentTs = options.longs === String ? $util.Long.prototype.toString.call(message.lastStickerSentTs) : options.longs === Number ? new $util.LongBits(message.lastStickerSentTs.low >>> 0, message.lastStickerSentTs.high >>> 0).toNumber() : message.lastStickerSentTs;
                return object;
            };

            /**
             * Converts this RemoveRecentStickerAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.RemoveRecentStickerAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoveRecentStickerAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RemoveRecentStickerAction;
        })();

        SyncActionValue.SecurityNotificationSetting = (function() {

            /**
             * Properties of a SecurityNotificationSetting.
             * @memberof proto.SyncActionValue
             * @interface ISecurityNotificationSetting
             * @property {boolean|null} [showNotification] SecurityNotificationSetting showNotification
             */

            /**
             * Constructs a new SecurityNotificationSetting.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a SecurityNotificationSetting.
             * @implements ISecurityNotificationSetting
             * @constructor
             * @param {proto.SyncActionValue.ISecurityNotificationSetting=} [properties] Properties to set
             */
            function SecurityNotificationSetting(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SecurityNotificationSetting showNotification.
             * @member {boolean} showNotification
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @instance
             */
            SecurityNotificationSetting.prototype.showNotification = false;

            /**
             * Creates a new SecurityNotificationSetting instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @static
             * @param {proto.SyncActionValue.ISecurityNotificationSetting=} [properties] Properties to set
             * @returns {proto.SyncActionValue.SecurityNotificationSetting} SecurityNotificationSetting instance
             */
            SecurityNotificationSetting.create = function create(properties) {
                return new SecurityNotificationSetting(properties);
            };

            /**
             * Encodes the specified SecurityNotificationSetting message. Does not implicitly {@link proto.SyncActionValue.SecurityNotificationSetting.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @static
             * @param {proto.SyncActionValue.ISecurityNotificationSetting} message SecurityNotificationSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecurityNotificationSetting.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.showNotification != null && Object.hasOwnProperty.call(message, "showNotification"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.showNotification);
                return writer;
            };

            /**
             * Encodes the specified SecurityNotificationSetting message, length delimited. Does not implicitly {@link proto.SyncActionValue.SecurityNotificationSetting.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @static
             * @param {proto.SyncActionValue.ISecurityNotificationSetting} message SecurityNotificationSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecurityNotificationSetting.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SecurityNotificationSetting message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.SecurityNotificationSetting} SecurityNotificationSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecurityNotificationSetting.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.SecurityNotificationSetting();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.showNotification = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SecurityNotificationSetting message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.SecurityNotificationSetting} SecurityNotificationSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecurityNotificationSetting.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SecurityNotificationSetting message.
             * @function verify
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SecurityNotificationSetting.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.showNotification != null && message.hasOwnProperty("showNotification"))
                    if (typeof message.showNotification !== "boolean")
                        return "showNotification: boolean expected";
                return null;
            };

            /**
             * Creates a SecurityNotificationSetting message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.SecurityNotificationSetting} SecurityNotificationSetting
             */
            SecurityNotificationSetting.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.SecurityNotificationSetting)
                    return object;
                var message = new $root.proto.SyncActionValue.SecurityNotificationSetting();
                if (object.showNotification != null)
                    message.showNotification = Boolean(object.showNotification);
                return message;
            };

            /**
             * Creates a plain object from a SecurityNotificationSetting message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @static
             * @param {proto.SyncActionValue.SecurityNotificationSetting} message SecurityNotificationSetting
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SecurityNotificationSetting.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.showNotification = false;
                if (message.showNotification != null && message.hasOwnProperty("showNotification"))
                    object.showNotification = message.showNotification;
                return object;
            };

            /**
             * Converts this SecurityNotificationSetting to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.SecurityNotificationSetting
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SecurityNotificationSetting.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SecurityNotificationSetting;
        })();

        SyncActionValue.StarAction = (function() {

            /**
             * Properties of a StarAction.
             * @memberof proto.SyncActionValue
             * @interface IStarAction
             * @property {boolean|null} [starred] StarAction starred
             */

            /**
             * Constructs a new StarAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a StarAction.
             * @implements IStarAction
             * @constructor
             * @param {proto.SyncActionValue.IStarAction=} [properties] Properties to set
             */
            function StarAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StarAction starred.
             * @member {boolean} starred
             * @memberof proto.SyncActionValue.StarAction
             * @instance
             */
            StarAction.prototype.starred = false;

            /**
             * Creates a new StarAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.StarAction
             * @static
             * @param {proto.SyncActionValue.IStarAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.StarAction} StarAction instance
             */
            StarAction.create = function create(properties) {
                return new StarAction(properties);
            };

            /**
             * Encodes the specified StarAction message. Does not implicitly {@link proto.SyncActionValue.StarAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.StarAction
             * @static
             * @param {proto.SyncActionValue.IStarAction} message StarAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StarAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.starred != null && Object.hasOwnProperty.call(message, "starred"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.starred);
                return writer;
            };

            /**
             * Encodes the specified StarAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.StarAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.StarAction
             * @static
             * @param {proto.SyncActionValue.IStarAction} message StarAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StarAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StarAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.StarAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.StarAction} StarAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StarAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.StarAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.starred = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StarAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.StarAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.StarAction} StarAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StarAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StarAction message.
             * @function verify
             * @memberof proto.SyncActionValue.StarAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StarAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.starred != null && message.hasOwnProperty("starred"))
                    if (typeof message.starred !== "boolean")
                        return "starred: boolean expected";
                return null;
            };

            /**
             * Creates a StarAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.StarAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.StarAction} StarAction
             */
            StarAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.StarAction)
                    return object;
                var message = new $root.proto.SyncActionValue.StarAction();
                if (object.starred != null)
                    message.starred = Boolean(object.starred);
                return message;
            };

            /**
             * Creates a plain object from a StarAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.StarAction
             * @static
             * @param {proto.SyncActionValue.StarAction} message StarAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StarAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.starred = false;
                if (message.starred != null && message.hasOwnProperty("starred"))
                    object.starred = message.starred;
                return object;
            };

            /**
             * Converts this StarAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.StarAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StarAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StarAction;
        })();

        SyncActionValue.StickerAction = (function() {

            /**
             * Properties of a StickerAction.
             * @memberof proto.SyncActionValue
             * @interface IStickerAction
             * @property {string|null} [url] StickerAction url
             * @property {Uint8Array|null} [fileEncSha256] StickerAction fileEncSha256
             * @property {Uint8Array|null} [mediaKey] StickerAction mediaKey
             * @property {string|null} [mimetype] StickerAction mimetype
             * @property {number|null} [height] StickerAction height
             * @property {number|null} [width] StickerAction width
             * @property {string|null} [directPath] StickerAction directPath
             * @property {number|Long|null} [fileLength] StickerAction fileLength
             * @property {boolean|null} [isFavorite] StickerAction isFavorite
             * @property {number|null} [deviceIdHint] StickerAction deviceIdHint
             */

            /**
             * Constructs a new StickerAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a StickerAction.
             * @implements IStickerAction
             * @constructor
             * @param {proto.SyncActionValue.IStickerAction=} [properties] Properties to set
             */
            function StickerAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StickerAction url.
             * @member {string} url
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.url = "";

            /**
             * StickerAction fileEncSha256.
             * @member {Uint8Array} fileEncSha256
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.fileEncSha256 = $util.newBuffer([]);

            /**
             * StickerAction mediaKey.
             * @member {Uint8Array} mediaKey
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.mediaKey = $util.newBuffer([]);

            /**
             * StickerAction mimetype.
             * @member {string} mimetype
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.mimetype = "";

            /**
             * StickerAction height.
             * @member {number} height
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.height = 0;

            /**
             * StickerAction width.
             * @member {number} width
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.width = 0;

            /**
             * StickerAction directPath.
             * @member {string} directPath
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.directPath = "";

            /**
             * StickerAction fileLength.
             * @member {number|Long} fileLength
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * StickerAction isFavorite.
             * @member {boolean} isFavorite
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.isFavorite = false;

            /**
             * StickerAction deviceIdHint.
             * @member {number} deviceIdHint
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             */
            StickerAction.prototype.deviceIdHint = 0;

            /**
             * Creates a new StickerAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.StickerAction
             * @static
             * @param {proto.SyncActionValue.IStickerAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.StickerAction} StickerAction instance
             */
            StickerAction.create = function create(properties) {
                return new StickerAction(properties);
            };

            /**
             * Encodes the specified StickerAction message. Does not implicitly {@link proto.SyncActionValue.StickerAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.StickerAction
             * @static
             * @param {proto.SyncActionValue.IStickerAction} message StickerAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.fileEncSha256);
                if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.mediaKey);
                if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.mimetype);
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.height);
                if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.width);
                if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.directPath);
                if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.fileLength);
                if (message.isFavorite != null && Object.hasOwnProperty.call(message, "isFavorite"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isFavorite);
                if (message.deviceIdHint != null && Object.hasOwnProperty.call(message, "deviceIdHint"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.deviceIdHint);
                return writer;
            };

            /**
             * Encodes the specified StickerAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.StickerAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.StickerAction
             * @static
             * @param {proto.SyncActionValue.IStickerAction} message StickerAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StickerAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StickerAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.StickerAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.StickerAction} StickerAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.StickerAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        message.fileEncSha256 = reader.bytes();
                        break;
                    case 3:
                        message.mediaKey = reader.bytes();
                        break;
                    case 4:
                        message.mimetype = reader.string();
                        break;
                    case 5:
                        message.height = reader.uint32();
                        break;
                    case 6:
                        message.width = reader.uint32();
                        break;
                    case 7:
                        message.directPath = reader.string();
                        break;
                    case 8:
                        message.fileLength = reader.uint64();
                        break;
                    case 9:
                        message.isFavorite = reader.bool();
                        break;
                    case 10:
                        message.deviceIdHint = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StickerAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.StickerAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.StickerAction} StickerAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StickerAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StickerAction message.
             * @function verify
             * @memberof proto.SyncActionValue.StickerAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StickerAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                        return "fileEncSha256: buffer expected";
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                        return "mediaKey: buffer expected";
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    if (!$util.isString(message.mimetype))
                        return "mimetype: string expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height))
                        return "height: integer expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    if (!$util.isString(message.directPath))
                        return "directPath: string expected";
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                        return "fileLength: integer|Long expected";
                if (message.isFavorite != null && message.hasOwnProperty("isFavorite"))
                    if (typeof message.isFavorite !== "boolean")
                        return "isFavorite: boolean expected";
                if (message.deviceIdHint != null && message.hasOwnProperty("deviceIdHint"))
                    if (!$util.isInteger(message.deviceIdHint))
                        return "deviceIdHint: integer expected";
                return null;
            };

            /**
             * Creates a StickerAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.StickerAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.StickerAction} StickerAction
             */
            StickerAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.StickerAction)
                    return object;
                var message = new $root.proto.SyncActionValue.StickerAction();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.fileEncSha256 != null)
                    if (typeof object.fileEncSha256 === "string")
                        $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                    else if (object.fileEncSha256.length)
                        message.fileEncSha256 = object.fileEncSha256;
                if (object.mediaKey != null)
                    if (typeof object.mediaKey === "string")
                        $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                    else if (object.mediaKey.length)
                        message.mediaKey = object.mediaKey;
                if (object.mimetype != null)
                    message.mimetype = String(object.mimetype);
                if (object.height != null)
                    message.height = object.height >>> 0;
                if (object.width != null)
                    message.width = object.width >>> 0;
                if (object.directPath != null)
                    message.directPath = String(object.directPath);
                if (object.fileLength != null)
                    if ($util.Long)
                        (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                    else if (typeof object.fileLength === "string")
                        message.fileLength = parseInt(object.fileLength, 10);
                    else if (typeof object.fileLength === "number")
                        message.fileLength = object.fileLength;
                    else if (typeof object.fileLength === "object")
                        message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
                if (object.isFavorite != null)
                    message.isFavorite = Boolean(object.isFavorite);
                if (object.deviceIdHint != null)
                    message.deviceIdHint = object.deviceIdHint >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a StickerAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.StickerAction
             * @static
             * @param {proto.SyncActionValue.StickerAction} message StickerAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StickerAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.url = "";
                    if (options.bytes === String)
                        object.fileEncSha256 = "";
                    else {
                        object.fileEncSha256 = [];
                        if (options.bytes !== Array)
                            object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                    }
                    if (options.bytes === String)
                        object.mediaKey = "";
                    else {
                        object.mediaKey = [];
                        if (options.bytes !== Array)
                            object.mediaKey = $util.newBuffer(object.mediaKey);
                    }
                    object.mimetype = "";
                    object.height = 0;
                    object.width = 0;
                    object.directPath = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileLength = options.longs === String ? "0" : 0;
                    object.isFavorite = false;
                    object.deviceIdHint = 0;
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                    object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
                if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                    object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
                if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                    object.mimetype = message.mimetype;
                if (message.height != null && message.hasOwnProperty("height"))
                    object.height = message.height;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = message.width;
                if (message.directPath != null && message.hasOwnProperty("directPath"))
                    object.directPath = message.directPath;
                if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                    if (typeof message.fileLength === "number")
                        object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                    else
                        object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
                if (message.isFavorite != null && message.hasOwnProperty("isFavorite"))
                    object.isFavorite = message.isFavorite;
                if (message.deviceIdHint != null && message.hasOwnProperty("deviceIdHint"))
                    object.deviceIdHint = message.deviceIdHint;
                return object;
            };

            /**
             * Converts this StickerAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.StickerAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StickerAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StickerAction;
        })();

        SyncActionValue.SubscriptionAction = (function() {

            /**
             * Properties of a SubscriptionAction.
             * @memberof proto.SyncActionValue
             * @interface ISubscriptionAction
             * @property {boolean|null} [isDeactivated] SubscriptionAction isDeactivated
             * @property {boolean|null} [isAutoRenewing] SubscriptionAction isAutoRenewing
             * @property {number|Long|null} [expirationDate] SubscriptionAction expirationDate
             */

            /**
             * Constructs a new SubscriptionAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a SubscriptionAction.
             * @implements ISubscriptionAction
             * @constructor
             * @param {proto.SyncActionValue.ISubscriptionAction=} [properties] Properties to set
             */
            function SubscriptionAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SubscriptionAction isDeactivated.
             * @member {boolean} isDeactivated
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @instance
             */
            SubscriptionAction.prototype.isDeactivated = false;

            /**
             * SubscriptionAction isAutoRenewing.
             * @member {boolean} isAutoRenewing
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @instance
             */
            SubscriptionAction.prototype.isAutoRenewing = false;

            /**
             * SubscriptionAction expirationDate.
             * @member {number|Long} expirationDate
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @instance
             */
            SubscriptionAction.prototype.expirationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SubscriptionAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @static
             * @param {proto.SyncActionValue.ISubscriptionAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.SubscriptionAction} SubscriptionAction instance
             */
            SubscriptionAction.create = function create(properties) {
                return new SubscriptionAction(properties);
            };

            /**
             * Encodes the specified SubscriptionAction message. Does not implicitly {@link proto.SyncActionValue.SubscriptionAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @static
             * @param {proto.SyncActionValue.ISubscriptionAction} message SubscriptionAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubscriptionAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isDeactivated != null && Object.hasOwnProperty.call(message, "isDeactivated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isDeactivated);
                if (message.isAutoRenewing != null && Object.hasOwnProperty.call(message, "isAutoRenewing"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isAutoRenewing);
                if (message.expirationDate != null && Object.hasOwnProperty.call(message, "expirationDate"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.expirationDate);
                return writer;
            };

            /**
             * Encodes the specified SubscriptionAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.SubscriptionAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @static
             * @param {proto.SyncActionValue.ISubscriptionAction} message SubscriptionAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubscriptionAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SubscriptionAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.SubscriptionAction} SubscriptionAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubscriptionAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.SubscriptionAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isDeactivated = reader.bool();
                        break;
                    case 2:
                        message.isAutoRenewing = reader.bool();
                        break;
                    case 3:
                        message.expirationDate = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SubscriptionAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.SubscriptionAction} SubscriptionAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubscriptionAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SubscriptionAction message.
             * @function verify
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubscriptionAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isDeactivated != null && message.hasOwnProperty("isDeactivated"))
                    if (typeof message.isDeactivated !== "boolean")
                        return "isDeactivated: boolean expected";
                if (message.isAutoRenewing != null && message.hasOwnProperty("isAutoRenewing"))
                    if (typeof message.isAutoRenewing !== "boolean")
                        return "isAutoRenewing: boolean expected";
                if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                    if (!$util.isInteger(message.expirationDate) && !(message.expirationDate && $util.isInteger(message.expirationDate.low) && $util.isInteger(message.expirationDate.high)))
                        return "expirationDate: integer|Long expected";
                return null;
            };

            /**
             * Creates a SubscriptionAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.SubscriptionAction} SubscriptionAction
             */
            SubscriptionAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.SubscriptionAction)
                    return object;
                var message = new $root.proto.SyncActionValue.SubscriptionAction();
                if (object.isDeactivated != null)
                    message.isDeactivated = Boolean(object.isDeactivated);
                if (object.isAutoRenewing != null)
                    message.isAutoRenewing = Boolean(object.isAutoRenewing);
                if (object.expirationDate != null)
                    if ($util.Long)
                        (message.expirationDate = $util.Long.fromValue(object.expirationDate)).unsigned = false;
                    else if (typeof object.expirationDate === "string")
                        message.expirationDate = parseInt(object.expirationDate, 10);
                    else if (typeof object.expirationDate === "number")
                        message.expirationDate = object.expirationDate;
                    else if (typeof object.expirationDate === "object")
                        message.expirationDate = new $util.LongBits(object.expirationDate.low >>> 0, object.expirationDate.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SubscriptionAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @static
             * @param {proto.SyncActionValue.SubscriptionAction} message SubscriptionAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubscriptionAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.isDeactivated = false;
                    object.isAutoRenewing = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expirationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expirationDate = options.longs === String ? "0" : 0;
                }
                if (message.isDeactivated != null && message.hasOwnProperty("isDeactivated"))
                    object.isDeactivated = message.isDeactivated;
                if (message.isAutoRenewing != null && message.hasOwnProperty("isAutoRenewing"))
                    object.isAutoRenewing = message.isAutoRenewing;
                if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                    if (typeof message.expirationDate === "number")
                        object.expirationDate = options.longs === String ? String(message.expirationDate) : message.expirationDate;
                    else
                        object.expirationDate = options.longs === String ? $util.Long.prototype.toString.call(message.expirationDate) : options.longs === Number ? new $util.LongBits(message.expirationDate.low >>> 0, message.expirationDate.high >>> 0).toNumber() : message.expirationDate;
                return object;
            };

            /**
             * Converts this SubscriptionAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.SubscriptionAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubscriptionAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SubscriptionAction;
        })();

        SyncActionValue.SyncActionMessage = (function() {

            /**
             * Properties of a SyncActionMessage.
             * @memberof proto.SyncActionValue
             * @interface ISyncActionMessage
             * @property {proto.IMessageKey|null} [key] SyncActionMessage key
             * @property {number|Long|null} [timestamp] SyncActionMessage timestamp
             */

            /**
             * Constructs a new SyncActionMessage.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a SyncActionMessage.
             * @implements ISyncActionMessage
             * @constructor
             * @param {proto.SyncActionValue.ISyncActionMessage=} [properties] Properties to set
             */
            function SyncActionMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SyncActionMessage key.
             * @member {proto.IMessageKey|null|undefined} key
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @instance
             */
            SyncActionMessage.prototype.key = null;

            /**
             * SyncActionMessage timestamp.
             * @member {number|Long} timestamp
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @instance
             */
            SyncActionMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SyncActionMessage instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @static
             * @param {proto.SyncActionValue.ISyncActionMessage=} [properties] Properties to set
             * @returns {proto.SyncActionValue.SyncActionMessage} SyncActionMessage instance
             */
            SyncActionMessage.create = function create(properties) {
                return new SyncActionMessage(properties);
            };

            /**
             * Encodes the specified SyncActionMessage message. Does not implicitly {@link proto.SyncActionValue.SyncActionMessage.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @static
             * @param {proto.SyncActionValue.ISyncActionMessage} message SyncActionMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncActionMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified SyncActionMessage message, length delimited. Does not implicitly {@link proto.SyncActionValue.SyncActionMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @static
             * @param {proto.SyncActionValue.ISyncActionMessage} message SyncActionMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncActionMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SyncActionMessage message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.SyncActionMessage} SyncActionMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncActionMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.SyncActionMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SyncActionMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.SyncActionMessage} SyncActionMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncActionMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SyncActionMessage message.
             * @function verify
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SyncActionMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key")) {
                    var error = $root.proto.MessageKey.verify(message.key);
                    if (error)
                        return "key." + error;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a SyncActionMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.SyncActionMessage} SyncActionMessage
             */
            SyncActionMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.SyncActionMessage)
                    return object;
                var message = new $root.proto.SyncActionValue.SyncActionMessage();
                if (object.key != null) {
                    if (typeof object.key !== "object")
                        throw TypeError(".proto.SyncActionValue.SyncActionMessage.key: object expected");
                    message.key = $root.proto.MessageKey.fromObject(object.key);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SyncActionMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @static
             * @param {proto.SyncActionValue.SyncActionMessage} message SyncActionMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SyncActionMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = $root.proto.MessageKey.toObject(message.key, options);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this SyncActionMessage to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.SyncActionMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SyncActionMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SyncActionMessage;
        })();

        SyncActionValue.SyncActionMessageRange = (function() {

            /**
             * Properties of a SyncActionMessageRange.
             * @memberof proto.SyncActionValue
             * @interface ISyncActionMessageRange
             * @property {number|Long|null} [lastMessageTimestamp] SyncActionMessageRange lastMessageTimestamp
             * @property {number|Long|null} [lastSystemMessageTimestamp] SyncActionMessageRange lastSystemMessageTimestamp
             * @property {Array.<proto.SyncActionValue.ISyncActionMessage>|null} [messages] SyncActionMessageRange messages
             */

            /**
             * Constructs a new SyncActionMessageRange.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a SyncActionMessageRange.
             * @implements ISyncActionMessageRange
             * @constructor
             * @param {proto.SyncActionValue.ISyncActionMessageRange=} [properties] Properties to set
             */
            function SyncActionMessageRange(properties) {
                this.messages = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SyncActionMessageRange lastMessageTimestamp.
             * @member {number|Long} lastMessageTimestamp
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @instance
             */
            SyncActionMessageRange.prototype.lastMessageTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SyncActionMessageRange lastSystemMessageTimestamp.
             * @member {number|Long} lastSystemMessageTimestamp
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @instance
             */
            SyncActionMessageRange.prototype.lastSystemMessageTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SyncActionMessageRange messages.
             * @member {Array.<proto.SyncActionValue.ISyncActionMessage>} messages
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @instance
             */
            SyncActionMessageRange.prototype.messages = $util.emptyArray;

            /**
             * Creates a new SyncActionMessageRange instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @static
             * @param {proto.SyncActionValue.ISyncActionMessageRange=} [properties] Properties to set
             * @returns {proto.SyncActionValue.SyncActionMessageRange} SyncActionMessageRange instance
             */
            SyncActionMessageRange.create = function create(properties) {
                return new SyncActionMessageRange(properties);
            };

            /**
             * Encodes the specified SyncActionMessageRange message. Does not implicitly {@link proto.SyncActionValue.SyncActionMessageRange.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @static
             * @param {proto.SyncActionValue.ISyncActionMessageRange} message SyncActionMessageRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncActionMessageRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lastMessageTimestamp != null && Object.hasOwnProperty.call(message, "lastMessageTimestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lastMessageTimestamp);
                if (message.lastSystemMessageTimestamp != null && Object.hasOwnProperty.call(message, "lastSystemMessageTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastSystemMessageTimestamp);
                if (message.messages != null && message.messages.length)
                    for (var i = 0; i < message.messages.length; ++i)
                        $root.proto.SyncActionValue.SyncActionMessage.encode(message.messages[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SyncActionMessageRange message, length delimited. Does not implicitly {@link proto.SyncActionValue.SyncActionMessageRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @static
             * @param {proto.SyncActionValue.ISyncActionMessageRange} message SyncActionMessageRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncActionMessageRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SyncActionMessageRange message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.SyncActionMessageRange} SyncActionMessageRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncActionMessageRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.SyncActionMessageRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lastMessageTimestamp = reader.int64();
                        break;
                    case 2:
                        message.lastSystemMessageTimestamp = reader.int64();
                        break;
                    case 3:
                        if (!(message.messages && message.messages.length))
                            message.messages = [];
                        message.messages.push($root.proto.SyncActionValue.SyncActionMessage.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SyncActionMessageRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.SyncActionMessageRange} SyncActionMessageRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncActionMessageRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SyncActionMessageRange message.
             * @function verify
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SyncActionMessageRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lastMessageTimestamp != null && message.hasOwnProperty("lastMessageTimestamp"))
                    if (!$util.isInteger(message.lastMessageTimestamp) && !(message.lastMessageTimestamp && $util.isInteger(message.lastMessageTimestamp.low) && $util.isInteger(message.lastMessageTimestamp.high)))
                        return "lastMessageTimestamp: integer|Long expected";
                if (message.lastSystemMessageTimestamp != null && message.hasOwnProperty("lastSystemMessageTimestamp"))
                    if (!$util.isInteger(message.lastSystemMessageTimestamp) && !(message.lastSystemMessageTimestamp && $util.isInteger(message.lastSystemMessageTimestamp.low) && $util.isInteger(message.lastSystemMessageTimestamp.high)))
                        return "lastSystemMessageTimestamp: integer|Long expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (var i = 0; i < message.messages.length; ++i) {
                        var error = $root.proto.SyncActionValue.SyncActionMessage.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SyncActionMessageRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.SyncActionMessageRange} SyncActionMessageRange
             */
            SyncActionMessageRange.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.SyncActionMessageRange)
                    return object;
                var message = new $root.proto.SyncActionValue.SyncActionMessageRange();
                if (object.lastMessageTimestamp != null)
                    if ($util.Long)
                        (message.lastMessageTimestamp = $util.Long.fromValue(object.lastMessageTimestamp)).unsigned = false;
                    else if (typeof object.lastMessageTimestamp === "string")
                        message.lastMessageTimestamp = parseInt(object.lastMessageTimestamp, 10);
                    else if (typeof object.lastMessageTimestamp === "number")
                        message.lastMessageTimestamp = object.lastMessageTimestamp;
                    else if (typeof object.lastMessageTimestamp === "object")
                        message.lastMessageTimestamp = new $util.LongBits(object.lastMessageTimestamp.low >>> 0, object.lastMessageTimestamp.high >>> 0).toNumber();
                if (object.lastSystemMessageTimestamp != null)
                    if ($util.Long)
                        (message.lastSystemMessageTimestamp = $util.Long.fromValue(object.lastSystemMessageTimestamp)).unsigned = false;
                    else if (typeof object.lastSystemMessageTimestamp === "string")
                        message.lastSystemMessageTimestamp = parseInt(object.lastSystemMessageTimestamp, 10);
                    else if (typeof object.lastSystemMessageTimestamp === "number")
                        message.lastSystemMessageTimestamp = object.lastSystemMessageTimestamp;
                    else if (typeof object.lastSystemMessageTimestamp === "object")
                        message.lastSystemMessageTimestamp = new $util.LongBits(object.lastSystemMessageTimestamp.low >>> 0, object.lastSystemMessageTimestamp.high >>> 0).toNumber();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".proto.SyncActionValue.SyncActionMessageRange.messages: array expected");
                    message.messages = [];
                    for (var i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".proto.SyncActionValue.SyncActionMessageRange.messages: object expected");
                        message.messages[i] = $root.proto.SyncActionValue.SyncActionMessage.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SyncActionMessageRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @static
             * @param {proto.SyncActionValue.SyncActionMessageRange} message SyncActionMessageRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SyncActionMessageRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastMessageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastMessageTimestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastSystemMessageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastSystemMessageTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.lastMessageTimestamp != null && message.hasOwnProperty("lastMessageTimestamp"))
                    if (typeof message.lastMessageTimestamp === "number")
                        object.lastMessageTimestamp = options.longs === String ? String(message.lastMessageTimestamp) : message.lastMessageTimestamp;
                    else
                        object.lastMessageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.lastMessageTimestamp) : options.longs === Number ? new $util.LongBits(message.lastMessageTimestamp.low >>> 0, message.lastMessageTimestamp.high >>> 0).toNumber() : message.lastMessageTimestamp;
                if (message.lastSystemMessageTimestamp != null && message.hasOwnProperty("lastSystemMessageTimestamp"))
                    if (typeof message.lastSystemMessageTimestamp === "number")
                        object.lastSystemMessageTimestamp = options.longs === String ? String(message.lastSystemMessageTimestamp) : message.lastSystemMessageTimestamp;
                    else
                        object.lastSystemMessageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.lastSystemMessageTimestamp) : options.longs === Number ? new $util.LongBits(message.lastSystemMessageTimestamp.low >>> 0, message.lastSystemMessageTimestamp.high >>> 0).toNumber() : message.lastSystemMessageTimestamp;
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (var j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.proto.SyncActionValue.SyncActionMessage.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this SyncActionMessageRange to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.SyncActionMessageRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SyncActionMessageRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SyncActionMessageRange;
        })();

        SyncActionValue.TimeFormatAction = (function() {

            /**
             * Properties of a TimeFormatAction.
             * @memberof proto.SyncActionValue
             * @interface ITimeFormatAction
             * @property {boolean|null} [isTwentyFourHourFormatEnabled] TimeFormatAction isTwentyFourHourFormatEnabled
             */

            /**
             * Constructs a new TimeFormatAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a TimeFormatAction.
             * @implements ITimeFormatAction
             * @constructor
             * @param {proto.SyncActionValue.ITimeFormatAction=} [properties] Properties to set
             */
            function TimeFormatAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TimeFormatAction isTwentyFourHourFormatEnabled.
             * @member {boolean} isTwentyFourHourFormatEnabled
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @instance
             */
            TimeFormatAction.prototype.isTwentyFourHourFormatEnabled = false;

            /**
             * Creates a new TimeFormatAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @static
             * @param {proto.SyncActionValue.ITimeFormatAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.TimeFormatAction} TimeFormatAction instance
             */
            TimeFormatAction.create = function create(properties) {
                return new TimeFormatAction(properties);
            };

            /**
             * Encodes the specified TimeFormatAction message. Does not implicitly {@link proto.SyncActionValue.TimeFormatAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @static
             * @param {proto.SyncActionValue.ITimeFormatAction} message TimeFormatAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeFormatAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isTwentyFourHourFormatEnabled != null && Object.hasOwnProperty.call(message, "isTwentyFourHourFormatEnabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isTwentyFourHourFormatEnabled);
                return writer;
            };

            /**
             * Encodes the specified TimeFormatAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.TimeFormatAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @static
             * @param {proto.SyncActionValue.ITimeFormatAction} message TimeFormatAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeFormatAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TimeFormatAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.TimeFormatAction} TimeFormatAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeFormatAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.TimeFormatAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isTwentyFourHourFormatEnabled = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TimeFormatAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.TimeFormatAction} TimeFormatAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeFormatAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TimeFormatAction message.
             * @function verify
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TimeFormatAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isTwentyFourHourFormatEnabled != null && message.hasOwnProperty("isTwentyFourHourFormatEnabled"))
                    if (typeof message.isTwentyFourHourFormatEnabled !== "boolean")
                        return "isTwentyFourHourFormatEnabled: boolean expected";
                return null;
            };

            /**
             * Creates a TimeFormatAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.TimeFormatAction} TimeFormatAction
             */
            TimeFormatAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.TimeFormatAction)
                    return object;
                var message = new $root.proto.SyncActionValue.TimeFormatAction();
                if (object.isTwentyFourHourFormatEnabled != null)
                    message.isTwentyFourHourFormatEnabled = Boolean(object.isTwentyFourHourFormatEnabled);
                return message;
            };

            /**
             * Creates a plain object from a TimeFormatAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @static
             * @param {proto.SyncActionValue.TimeFormatAction} message TimeFormatAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TimeFormatAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.isTwentyFourHourFormatEnabled = false;
                if (message.isTwentyFourHourFormatEnabled != null && message.hasOwnProperty("isTwentyFourHourFormatEnabled"))
                    object.isTwentyFourHourFormatEnabled = message.isTwentyFourHourFormatEnabled;
                return object;
            };

            /**
             * Converts this TimeFormatAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.TimeFormatAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TimeFormatAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TimeFormatAction;
        })();

        SyncActionValue.UnarchiveChatsSetting = (function() {

            /**
             * Properties of an UnarchiveChatsSetting.
             * @memberof proto.SyncActionValue
             * @interface IUnarchiveChatsSetting
             * @property {boolean|null} [unarchiveChats] UnarchiveChatsSetting unarchiveChats
             */

            /**
             * Constructs a new UnarchiveChatsSetting.
             * @memberof proto.SyncActionValue
             * @classdesc Represents an UnarchiveChatsSetting.
             * @implements IUnarchiveChatsSetting
             * @constructor
             * @param {proto.SyncActionValue.IUnarchiveChatsSetting=} [properties] Properties to set
             */
            function UnarchiveChatsSetting(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnarchiveChatsSetting unarchiveChats.
             * @member {boolean} unarchiveChats
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @instance
             */
            UnarchiveChatsSetting.prototype.unarchiveChats = false;

            /**
             * Creates a new UnarchiveChatsSetting instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @static
             * @param {proto.SyncActionValue.IUnarchiveChatsSetting=} [properties] Properties to set
             * @returns {proto.SyncActionValue.UnarchiveChatsSetting} UnarchiveChatsSetting instance
             */
            UnarchiveChatsSetting.create = function create(properties) {
                return new UnarchiveChatsSetting(properties);
            };

            /**
             * Encodes the specified UnarchiveChatsSetting message. Does not implicitly {@link proto.SyncActionValue.UnarchiveChatsSetting.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @static
             * @param {proto.SyncActionValue.IUnarchiveChatsSetting} message UnarchiveChatsSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnarchiveChatsSetting.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.unarchiveChats != null && Object.hasOwnProperty.call(message, "unarchiveChats"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.unarchiveChats);
                return writer;
            };

            /**
             * Encodes the specified UnarchiveChatsSetting message, length delimited. Does not implicitly {@link proto.SyncActionValue.UnarchiveChatsSetting.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @static
             * @param {proto.SyncActionValue.IUnarchiveChatsSetting} message UnarchiveChatsSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnarchiveChatsSetting.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnarchiveChatsSetting message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.UnarchiveChatsSetting} UnarchiveChatsSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnarchiveChatsSetting.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.UnarchiveChatsSetting();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.unarchiveChats = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnarchiveChatsSetting message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.UnarchiveChatsSetting} UnarchiveChatsSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnarchiveChatsSetting.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnarchiveChatsSetting message.
             * @function verify
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnarchiveChatsSetting.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.unarchiveChats != null && message.hasOwnProperty("unarchiveChats"))
                    if (typeof message.unarchiveChats !== "boolean")
                        return "unarchiveChats: boolean expected";
                return null;
            };

            /**
             * Creates an UnarchiveChatsSetting message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.UnarchiveChatsSetting} UnarchiveChatsSetting
             */
            UnarchiveChatsSetting.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.UnarchiveChatsSetting)
                    return object;
                var message = new $root.proto.SyncActionValue.UnarchiveChatsSetting();
                if (object.unarchiveChats != null)
                    message.unarchiveChats = Boolean(object.unarchiveChats);
                return message;
            };

            /**
             * Creates a plain object from an UnarchiveChatsSetting message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @static
             * @param {proto.SyncActionValue.UnarchiveChatsSetting} message UnarchiveChatsSetting
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnarchiveChatsSetting.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.unarchiveChats = false;
                if (message.unarchiveChats != null && message.hasOwnProperty("unarchiveChats"))
                    object.unarchiveChats = message.unarchiveChats;
                return object;
            };

            /**
             * Converts this UnarchiveChatsSetting to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.UnarchiveChatsSetting
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnarchiveChatsSetting.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnarchiveChatsSetting;
        })();

        SyncActionValue.UserStatusMuteAction = (function() {

            /**
             * Properties of a UserStatusMuteAction.
             * @memberof proto.SyncActionValue
             * @interface IUserStatusMuteAction
             * @property {boolean|null} [muted] UserStatusMuteAction muted
             */

            /**
             * Constructs a new UserStatusMuteAction.
             * @memberof proto.SyncActionValue
             * @classdesc Represents a UserStatusMuteAction.
             * @implements IUserStatusMuteAction
             * @constructor
             * @param {proto.SyncActionValue.IUserStatusMuteAction=} [properties] Properties to set
             */
            function UserStatusMuteAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserStatusMuteAction muted.
             * @member {boolean} muted
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @instance
             */
            UserStatusMuteAction.prototype.muted = false;

            /**
             * Creates a new UserStatusMuteAction instance using the specified properties.
             * @function create
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @static
             * @param {proto.SyncActionValue.IUserStatusMuteAction=} [properties] Properties to set
             * @returns {proto.SyncActionValue.UserStatusMuteAction} UserStatusMuteAction instance
             */
            UserStatusMuteAction.create = function create(properties) {
                return new UserStatusMuteAction(properties);
            };

            /**
             * Encodes the specified UserStatusMuteAction message. Does not implicitly {@link proto.SyncActionValue.UserStatusMuteAction.verify|verify} messages.
             * @function encode
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @static
             * @param {proto.SyncActionValue.IUserStatusMuteAction} message UserStatusMuteAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserStatusMuteAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.muted != null && Object.hasOwnProperty.call(message, "muted"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.muted);
                return writer;
            };

            /**
             * Encodes the specified UserStatusMuteAction message, length delimited. Does not implicitly {@link proto.SyncActionValue.UserStatusMuteAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @static
             * @param {proto.SyncActionValue.IUserStatusMuteAction} message UserStatusMuteAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserStatusMuteAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserStatusMuteAction message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SyncActionValue.UserStatusMuteAction} UserStatusMuteAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserStatusMuteAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncActionValue.UserStatusMuteAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.muted = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserStatusMuteAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SyncActionValue.UserStatusMuteAction} UserStatusMuteAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserStatusMuteAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserStatusMuteAction message.
             * @function verify
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserStatusMuteAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.muted != null && message.hasOwnProperty("muted"))
                    if (typeof message.muted !== "boolean")
                        return "muted: boolean expected";
                return null;
            };

            /**
             * Creates a UserStatusMuteAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SyncActionValue.UserStatusMuteAction} UserStatusMuteAction
             */
            UserStatusMuteAction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SyncActionValue.UserStatusMuteAction)
                    return object;
                var message = new $root.proto.SyncActionValue.UserStatusMuteAction();
                if (object.muted != null)
                    message.muted = Boolean(object.muted);
                return message;
            };

            /**
             * Creates a plain object from a UserStatusMuteAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @static
             * @param {proto.SyncActionValue.UserStatusMuteAction} message UserStatusMuteAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserStatusMuteAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.muted = false;
                if (message.muted != null && message.hasOwnProperty("muted"))
                    object.muted = message.muted;
                return object;
            };

            /**
             * Converts this UserStatusMuteAction to JSON.
             * @function toJSON
             * @memberof proto.SyncActionValue.UserStatusMuteAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserStatusMuteAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UserStatusMuteAction;
        })();

        return SyncActionValue;
    })();

    proto.SyncdIndex = (function() {

        /**
         * Properties of a SyncdIndex.
         * @memberof proto
         * @interface ISyncdIndex
         * @property {Uint8Array|null} [blob] SyncdIndex blob
         */

        /**
         * Constructs a new SyncdIndex.
         * @memberof proto
         * @classdesc Represents a SyncdIndex.
         * @implements ISyncdIndex
         * @constructor
         * @param {proto.ISyncdIndex=} [properties] Properties to set
         */
        function SyncdIndex(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncdIndex blob.
         * @member {Uint8Array} blob
         * @memberof proto.SyncdIndex
         * @instance
         */
        SyncdIndex.prototype.blob = $util.newBuffer([]);

        /**
         * Creates a new SyncdIndex instance using the specified properties.
         * @function create
         * @memberof proto.SyncdIndex
         * @static
         * @param {proto.ISyncdIndex=} [properties] Properties to set
         * @returns {proto.SyncdIndex} SyncdIndex instance
         */
        SyncdIndex.create = function create(properties) {
            return new SyncdIndex(properties);
        };

        /**
         * Encodes the specified SyncdIndex message. Does not implicitly {@link proto.SyncdIndex.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncdIndex
         * @static
         * @param {proto.ISyncdIndex} message SyncdIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdIndex.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blob);
            return writer;
        };

        /**
         * Encodes the specified SyncdIndex message, length delimited. Does not implicitly {@link proto.SyncdIndex.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncdIndex
         * @static
         * @param {proto.ISyncdIndex} message SyncdIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdIndex.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncdIndex message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncdIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncdIndex} SyncdIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdIndex.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncdIndex();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blob = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncdIndex message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncdIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncdIndex} SyncdIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdIndex.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncdIndex message.
         * @function verify
         * @memberof proto.SyncdIndex
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncdIndex.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blob != null && message.hasOwnProperty("blob"))
                if (!(message.blob && typeof message.blob.length === "number" || $util.isString(message.blob)))
                    return "blob: buffer expected";
            return null;
        };

        /**
         * Creates a SyncdIndex message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncdIndex
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncdIndex} SyncdIndex
         */
        SyncdIndex.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncdIndex)
                return object;
            var message = new $root.proto.SyncdIndex();
            if (object.blob != null)
                if (typeof object.blob === "string")
                    $util.base64.decode(object.blob, message.blob = $util.newBuffer($util.base64.length(object.blob)), 0);
                else if (object.blob.length)
                    message.blob = object.blob;
            return message;
        };

        /**
         * Creates a plain object from a SyncdIndex message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncdIndex
         * @static
         * @param {proto.SyncdIndex} message SyncdIndex
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncdIndex.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.blob = "";
                else {
                    object.blob = [];
                    if (options.bytes !== Array)
                        object.blob = $util.newBuffer(object.blob);
                }
            if (message.blob != null && message.hasOwnProperty("blob"))
                object.blob = options.bytes === String ? $util.base64.encode(message.blob, 0, message.blob.length) : options.bytes === Array ? Array.prototype.slice.call(message.blob) : message.blob;
            return object;
        };

        /**
         * Converts this SyncdIndex to JSON.
         * @function toJSON
         * @memberof proto.SyncdIndex
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncdIndex.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncdIndex;
    })();

    proto.SyncdMutation = (function() {

        /**
         * Properties of a SyncdMutation.
         * @memberof proto
         * @interface ISyncdMutation
         * @property {proto.SyncdMutation.SyncdOperation|null} [operation] SyncdMutation operation
         * @property {proto.ISyncdRecord|null} [record] SyncdMutation record
         */

        /**
         * Constructs a new SyncdMutation.
         * @memberof proto
         * @classdesc Represents a SyncdMutation.
         * @implements ISyncdMutation
         * @constructor
         * @param {proto.ISyncdMutation=} [properties] Properties to set
         */
        function SyncdMutation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncdMutation operation.
         * @member {proto.SyncdMutation.SyncdOperation} operation
         * @memberof proto.SyncdMutation
         * @instance
         */
        SyncdMutation.prototype.operation = 0;

        /**
         * SyncdMutation record.
         * @member {proto.ISyncdRecord|null|undefined} record
         * @memberof proto.SyncdMutation
         * @instance
         */
        SyncdMutation.prototype.record = null;

        /**
         * Creates a new SyncdMutation instance using the specified properties.
         * @function create
         * @memberof proto.SyncdMutation
         * @static
         * @param {proto.ISyncdMutation=} [properties] Properties to set
         * @returns {proto.SyncdMutation} SyncdMutation instance
         */
        SyncdMutation.create = function create(properties) {
            return new SyncdMutation(properties);
        };

        /**
         * Encodes the specified SyncdMutation message. Does not implicitly {@link proto.SyncdMutation.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncdMutation
         * @static
         * @param {proto.ISyncdMutation} message SyncdMutation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdMutation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operation);
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.proto.SyncdRecord.encode(message.record, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncdMutation message, length delimited. Does not implicitly {@link proto.SyncdMutation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncdMutation
         * @static
         * @param {proto.ISyncdMutation} message SyncdMutation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdMutation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncdMutation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncdMutation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncdMutation} SyncdMutation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdMutation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncdMutation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.operation = reader.int32();
                    break;
                case 2:
                    message.record = $root.proto.SyncdRecord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncdMutation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncdMutation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncdMutation} SyncdMutation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdMutation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncdMutation message.
         * @function verify
         * @memberof proto.SyncdMutation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncdMutation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operation != null && message.hasOwnProperty("operation"))
                switch (message.operation) {
                default:
                    return "operation: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.record != null && message.hasOwnProperty("record")) {
                var error = $root.proto.SyncdRecord.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates a SyncdMutation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncdMutation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncdMutation} SyncdMutation
         */
        SyncdMutation.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncdMutation)
                return object;
            var message = new $root.proto.SyncdMutation();
            switch (object.operation) {
            case "SET":
            case 0:
                message.operation = 0;
                break;
            case "REMOVE":
            case 1:
                message.operation = 1;
                break;
            }
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".proto.SyncdMutation.record: object expected");
                message.record = $root.proto.SyncdRecord.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncdMutation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncdMutation
         * @static
         * @param {proto.SyncdMutation} message SyncdMutation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncdMutation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.operation = options.enums === String ? "SET" : 0;
                object.record = null;
            }
            if (message.operation != null && message.hasOwnProperty("operation"))
                object.operation = options.enums === String ? $root.proto.SyncdMutation.SyncdOperation[message.operation] : message.operation;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.proto.SyncdRecord.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this SyncdMutation to JSON.
         * @function toJSON
         * @memberof proto.SyncdMutation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncdMutation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * SyncdOperation enum.
         * @name proto.SyncdMutation.SyncdOperation
         * @enum {number}
         * @property {number} SET=0 SET value
         * @property {number} REMOVE=1 REMOVE value
         */
        SyncdMutation.SyncdOperation = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SET"] = 0;
            values[valuesById[1] = "REMOVE"] = 1;
            return values;
        })();

        return SyncdMutation;
    })();

    proto.SyncdMutations = (function() {

        /**
         * Properties of a SyncdMutations.
         * @memberof proto
         * @interface ISyncdMutations
         * @property {Array.<proto.ISyncdMutation>|null} [mutations] SyncdMutations mutations
         */

        /**
         * Constructs a new SyncdMutations.
         * @memberof proto
         * @classdesc Represents a SyncdMutations.
         * @implements ISyncdMutations
         * @constructor
         * @param {proto.ISyncdMutations=} [properties] Properties to set
         */
        function SyncdMutations(properties) {
            this.mutations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncdMutations mutations.
         * @member {Array.<proto.ISyncdMutation>} mutations
         * @memberof proto.SyncdMutations
         * @instance
         */
        SyncdMutations.prototype.mutations = $util.emptyArray;

        /**
         * Creates a new SyncdMutations instance using the specified properties.
         * @function create
         * @memberof proto.SyncdMutations
         * @static
         * @param {proto.ISyncdMutations=} [properties] Properties to set
         * @returns {proto.SyncdMutations} SyncdMutations instance
         */
        SyncdMutations.create = function create(properties) {
            return new SyncdMutations(properties);
        };

        /**
         * Encodes the specified SyncdMutations message. Does not implicitly {@link proto.SyncdMutations.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncdMutations
         * @static
         * @param {proto.ISyncdMutations} message SyncdMutations message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdMutations.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mutations != null && message.mutations.length)
                for (var i = 0; i < message.mutations.length; ++i)
                    $root.proto.SyncdMutation.encode(message.mutations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncdMutations message, length delimited. Does not implicitly {@link proto.SyncdMutations.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncdMutations
         * @static
         * @param {proto.ISyncdMutations} message SyncdMutations message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdMutations.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncdMutations message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncdMutations
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncdMutations} SyncdMutations
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdMutations.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncdMutations();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mutations && message.mutations.length))
                        message.mutations = [];
                    message.mutations.push($root.proto.SyncdMutation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncdMutations message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncdMutations
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncdMutations} SyncdMutations
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdMutations.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncdMutations message.
         * @function verify
         * @memberof proto.SyncdMutations
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncdMutations.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mutations != null && message.hasOwnProperty("mutations")) {
                if (!Array.isArray(message.mutations))
                    return "mutations: array expected";
                for (var i = 0; i < message.mutations.length; ++i) {
                    var error = $root.proto.SyncdMutation.verify(message.mutations[i]);
                    if (error)
                        return "mutations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SyncdMutations message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncdMutations
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncdMutations} SyncdMutations
         */
        SyncdMutations.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncdMutations)
                return object;
            var message = new $root.proto.SyncdMutations();
            if (object.mutations) {
                if (!Array.isArray(object.mutations))
                    throw TypeError(".proto.SyncdMutations.mutations: array expected");
                message.mutations = [];
                for (var i = 0; i < object.mutations.length; ++i) {
                    if (typeof object.mutations[i] !== "object")
                        throw TypeError(".proto.SyncdMutations.mutations: object expected");
                    message.mutations[i] = $root.proto.SyncdMutation.fromObject(object.mutations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncdMutations message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncdMutations
         * @static
         * @param {proto.SyncdMutations} message SyncdMutations
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncdMutations.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mutations = [];
            if (message.mutations && message.mutations.length) {
                object.mutations = [];
                for (var j = 0; j < message.mutations.length; ++j)
                    object.mutations[j] = $root.proto.SyncdMutation.toObject(message.mutations[j], options);
            }
            return object;
        };

        /**
         * Converts this SyncdMutations to JSON.
         * @function toJSON
         * @memberof proto.SyncdMutations
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncdMutations.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncdMutations;
    })();

    proto.SyncdPatch = (function() {

        /**
         * Properties of a SyncdPatch.
         * @memberof proto
         * @interface ISyncdPatch
         * @property {proto.ISyncdVersion|null} [version] SyncdPatch version
         * @property {Array.<proto.ISyncdMutation>|null} [mutations] SyncdPatch mutations
         * @property {proto.IExternalBlobReference|null} [externalMutations] SyncdPatch externalMutations
         * @property {Uint8Array|null} [snapshotMac] SyncdPatch snapshotMac
         * @property {Uint8Array|null} [patchMac] SyncdPatch patchMac
         * @property {proto.IKeyId|null} [keyId] SyncdPatch keyId
         * @property {proto.IExitCode|null} [exitCode] SyncdPatch exitCode
         * @property {number|null} [deviceIndex] SyncdPatch deviceIndex
         */

        /**
         * Constructs a new SyncdPatch.
         * @memberof proto
         * @classdesc Represents a SyncdPatch.
         * @implements ISyncdPatch
         * @constructor
         * @param {proto.ISyncdPatch=} [properties] Properties to set
         */
        function SyncdPatch(properties) {
            this.mutations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncdPatch version.
         * @member {proto.ISyncdVersion|null|undefined} version
         * @memberof proto.SyncdPatch
         * @instance
         */
        SyncdPatch.prototype.version = null;

        /**
         * SyncdPatch mutations.
         * @member {Array.<proto.ISyncdMutation>} mutations
         * @memberof proto.SyncdPatch
         * @instance
         */
        SyncdPatch.prototype.mutations = $util.emptyArray;

        /**
         * SyncdPatch externalMutations.
         * @member {proto.IExternalBlobReference|null|undefined} externalMutations
         * @memberof proto.SyncdPatch
         * @instance
         */
        SyncdPatch.prototype.externalMutations = null;

        /**
         * SyncdPatch snapshotMac.
         * @member {Uint8Array} snapshotMac
         * @memberof proto.SyncdPatch
         * @instance
         */
        SyncdPatch.prototype.snapshotMac = $util.newBuffer([]);

        /**
         * SyncdPatch patchMac.
         * @member {Uint8Array} patchMac
         * @memberof proto.SyncdPatch
         * @instance
         */
        SyncdPatch.prototype.patchMac = $util.newBuffer([]);

        /**
         * SyncdPatch keyId.
         * @member {proto.IKeyId|null|undefined} keyId
         * @memberof proto.SyncdPatch
         * @instance
         */
        SyncdPatch.prototype.keyId = null;

        /**
         * SyncdPatch exitCode.
         * @member {proto.IExitCode|null|undefined} exitCode
         * @memberof proto.SyncdPatch
         * @instance
         */
        SyncdPatch.prototype.exitCode = null;

        /**
         * SyncdPatch deviceIndex.
         * @member {number} deviceIndex
         * @memberof proto.SyncdPatch
         * @instance
         */
        SyncdPatch.prototype.deviceIndex = 0;

        /**
         * Creates a new SyncdPatch instance using the specified properties.
         * @function create
         * @memberof proto.SyncdPatch
         * @static
         * @param {proto.ISyncdPatch=} [properties] Properties to set
         * @returns {proto.SyncdPatch} SyncdPatch instance
         */
        SyncdPatch.create = function create(properties) {
            return new SyncdPatch(properties);
        };

        /**
         * Encodes the specified SyncdPatch message. Does not implicitly {@link proto.SyncdPatch.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncdPatch
         * @static
         * @param {proto.ISyncdPatch} message SyncdPatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdPatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                $root.proto.SyncdVersion.encode(message.version, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mutations != null && message.mutations.length)
                for (var i = 0; i < message.mutations.length; ++i)
                    $root.proto.SyncdMutation.encode(message.mutations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.externalMutations != null && Object.hasOwnProperty.call(message, "externalMutations"))
                $root.proto.ExternalBlobReference.encode(message.externalMutations, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.snapshotMac != null && Object.hasOwnProperty.call(message, "snapshotMac"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.snapshotMac);
            if (message.patchMac != null && Object.hasOwnProperty.call(message, "patchMac"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.patchMac);
            if (message.keyId != null && Object.hasOwnProperty.call(message, "keyId"))
                $root.proto.KeyId.encode(message.keyId, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.exitCode != null && Object.hasOwnProperty.call(message, "exitCode"))
                $root.proto.ExitCode.encode(message.exitCode, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.deviceIndex != null && Object.hasOwnProperty.call(message, "deviceIndex"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.deviceIndex);
            return writer;
        };

        /**
         * Encodes the specified SyncdPatch message, length delimited. Does not implicitly {@link proto.SyncdPatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncdPatch
         * @static
         * @param {proto.ISyncdPatch} message SyncdPatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdPatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncdPatch message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncdPatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncdPatch} SyncdPatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdPatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncdPatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = $root.proto.SyncdVersion.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.mutations && message.mutations.length))
                        message.mutations = [];
                    message.mutations.push($root.proto.SyncdMutation.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.externalMutations = $root.proto.ExternalBlobReference.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.snapshotMac = reader.bytes();
                    break;
                case 5:
                    message.patchMac = reader.bytes();
                    break;
                case 6:
                    message.keyId = $root.proto.KeyId.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.exitCode = $root.proto.ExitCode.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.deviceIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncdPatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncdPatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncdPatch} SyncdPatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdPatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncdPatch message.
         * @function verify
         * @memberof proto.SyncdPatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncdPatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version")) {
                var error = $root.proto.SyncdVersion.verify(message.version);
                if (error)
                    return "version." + error;
            }
            if (message.mutations != null && message.hasOwnProperty("mutations")) {
                if (!Array.isArray(message.mutations))
                    return "mutations: array expected";
                for (var i = 0; i < message.mutations.length; ++i) {
                    var error = $root.proto.SyncdMutation.verify(message.mutations[i]);
                    if (error)
                        return "mutations." + error;
                }
            }
            if (message.externalMutations != null && message.hasOwnProperty("externalMutations")) {
                var error = $root.proto.ExternalBlobReference.verify(message.externalMutations);
                if (error)
                    return "externalMutations." + error;
            }
            if (message.snapshotMac != null && message.hasOwnProperty("snapshotMac"))
                if (!(message.snapshotMac && typeof message.snapshotMac.length === "number" || $util.isString(message.snapshotMac)))
                    return "snapshotMac: buffer expected";
            if (message.patchMac != null && message.hasOwnProperty("patchMac"))
                if (!(message.patchMac && typeof message.patchMac.length === "number" || $util.isString(message.patchMac)))
                    return "patchMac: buffer expected";
            if (message.keyId != null && message.hasOwnProperty("keyId")) {
                var error = $root.proto.KeyId.verify(message.keyId);
                if (error)
                    return "keyId." + error;
            }
            if (message.exitCode != null && message.hasOwnProperty("exitCode")) {
                var error = $root.proto.ExitCode.verify(message.exitCode);
                if (error)
                    return "exitCode." + error;
            }
            if (message.deviceIndex != null && message.hasOwnProperty("deviceIndex"))
                if (!$util.isInteger(message.deviceIndex))
                    return "deviceIndex: integer expected";
            return null;
        };

        /**
         * Creates a SyncdPatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncdPatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncdPatch} SyncdPatch
         */
        SyncdPatch.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncdPatch)
                return object;
            var message = new $root.proto.SyncdPatch();
            if (object.version != null) {
                if (typeof object.version !== "object")
                    throw TypeError(".proto.SyncdPatch.version: object expected");
                message.version = $root.proto.SyncdVersion.fromObject(object.version);
            }
            if (object.mutations) {
                if (!Array.isArray(object.mutations))
                    throw TypeError(".proto.SyncdPatch.mutations: array expected");
                message.mutations = [];
                for (var i = 0; i < object.mutations.length; ++i) {
                    if (typeof object.mutations[i] !== "object")
                        throw TypeError(".proto.SyncdPatch.mutations: object expected");
                    message.mutations[i] = $root.proto.SyncdMutation.fromObject(object.mutations[i]);
                }
            }
            if (object.externalMutations != null) {
                if (typeof object.externalMutations !== "object")
                    throw TypeError(".proto.SyncdPatch.externalMutations: object expected");
                message.externalMutations = $root.proto.ExternalBlobReference.fromObject(object.externalMutations);
            }
            if (object.snapshotMac != null)
                if (typeof object.snapshotMac === "string")
                    $util.base64.decode(object.snapshotMac, message.snapshotMac = $util.newBuffer($util.base64.length(object.snapshotMac)), 0);
                else if (object.snapshotMac.length)
                    message.snapshotMac = object.snapshotMac;
            if (object.patchMac != null)
                if (typeof object.patchMac === "string")
                    $util.base64.decode(object.patchMac, message.patchMac = $util.newBuffer($util.base64.length(object.patchMac)), 0);
                else if (object.patchMac.length)
                    message.patchMac = object.patchMac;
            if (object.keyId != null) {
                if (typeof object.keyId !== "object")
                    throw TypeError(".proto.SyncdPatch.keyId: object expected");
                message.keyId = $root.proto.KeyId.fromObject(object.keyId);
            }
            if (object.exitCode != null) {
                if (typeof object.exitCode !== "object")
                    throw TypeError(".proto.SyncdPatch.exitCode: object expected");
                message.exitCode = $root.proto.ExitCode.fromObject(object.exitCode);
            }
            if (object.deviceIndex != null)
                message.deviceIndex = object.deviceIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a SyncdPatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncdPatch
         * @static
         * @param {proto.SyncdPatch} message SyncdPatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncdPatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mutations = [];
            if (options.defaults) {
                object.version = null;
                object.externalMutations = null;
                if (options.bytes === String)
                    object.snapshotMac = "";
                else {
                    object.snapshotMac = [];
                    if (options.bytes !== Array)
                        object.snapshotMac = $util.newBuffer(object.snapshotMac);
                }
                if (options.bytes === String)
                    object.patchMac = "";
                else {
                    object.patchMac = [];
                    if (options.bytes !== Array)
                        object.patchMac = $util.newBuffer(object.patchMac);
                }
                object.keyId = null;
                object.exitCode = null;
                object.deviceIndex = 0;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = $root.proto.SyncdVersion.toObject(message.version, options);
            if (message.mutations && message.mutations.length) {
                object.mutations = [];
                for (var j = 0; j < message.mutations.length; ++j)
                    object.mutations[j] = $root.proto.SyncdMutation.toObject(message.mutations[j], options);
            }
            if (message.externalMutations != null && message.hasOwnProperty("externalMutations"))
                object.externalMutations = $root.proto.ExternalBlobReference.toObject(message.externalMutations, options);
            if (message.snapshotMac != null && message.hasOwnProperty("snapshotMac"))
                object.snapshotMac = options.bytes === String ? $util.base64.encode(message.snapshotMac, 0, message.snapshotMac.length) : options.bytes === Array ? Array.prototype.slice.call(message.snapshotMac) : message.snapshotMac;
            if (message.patchMac != null && message.hasOwnProperty("patchMac"))
                object.patchMac = options.bytes === String ? $util.base64.encode(message.patchMac, 0, message.patchMac.length) : options.bytes === Array ? Array.prototype.slice.call(message.patchMac) : message.patchMac;
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                object.keyId = $root.proto.KeyId.toObject(message.keyId, options);
            if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                object.exitCode = $root.proto.ExitCode.toObject(message.exitCode, options);
            if (message.deviceIndex != null && message.hasOwnProperty("deviceIndex"))
                object.deviceIndex = message.deviceIndex;
            return object;
        };

        /**
         * Converts this SyncdPatch to JSON.
         * @function toJSON
         * @memberof proto.SyncdPatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncdPatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncdPatch;
    })();

    proto.SyncdRecord = (function() {

        /**
         * Properties of a SyncdRecord.
         * @memberof proto
         * @interface ISyncdRecord
         * @property {proto.ISyncdIndex|null} [index] SyncdRecord index
         * @property {proto.ISyncdValue|null} [value] SyncdRecord value
         * @property {proto.IKeyId|null} [keyId] SyncdRecord keyId
         */

        /**
         * Constructs a new SyncdRecord.
         * @memberof proto
         * @classdesc Represents a SyncdRecord.
         * @implements ISyncdRecord
         * @constructor
         * @param {proto.ISyncdRecord=} [properties] Properties to set
         */
        function SyncdRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncdRecord index.
         * @member {proto.ISyncdIndex|null|undefined} index
         * @memberof proto.SyncdRecord
         * @instance
         */
        SyncdRecord.prototype.index = null;

        /**
         * SyncdRecord value.
         * @member {proto.ISyncdValue|null|undefined} value
         * @memberof proto.SyncdRecord
         * @instance
         */
        SyncdRecord.prototype.value = null;

        /**
         * SyncdRecord keyId.
         * @member {proto.IKeyId|null|undefined} keyId
         * @memberof proto.SyncdRecord
         * @instance
         */
        SyncdRecord.prototype.keyId = null;

        /**
         * Creates a new SyncdRecord instance using the specified properties.
         * @function create
         * @memberof proto.SyncdRecord
         * @static
         * @param {proto.ISyncdRecord=} [properties] Properties to set
         * @returns {proto.SyncdRecord} SyncdRecord instance
         */
        SyncdRecord.create = function create(properties) {
            return new SyncdRecord(properties);
        };

        /**
         * Encodes the specified SyncdRecord message. Does not implicitly {@link proto.SyncdRecord.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncdRecord
         * @static
         * @param {proto.ISyncdRecord} message SyncdRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                $root.proto.SyncdIndex.encode(message.index, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                $root.proto.SyncdValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.keyId != null && Object.hasOwnProperty.call(message, "keyId"))
                $root.proto.KeyId.encode(message.keyId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncdRecord message, length delimited. Does not implicitly {@link proto.SyncdRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncdRecord
         * @static
         * @param {proto.ISyncdRecord} message SyncdRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncdRecord message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncdRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncdRecord} SyncdRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncdRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = $root.proto.SyncdIndex.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.value = $root.proto.SyncdValue.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.keyId = $root.proto.KeyId.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncdRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncdRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncdRecord} SyncdRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncdRecord message.
         * @function verify
         * @memberof proto.SyncdRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncdRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index")) {
                var error = $root.proto.SyncdIndex.verify(message.index);
                if (error)
                    return "index." + error;
            }
            if (message.value != null && message.hasOwnProperty("value")) {
                var error = $root.proto.SyncdValue.verify(message.value);
                if (error)
                    return "value." + error;
            }
            if (message.keyId != null && message.hasOwnProperty("keyId")) {
                var error = $root.proto.KeyId.verify(message.keyId);
                if (error)
                    return "keyId." + error;
            }
            return null;
        };

        /**
         * Creates a SyncdRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncdRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncdRecord} SyncdRecord
         */
        SyncdRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncdRecord)
                return object;
            var message = new $root.proto.SyncdRecord();
            if (object.index != null) {
                if (typeof object.index !== "object")
                    throw TypeError(".proto.SyncdRecord.index: object expected");
                message.index = $root.proto.SyncdIndex.fromObject(object.index);
            }
            if (object.value != null) {
                if (typeof object.value !== "object")
                    throw TypeError(".proto.SyncdRecord.value: object expected");
                message.value = $root.proto.SyncdValue.fromObject(object.value);
            }
            if (object.keyId != null) {
                if (typeof object.keyId !== "object")
                    throw TypeError(".proto.SyncdRecord.keyId: object expected");
                message.keyId = $root.proto.KeyId.fromObject(object.keyId);
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncdRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncdRecord
         * @static
         * @param {proto.SyncdRecord} message SyncdRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncdRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = null;
                object.value = null;
                object.keyId = null;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = $root.proto.SyncdIndex.toObject(message.index, options);
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = $root.proto.SyncdValue.toObject(message.value, options);
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                object.keyId = $root.proto.KeyId.toObject(message.keyId, options);
            return object;
        };

        /**
         * Converts this SyncdRecord to JSON.
         * @function toJSON
         * @memberof proto.SyncdRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncdRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncdRecord;
    })();

    proto.SyncdSnapshot = (function() {

        /**
         * Properties of a SyncdSnapshot.
         * @memberof proto
         * @interface ISyncdSnapshot
         * @property {proto.ISyncdVersion|null} [version] SyncdSnapshot version
         * @property {Array.<proto.ISyncdRecord>|null} [records] SyncdSnapshot records
         * @property {Uint8Array|null} [mac] SyncdSnapshot mac
         * @property {proto.IKeyId|null} [keyId] SyncdSnapshot keyId
         */

        /**
         * Constructs a new SyncdSnapshot.
         * @memberof proto
         * @classdesc Represents a SyncdSnapshot.
         * @implements ISyncdSnapshot
         * @constructor
         * @param {proto.ISyncdSnapshot=} [properties] Properties to set
         */
        function SyncdSnapshot(properties) {
            this.records = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncdSnapshot version.
         * @member {proto.ISyncdVersion|null|undefined} version
         * @memberof proto.SyncdSnapshot
         * @instance
         */
        SyncdSnapshot.prototype.version = null;

        /**
         * SyncdSnapshot records.
         * @member {Array.<proto.ISyncdRecord>} records
         * @memberof proto.SyncdSnapshot
         * @instance
         */
        SyncdSnapshot.prototype.records = $util.emptyArray;

        /**
         * SyncdSnapshot mac.
         * @member {Uint8Array} mac
         * @memberof proto.SyncdSnapshot
         * @instance
         */
        SyncdSnapshot.prototype.mac = $util.newBuffer([]);

        /**
         * SyncdSnapshot keyId.
         * @member {proto.IKeyId|null|undefined} keyId
         * @memberof proto.SyncdSnapshot
         * @instance
         */
        SyncdSnapshot.prototype.keyId = null;

        /**
         * Creates a new SyncdSnapshot instance using the specified properties.
         * @function create
         * @memberof proto.SyncdSnapshot
         * @static
         * @param {proto.ISyncdSnapshot=} [properties] Properties to set
         * @returns {proto.SyncdSnapshot} SyncdSnapshot instance
         */
        SyncdSnapshot.create = function create(properties) {
            return new SyncdSnapshot(properties);
        };

        /**
         * Encodes the specified SyncdSnapshot message. Does not implicitly {@link proto.SyncdSnapshot.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncdSnapshot
         * @static
         * @param {proto.ISyncdSnapshot} message SyncdSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdSnapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                $root.proto.SyncdVersion.encode(message.version, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.records != null && message.records.length)
                for (var i = 0; i < message.records.length; ++i)
                    $root.proto.SyncdRecord.encode(message.records[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.mac != null && Object.hasOwnProperty.call(message, "mac"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.mac);
            if (message.keyId != null && Object.hasOwnProperty.call(message, "keyId"))
                $root.proto.KeyId.encode(message.keyId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncdSnapshot message, length delimited. Does not implicitly {@link proto.SyncdSnapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncdSnapshot
         * @static
         * @param {proto.ISyncdSnapshot} message SyncdSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncdSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncdSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncdSnapshot} SyncdSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdSnapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncdSnapshot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = $root.proto.SyncdVersion.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push($root.proto.SyncdRecord.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.mac = reader.bytes();
                    break;
                case 4:
                    message.keyId = $root.proto.KeyId.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncdSnapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncdSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncdSnapshot} SyncdSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdSnapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncdSnapshot message.
         * @function verify
         * @memberof proto.SyncdSnapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncdSnapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version")) {
                var error = $root.proto.SyncdVersion.verify(message.version);
                if (error)
                    return "version." + error;
            }
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (var i = 0; i < message.records.length; ++i) {
                    var error = $root.proto.SyncdRecord.verify(message.records[i]);
                    if (error)
                        return "records." + error;
                }
            }
            if (message.mac != null && message.hasOwnProperty("mac"))
                if (!(message.mac && typeof message.mac.length === "number" || $util.isString(message.mac)))
                    return "mac: buffer expected";
            if (message.keyId != null && message.hasOwnProperty("keyId")) {
                var error = $root.proto.KeyId.verify(message.keyId);
                if (error)
                    return "keyId." + error;
            }
            return null;
        };

        /**
         * Creates a SyncdSnapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncdSnapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncdSnapshot} SyncdSnapshot
         */
        SyncdSnapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncdSnapshot)
                return object;
            var message = new $root.proto.SyncdSnapshot();
            if (object.version != null) {
                if (typeof object.version !== "object")
                    throw TypeError(".proto.SyncdSnapshot.version: object expected");
                message.version = $root.proto.SyncdVersion.fromObject(object.version);
            }
            if (object.records) {
                if (!Array.isArray(object.records))
                    throw TypeError(".proto.SyncdSnapshot.records: array expected");
                message.records = [];
                for (var i = 0; i < object.records.length; ++i) {
                    if (typeof object.records[i] !== "object")
                        throw TypeError(".proto.SyncdSnapshot.records: object expected");
                    message.records[i] = $root.proto.SyncdRecord.fromObject(object.records[i]);
                }
            }
            if (object.mac != null)
                if (typeof object.mac === "string")
                    $util.base64.decode(object.mac, message.mac = $util.newBuffer($util.base64.length(object.mac)), 0);
                else if (object.mac.length)
                    message.mac = object.mac;
            if (object.keyId != null) {
                if (typeof object.keyId !== "object")
                    throw TypeError(".proto.SyncdSnapshot.keyId: object expected");
                message.keyId = $root.proto.KeyId.fromObject(object.keyId);
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncdSnapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncdSnapshot
         * @static
         * @param {proto.SyncdSnapshot} message SyncdSnapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncdSnapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.records = [];
            if (options.defaults) {
                object.version = null;
                if (options.bytes === String)
                    object.mac = "";
                else {
                    object.mac = [];
                    if (options.bytes !== Array)
                        object.mac = $util.newBuffer(object.mac);
                }
                object.keyId = null;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = $root.proto.SyncdVersion.toObject(message.version, options);
            if (message.records && message.records.length) {
                object.records = [];
                for (var j = 0; j < message.records.length; ++j)
                    object.records[j] = $root.proto.SyncdRecord.toObject(message.records[j], options);
            }
            if (message.mac != null && message.hasOwnProperty("mac"))
                object.mac = options.bytes === String ? $util.base64.encode(message.mac, 0, message.mac.length) : options.bytes === Array ? Array.prototype.slice.call(message.mac) : message.mac;
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                object.keyId = $root.proto.KeyId.toObject(message.keyId, options);
            return object;
        };

        /**
         * Converts this SyncdSnapshot to JSON.
         * @function toJSON
         * @memberof proto.SyncdSnapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncdSnapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncdSnapshot;
    })();

    proto.SyncdValue = (function() {

        /**
         * Properties of a SyncdValue.
         * @memberof proto
         * @interface ISyncdValue
         * @property {Uint8Array|null} [blob] SyncdValue blob
         */

        /**
         * Constructs a new SyncdValue.
         * @memberof proto
         * @classdesc Represents a SyncdValue.
         * @implements ISyncdValue
         * @constructor
         * @param {proto.ISyncdValue=} [properties] Properties to set
         */
        function SyncdValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncdValue blob.
         * @member {Uint8Array} blob
         * @memberof proto.SyncdValue
         * @instance
         */
        SyncdValue.prototype.blob = $util.newBuffer([]);

        /**
         * Creates a new SyncdValue instance using the specified properties.
         * @function create
         * @memberof proto.SyncdValue
         * @static
         * @param {proto.ISyncdValue=} [properties] Properties to set
         * @returns {proto.SyncdValue} SyncdValue instance
         */
        SyncdValue.create = function create(properties) {
            return new SyncdValue(properties);
        };

        /**
         * Encodes the specified SyncdValue message. Does not implicitly {@link proto.SyncdValue.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncdValue
         * @static
         * @param {proto.ISyncdValue} message SyncdValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blob);
            return writer;
        };

        /**
         * Encodes the specified SyncdValue message, length delimited. Does not implicitly {@link proto.SyncdValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncdValue
         * @static
         * @param {proto.ISyncdValue} message SyncdValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncdValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncdValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncdValue} SyncdValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncdValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blob = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncdValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncdValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncdValue} SyncdValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncdValue message.
         * @function verify
         * @memberof proto.SyncdValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncdValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blob != null && message.hasOwnProperty("blob"))
                if (!(message.blob && typeof message.blob.length === "number" || $util.isString(message.blob)))
                    return "blob: buffer expected";
            return null;
        };

        /**
         * Creates a SyncdValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncdValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncdValue} SyncdValue
         */
        SyncdValue.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncdValue)
                return object;
            var message = new $root.proto.SyncdValue();
            if (object.blob != null)
                if (typeof object.blob === "string")
                    $util.base64.decode(object.blob, message.blob = $util.newBuffer($util.base64.length(object.blob)), 0);
                else if (object.blob.length)
                    message.blob = object.blob;
            return message;
        };

        /**
         * Creates a plain object from a SyncdValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncdValue
         * @static
         * @param {proto.SyncdValue} message SyncdValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncdValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.blob = "";
                else {
                    object.blob = [];
                    if (options.bytes !== Array)
                        object.blob = $util.newBuffer(object.blob);
                }
            if (message.blob != null && message.hasOwnProperty("blob"))
                object.blob = options.bytes === String ? $util.base64.encode(message.blob, 0, message.blob.length) : options.bytes === Array ? Array.prototype.slice.call(message.blob) : message.blob;
            return object;
        };

        /**
         * Converts this SyncdValue to JSON.
         * @function toJSON
         * @memberof proto.SyncdValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncdValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncdValue;
    })();

    proto.SyncdVersion = (function() {

        /**
         * Properties of a SyncdVersion.
         * @memberof proto
         * @interface ISyncdVersion
         * @property {number|Long|null} [version] SyncdVersion version
         */

        /**
         * Constructs a new SyncdVersion.
         * @memberof proto
         * @classdesc Represents a SyncdVersion.
         * @implements ISyncdVersion
         * @constructor
         * @param {proto.ISyncdVersion=} [properties] Properties to set
         */
        function SyncdVersion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncdVersion version.
         * @member {number|Long} version
         * @memberof proto.SyncdVersion
         * @instance
         */
        SyncdVersion.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SyncdVersion instance using the specified properties.
         * @function create
         * @memberof proto.SyncdVersion
         * @static
         * @param {proto.ISyncdVersion=} [properties] Properties to set
         * @returns {proto.SyncdVersion} SyncdVersion instance
         */
        SyncdVersion.create = function create(properties) {
            return new SyncdVersion(properties);
        };

        /**
         * Encodes the specified SyncdVersion message. Does not implicitly {@link proto.SyncdVersion.verify|verify} messages.
         * @function encode
         * @memberof proto.SyncdVersion
         * @static
         * @param {proto.ISyncdVersion} message SyncdVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdVersion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
            return writer;
        };

        /**
         * Encodes the specified SyncdVersion message, length delimited. Does not implicitly {@link proto.SyncdVersion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SyncdVersion
         * @static
         * @param {proto.ISyncdVersion} message SyncdVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncdVersion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncdVersion message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SyncdVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SyncdVersion} SyncdVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdVersion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SyncdVersion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncdVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SyncdVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SyncdVersion} SyncdVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncdVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncdVersion message.
         * @function verify
         * @memberof proto.SyncdVersion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncdVersion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                    return "version: integer|Long expected";
            return null;
        };

        /**
         * Creates a SyncdVersion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SyncdVersion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SyncdVersion} SyncdVersion
         */
        SyncdVersion.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SyncdVersion)
                return object;
            var message = new $root.proto.SyncdVersion();
            if (object.version != null)
                if ($util.Long)
                    (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                else if (typeof object.version === "string")
                    message.version = parseInt(object.version, 10);
                else if (typeof object.version === "number")
                    message.version = object.version;
                else if (typeof object.version === "object")
                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SyncdVersion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SyncdVersion
         * @static
         * @param {proto.SyncdVersion} message SyncdVersion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncdVersion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.version = options.longs === String ? "0" : 0;
            if (message.version != null && message.hasOwnProperty("version"))
                if (typeof message.version === "number")
                    object.version = options.longs === String ? String(message.version) : message.version;
                else
                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
            return object;
        };

        /**
         * Converts this SyncdVersion to JSON.
         * @function toJSON
         * @memberof proto.SyncdVersion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncdVersion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncdVersion;
    })();

    proto.TemplateButton = (function() {

        /**
         * Properties of a TemplateButton.
         * @memberof proto
         * @interface ITemplateButton
         * @property {number|null} [index] TemplateButton index
         * @property {proto.TemplateButton.IQuickReplyButton|null} [quickReplyButton] TemplateButton quickReplyButton
         * @property {proto.TemplateButton.IURLButton|null} [urlButton] TemplateButton urlButton
         * @property {proto.TemplateButton.ICallButton|null} [callButton] TemplateButton callButton
         */

        /**
         * Constructs a new TemplateButton.
         * @memberof proto
         * @classdesc Represents a TemplateButton.
         * @implements ITemplateButton
         * @constructor
         * @param {proto.ITemplateButton=} [properties] Properties to set
         */
        function TemplateButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TemplateButton index.
         * @member {number} index
         * @memberof proto.TemplateButton
         * @instance
         */
        TemplateButton.prototype.index = 0;

        /**
         * TemplateButton quickReplyButton.
         * @member {proto.TemplateButton.IQuickReplyButton|null|undefined} quickReplyButton
         * @memberof proto.TemplateButton
         * @instance
         */
        TemplateButton.prototype.quickReplyButton = null;

        /**
         * TemplateButton urlButton.
         * @member {proto.TemplateButton.IURLButton|null|undefined} urlButton
         * @memberof proto.TemplateButton
         * @instance
         */
        TemplateButton.prototype.urlButton = null;

        /**
         * TemplateButton callButton.
         * @member {proto.TemplateButton.ICallButton|null|undefined} callButton
         * @memberof proto.TemplateButton
         * @instance
         */
        TemplateButton.prototype.callButton = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TemplateButton button.
         * @member {"quickReplyButton"|"urlButton"|"callButton"|undefined} button
         * @memberof proto.TemplateButton
         * @instance
         */
        Object.defineProperty(TemplateButton.prototype, "button", {
            get: $util.oneOfGetter($oneOfFields = ["quickReplyButton", "urlButton", "callButton"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TemplateButton instance using the specified properties.
         * @function create
         * @memberof proto.TemplateButton
         * @static
         * @param {proto.ITemplateButton=} [properties] Properties to set
         * @returns {proto.TemplateButton} TemplateButton instance
         */
        TemplateButton.create = function create(properties) {
            return new TemplateButton(properties);
        };

        /**
         * Encodes the specified TemplateButton message. Does not implicitly {@link proto.TemplateButton.verify|verify} messages.
         * @function encode
         * @memberof proto.TemplateButton
         * @static
         * @param {proto.ITemplateButton} message TemplateButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.quickReplyButton != null && Object.hasOwnProperty.call(message, "quickReplyButton"))
                $root.proto.TemplateButton.QuickReplyButton.encode(message.quickReplyButton, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.urlButton != null && Object.hasOwnProperty.call(message, "urlButton"))
                $root.proto.TemplateButton.URLButton.encode(message.urlButton, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.callButton != null && Object.hasOwnProperty.call(message, "callButton"))
                $root.proto.TemplateButton.CallButton.encode(message.callButton, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.index);
            return writer;
        };

        /**
         * Encodes the specified TemplateButton message, length delimited. Does not implicitly {@link proto.TemplateButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TemplateButton
         * @static
         * @param {proto.ITemplateButton} message TemplateButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TemplateButton message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TemplateButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TemplateButton} TemplateButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TemplateButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.index = reader.uint32();
                    break;
                case 1:
                    message.quickReplyButton = $root.proto.TemplateButton.QuickReplyButton.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.urlButton = $root.proto.TemplateButton.URLButton.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.callButton = $root.proto.TemplateButton.CallButton.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TemplateButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TemplateButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TemplateButton} TemplateButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TemplateButton message.
         * @function verify
         * @memberof proto.TemplateButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TemplateButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.quickReplyButton != null && message.hasOwnProperty("quickReplyButton")) {
                properties.button = 1;
                {
                    var error = $root.proto.TemplateButton.QuickReplyButton.verify(message.quickReplyButton);
                    if (error)
                        return "quickReplyButton." + error;
                }
            }
            if (message.urlButton != null && message.hasOwnProperty("urlButton")) {
                if (properties.button === 1)
                    return "button: multiple values";
                properties.button = 1;
                {
                    var error = $root.proto.TemplateButton.URLButton.verify(message.urlButton);
                    if (error)
                        return "urlButton." + error;
                }
            }
            if (message.callButton != null && message.hasOwnProperty("callButton")) {
                if (properties.button === 1)
                    return "button: multiple values";
                properties.button = 1;
                {
                    var error = $root.proto.TemplateButton.CallButton.verify(message.callButton);
                    if (error)
                        return "callButton." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TemplateButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TemplateButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TemplateButton} TemplateButton
         */
        TemplateButton.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TemplateButton)
                return object;
            var message = new $root.proto.TemplateButton();
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.quickReplyButton != null) {
                if (typeof object.quickReplyButton !== "object")
                    throw TypeError(".proto.TemplateButton.quickReplyButton: object expected");
                message.quickReplyButton = $root.proto.TemplateButton.QuickReplyButton.fromObject(object.quickReplyButton);
            }
            if (object.urlButton != null) {
                if (typeof object.urlButton !== "object")
                    throw TypeError(".proto.TemplateButton.urlButton: object expected");
                message.urlButton = $root.proto.TemplateButton.URLButton.fromObject(object.urlButton);
            }
            if (object.callButton != null) {
                if (typeof object.callButton !== "object")
                    throw TypeError(".proto.TemplateButton.callButton: object expected");
                message.callButton = $root.proto.TemplateButton.CallButton.fromObject(object.callButton);
            }
            return message;
        };

        /**
         * Creates a plain object from a TemplateButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TemplateButton
         * @static
         * @param {proto.TemplateButton} message TemplateButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TemplateButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = 0;
            if (message.quickReplyButton != null && message.hasOwnProperty("quickReplyButton")) {
                object.quickReplyButton = $root.proto.TemplateButton.QuickReplyButton.toObject(message.quickReplyButton, options);
                if (options.oneofs)
                    object.button = "quickReplyButton";
            }
            if (message.urlButton != null && message.hasOwnProperty("urlButton")) {
                object.urlButton = $root.proto.TemplateButton.URLButton.toObject(message.urlButton, options);
                if (options.oneofs)
                    object.button = "urlButton";
            }
            if (message.callButton != null && message.hasOwnProperty("callButton")) {
                object.callButton = $root.proto.TemplateButton.CallButton.toObject(message.callButton, options);
                if (options.oneofs)
                    object.button = "callButton";
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this TemplateButton to JSON.
         * @function toJSON
         * @memberof proto.TemplateButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TemplateButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TemplateButton.CallButton = (function() {

            /**
             * Properties of a CallButton.
             * @memberof proto.TemplateButton
             * @interface ICallButton
             * @property {proto.Message.IHighlyStructuredMessage|null} [displayText] CallButton displayText
             * @property {proto.Message.IHighlyStructuredMessage|null} [phoneNumber] CallButton phoneNumber
             */

            /**
             * Constructs a new CallButton.
             * @memberof proto.TemplateButton
             * @classdesc Represents a CallButton.
             * @implements ICallButton
             * @constructor
             * @param {proto.TemplateButton.ICallButton=} [properties] Properties to set
             */
            function CallButton(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CallButton displayText.
             * @member {proto.Message.IHighlyStructuredMessage|null|undefined} displayText
             * @memberof proto.TemplateButton.CallButton
             * @instance
             */
            CallButton.prototype.displayText = null;

            /**
             * CallButton phoneNumber.
             * @member {proto.Message.IHighlyStructuredMessage|null|undefined} phoneNumber
             * @memberof proto.TemplateButton.CallButton
             * @instance
             */
            CallButton.prototype.phoneNumber = null;

            /**
             * Creates a new CallButton instance using the specified properties.
             * @function create
             * @memberof proto.TemplateButton.CallButton
             * @static
             * @param {proto.TemplateButton.ICallButton=} [properties] Properties to set
             * @returns {proto.TemplateButton.CallButton} CallButton instance
             */
            CallButton.create = function create(properties) {
                return new CallButton(properties);
            };

            /**
             * Encodes the specified CallButton message. Does not implicitly {@link proto.TemplateButton.CallButton.verify|verify} messages.
             * @function encode
             * @memberof proto.TemplateButton.CallButton
             * @static
             * @param {proto.TemplateButton.ICallButton} message CallButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallButton.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                    $root.proto.Message.HighlyStructuredMessage.encode(message.displayText, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.phoneNumber != null && Object.hasOwnProperty.call(message, "phoneNumber"))
                    $root.proto.Message.HighlyStructuredMessage.encode(message.phoneNumber, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CallButton message, length delimited. Does not implicitly {@link proto.TemplateButton.CallButton.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.TemplateButton.CallButton
             * @static
             * @param {proto.TemplateButton.ICallButton} message CallButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallButton.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CallButton message from the specified reader or buffer.
             * @function decode
             * @memberof proto.TemplateButton.CallButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.TemplateButton.CallButton} CallButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallButton.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TemplateButton.CallButton();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayText = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.phoneNumber = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CallButton message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.TemplateButton.CallButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.TemplateButton.CallButton} CallButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallButton.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CallButton message.
             * @function verify
             * @memberof proto.TemplateButton.CallButton
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CallButton.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayText != null && message.hasOwnProperty("displayText")) {
                    var error = $root.proto.Message.HighlyStructuredMessage.verify(message.displayText);
                    if (error)
                        return "displayText." + error;
                }
                if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber")) {
                    var error = $root.proto.Message.HighlyStructuredMessage.verify(message.phoneNumber);
                    if (error)
                        return "phoneNumber." + error;
                }
                return null;
            };

            /**
             * Creates a CallButton message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.TemplateButton.CallButton
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.TemplateButton.CallButton} CallButton
             */
            CallButton.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.TemplateButton.CallButton)
                    return object;
                var message = new $root.proto.TemplateButton.CallButton();
                if (object.displayText != null) {
                    if (typeof object.displayText !== "object")
                        throw TypeError(".proto.TemplateButton.CallButton.displayText: object expected");
                    message.displayText = $root.proto.Message.HighlyStructuredMessage.fromObject(object.displayText);
                }
                if (object.phoneNumber != null) {
                    if (typeof object.phoneNumber !== "object")
                        throw TypeError(".proto.TemplateButton.CallButton.phoneNumber: object expected");
                    message.phoneNumber = $root.proto.Message.HighlyStructuredMessage.fromObject(object.phoneNumber);
                }
                return message;
            };

            /**
             * Creates a plain object from a CallButton message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.TemplateButton.CallButton
             * @static
             * @param {proto.TemplateButton.CallButton} message CallButton
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CallButton.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayText = null;
                    object.phoneNumber = null;
                }
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    object.displayText = $root.proto.Message.HighlyStructuredMessage.toObject(message.displayText, options);
                if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                    object.phoneNumber = $root.proto.Message.HighlyStructuredMessage.toObject(message.phoneNumber, options);
                return object;
            };

            /**
             * Converts this CallButton to JSON.
             * @function toJSON
             * @memberof proto.TemplateButton.CallButton
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CallButton.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CallButton;
        })();

        TemplateButton.QuickReplyButton = (function() {

            /**
             * Properties of a QuickReplyButton.
             * @memberof proto.TemplateButton
             * @interface IQuickReplyButton
             * @property {proto.Message.IHighlyStructuredMessage|null} [displayText] QuickReplyButton displayText
             * @property {string|null} [id] QuickReplyButton id
             */

            /**
             * Constructs a new QuickReplyButton.
             * @memberof proto.TemplateButton
             * @classdesc Represents a QuickReplyButton.
             * @implements IQuickReplyButton
             * @constructor
             * @param {proto.TemplateButton.IQuickReplyButton=} [properties] Properties to set
             */
            function QuickReplyButton(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QuickReplyButton displayText.
             * @member {proto.Message.IHighlyStructuredMessage|null|undefined} displayText
             * @memberof proto.TemplateButton.QuickReplyButton
             * @instance
             */
            QuickReplyButton.prototype.displayText = null;

            /**
             * QuickReplyButton id.
             * @member {string} id
             * @memberof proto.TemplateButton.QuickReplyButton
             * @instance
             */
            QuickReplyButton.prototype.id = "";

            /**
             * Creates a new QuickReplyButton instance using the specified properties.
             * @function create
             * @memberof proto.TemplateButton.QuickReplyButton
             * @static
             * @param {proto.TemplateButton.IQuickReplyButton=} [properties] Properties to set
             * @returns {proto.TemplateButton.QuickReplyButton} QuickReplyButton instance
             */
            QuickReplyButton.create = function create(properties) {
                return new QuickReplyButton(properties);
            };

            /**
             * Encodes the specified QuickReplyButton message. Does not implicitly {@link proto.TemplateButton.QuickReplyButton.verify|verify} messages.
             * @function encode
             * @memberof proto.TemplateButton.QuickReplyButton
             * @static
             * @param {proto.TemplateButton.IQuickReplyButton} message QuickReplyButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuickReplyButton.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                    $root.proto.Message.HighlyStructuredMessage.encode(message.displayText, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified QuickReplyButton message, length delimited. Does not implicitly {@link proto.TemplateButton.QuickReplyButton.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.TemplateButton.QuickReplyButton
             * @static
             * @param {proto.TemplateButton.IQuickReplyButton} message QuickReplyButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuickReplyButton.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QuickReplyButton message from the specified reader or buffer.
             * @function decode
             * @memberof proto.TemplateButton.QuickReplyButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.TemplateButton.QuickReplyButton} QuickReplyButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuickReplyButton.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TemplateButton.QuickReplyButton();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayText = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QuickReplyButton message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.TemplateButton.QuickReplyButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.TemplateButton.QuickReplyButton} QuickReplyButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuickReplyButton.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QuickReplyButton message.
             * @function verify
             * @memberof proto.TemplateButton.QuickReplyButton
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QuickReplyButton.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayText != null && message.hasOwnProperty("displayText")) {
                    var error = $root.proto.Message.HighlyStructuredMessage.verify(message.displayText);
                    if (error)
                        return "displayText." + error;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a QuickReplyButton message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.TemplateButton.QuickReplyButton
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.TemplateButton.QuickReplyButton} QuickReplyButton
             */
            QuickReplyButton.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.TemplateButton.QuickReplyButton)
                    return object;
                var message = new $root.proto.TemplateButton.QuickReplyButton();
                if (object.displayText != null) {
                    if (typeof object.displayText !== "object")
                        throw TypeError(".proto.TemplateButton.QuickReplyButton.displayText: object expected");
                    message.displayText = $root.proto.Message.HighlyStructuredMessage.fromObject(object.displayText);
                }
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a QuickReplyButton message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.TemplateButton.QuickReplyButton
             * @static
             * @param {proto.TemplateButton.QuickReplyButton} message QuickReplyButton
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QuickReplyButton.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayText = null;
                    object.id = "";
                }
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    object.displayText = $root.proto.Message.HighlyStructuredMessage.toObject(message.displayText, options);
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this QuickReplyButton to JSON.
             * @function toJSON
             * @memberof proto.TemplateButton.QuickReplyButton
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QuickReplyButton.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QuickReplyButton;
        })();

        TemplateButton.URLButton = (function() {

            /**
             * Properties of a URLButton.
             * @memberof proto.TemplateButton
             * @interface IURLButton
             * @property {proto.Message.IHighlyStructuredMessage|null} [displayText] URLButton displayText
             * @property {proto.Message.IHighlyStructuredMessage|null} [url] URLButton url
             */

            /**
             * Constructs a new URLButton.
             * @memberof proto.TemplateButton
             * @classdesc Represents a URLButton.
             * @implements IURLButton
             * @constructor
             * @param {proto.TemplateButton.IURLButton=} [properties] Properties to set
             */
            function URLButton(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * URLButton displayText.
             * @member {proto.Message.IHighlyStructuredMessage|null|undefined} displayText
             * @memberof proto.TemplateButton.URLButton
             * @instance
             */
            URLButton.prototype.displayText = null;

            /**
             * URLButton url.
             * @member {proto.Message.IHighlyStructuredMessage|null|undefined} url
             * @memberof proto.TemplateButton.URLButton
             * @instance
             */
            URLButton.prototype.url = null;

            /**
             * Creates a new URLButton instance using the specified properties.
             * @function create
             * @memberof proto.TemplateButton.URLButton
             * @static
             * @param {proto.TemplateButton.IURLButton=} [properties] Properties to set
             * @returns {proto.TemplateButton.URLButton} URLButton instance
             */
            URLButton.create = function create(properties) {
                return new URLButton(properties);
            };

            /**
             * Encodes the specified URLButton message. Does not implicitly {@link proto.TemplateButton.URLButton.verify|verify} messages.
             * @function encode
             * @memberof proto.TemplateButton.URLButton
             * @static
             * @param {proto.TemplateButton.IURLButton} message URLButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            URLButton.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                    $root.proto.Message.HighlyStructuredMessage.encode(message.displayText, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    $root.proto.Message.HighlyStructuredMessage.encode(message.url, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified URLButton message, length delimited. Does not implicitly {@link proto.TemplateButton.URLButton.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.TemplateButton.URLButton
             * @static
             * @param {proto.TemplateButton.IURLButton} message URLButton message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            URLButton.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a URLButton message from the specified reader or buffer.
             * @function decode
             * @memberof proto.TemplateButton.URLButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.TemplateButton.URLButton} URLButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            URLButton.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TemplateButton.URLButton();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.displayText = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.url = $root.proto.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a URLButton message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.TemplateButton.URLButton
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.TemplateButton.URLButton} URLButton
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            URLButton.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a URLButton message.
             * @function verify
             * @memberof proto.TemplateButton.URLButton
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            URLButton.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.displayText != null && message.hasOwnProperty("displayText")) {
                    var error = $root.proto.Message.HighlyStructuredMessage.verify(message.displayText);
                    if (error)
                        return "displayText." + error;
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    var error = $root.proto.Message.HighlyStructuredMessage.verify(message.url);
                    if (error)
                        return "url." + error;
                }
                return null;
            };

            /**
             * Creates a URLButton message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.TemplateButton.URLButton
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.TemplateButton.URLButton} URLButton
             */
            URLButton.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.TemplateButton.URLButton)
                    return object;
                var message = new $root.proto.TemplateButton.URLButton();
                if (object.displayText != null) {
                    if (typeof object.displayText !== "object")
                        throw TypeError(".proto.TemplateButton.URLButton.displayText: object expected");
                    message.displayText = $root.proto.Message.HighlyStructuredMessage.fromObject(object.displayText);
                }
                if (object.url != null) {
                    if (typeof object.url !== "object")
                        throw TypeError(".proto.TemplateButton.URLButton.url: object expected");
                    message.url = $root.proto.Message.HighlyStructuredMessage.fromObject(object.url);
                }
                return message;
            };

            /**
             * Creates a plain object from a URLButton message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.TemplateButton.URLButton
             * @static
             * @param {proto.TemplateButton.URLButton} message URLButton
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            URLButton.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.displayText = null;
                    object.url = null;
                }
                if (message.displayText != null && message.hasOwnProperty("displayText"))
                    object.displayText = $root.proto.Message.HighlyStructuredMessage.toObject(message.displayText, options);
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = $root.proto.Message.HighlyStructuredMessage.toObject(message.url, options);
                return object;
            };

            /**
             * Converts this URLButton to JSON.
             * @function toJSON
             * @memberof proto.TemplateButton.URLButton
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            URLButton.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return URLButton;
        })();

        return TemplateButton;
    })();

    proto.UserReceipt = (function() {

        /**
         * Properties of a UserReceipt.
         * @memberof proto
         * @interface IUserReceipt
         * @property {string} userJid UserReceipt userJid
         * @property {number|Long|null} [receiptTimestamp] UserReceipt receiptTimestamp
         * @property {number|Long|null} [readTimestamp] UserReceipt readTimestamp
         * @property {number|Long|null} [playedTimestamp] UserReceipt playedTimestamp
         * @property {Array.<string>|null} [pendingDeviceJid] UserReceipt pendingDeviceJid
         * @property {Array.<string>|null} [deliveredDeviceJid] UserReceipt deliveredDeviceJid
         */

        /**
         * Constructs a new UserReceipt.
         * @memberof proto
         * @classdesc Represents a UserReceipt.
         * @implements IUserReceipt
         * @constructor
         * @param {proto.IUserReceipt=} [properties] Properties to set
         */
        function UserReceipt(properties) {
            this.pendingDeviceJid = [];
            this.deliveredDeviceJid = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserReceipt userJid.
         * @member {string} userJid
         * @memberof proto.UserReceipt
         * @instance
         */
        UserReceipt.prototype.userJid = "";

        /**
         * UserReceipt receiptTimestamp.
         * @member {number|Long} receiptTimestamp
         * @memberof proto.UserReceipt
         * @instance
         */
        UserReceipt.prototype.receiptTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserReceipt readTimestamp.
         * @member {number|Long} readTimestamp
         * @memberof proto.UserReceipt
         * @instance
         */
        UserReceipt.prototype.readTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserReceipt playedTimestamp.
         * @member {number|Long} playedTimestamp
         * @memberof proto.UserReceipt
         * @instance
         */
        UserReceipt.prototype.playedTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserReceipt pendingDeviceJid.
         * @member {Array.<string>} pendingDeviceJid
         * @memberof proto.UserReceipt
         * @instance
         */
        UserReceipt.prototype.pendingDeviceJid = $util.emptyArray;

        /**
         * UserReceipt deliveredDeviceJid.
         * @member {Array.<string>} deliveredDeviceJid
         * @memberof proto.UserReceipt
         * @instance
         */
        UserReceipt.prototype.deliveredDeviceJid = $util.emptyArray;

        /**
         * Creates a new UserReceipt instance using the specified properties.
         * @function create
         * @memberof proto.UserReceipt
         * @static
         * @param {proto.IUserReceipt=} [properties] Properties to set
         * @returns {proto.UserReceipt} UserReceipt instance
         */
        UserReceipt.create = function create(properties) {
            return new UserReceipt(properties);
        };

        /**
         * Encodes the specified UserReceipt message. Does not implicitly {@link proto.UserReceipt.verify|verify} messages.
         * @function encode
         * @memberof proto.UserReceipt
         * @static
         * @param {proto.IUserReceipt} message UserReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.userJid);
            if (message.receiptTimestamp != null && Object.hasOwnProperty.call(message, "receiptTimestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.receiptTimestamp);
            if (message.readTimestamp != null && Object.hasOwnProperty.call(message, "readTimestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.readTimestamp);
            if (message.playedTimestamp != null && Object.hasOwnProperty.call(message, "playedTimestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.playedTimestamp);
            if (message.pendingDeviceJid != null && message.pendingDeviceJid.length)
                for (var i = 0; i < message.pendingDeviceJid.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.pendingDeviceJid[i]);
            if (message.deliveredDeviceJid != null && message.deliveredDeviceJid.length)
                for (var i = 0; i < message.deliveredDeviceJid.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.deliveredDeviceJid[i]);
            return writer;
        };

        /**
         * Encodes the specified UserReceipt message, length delimited. Does not implicitly {@link proto.UserReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.UserReceipt
         * @static
         * @param {proto.IUserReceipt} message UserReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserReceipt} UserReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userJid = reader.string();
                    break;
                case 2:
                    message.receiptTimestamp = reader.int64();
                    break;
                case 3:
                    message.readTimestamp = reader.int64();
                    break;
                case 4:
                    message.playedTimestamp = reader.int64();
                    break;
                case 5:
                    if (!(message.pendingDeviceJid && message.pendingDeviceJid.length))
                        message.pendingDeviceJid = [];
                    message.pendingDeviceJid.push(reader.string());
                    break;
                case 6:
                    if (!(message.deliveredDeviceJid && message.deliveredDeviceJid.length))
                        message.deliveredDeviceJid = [];
                    message.deliveredDeviceJid.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userJid"))
                throw $util.ProtocolError("missing required 'userJid'", { instance: message });
            return message;
        };

        /**
         * Decodes a UserReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.UserReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.UserReceipt} UserReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserReceipt message.
         * @function verify
         * @memberof proto.UserReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.userJid))
                return "userJid: string expected";
            if (message.receiptTimestamp != null && message.hasOwnProperty("receiptTimestamp"))
                if (!$util.isInteger(message.receiptTimestamp) && !(message.receiptTimestamp && $util.isInteger(message.receiptTimestamp.low) && $util.isInteger(message.receiptTimestamp.high)))
                    return "receiptTimestamp: integer|Long expected";
            if (message.readTimestamp != null && message.hasOwnProperty("readTimestamp"))
                if (!$util.isInteger(message.readTimestamp) && !(message.readTimestamp && $util.isInteger(message.readTimestamp.low) && $util.isInteger(message.readTimestamp.high)))
                    return "readTimestamp: integer|Long expected";
            if (message.playedTimestamp != null && message.hasOwnProperty("playedTimestamp"))
                if (!$util.isInteger(message.playedTimestamp) && !(message.playedTimestamp && $util.isInteger(message.playedTimestamp.low) && $util.isInteger(message.playedTimestamp.high)))
                    return "playedTimestamp: integer|Long expected";
            if (message.pendingDeviceJid != null && message.hasOwnProperty("pendingDeviceJid")) {
                if (!Array.isArray(message.pendingDeviceJid))
                    return "pendingDeviceJid: array expected";
                for (var i = 0; i < message.pendingDeviceJid.length; ++i)
                    if (!$util.isString(message.pendingDeviceJid[i]))
                        return "pendingDeviceJid: string[] expected";
            }
            if (message.deliveredDeviceJid != null && message.hasOwnProperty("deliveredDeviceJid")) {
                if (!Array.isArray(message.deliveredDeviceJid))
                    return "deliveredDeviceJid: array expected";
                for (var i = 0; i < message.deliveredDeviceJid.length; ++i)
                    if (!$util.isString(message.deliveredDeviceJid[i]))
                        return "deliveredDeviceJid: string[] expected";
            }
            return null;
        };

        /**
         * Creates a UserReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.UserReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.UserReceipt} UserReceipt
         */
        UserReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.UserReceipt)
                return object;
            var message = new $root.proto.UserReceipt();
            if (object.userJid != null)
                message.userJid = String(object.userJid);
            if (object.receiptTimestamp != null)
                if ($util.Long)
                    (message.receiptTimestamp = $util.Long.fromValue(object.receiptTimestamp)).unsigned = false;
                else if (typeof object.receiptTimestamp === "string")
                    message.receiptTimestamp = parseInt(object.receiptTimestamp, 10);
                else if (typeof object.receiptTimestamp === "number")
                    message.receiptTimestamp = object.receiptTimestamp;
                else if (typeof object.receiptTimestamp === "object")
                    message.receiptTimestamp = new $util.LongBits(object.receiptTimestamp.low >>> 0, object.receiptTimestamp.high >>> 0).toNumber();
            if (object.readTimestamp != null)
                if ($util.Long)
                    (message.readTimestamp = $util.Long.fromValue(object.readTimestamp)).unsigned = false;
                else if (typeof object.readTimestamp === "string")
                    message.readTimestamp = parseInt(object.readTimestamp, 10);
                else if (typeof object.readTimestamp === "number")
                    message.readTimestamp = object.readTimestamp;
                else if (typeof object.readTimestamp === "object")
                    message.readTimestamp = new $util.LongBits(object.readTimestamp.low >>> 0, object.readTimestamp.high >>> 0).toNumber();
            if (object.playedTimestamp != null)
                if ($util.Long)
                    (message.playedTimestamp = $util.Long.fromValue(object.playedTimestamp)).unsigned = false;
                else if (typeof object.playedTimestamp === "string")
                    message.playedTimestamp = parseInt(object.playedTimestamp, 10);
                else if (typeof object.playedTimestamp === "number")
                    message.playedTimestamp = object.playedTimestamp;
                else if (typeof object.playedTimestamp === "object")
                    message.playedTimestamp = new $util.LongBits(object.playedTimestamp.low >>> 0, object.playedTimestamp.high >>> 0).toNumber();
            if (object.pendingDeviceJid) {
                if (!Array.isArray(object.pendingDeviceJid))
                    throw TypeError(".proto.UserReceipt.pendingDeviceJid: array expected");
                message.pendingDeviceJid = [];
                for (var i = 0; i < object.pendingDeviceJid.length; ++i)
                    message.pendingDeviceJid[i] = String(object.pendingDeviceJid[i]);
            }
            if (object.deliveredDeviceJid) {
                if (!Array.isArray(object.deliveredDeviceJid))
                    throw TypeError(".proto.UserReceipt.deliveredDeviceJid: array expected");
                message.deliveredDeviceJid = [];
                for (var i = 0; i < object.deliveredDeviceJid.length; ++i)
                    message.deliveredDeviceJid[i] = String(object.deliveredDeviceJid[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a UserReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.UserReceipt
         * @static
         * @param {proto.UserReceipt} message UserReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.pendingDeviceJid = [];
                object.deliveredDeviceJid = [];
            }
            if (options.defaults) {
                object.userJid = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.receiptTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.receiptTimestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.readTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.readTimestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.playedTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.playedTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.userJid != null && message.hasOwnProperty("userJid"))
                object.userJid = message.userJid;
            if (message.receiptTimestamp != null && message.hasOwnProperty("receiptTimestamp"))
                if (typeof message.receiptTimestamp === "number")
                    object.receiptTimestamp = options.longs === String ? String(message.receiptTimestamp) : message.receiptTimestamp;
                else
                    object.receiptTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.receiptTimestamp) : options.longs === Number ? new $util.LongBits(message.receiptTimestamp.low >>> 0, message.receiptTimestamp.high >>> 0).toNumber() : message.receiptTimestamp;
            if (message.readTimestamp != null && message.hasOwnProperty("readTimestamp"))
                if (typeof message.readTimestamp === "number")
                    object.readTimestamp = options.longs === String ? String(message.readTimestamp) : message.readTimestamp;
                else
                    object.readTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.readTimestamp) : options.longs === Number ? new $util.LongBits(message.readTimestamp.low >>> 0, message.readTimestamp.high >>> 0).toNumber() : message.readTimestamp;
            if (message.playedTimestamp != null && message.hasOwnProperty("playedTimestamp"))
                if (typeof message.playedTimestamp === "number")
                    object.playedTimestamp = options.longs === String ? String(message.playedTimestamp) : message.playedTimestamp;
                else
                    object.playedTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.playedTimestamp) : options.longs === Number ? new $util.LongBits(message.playedTimestamp.low >>> 0, message.playedTimestamp.high >>> 0).toNumber() : message.playedTimestamp;
            if (message.pendingDeviceJid && message.pendingDeviceJid.length) {
                object.pendingDeviceJid = [];
                for (var j = 0; j < message.pendingDeviceJid.length; ++j)
                    object.pendingDeviceJid[j] = message.pendingDeviceJid[j];
            }
            if (message.deliveredDeviceJid && message.deliveredDeviceJid.length) {
                object.deliveredDeviceJid = [];
                for (var j = 0; j < message.deliveredDeviceJid.length; ++j)
                    object.deliveredDeviceJid[j] = message.deliveredDeviceJid[j];
            }
            return object;
        };

        /**
         * Converts this UserReceipt to JSON.
         * @function toJSON
         * @memberof proto.UserReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserReceipt;
    })();

    proto.VerifiedNameCertificate = (function() {

        /**
         * Properties of a VerifiedNameCertificate.
         * @memberof proto
         * @interface IVerifiedNameCertificate
         * @property {Uint8Array|null} [details] VerifiedNameCertificate details
         * @property {Uint8Array|null} [signature] VerifiedNameCertificate signature
         * @property {Uint8Array|null} [serverSignature] VerifiedNameCertificate serverSignature
         */

        /**
         * Constructs a new VerifiedNameCertificate.
         * @memberof proto
         * @classdesc Represents a VerifiedNameCertificate.
         * @implements IVerifiedNameCertificate
         * @constructor
         * @param {proto.IVerifiedNameCertificate=} [properties] Properties to set
         */
        function VerifiedNameCertificate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifiedNameCertificate details.
         * @member {Uint8Array} details
         * @memberof proto.VerifiedNameCertificate
         * @instance
         */
        VerifiedNameCertificate.prototype.details = $util.newBuffer([]);

        /**
         * VerifiedNameCertificate signature.
         * @member {Uint8Array} signature
         * @memberof proto.VerifiedNameCertificate
         * @instance
         */
        VerifiedNameCertificate.prototype.signature = $util.newBuffer([]);

        /**
         * VerifiedNameCertificate serverSignature.
         * @member {Uint8Array} serverSignature
         * @memberof proto.VerifiedNameCertificate
         * @instance
         */
        VerifiedNameCertificate.prototype.serverSignature = $util.newBuffer([]);

        /**
         * Creates a new VerifiedNameCertificate instance using the specified properties.
         * @function create
         * @memberof proto.VerifiedNameCertificate
         * @static
         * @param {proto.IVerifiedNameCertificate=} [properties] Properties to set
         * @returns {proto.VerifiedNameCertificate} VerifiedNameCertificate instance
         */
        VerifiedNameCertificate.create = function create(properties) {
            return new VerifiedNameCertificate(properties);
        };

        /**
         * Encodes the specified VerifiedNameCertificate message. Does not implicitly {@link proto.VerifiedNameCertificate.verify|verify} messages.
         * @function encode
         * @memberof proto.VerifiedNameCertificate
         * @static
         * @param {proto.IVerifiedNameCertificate} message VerifiedNameCertificate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifiedNameCertificate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.details);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            if (message.serverSignature != null && Object.hasOwnProperty.call(message, "serverSignature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.serverSignature);
            return writer;
        };

        /**
         * Encodes the specified VerifiedNameCertificate message, length delimited. Does not implicitly {@link proto.VerifiedNameCertificate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.VerifiedNameCertificate
         * @static
         * @param {proto.IVerifiedNameCertificate} message VerifiedNameCertificate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifiedNameCertificate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifiedNameCertificate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.VerifiedNameCertificate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.VerifiedNameCertificate} VerifiedNameCertificate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifiedNameCertificate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.VerifiedNameCertificate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.details = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                case 3:
                    message.serverSignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifiedNameCertificate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.VerifiedNameCertificate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.VerifiedNameCertificate} VerifiedNameCertificate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifiedNameCertificate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifiedNameCertificate message.
         * @function verify
         * @memberof proto.VerifiedNameCertificate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifiedNameCertificate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.details != null && message.hasOwnProperty("details"))
                if (!(message.details && typeof message.details.length === "number" || $util.isString(message.details)))
                    return "details: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.serverSignature != null && message.hasOwnProperty("serverSignature"))
                if (!(message.serverSignature && typeof message.serverSignature.length === "number" || $util.isString(message.serverSignature)))
                    return "serverSignature: buffer expected";
            return null;
        };

        /**
         * Creates a VerifiedNameCertificate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.VerifiedNameCertificate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.VerifiedNameCertificate} VerifiedNameCertificate
         */
        VerifiedNameCertificate.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.VerifiedNameCertificate)
                return object;
            var message = new $root.proto.VerifiedNameCertificate();
            if (object.details != null)
                if (typeof object.details === "string")
                    $util.base64.decode(object.details, message.details = $util.newBuffer($util.base64.length(object.details)), 0);
                else if (object.details.length)
                    message.details = object.details;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.serverSignature != null)
                if (typeof object.serverSignature === "string")
                    $util.base64.decode(object.serverSignature, message.serverSignature = $util.newBuffer($util.base64.length(object.serverSignature)), 0);
                else if (object.serverSignature.length)
                    message.serverSignature = object.serverSignature;
            return message;
        };

        /**
         * Creates a plain object from a VerifiedNameCertificate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.VerifiedNameCertificate
         * @static
         * @param {proto.VerifiedNameCertificate} message VerifiedNameCertificate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifiedNameCertificate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.details = "";
                else {
                    object.details = [];
                    if (options.bytes !== Array)
                        object.details = $util.newBuffer(object.details);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                if (options.bytes === String)
                    object.serverSignature = "";
                else {
                    object.serverSignature = [];
                    if (options.bytes !== Array)
                        object.serverSignature = $util.newBuffer(object.serverSignature);
                }
            }
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = options.bytes === String ? $util.base64.encode(message.details, 0, message.details.length) : options.bytes === Array ? Array.prototype.slice.call(message.details) : message.details;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.serverSignature != null && message.hasOwnProperty("serverSignature"))
                object.serverSignature = options.bytes === String ? $util.base64.encode(message.serverSignature, 0, message.serverSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverSignature) : message.serverSignature;
            return object;
        };

        /**
         * Converts this VerifiedNameCertificate to JSON.
         * @function toJSON
         * @memberof proto.VerifiedNameCertificate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifiedNameCertificate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        VerifiedNameCertificate.Details = (function() {

            /**
             * Properties of a Details.
             * @memberof proto.VerifiedNameCertificate
             * @interface IDetails
             * @property {number|Long|null} [serial] Details serial
             * @property {string|null} [issuer] Details issuer
             * @property {string|null} [verifiedName] Details verifiedName
             * @property {Array.<proto.ILocalizedName>|null} [localizedNames] Details localizedNames
             * @property {number|Long|null} [issueTime] Details issueTime
             */

            /**
             * Constructs a new Details.
             * @memberof proto.VerifiedNameCertificate
             * @classdesc Represents a Details.
             * @implements IDetails
             * @constructor
             * @param {proto.VerifiedNameCertificate.IDetails=} [properties] Properties to set
             */
            function Details(properties) {
                this.localizedNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Details serial.
             * @member {number|Long} serial
             * @memberof proto.VerifiedNameCertificate.Details
             * @instance
             */
            Details.prototype.serial = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Details issuer.
             * @member {string} issuer
             * @memberof proto.VerifiedNameCertificate.Details
             * @instance
             */
            Details.prototype.issuer = "";

            /**
             * Details verifiedName.
             * @member {string} verifiedName
             * @memberof proto.VerifiedNameCertificate.Details
             * @instance
             */
            Details.prototype.verifiedName = "";

            /**
             * Details localizedNames.
             * @member {Array.<proto.ILocalizedName>} localizedNames
             * @memberof proto.VerifiedNameCertificate.Details
             * @instance
             */
            Details.prototype.localizedNames = $util.emptyArray;

            /**
             * Details issueTime.
             * @member {number|Long} issueTime
             * @memberof proto.VerifiedNameCertificate.Details
             * @instance
             */
            Details.prototype.issueTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Details instance using the specified properties.
             * @function create
             * @memberof proto.VerifiedNameCertificate.Details
             * @static
             * @param {proto.VerifiedNameCertificate.IDetails=} [properties] Properties to set
             * @returns {proto.VerifiedNameCertificate.Details} Details instance
             */
            Details.create = function create(properties) {
                return new Details(properties);
            };

            /**
             * Encodes the specified Details message. Does not implicitly {@link proto.VerifiedNameCertificate.Details.verify|verify} messages.
             * @function encode
             * @memberof proto.VerifiedNameCertificate.Details
             * @static
             * @param {proto.VerifiedNameCertificate.IDetails} message Details message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Details.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serial != null && Object.hasOwnProperty.call(message, "serial"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.serial);
                if (message.issuer != null && Object.hasOwnProperty.call(message, "issuer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.issuer);
                if (message.verifiedName != null && Object.hasOwnProperty.call(message, "verifiedName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.verifiedName);
                if (message.localizedNames != null && message.localizedNames.length)
                    for (var i = 0; i < message.localizedNames.length; ++i)
                        $root.proto.LocalizedName.encode(message.localizedNames[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.issueTime != null && Object.hasOwnProperty.call(message, "issueTime"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.issueTime);
                return writer;
            };

            /**
             * Encodes the specified Details message, length delimited. Does not implicitly {@link proto.VerifiedNameCertificate.Details.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.VerifiedNameCertificate.Details
             * @static
             * @param {proto.VerifiedNameCertificate.IDetails} message Details message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Details.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Details message from the specified reader or buffer.
             * @function decode
             * @memberof proto.VerifiedNameCertificate.Details
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.VerifiedNameCertificate.Details} Details
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Details.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.VerifiedNameCertificate.Details();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serial = reader.uint64();
                        break;
                    case 2:
                        message.issuer = reader.string();
                        break;
                    case 4:
                        message.verifiedName = reader.string();
                        break;
                    case 8:
                        if (!(message.localizedNames && message.localizedNames.length))
                            message.localizedNames = [];
                        message.localizedNames.push($root.proto.LocalizedName.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        message.issueTime = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Details message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.VerifiedNameCertificate.Details
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.VerifiedNameCertificate.Details} Details
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Details.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Details message.
             * @function verify
             * @memberof proto.VerifiedNameCertificate.Details
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Details.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serial != null && message.hasOwnProperty("serial"))
                    if (!$util.isInteger(message.serial) && !(message.serial && $util.isInteger(message.serial.low) && $util.isInteger(message.serial.high)))
                        return "serial: integer|Long expected";
                if (message.issuer != null && message.hasOwnProperty("issuer"))
                    if (!$util.isString(message.issuer))
                        return "issuer: string expected";
                if (message.verifiedName != null && message.hasOwnProperty("verifiedName"))
                    if (!$util.isString(message.verifiedName))
                        return "verifiedName: string expected";
                if (message.localizedNames != null && message.hasOwnProperty("localizedNames")) {
                    if (!Array.isArray(message.localizedNames))
                        return "localizedNames: array expected";
                    for (var i = 0; i < message.localizedNames.length; ++i) {
                        var error = $root.proto.LocalizedName.verify(message.localizedNames[i]);
                        if (error)
                            return "localizedNames." + error;
                    }
                }
                if (message.issueTime != null && message.hasOwnProperty("issueTime"))
                    if (!$util.isInteger(message.issueTime) && !(message.issueTime && $util.isInteger(message.issueTime.low) && $util.isInteger(message.issueTime.high)))
                        return "issueTime: integer|Long expected";
                return null;
            };

            /**
             * Creates a Details message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.VerifiedNameCertificate.Details
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.VerifiedNameCertificate.Details} Details
             */
            Details.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.VerifiedNameCertificate.Details)
                    return object;
                var message = new $root.proto.VerifiedNameCertificate.Details();
                if (object.serial != null)
                    if ($util.Long)
                        (message.serial = $util.Long.fromValue(object.serial)).unsigned = true;
                    else if (typeof object.serial === "string")
                        message.serial = parseInt(object.serial, 10);
                    else if (typeof object.serial === "number")
                        message.serial = object.serial;
                    else if (typeof object.serial === "object")
                        message.serial = new $util.LongBits(object.serial.low >>> 0, object.serial.high >>> 0).toNumber(true);
                if (object.issuer != null)
                    message.issuer = String(object.issuer);
                if (object.verifiedName != null)
                    message.verifiedName = String(object.verifiedName);
                if (object.localizedNames) {
                    if (!Array.isArray(object.localizedNames))
                        throw TypeError(".proto.VerifiedNameCertificate.Details.localizedNames: array expected");
                    message.localizedNames = [];
                    for (var i = 0; i < object.localizedNames.length; ++i) {
                        if (typeof object.localizedNames[i] !== "object")
                            throw TypeError(".proto.VerifiedNameCertificate.Details.localizedNames: object expected");
                        message.localizedNames[i] = $root.proto.LocalizedName.fromObject(object.localizedNames[i]);
                    }
                }
                if (object.issueTime != null)
                    if ($util.Long)
                        (message.issueTime = $util.Long.fromValue(object.issueTime)).unsigned = true;
                    else if (typeof object.issueTime === "string")
                        message.issueTime = parseInt(object.issueTime, 10);
                    else if (typeof object.issueTime === "number")
                        message.issueTime = object.issueTime;
                    else if (typeof object.issueTime === "object")
                        message.issueTime = new $util.LongBits(object.issueTime.low >>> 0, object.issueTime.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Details message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.VerifiedNameCertificate.Details
             * @static
             * @param {proto.VerifiedNameCertificate.Details} message Details
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Details.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.localizedNames = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.serial = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.serial = options.longs === String ? "0" : 0;
                    object.issuer = "";
                    object.verifiedName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.issueTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.issueTime = options.longs === String ? "0" : 0;
                }
                if (message.serial != null && message.hasOwnProperty("serial"))
                    if (typeof message.serial === "number")
                        object.serial = options.longs === String ? String(message.serial) : message.serial;
                    else
                        object.serial = options.longs === String ? $util.Long.prototype.toString.call(message.serial) : options.longs === Number ? new $util.LongBits(message.serial.low >>> 0, message.serial.high >>> 0).toNumber(true) : message.serial;
                if (message.issuer != null && message.hasOwnProperty("issuer"))
                    object.issuer = message.issuer;
                if (message.verifiedName != null && message.hasOwnProperty("verifiedName"))
                    object.verifiedName = message.verifiedName;
                if (message.localizedNames && message.localizedNames.length) {
                    object.localizedNames = [];
                    for (var j = 0; j < message.localizedNames.length; ++j)
                        object.localizedNames[j] = $root.proto.LocalizedName.toObject(message.localizedNames[j], options);
                }
                if (message.issueTime != null && message.hasOwnProperty("issueTime"))
                    if (typeof message.issueTime === "number")
                        object.issueTime = options.longs === String ? String(message.issueTime) : message.issueTime;
                    else
                        object.issueTime = options.longs === String ? $util.Long.prototype.toString.call(message.issueTime) : options.longs === Number ? new $util.LongBits(message.issueTime.low >>> 0, message.issueTime.high >>> 0).toNumber(true) : message.issueTime;
                return object;
            };

            /**
             * Converts this Details to JSON.
             * @function toJSON
             * @memberof proto.VerifiedNameCertificate.Details
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Details.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Details;
        })();

        return VerifiedNameCertificate;
    })();

    proto.WallpaperSettings = (function() {

        /**
         * Properties of a WallpaperSettings.
         * @memberof proto
         * @interface IWallpaperSettings
         * @property {string|null} [filename] WallpaperSettings filename
         * @property {number|null} [opacity] WallpaperSettings opacity
         */

        /**
         * Constructs a new WallpaperSettings.
         * @memberof proto
         * @classdesc Represents a WallpaperSettings.
         * @implements IWallpaperSettings
         * @constructor
         * @param {proto.IWallpaperSettings=} [properties] Properties to set
         */
        function WallpaperSettings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WallpaperSettings filename.
         * @member {string} filename
         * @memberof proto.WallpaperSettings
         * @instance
         */
        WallpaperSettings.prototype.filename = "";

        /**
         * WallpaperSettings opacity.
         * @member {number} opacity
         * @memberof proto.WallpaperSettings
         * @instance
         */
        WallpaperSettings.prototype.opacity = 0;

        /**
         * Creates a new WallpaperSettings instance using the specified properties.
         * @function create
         * @memberof proto.WallpaperSettings
         * @static
         * @param {proto.IWallpaperSettings=} [properties] Properties to set
         * @returns {proto.WallpaperSettings} WallpaperSettings instance
         */
        WallpaperSettings.create = function create(properties) {
            return new WallpaperSettings(properties);
        };

        /**
         * Encodes the specified WallpaperSettings message. Does not implicitly {@link proto.WallpaperSettings.verify|verify} messages.
         * @function encode
         * @memberof proto.WallpaperSettings
         * @static
         * @param {proto.IWallpaperSettings} message WallpaperSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WallpaperSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.filename);
            if (message.opacity != null && Object.hasOwnProperty.call(message, "opacity"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.opacity);
            return writer;
        };

        /**
         * Encodes the specified WallpaperSettings message, length delimited. Does not implicitly {@link proto.WallpaperSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.WallpaperSettings
         * @static
         * @param {proto.IWallpaperSettings} message WallpaperSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WallpaperSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WallpaperSettings message from the specified reader or buffer.
         * @function decode
         * @memberof proto.WallpaperSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.WallpaperSettings} WallpaperSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WallpaperSettings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.WallpaperSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.filename = reader.string();
                    break;
                case 2:
                    message.opacity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WallpaperSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.WallpaperSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.WallpaperSettings} WallpaperSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WallpaperSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WallpaperSettings message.
         * @function verify
         * @memberof proto.WallpaperSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WallpaperSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filename != null && message.hasOwnProperty("filename"))
                if (!$util.isString(message.filename))
                    return "filename: string expected";
            if (message.opacity != null && message.hasOwnProperty("opacity"))
                if (!$util.isInteger(message.opacity))
                    return "opacity: integer expected";
            return null;
        };

        /**
         * Creates a WallpaperSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.WallpaperSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.WallpaperSettings} WallpaperSettings
         */
        WallpaperSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.WallpaperSettings)
                return object;
            var message = new $root.proto.WallpaperSettings();
            if (object.filename != null)
                message.filename = String(object.filename);
            if (object.opacity != null)
                message.opacity = object.opacity >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a WallpaperSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.WallpaperSettings
         * @static
         * @param {proto.WallpaperSettings} message WallpaperSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WallpaperSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.filename = "";
                object.opacity = 0;
            }
            if (message.filename != null && message.hasOwnProperty("filename"))
                object.filename = message.filename;
            if (message.opacity != null && message.hasOwnProperty("opacity"))
                object.opacity = message.opacity;
            return object;
        };

        /**
         * Converts this WallpaperSettings to JSON.
         * @function toJSON
         * @memberof proto.WallpaperSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WallpaperSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WallpaperSettings;
    })();

    proto.WebFeatures = (function() {

        /**
         * Properties of a WebFeatures.
         * @memberof proto
         * @interface IWebFeatures
         * @property {proto.WebFeatures.Flag|null} [labelsDisplay] WebFeatures labelsDisplay
         * @property {proto.WebFeatures.Flag|null} [voipIndividualOutgoing] WebFeatures voipIndividualOutgoing
         * @property {proto.WebFeatures.Flag|null} [groupsV3] WebFeatures groupsV3
         * @property {proto.WebFeatures.Flag|null} [groupsV3Create] WebFeatures groupsV3Create
         * @property {proto.WebFeatures.Flag|null} [changeNumberV2] WebFeatures changeNumberV2
         * @property {proto.WebFeatures.Flag|null} [queryStatusV3Thumbnail] WebFeatures queryStatusV3Thumbnail
         * @property {proto.WebFeatures.Flag|null} [liveLocations] WebFeatures liveLocations
         * @property {proto.WebFeatures.Flag|null} [queryVname] WebFeatures queryVname
         * @property {proto.WebFeatures.Flag|null} [voipIndividualIncoming] WebFeatures voipIndividualIncoming
         * @property {proto.WebFeatures.Flag|null} [quickRepliesQuery] WebFeatures quickRepliesQuery
         * @property {proto.WebFeatures.Flag|null} [payments] WebFeatures payments
         * @property {proto.WebFeatures.Flag|null} [stickerPackQuery] WebFeatures stickerPackQuery
         * @property {proto.WebFeatures.Flag|null} [liveLocationsFinal] WebFeatures liveLocationsFinal
         * @property {proto.WebFeatures.Flag|null} [labelsEdit] WebFeatures labelsEdit
         * @property {proto.WebFeatures.Flag|null} [mediaUpload] WebFeatures mediaUpload
         * @property {proto.WebFeatures.Flag|null} [mediaUploadRichQuickReplies] WebFeatures mediaUploadRichQuickReplies
         * @property {proto.WebFeatures.Flag|null} [vnameV2] WebFeatures vnameV2
         * @property {proto.WebFeatures.Flag|null} [videoPlaybackUrl] WebFeatures videoPlaybackUrl
         * @property {proto.WebFeatures.Flag|null} [statusRanking] WebFeatures statusRanking
         * @property {proto.WebFeatures.Flag|null} [voipIndividualVideo] WebFeatures voipIndividualVideo
         * @property {proto.WebFeatures.Flag|null} [thirdPartyStickers] WebFeatures thirdPartyStickers
         * @property {proto.WebFeatures.Flag|null} [frequentlyForwardedSetting] WebFeatures frequentlyForwardedSetting
         * @property {proto.WebFeatures.Flag|null} [groupsV4JoinPermission] WebFeatures groupsV4JoinPermission
         * @property {proto.WebFeatures.Flag|null} [recentStickers] WebFeatures recentStickers
         * @property {proto.WebFeatures.Flag|null} [catalog] WebFeatures catalog
         * @property {proto.WebFeatures.Flag|null} [starredStickers] WebFeatures starredStickers
         * @property {proto.WebFeatures.Flag|null} [voipGroupCall] WebFeatures voipGroupCall
         * @property {proto.WebFeatures.Flag|null} [templateMessage] WebFeatures templateMessage
         * @property {proto.WebFeatures.Flag|null} [templateMessageInteractivity] WebFeatures templateMessageInteractivity
         * @property {proto.WebFeatures.Flag|null} [ephemeralMessages] WebFeatures ephemeralMessages
         * @property {proto.WebFeatures.Flag|null} [e2ENotificationSync] WebFeatures e2ENotificationSync
         * @property {proto.WebFeatures.Flag|null} [recentStickersV2] WebFeatures recentStickersV2
         * @property {proto.WebFeatures.Flag|null} [recentStickersV3] WebFeatures recentStickersV3
         * @property {proto.WebFeatures.Flag|null} [userNotice] WebFeatures userNotice
         * @property {proto.WebFeatures.Flag|null} [support] WebFeatures support
         * @property {proto.WebFeatures.Flag|null} [groupUiiCleanup] WebFeatures groupUiiCleanup
         * @property {proto.WebFeatures.Flag|null} [groupDogfoodingInternalOnly] WebFeatures groupDogfoodingInternalOnly
         * @property {proto.WebFeatures.Flag|null} [settingsSync] WebFeatures settingsSync
         * @property {proto.WebFeatures.Flag|null} [archiveV2] WebFeatures archiveV2
         * @property {proto.WebFeatures.Flag|null} [ephemeralAllowGroupMembers] WebFeatures ephemeralAllowGroupMembers
         * @property {proto.WebFeatures.Flag|null} [ephemeral24HDuration] WebFeatures ephemeral24HDuration
         * @property {proto.WebFeatures.Flag|null} [mdForceUpgrade] WebFeatures mdForceUpgrade
         * @property {proto.WebFeatures.Flag|null} [disappearingMode] WebFeatures disappearingMode
         * @property {proto.WebFeatures.Flag|null} [externalMdOptInAvailable] WebFeatures externalMdOptInAvailable
         * @property {proto.WebFeatures.Flag|null} [noDeleteMessageTimeLimit] WebFeatures noDeleteMessageTimeLimit
         */

        /**
         * Constructs a new WebFeatures.
         * @memberof proto
         * @classdesc Represents a WebFeatures.
         * @implements IWebFeatures
         * @constructor
         * @param {proto.IWebFeatures=} [properties] Properties to set
         */
        function WebFeatures(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebFeatures labelsDisplay.
         * @member {proto.WebFeatures.Flag} labelsDisplay
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.labelsDisplay = 0;

        /**
         * WebFeatures voipIndividualOutgoing.
         * @member {proto.WebFeatures.Flag} voipIndividualOutgoing
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.voipIndividualOutgoing = 0;

        /**
         * WebFeatures groupsV3.
         * @member {proto.WebFeatures.Flag} groupsV3
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.groupsV3 = 0;

        /**
         * WebFeatures groupsV3Create.
         * @member {proto.WebFeatures.Flag} groupsV3Create
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.groupsV3Create = 0;

        /**
         * WebFeatures changeNumberV2.
         * @member {proto.WebFeatures.Flag} changeNumberV2
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.changeNumberV2 = 0;

        /**
         * WebFeatures queryStatusV3Thumbnail.
         * @member {proto.WebFeatures.Flag} queryStatusV3Thumbnail
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.queryStatusV3Thumbnail = 0;

        /**
         * WebFeatures liveLocations.
         * @member {proto.WebFeatures.Flag} liveLocations
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.liveLocations = 0;

        /**
         * WebFeatures queryVname.
         * @member {proto.WebFeatures.Flag} queryVname
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.queryVname = 0;

        /**
         * WebFeatures voipIndividualIncoming.
         * @member {proto.WebFeatures.Flag} voipIndividualIncoming
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.voipIndividualIncoming = 0;

        /**
         * WebFeatures quickRepliesQuery.
         * @member {proto.WebFeatures.Flag} quickRepliesQuery
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.quickRepliesQuery = 0;

        /**
         * WebFeatures payments.
         * @member {proto.WebFeatures.Flag} payments
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.payments = 0;

        /**
         * WebFeatures stickerPackQuery.
         * @member {proto.WebFeatures.Flag} stickerPackQuery
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.stickerPackQuery = 0;

        /**
         * WebFeatures liveLocationsFinal.
         * @member {proto.WebFeatures.Flag} liveLocationsFinal
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.liveLocationsFinal = 0;

        /**
         * WebFeatures labelsEdit.
         * @member {proto.WebFeatures.Flag} labelsEdit
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.labelsEdit = 0;

        /**
         * WebFeatures mediaUpload.
         * @member {proto.WebFeatures.Flag} mediaUpload
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.mediaUpload = 0;

        /**
         * WebFeatures mediaUploadRichQuickReplies.
         * @member {proto.WebFeatures.Flag} mediaUploadRichQuickReplies
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.mediaUploadRichQuickReplies = 0;

        /**
         * WebFeatures vnameV2.
         * @member {proto.WebFeatures.Flag} vnameV2
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.vnameV2 = 0;

        /**
         * WebFeatures videoPlaybackUrl.
         * @member {proto.WebFeatures.Flag} videoPlaybackUrl
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.videoPlaybackUrl = 0;

        /**
         * WebFeatures statusRanking.
         * @member {proto.WebFeatures.Flag} statusRanking
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.statusRanking = 0;

        /**
         * WebFeatures voipIndividualVideo.
         * @member {proto.WebFeatures.Flag} voipIndividualVideo
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.voipIndividualVideo = 0;

        /**
         * WebFeatures thirdPartyStickers.
         * @member {proto.WebFeatures.Flag} thirdPartyStickers
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.thirdPartyStickers = 0;

        /**
         * WebFeatures frequentlyForwardedSetting.
         * @member {proto.WebFeatures.Flag} frequentlyForwardedSetting
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.frequentlyForwardedSetting = 0;

        /**
         * WebFeatures groupsV4JoinPermission.
         * @member {proto.WebFeatures.Flag} groupsV4JoinPermission
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.groupsV4JoinPermission = 0;

        /**
         * WebFeatures recentStickers.
         * @member {proto.WebFeatures.Flag} recentStickers
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.recentStickers = 0;

        /**
         * WebFeatures catalog.
         * @member {proto.WebFeatures.Flag} catalog
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.catalog = 0;

        /**
         * WebFeatures starredStickers.
         * @member {proto.WebFeatures.Flag} starredStickers
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.starredStickers = 0;

        /**
         * WebFeatures voipGroupCall.
         * @member {proto.WebFeatures.Flag} voipGroupCall
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.voipGroupCall = 0;

        /**
         * WebFeatures templateMessage.
         * @member {proto.WebFeatures.Flag} templateMessage
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.templateMessage = 0;

        /**
         * WebFeatures templateMessageInteractivity.
         * @member {proto.WebFeatures.Flag} templateMessageInteractivity
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.templateMessageInteractivity = 0;

        /**
         * WebFeatures ephemeralMessages.
         * @member {proto.WebFeatures.Flag} ephemeralMessages
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.ephemeralMessages = 0;

        /**
         * WebFeatures e2ENotificationSync.
         * @member {proto.WebFeatures.Flag} e2ENotificationSync
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.e2ENotificationSync = 0;

        /**
         * WebFeatures recentStickersV2.
         * @member {proto.WebFeatures.Flag} recentStickersV2
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.recentStickersV2 = 0;

        /**
         * WebFeatures recentStickersV3.
         * @member {proto.WebFeatures.Flag} recentStickersV3
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.recentStickersV3 = 0;

        /**
         * WebFeatures userNotice.
         * @member {proto.WebFeatures.Flag} userNotice
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.userNotice = 0;

        /**
         * WebFeatures support.
         * @member {proto.WebFeatures.Flag} support
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.support = 0;

        /**
         * WebFeatures groupUiiCleanup.
         * @member {proto.WebFeatures.Flag} groupUiiCleanup
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.groupUiiCleanup = 0;

        /**
         * WebFeatures groupDogfoodingInternalOnly.
         * @member {proto.WebFeatures.Flag} groupDogfoodingInternalOnly
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.groupDogfoodingInternalOnly = 0;

        /**
         * WebFeatures settingsSync.
         * @member {proto.WebFeatures.Flag} settingsSync
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.settingsSync = 0;

        /**
         * WebFeatures archiveV2.
         * @member {proto.WebFeatures.Flag} archiveV2
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.archiveV2 = 0;

        /**
         * WebFeatures ephemeralAllowGroupMembers.
         * @member {proto.WebFeatures.Flag} ephemeralAllowGroupMembers
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.ephemeralAllowGroupMembers = 0;

        /**
         * WebFeatures ephemeral24HDuration.
         * @member {proto.WebFeatures.Flag} ephemeral24HDuration
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.ephemeral24HDuration = 0;

        /**
         * WebFeatures mdForceUpgrade.
         * @member {proto.WebFeatures.Flag} mdForceUpgrade
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.mdForceUpgrade = 0;

        /**
         * WebFeatures disappearingMode.
         * @member {proto.WebFeatures.Flag} disappearingMode
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.disappearingMode = 0;

        /**
         * WebFeatures externalMdOptInAvailable.
         * @member {proto.WebFeatures.Flag} externalMdOptInAvailable
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.externalMdOptInAvailable = 0;

        /**
         * WebFeatures noDeleteMessageTimeLimit.
         * @member {proto.WebFeatures.Flag} noDeleteMessageTimeLimit
         * @memberof proto.WebFeatures
         * @instance
         */
        WebFeatures.prototype.noDeleteMessageTimeLimit = 0;

        /**
         * Creates a new WebFeatures instance using the specified properties.
         * @function create
         * @memberof proto.WebFeatures
         * @static
         * @param {proto.IWebFeatures=} [properties] Properties to set
         * @returns {proto.WebFeatures} WebFeatures instance
         */
        WebFeatures.create = function create(properties) {
            return new WebFeatures(properties);
        };

        /**
         * Encodes the specified WebFeatures message. Does not implicitly {@link proto.WebFeatures.verify|verify} messages.
         * @function encode
         * @memberof proto.WebFeatures
         * @static
         * @param {proto.IWebFeatures} message WebFeatures message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebFeatures.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.labelsDisplay != null && Object.hasOwnProperty.call(message, "labelsDisplay"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.labelsDisplay);
            if (message.voipIndividualOutgoing != null && Object.hasOwnProperty.call(message, "voipIndividualOutgoing"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.voipIndividualOutgoing);
            if (message.groupsV3 != null && Object.hasOwnProperty.call(message, "groupsV3"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.groupsV3);
            if (message.groupsV3Create != null && Object.hasOwnProperty.call(message, "groupsV3Create"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.groupsV3Create);
            if (message.changeNumberV2 != null && Object.hasOwnProperty.call(message, "changeNumberV2"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.changeNumberV2);
            if (message.queryStatusV3Thumbnail != null && Object.hasOwnProperty.call(message, "queryStatusV3Thumbnail"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.queryStatusV3Thumbnail);
            if (message.liveLocations != null && Object.hasOwnProperty.call(message, "liveLocations"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.liveLocations);
            if (message.queryVname != null && Object.hasOwnProperty.call(message, "queryVname"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.queryVname);
            if (message.voipIndividualIncoming != null && Object.hasOwnProperty.call(message, "voipIndividualIncoming"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.voipIndividualIncoming);
            if (message.quickRepliesQuery != null && Object.hasOwnProperty.call(message, "quickRepliesQuery"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.quickRepliesQuery);
            if (message.payments != null && Object.hasOwnProperty.call(message, "payments"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.payments);
            if (message.stickerPackQuery != null && Object.hasOwnProperty.call(message, "stickerPackQuery"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.stickerPackQuery);
            if (message.liveLocationsFinal != null && Object.hasOwnProperty.call(message, "liveLocationsFinal"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.liveLocationsFinal);
            if (message.labelsEdit != null && Object.hasOwnProperty.call(message, "labelsEdit"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.labelsEdit);
            if (message.mediaUpload != null && Object.hasOwnProperty.call(message, "mediaUpload"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.mediaUpload);
            if (message.mediaUploadRichQuickReplies != null && Object.hasOwnProperty.call(message, "mediaUploadRichQuickReplies"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.mediaUploadRichQuickReplies);
            if (message.vnameV2 != null && Object.hasOwnProperty.call(message, "vnameV2"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.vnameV2);
            if (message.videoPlaybackUrl != null && Object.hasOwnProperty.call(message, "videoPlaybackUrl"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.videoPlaybackUrl);
            if (message.statusRanking != null && Object.hasOwnProperty.call(message, "statusRanking"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.statusRanking);
            if (message.voipIndividualVideo != null && Object.hasOwnProperty.call(message, "voipIndividualVideo"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.voipIndividualVideo);
            if (message.thirdPartyStickers != null && Object.hasOwnProperty.call(message, "thirdPartyStickers"))
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.thirdPartyStickers);
            if (message.frequentlyForwardedSetting != null && Object.hasOwnProperty.call(message, "frequentlyForwardedSetting"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.frequentlyForwardedSetting);
            if (message.groupsV4JoinPermission != null && Object.hasOwnProperty.call(message, "groupsV4JoinPermission"))
                writer.uint32(/* id 25, wireType 0 =*/200).int32(message.groupsV4JoinPermission);
            if (message.recentStickers != null && Object.hasOwnProperty.call(message, "recentStickers"))
                writer.uint32(/* id 26, wireType 0 =*/208).int32(message.recentStickers);
            if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
                writer.uint32(/* id 27, wireType 0 =*/216).int32(message.catalog);
            if (message.starredStickers != null && Object.hasOwnProperty.call(message, "starredStickers"))
                writer.uint32(/* id 28, wireType 0 =*/224).int32(message.starredStickers);
            if (message.voipGroupCall != null && Object.hasOwnProperty.call(message, "voipGroupCall"))
                writer.uint32(/* id 29, wireType 0 =*/232).int32(message.voipGroupCall);
            if (message.templateMessage != null && Object.hasOwnProperty.call(message, "templateMessage"))
                writer.uint32(/* id 30, wireType 0 =*/240).int32(message.templateMessage);
            if (message.templateMessageInteractivity != null && Object.hasOwnProperty.call(message, "templateMessageInteractivity"))
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.templateMessageInteractivity);
            if (message.ephemeralMessages != null && Object.hasOwnProperty.call(message, "ephemeralMessages"))
                writer.uint32(/* id 32, wireType 0 =*/256).int32(message.ephemeralMessages);
            if (message.e2ENotificationSync != null && Object.hasOwnProperty.call(message, "e2ENotificationSync"))
                writer.uint32(/* id 33, wireType 0 =*/264).int32(message.e2ENotificationSync);
            if (message.recentStickersV2 != null && Object.hasOwnProperty.call(message, "recentStickersV2"))
                writer.uint32(/* id 34, wireType 0 =*/272).int32(message.recentStickersV2);
            if (message.recentStickersV3 != null && Object.hasOwnProperty.call(message, "recentStickersV3"))
                writer.uint32(/* id 36, wireType 0 =*/288).int32(message.recentStickersV3);
            if (message.userNotice != null && Object.hasOwnProperty.call(message, "userNotice"))
                writer.uint32(/* id 37, wireType 0 =*/296).int32(message.userNotice);
            if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                writer.uint32(/* id 39, wireType 0 =*/312).int32(message.support);
            if (message.groupUiiCleanup != null && Object.hasOwnProperty.call(message, "groupUiiCleanup"))
                writer.uint32(/* id 40, wireType 0 =*/320).int32(message.groupUiiCleanup);
            if (message.groupDogfoodingInternalOnly != null && Object.hasOwnProperty.call(message, "groupDogfoodingInternalOnly"))
                writer.uint32(/* id 41, wireType 0 =*/328).int32(message.groupDogfoodingInternalOnly);
            if (message.settingsSync != null && Object.hasOwnProperty.call(message, "settingsSync"))
                writer.uint32(/* id 42, wireType 0 =*/336).int32(message.settingsSync);
            if (message.archiveV2 != null && Object.hasOwnProperty.call(message, "archiveV2"))
                writer.uint32(/* id 43, wireType 0 =*/344).int32(message.archiveV2);
            if (message.ephemeralAllowGroupMembers != null && Object.hasOwnProperty.call(message, "ephemeralAllowGroupMembers"))
                writer.uint32(/* id 44, wireType 0 =*/352).int32(message.ephemeralAllowGroupMembers);
            if (message.ephemeral24HDuration != null && Object.hasOwnProperty.call(message, "ephemeral24HDuration"))
                writer.uint32(/* id 45, wireType 0 =*/360).int32(message.ephemeral24HDuration);
            if (message.mdForceUpgrade != null && Object.hasOwnProperty.call(message, "mdForceUpgrade"))
                writer.uint32(/* id 46, wireType 0 =*/368).int32(message.mdForceUpgrade);
            if (message.disappearingMode != null && Object.hasOwnProperty.call(message, "disappearingMode"))
                writer.uint32(/* id 47, wireType 0 =*/376).int32(message.disappearingMode);
            if (message.externalMdOptInAvailable != null && Object.hasOwnProperty.call(message, "externalMdOptInAvailable"))
                writer.uint32(/* id 48, wireType 0 =*/384).int32(message.externalMdOptInAvailable);
            if (message.noDeleteMessageTimeLimit != null && Object.hasOwnProperty.call(message, "noDeleteMessageTimeLimit"))
                writer.uint32(/* id 49, wireType 0 =*/392).int32(message.noDeleteMessageTimeLimit);
            return writer;
        };

        /**
         * Encodes the specified WebFeatures message, length delimited. Does not implicitly {@link proto.WebFeatures.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.WebFeatures
         * @static
         * @param {proto.IWebFeatures} message WebFeatures message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebFeatures.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebFeatures message from the specified reader or buffer.
         * @function decode
         * @memberof proto.WebFeatures
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.WebFeatures} WebFeatures
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebFeatures.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.WebFeatures();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.labelsDisplay = reader.int32();
                    break;
                case 2:
                    message.voipIndividualOutgoing = reader.int32();
                    break;
                case 3:
                    message.groupsV3 = reader.int32();
                    break;
                case 4:
                    message.groupsV3Create = reader.int32();
                    break;
                case 5:
                    message.changeNumberV2 = reader.int32();
                    break;
                case 6:
                    message.queryStatusV3Thumbnail = reader.int32();
                    break;
                case 7:
                    message.liveLocations = reader.int32();
                    break;
                case 8:
                    message.queryVname = reader.int32();
                    break;
                case 9:
                    message.voipIndividualIncoming = reader.int32();
                    break;
                case 10:
                    message.quickRepliesQuery = reader.int32();
                    break;
                case 11:
                    message.payments = reader.int32();
                    break;
                case 12:
                    message.stickerPackQuery = reader.int32();
                    break;
                case 13:
                    message.liveLocationsFinal = reader.int32();
                    break;
                case 14:
                    message.labelsEdit = reader.int32();
                    break;
                case 15:
                    message.mediaUpload = reader.int32();
                    break;
                case 18:
                    message.mediaUploadRichQuickReplies = reader.int32();
                    break;
                case 19:
                    message.vnameV2 = reader.int32();
                    break;
                case 20:
                    message.videoPlaybackUrl = reader.int32();
                    break;
                case 21:
                    message.statusRanking = reader.int32();
                    break;
                case 22:
                    message.voipIndividualVideo = reader.int32();
                    break;
                case 23:
                    message.thirdPartyStickers = reader.int32();
                    break;
                case 24:
                    message.frequentlyForwardedSetting = reader.int32();
                    break;
                case 25:
                    message.groupsV4JoinPermission = reader.int32();
                    break;
                case 26:
                    message.recentStickers = reader.int32();
                    break;
                case 27:
                    message.catalog = reader.int32();
                    break;
                case 28:
                    message.starredStickers = reader.int32();
                    break;
                case 29:
                    message.voipGroupCall = reader.int32();
                    break;
                case 30:
                    message.templateMessage = reader.int32();
                    break;
                case 31:
                    message.templateMessageInteractivity = reader.int32();
                    break;
                case 32:
                    message.ephemeralMessages = reader.int32();
                    break;
                case 33:
                    message.e2ENotificationSync = reader.int32();
                    break;
                case 34:
                    message.recentStickersV2 = reader.int32();
                    break;
                case 36:
                    message.recentStickersV3 = reader.int32();
                    break;
                case 37:
                    message.userNotice = reader.int32();
                    break;
                case 39:
                    message.support = reader.int32();
                    break;
                case 40:
                    message.groupUiiCleanup = reader.int32();
                    break;
                case 41:
                    message.groupDogfoodingInternalOnly = reader.int32();
                    break;
                case 42:
                    message.settingsSync = reader.int32();
                    break;
                case 43:
                    message.archiveV2 = reader.int32();
                    break;
                case 44:
                    message.ephemeralAllowGroupMembers = reader.int32();
                    break;
                case 45:
                    message.ephemeral24HDuration = reader.int32();
                    break;
                case 46:
                    message.mdForceUpgrade = reader.int32();
                    break;
                case 47:
                    message.disappearingMode = reader.int32();
                    break;
                case 48:
                    message.externalMdOptInAvailable = reader.int32();
                    break;
                case 49:
                    message.noDeleteMessageTimeLimit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebFeatures message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.WebFeatures
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.WebFeatures} WebFeatures
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebFeatures.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebFeatures message.
         * @function verify
         * @memberof proto.WebFeatures
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebFeatures.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.labelsDisplay != null && message.hasOwnProperty("labelsDisplay"))
                switch (message.labelsDisplay) {
                default:
                    return "labelsDisplay: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.voipIndividualOutgoing != null && message.hasOwnProperty("voipIndividualOutgoing"))
                switch (message.voipIndividualOutgoing) {
                default:
                    return "voipIndividualOutgoing: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.groupsV3 != null && message.hasOwnProperty("groupsV3"))
                switch (message.groupsV3) {
                default:
                    return "groupsV3: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.groupsV3Create != null && message.hasOwnProperty("groupsV3Create"))
                switch (message.groupsV3Create) {
                default:
                    return "groupsV3Create: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.changeNumberV2 != null && message.hasOwnProperty("changeNumberV2"))
                switch (message.changeNumberV2) {
                default:
                    return "changeNumberV2: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.queryStatusV3Thumbnail != null && message.hasOwnProperty("queryStatusV3Thumbnail"))
                switch (message.queryStatusV3Thumbnail) {
                default:
                    return "queryStatusV3Thumbnail: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.liveLocations != null && message.hasOwnProperty("liveLocations"))
                switch (message.liveLocations) {
                default:
                    return "liveLocations: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.queryVname != null && message.hasOwnProperty("queryVname"))
                switch (message.queryVname) {
                default:
                    return "queryVname: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.voipIndividualIncoming != null && message.hasOwnProperty("voipIndividualIncoming"))
                switch (message.voipIndividualIncoming) {
                default:
                    return "voipIndividualIncoming: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.quickRepliesQuery != null && message.hasOwnProperty("quickRepliesQuery"))
                switch (message.quickRepliesQuery) {
                default:
                    return "quickRepliesQuery: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.payments != null && message.hasOwnProperty("payments"))
                switch (message.payments) {
                default:
                    return "payments: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.stickerPackQuery != null && message.hasOwnProperty("stickerPackQuery"))
                switch (message.stickerPackQuery) {
                default:
                    return "stickerPackQuery: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.liveLocationsFinal != null && message.hasOwnProperty("liveLocationsFinal"))
                switch (message.liveLocationsFinal) {
                default:
                    return "liveLocationsFinal: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.labelsEdit != null && message.hasOwnProperty("labelsEdit"))
                switch (message.labelsEdit) {
                default:
                    return "labelsEdit: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.mediaUpload != null && message.hasOwnProperty("mediaUpload"))
                switch (message.mediaUpload) {
                default:
                    return "mediaUpload: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.mediaUploadRichQuickReplies != null && message.hasOwnProperty("mediaUploadRichQuickReplies"))
                switch (message.mediaUploadRichQuickReplies) {
                default:
                    return "mediaUploadRichQuickReplies: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.vnameV2 != null && message.hasOwnProperty("vnameV2"))
                switch (message.vnameV2) {
                default:
                    return "vnameV2: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.videoPlaybackUrl != null && message.hasOwnProperty("videoPlaybackUrl"))
                switch (message.videoPlaybackUrl) {
                default:
                    return "videoPlaybackUrl: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.statusRanking != null && message.hasOwnProperty("statusRanking"))
                switch (message.statusRanking) {
                default:
                    return "statusRanking: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.voipIndividualVideo != null && message.hasOwnProperty("voipIndividualVideo"))
                switch (message.voipIndividualVideo) {
                default:
                    return "voipIndividualVideo: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.thirdPartyStickers != null && message.hasOwnProperty("thirdPartyStickers"))
                switch (message.thirdPartyStickers) {
                default:
                    return "thirdPartyStickers: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.frequentlyForwardedSetting != null && message.hasOwnProperty("frequentlyForwardedSetting"))
                switch (message.frequentlyForwardedSetting) {
                default:
                    return "frequentlyForwardedSetting: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.groupsV4JoinPermission != null && message.hasOwnProperty("groupsV4JoinPermission"))
                switch (message.groupsV4JoinPermission) {
                default:
                    return "groupsV4JoinPermission: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.recentStickers != null && message.hasOwnProperty("recentStickers"))
                switch (message.recentStickers) {
                default:
                    return "recentStickers: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                switch (message.catalog) {
                default:
                    return "catalog: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.starredStickers != null && message.hasOwnProperty("starredStickers"))
                switch (message.starredStickers) {
                default:
                    return "starredStickers: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.voipGroupCall != null && message.hasOwnProperty("voipGroupCall"))
                switch (message.voipGroupCall) {
                default:
                    return "voipGroupCall: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage"))
                switch (message.templateMessage) {
                default:
                    return "templateMessage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.templateMessageInteractivity != null && message.hasOwnProperty("templateMessageInteractivity"))
                switch (message.templateMessageInteractivity) {
                default:
                    return "templateMessageInteractivity: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.ephemeralMessages != null && message.hasOwnProperty("ephemeralMessages"))
                switch (message.ephemeralMessages) {
                default:
                    return "ephemeralMessages: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.e2ENotificationSync != null && message.hasOwnProperty("e2ENotificationSync"))
                switch (message.e2ENotificationSync) {
                default:
                    return "e2ENotificationSync: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.recentStickersV2 != null && message.hasOwnProperty("recentStickersV2"))
                switch (message.recentStickersV2) {
                default:
                    return "recentStickersV2: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.recentStickersV3 != null && message.hasOwnProperty("recentStickersV3"))
                switch (message.recentStickersV3) {
                default:
                    return "recentStickersV3: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.userNotice != null && message.hasOwnProperty("userNotice"))
                switch (message.userNotice) {
                default:
                    return "userNotice: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.support != null && message.hasOwnProperty("support"))
                switch (message.support) {
                default:
                    return "support: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.groupUiiCleanup != null && message.hasOwnProperty("groupUiiCleanup"))
                switch (message.groupUiiCleanup) {
                default:
                    return "groupUiiCleanup: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.groupDogfoodingInternalOnly != null && message.hasOwnProperty("groupDogfoodingInternalOnly"))
                switch (message.groupDogfoodingInternalOnly) {
                default:
                    return "groupDogfoodingInternalOnly: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.settingsSync != null && message.hasOwnProperty("settingsSync"))
                switch (message.settingsSync) {
                default:
                    return "settingsSync: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.archiveV2 != null && message.hasOwnProperty("archiveV2"))
                switch (message.archiveV2) {
                default:
                    return "archiveV2: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.ephemeralAllowGroupMembers != null && message.hasOwnProperty("ephemeralAllowGroupMembers"))
                switch (message.ephemeralAllowGroupMembers) {
                default:
                    return "ephemeralAllowGroupMembers: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.ephemeral24HDuration != null && message.hasOwnProperty("ephemeral24HDuration"))
                switch (message.ephemeral24HDuration) {
                default:
                    return "ephemeral24HDuration: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.mdForceUpgrade != null && message.hasOwnProperty("mdForceUpgrade"))
                switch (message.mdForceUpgrade) {
                default:
                    return "mdForceUpgrade: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.disappearingMode != null && message.hasOwnProperty("disappearingMode"))
                switch (message.disappearingMode) {
                default:
                    return "disappearingMode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.externalMdOptInAvailable != null && message.hasOwnProperty("externalMdOptInAvailable"))
                switch (message.externalMdOptInAvailable) {
                default:
                    return "externalMdOptInAvailable: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.noDeleteMessageTimeLimit != null && message.hasOwnProperty("noDeleteMessageTimeLimit"))
                switch (message.noDeleteMessageTimeLimit) {
                default:
                    return "noDeleteMessageTimeLimit: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a WebFeatures message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.WebFeatures
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.WebFeatures} WebFeatures
         */
        WebFeatures.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.WebFeatures)
                return object;
            var message = new $root.proto.WebFeatures();
            switch (object.labelsDisplay) {
            case "NOT_STARTED":
            case 0:
                message.labelsDisplay = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.labelsDisplay = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.labelsDisplay = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.labelsDisplay = 3;
                break;
            }
            switch (object.voipIndividualOutgoing) {
            case "NOT_STARTED":
            case 0:
                message.voipIndividualOutgoing = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.voipIndividualOutgoing = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.voipIndividualOutgoing = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.voipIndividualOutgoing = 3;
                break;
            }
            switch (object.groupsV3) {
            case "NOT_STARTED":
            case 0:
                message.groupsV3 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.groupsV3 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.groupsV3 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.groupsV3 = 3;
                break;
            }
            switch (object.groupsV3Create) {
            case "NOT_STARTED":
            case 0:
                message.groupsV3Create = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.groupsV3Create = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.groupsV3Create = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.groupsV3Create = 3;
                break;
            }
            switch (object.changeNumberV2) {
            case "NOT_STARTED":
            case 0:
                message.changeNumberV2 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.changeNumberV2 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.changeNumberV2 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.changeNumberV2 = 3;
                break;
            }
            switch (object.queryStatusV3Thumbnail) {
            case "NOT_STARTED":
            case 0:
                message.queryStatusV3Thumbnail = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.queryStatusV3Thumbnail = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.queryStatusV3Thumbnail = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.queryStatusV3Thumbnail = 3;
                break;
            }
            switch (object.liveLocations) {
            case "NOT_STARTED":
            case 0:
                message.liveLocations = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.liveLocations = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.liveLocations = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.liveLocations = 3;
                break;
            }
            switch (object.queryVname) {
            case "NOT_STARTED":
            case 0:
                message.queryVname = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.queryVname = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.queryVname = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.queryVname = 3;
                break;
            }
            switch (object.voipIndividualIncoming) {
            case "NOT_STARTED":
            case 0:
                message.voipIndividualIncoming = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.voipIndividualIncoming = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.voipIndividualIncoming = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.voipIndividualIncoming = 3;
                break;
            }
            switch (object.quickRepliesQuery) {
            case "NOT_STARTED":
            case 0:
                message.quickRepliesQuery = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.quickRepliesQuery = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.quickRepliesQuery = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.quickRepliesQuery = 3;
                break;
            }
            switch (object.payments) {
            case "NOT_STARTED":
            case 0:
                message.payments = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.payments = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.payments = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.payments = 3;
                break;
            }
            switch (object.stickerPackQuery) {
            case "NOT_STARTED":
            case 0:
                message.stickerPackQuery = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.stickerPackQuery = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.stickerPackQuery = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.stickerPackQuery = 3;
                break;
            }
            switch (object.liveLocationsFinal) {
            case "NOT_STARTED":
            case 0:
                message.liveLocationsFinal = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.liveLocationsFinal = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.liveLocationsFinal = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.liveLocationsFinal = 3;
                break;
            }
            switch (object.labelsEdit) {
            case "NOT_STARTED":
            case 0:
                message.labelsEdit = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.labelsEdit = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.labelsEdit = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.labelsEdit = 3;
                break;
            }
            switch (object.mediaUpload) {
            case "NOT_STARTED":
            case 0:
                message.mediaUpload = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.mediaUpload = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.mediaUpload = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.mediaUpload = 3;
                break;
            }
            switch (object.mediaUploadRichQuickReplies) {
            case "NOT_STARTED":
            case 0:
                message.mediaUploadRichQuickReplies = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.mediaUploadRichQuickReplies = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.mediaUploadRichQuickReplies = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.mediaUploadRichQuickReplies = 3;
                break;
            }
            switch (object.vnameV2) {
            case "NOT_STARTED":
            case 0:
                message.vnameV2 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.vnameV2 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.vnameV2 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.vnameV2 = 3;
                break;
            }
            switch (object.videoPlaybackUrl) {
            case "NOT_STARTED":
            case 0:
                message.videoPlaybackUrl = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.videoPlaybackUrl = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.videoPlaybackUrl = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.videoPlaybackUrl = 3;
                break;
            }
            switch (object.statusRanking) {
            case "NOT_STARTED":
            case 0:
                message.statusRanking = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.statusRanking = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.statusRanking = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.statusRanking = 3;
                break;
            }
            switch (object.voipIndividualVideo) {
            case "NOT_STARTED":
            case 0:
                message.voipIndividualVideo = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.voipIndividualVideo = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.voipIndividualVideo = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.voipIndividualVideo = 3;
                break;
            }
            switch (object.thirdPartyStickers) {
            case "NOT_STARTED":
            case 0:
                message.thirdPartyStickers = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.thirdPartyStickers = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.thirdPartyStickers = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.thirdPartyStickers = 3;
                break;
            }
            switch (object.frequentlyForwardedSetting) {
            case "NOT_STARTED":
            case 0:
                message.frequentlyForwardedSetting = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.frequentlyForwardedSetting = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.frequentlyForwardedSetting = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.frequentlyForwardedSetting = 3;
                break;
            }
            switch (object.groupsV4JoinPermission) {
            case "NOT_STARTED":
            case 0:
                message.groupsV4JoinPermission = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.groupsV4JoinPermission = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.groupsV4JoinPermission = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.groupsV4JoinPermission = 3;
                break;
            }
            switch (object.recentStickers) {
            case "NOT_STARTED":
            case 0:
                message.recentStickers = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.recentStickers = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.recentStickers = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.recentStickers = 3;
                break;
            }
            switch (object.catalog) {
            case "NOT_STARTED":
            case 0:
                message.catalog = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.catalog = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.catalog = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.catalog = 3;
                break;
            }
            switch (object.starredStickers) {
            case "NOT_STARTED":
            case 0:
                message.starredStickers = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.starredStickers = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.starredStickers = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.starredStickers = 3;
                break;
            }
            switch (object.voipGroupCall) {
            case "NOT_STARTED":
            case 0:
                message.voipGroupCall = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.voipGroupCall = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.voipGroupCall = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.voipGroupCall = 3;
                break;
            }
            switch (object.templateMessage) {
            case "NOT_STARTED":
            case 0:
                message.templateMessage = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.templateMessage = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.templateMessage = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.templateMessage = 3;
                break;
            }
            switch (object.templateMessageInteractivity) {
            case "NOT_STARTED":
            case 0:
                message.templateMessageInteractivity = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.templateMessageInteractivity = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.templateMessageInteractivity = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.templateMessageInteractivity = 3;
                break;
            }
            switch (object.ephemeralMessages) {
            case "NOT_STARTED":
            case 0:
                message.ephemeralMessages = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.ephemeralMessages = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.ephemeralMessages = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.ephemeralMessages = 3;
                break;
            }
            switch (object.e2ENotificationSync) {
            case "NOT_STARTED":
            case 0:
                message.e2ENotificationSync = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.e2ENotificationSync = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.e2ENotificationSync = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.e2ENotificationSync = 3;
                break;
            }
            switch (object.recentStickersV2) {
            case "NOT_STARTED":
            case 0:
                message.recentStickersV2 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.recentStickersV2 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.recentStickersV2 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.recentStickersV2 = 3;
                break;
            }
            switch (object.recentStickersV3) {
            case "NOT_STARTED":
            case 0:
                message.recentStickersV3 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.recentStickersV3 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.recentStickersV3 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.recentStickersV3 = 3;
                break;
            }
            switch (object.userNotice) {
            case "NOT_STARTED":
            case 0:
                message.userNotice = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.userNotice = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.userNotice = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.userNotice = 3;
                break;
            }
            switch (object.support) {
            case "NOT_STARTED":
            case 0:
                message.support = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.support = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.support = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.support = 3;
                break;
            }
            switch (object.groupUiiCleanup) {
            case "NOT_STARTED":
            case 0:
                message.groupUiiCleanup = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.groupUiiCleanup = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.groupUiiCleanup = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.groupUiiCleanup = 3;
                break;
            }
            switch (object.groupDogfoodingInternalOnly) {
            case "NOT_STARTED":
            case 0:
                message.groupDogfoodingInternalOnly = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.groupDogfoodingInternalOnly = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.groupDogfoodingInternalOnly = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.groupDogfoodingInternalOnly = 3;
                break;
            }
            switch (object.settingsSync) {
            case "NOT_STARTED":
            case 0:
                message.settingsSync = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.settingsSync = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.settingsSync = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.settingsSync = 3;
                break;
            }
            switch (object.archiveV2) {
            case "NOT_STARTED":
            case 0:
                message.archiveV2 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.archiveV2 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.archiveV2 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.archiveV2 = 3;
                break;
            }
            switch (object.ephemeralAllowGroupMembers) {
            case "NOT_STARTED":
            case 0:
                message.ephemeralAllowGroupMembers = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.ephemeralAllowGroupMembers = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.ephemeralAllowGroupMembers = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.ephemeralAllowGroupMembers = 3;
                break;
            }
            switch (object.ephemeral24HDuration) {
            case "NOT_STARTED":
            case 0:
                message.ephemeral24HDuration = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.ephemeral24HDuration = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.ephemeral24HDuration = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.ephemeral24HDuration = 3;
                break;
            }
            switch (object.mdForceUpgrade) {
            case "NOT_STARTED":
            case 0:
                message.mdForceUpgrade = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.mdForceUpgrade = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.mdForceUpgrade = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.mdForceUpgrade = 3;
                break;
            }
            switch (object.disappearingMode) {
            case "NOT_STARTED":
            case 0:
                message.disappearingMode = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.disappearingMode = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.disappearingMode = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.disappearingMode = 3;
                break;
            }
            switch (object.externalMdOptInAvailable) {
            case "NOT_STARTED":
            case 0:
                message.externalMdOptInAvailable = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.externalMdOptInAvailable = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.externalMdOptInAvailable = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.externalMdOptInAvailable = 3;
                break;
            }
            switch (object.noDeleteMessageTimeLimit) {
            case "NOT_STARTED":
            case 0:
                message.noDeleteMessageTimeLimit = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.noDeleteMessageTimeLimit = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.noDeleteMessageTimeLimit = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.noDeleteMessageTimeLimit = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a WebFeatures message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.WebFeatures
         * @static
         * @param {proto.WebFeatures} message WebFeatures
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebFeatures.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.labelsDisplay = options.enums === String ? "NOT_STARTED" : 0;
                object.voipIndividualOutgoing = options.enums === String ? "NOT_STARTED" : 0;
                object.groupsV3 = options.enums === String ? "NOT_STARTED" : 0;
                object.groupsV3Create = options.enums === String ? "NOT_STARTED" : 0;
                object.changeNumberV2 = options.enums === String ? "NOT_STARTED" : 0;
                object.queryStatusV3Thumbnail = options.enums === String ? "NOT_STARTED" : 0;
                object.liveLocations = options.enums === String ? "NOT_STARTED" : 0;
                object.queryVname = options.enums === String ? "NOT_STARTED" : 0;
                object.voipIndividualIncoming = options.enums === String ? "NOT_STARTED" : 0;
                object.quickRepliesQuery = options.enums === String ? "NOT_STARTED" : 0;
                object.payments = options.enums === String ? "NOT_STARTED" : 0;
                object.stickerPackQuery = options.enums === String ? "NOT_STARTED" : 0;
                object.liveLocationsFinal = options.enums === String ? "NOT_STARTED" : 0;
                object.labelsEdit = options.enums === String ? "NOT_STARTED" : 0;
                object.mediaUpload = options.enums === String ? "NOT_STARTED" : 0;
                object.mediaUploadRichQuickReplies = options.enums === String ? "NOT_STARTED" : 0;
                object.vnameV2 = options.enums === String ? "NOT_STARTED" : 0;
                object.videoPlaybackUrl = options.enums === String ? "NOT_STARTED" : 0;
                object.statusRanking = options.enums === String ? "NOT_STARTED" : 0;
                object.voipIndividualVideo = options.enums === String ? "NOT_STARTED" : 0;
                object.thirdPartyStickers = options.enums === String ? "NOT_STARTED" : 0;
                object.frequentlyForwardedSetting = options.enums === String ? "NOT_STARTED" : 0;
                object.groupsV4JoinPermission = options.enums === String ? "NOT_STARTED" : 0;
                object.recentStickers = options.enums === String ? "NOT_STARTED" : 0;
                object.catalog = options.enums === String ? "NOT_STARTED" : 0;
                object.starredStickers = options.enums === String ? "NOT_STARTED" : 0;
                object.voipGroupCall = options.enums === String ? "NOT_STARTED" : 0;
                object.templateMessage = options.enums === String ? "NOT_STARTED" : 0;
                object.templateMessageInteractivity = options.enums === String ? "NOT_STARTED" : 0;
                object.ephemeralMessages = options.enums === String ? "NOT_STARTED" : 0;
                object.e2ENotificationSync = options.enums === String ? "NOT_STARTED" : 0;
                object.recentStickersV2 = options.enums === String ? "NOT_STARTED" : 0;
                object.recentStickersV3 = options.enums === String ? "NOT_STARTED" : 0;
                object.userNotice = options.enums === String ? "NOT_STARTED" : 0;
                object.support = options.enums === String ? "NOT_STARTED" : 0;
                object.groupUiiCleanup = options.enums === String ? "NOT_STARTED" : 0;
                object.groupDogfoodingInternalOnly = options.enums === String ? "NOT_STARTED" : 0;
                object.settingsSync = options.enums === String ? "NOT_STARTED" : 0;
                object.archiveV2 = options.enums === String ? "NOT_STARTED" : 0;
                object.ephemeralAllowGroupMembers = options.enums === String ? "NOT_STARTED" : 0;
                object.ephemeral24HDuration = options.enums === String ? "NOT_STARTED" : 0;
                object.mdForceUpgrade = options.enums === String ? "NOT_STARTED" : 0;
                object.disappearingMode = options.enums === String ? "NOT_STARTED" : 0;
                object.externalMdOptInAvailable = options.enums === String ? "NOT_STARTED" : 0;
                object.noDeleteMessageTimeLimit = options.enums === String ? "NOT_STARTED" : 0;
            }
            if (message.labelsDisplay != null && message.hasOwnProperty("labelsDisplay"))
                object.labelsDisplay = options.enums === String ? $root.proto.WebFeatures.Flag[message.labelsDisplay] : message.labelsDisplay;
            if (message.voipIndividualOutgoing != null && message.hasOwnProperty("voipIndividualOutgoing"))
                object.voipIndividualOutgoing = options.enums === String ? $root.proto.WebFeatures.Flag[message.voipIndividualOutgoing] : message.voipIndividualOutgoing;
            if (message.groupsV3 != null && message.hasOwnProperty("groupsV3"))
                object.groupsV3 = options.enums === String ? $root.proto.WebFeatures.Flag[message.groupsV3] : message.groupsV3;
            if (message.groupsV3Create != null && message.hasOwnProperty("groupsV3Create"))
                object.groupsV3Create = options.enums === String ? $root.proto.WebFeatures.Flag[message.groupsV3Create] : message.groupsV3Create;
            if (message.changeNumberV2 != null && message.hasOwnProperty("changeNumberV2"))
                object.changeNumberV2 = options.enums === String ? $root.proto.WebFeatures.Flag[message.changeNumberV2] : message.changeNumberV2;
            if (message.queryStatusV3Thumbnail != null && message.hasOwnProperty("queryStatusV3Thumbnail"))
                object.queryStatusV3Thumbnail = options.enums === String ? $root.proto.WebFeatures.Flag[message.queryStatusV3Thumbnail] : message.queryStatusV3Thumbnail;
            if (message.liveLocations != null && message.hasOwnProperty("liveLocations"))
                object.liveLocations = options.enums === String ? $root.proto.WebFeatures.Flag[message.liveLocations] : message.liveLocations;
            if (message.queryVname != null && message.hasOwnProperty("queryVname"))
                object.queryVname = options.enums === String ? $root.proto.WebFeatures.Flag[message.queryVname] : message.queryVname;
            if (message.voipIndividualIncoming != null && message.hasOwnProperty("voipIndividualIncoming"))
                object.voipIndividualIncoming = options.enums === String ? $root.proto.WebFeatures.Flag[message.voipIndividualIncoming] : message.voipIndividualIncoming;
            if (message.quickRepliesQuery != null && message.hasOwnProperty("quickRepliesQuery"))
                object.quickRepliesQuery = options.enums === String ? $root.proto.WebFeatures.Flag[message.quickRepliesQuery] : message.quickRepliesQuery;
            if (message.payments != null && message.hasOwnProperty("payments"))
                object.payments = options.enums === String ? $root.proto.WebFeatures.Flag[message.payments] : message.payments;
            if (message.stickerPackQuery != null && message.hasOwnProperty("stickerPackQuery"))
                object.stickerPackQuery = options.enums === String ? $root.proto.WebFeatures.Flag[message.stickerPackQuery] : message.stickerPackQuery;
            if (message.liveLocationsFinal != null && message.hasOwnProperty("liveLocationsFinal"))
                object.liveLocationsFinal = options.enums === String ? $root.proto.WebFeatures.Flag[message.liveLocationsFinal] : message.liveLocationsFinal;
            if (message.labelsEdit != null && message.hasOwnProperty("labelsEdit"))
                object.labelsEdit = options.enums === String ? $root.proto.WebFeatures.Flag[message.labelsEdit] : message.labelsEdit;
            if (message.mediaUpload != null && message.hasOwnProperty("mediaUpload"))
                object.mediaUpload = options.enums === String ? $root.proto.WebFeatures.Flag[message.mediaUpload] : message.mediaUpload;
            if (message.mediaUploadRichQuickReplies != null && message.hasOwnProperty("mediaUploadRichQuickReplies"))
                object.mediaUploadRichQuickReplies = options.enums === String ? $root.proto.WebFeatures.Flag[message.mediaUploadRichQuickReplies] : message.mediaUploadRichQuickReplies;
            if (message.vnameV2 != null && message.hasOwnProperty("vnameV2"))
                object.vnameV2 = options.enums === String ? $root.proto.WebFeatures.Flag[message.vnameV2] : message.vnameV2;
            if (message.videoPlaybackUrl != null && message.hasOwnProperty("videoPlaybackUrl"))
                object.videoPlaybackUrl = options.enums === String ? $root.proto.WebFeatures.Flag[message.videoPlaybackUrl] : message.videoPlaybackUrl;
            if (message.statusRanking != null && message.hasOwnProperty("statusRanking"))
                object.statusRanking = options.enums === String ? $root.proto.WebFeatures.Flag[message.statusRanking] : message.statusRanking;
            if (message.voipIndividualVideo != null && message.hasOwnProperty("voipIndividualVideo"))
                object.voipIndividualVideo = options.enums === String ? $root.proto.WebFeatures.Flag[message.voipIndividualVideo] : message.voipIndividualVideo;
            if (message.thirdPartyStickers != null && message.hasOwnProperty("thirdPartyStickers"))
                object.thirdPartyStickers = options.enums === String ? $root.proto.WebFeatures.Flag[message.thirdPartyStickers] : message.thirdPartyStickers;
            if (message.frequentlyForwardedSetting != null && message.hasOwnProperty("frequentlyForwardedSetting"))
                object.frequentlyForwardedSetting = options.enums === String ? $root.proto.WebFeatures.Flag[message.frequentlyForwardedSetting] : message.frequentlyForwardedSetting;
            if (message.groupsV4JoinPermission != null && message.hasOwnProperty("groupsV4JoinPermission"))
                object.groupsV4JoinPermission = options.enums === String ? $root.proto.WebFeatures.Flag[message.groupsV4JoinPermission] : message.groupsV4JoinPermission;
            if (message.recentStickers != null && message.hasOwnProperty("recentStickers"))
                object.recentStickers = options.enums === String ? $root.proto.WebFeatures.Flag[message.recentStickers] : message.recentStickers;
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                object.catalog = options.enums === String ? $root.proto.WebFeatures.Flag[message.catalog] : message.catalog;
            if (message.starredStickers != null && message.hasOwnProperty("starredStickers"))
                object.starredStickers = options.enums === String ? $root.proto.WebFeatures.Flag[message.starredStickers] : message.starredStickers;
            if (message.voipGroupCall != null && message.hasOwnProperty("voipGroupCall"))
                object.voipGroupCall = options.enums === String ? $root.proto.WebFeatures.Flag[message.voipGroupCall] : message.voipGroupCall;
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage"))
                object.templateMessage = options.enums === String ? $root.proto.WebFeatures.Flag[message.templateMessage] : message.templateMessage;
            if (message.templateMessageInteractivity != null && message.hasOwnProperty("templateMessageInteractivity"))
                object.templateMessageInteractivity = options.enums === String ? $root.proto.WebFeatures.Flag[message.templateMessageInteractivity] : message.templateMessageInteractivity;
            if (message.ephemeralMessages != null && message.hasOwnProperty("ephemeralMessages"))
                object.ephemeralMessages = options.enums === String ? $root.proto.WebFeatures.Flag[message.ephemeralMessages] : message.ephemeralMessages;
            if (message.e2ENotificationSync != null && message.hasOwnProperty("e2ENotificationSync"))
                object.e2ENotificationSync = options.enums === String ? $root.proto.WebFeatures.Flag[message.e2ENotificationSync] : message.e2ENotificationSync;
            if (message.recentStickersV2 != null && message.hasOwnProperty("recentStickersV2"))
                object.recentStickersV2 = options.enums === String ? $root.proto.WebFeatures.Flag[message.recentStickersV2] : message.recentStickersV2;
            if (message.recentStickersV3 != null && message.hasOwnProperty("recentStickersV3"))
                object.recentStickersV3 = options.enums === String ? $root.proto.WebFeatures.Flag[message.recentStickersV3] : message.recentStickersV3;
            if (message.userNotice != null && message.hasOwnProperty("userNotice"))
                object.userNotice = options.enums === String ? $root.proto.WebFeatures.Flag[message.userNotice] : message.userNotice;
            if (message.support != null && message.hasOwnProperty("support"))
                object.support = options.enums === String ? $root.proto.WebFeatures.Flag[message.support] : message.support;
            if (message.groupUiiCleanup != null && message.hasOwnProperty("groupUiiCleanup"))
                object.groupUiiCleanup = options.enums === String ? $root.proto.WebFeatures.Flag[message.groupUiiCleanup] : message.groupUiiCleanup;
            if (message.groupDogfoodingInternalOnly != null && message.hasOwnProperty("groupDogfoodingInternalOnly"))
                object.groupDogfoodingInternalOnly = options.enums === String ? $root.proto.WebFeatures.Flag[message.groupDogfoodingInternalOnly] : message.groupDogfoodingInternalOnly;
            if (message.settingsSync != null && message.hasOwnProperty("settingsSync"))
                object.settingsSync = options.enums === String ? $root.proto.WebFeatures.Flag[message.settingsSync] : message.settingsSync;
            if (message.archiveV2 != null && message.hasOwnProperty("archiveV2"))
                object.archiveV2 = options.enums === String ? $root.proto.WebFeatures.Flag[message.archiveV2] : message.archiveV2;
            if (message.ephemeralAllowGroupMembers != null && message.hasOwnProperty("ephemeralAllowGroupMembers"))
                object.ephemeralAllowGroupMembers = options.enums === String ? $root.proto.WebFeatures.Flag[message.ephemeralAllowGroupMembers] : message.ephemeralAllowGroupMembers;
            if (message.ephemeral24HDuration != null && message.hasOwnProperty("ephemeral24HDuration"))
                object.ephemeral24HDuration = options.enums === String ? $root.proto.WebFeatures.Flag[message.ephemeral24HDuration] : message.ephemeral24HDuration;
            if (message.mdForceUpgrade != null && message.hasOwnProperty("mdForceUpgrade"))
                object.mdForceUpgrade = options.enums === String ? $root.proto.WebFeatures.Flag[message.mdForceUpgrade] : message.mdForceUpgrade;
            if (message.disappearingMode != null && message.hasOwnProperty("disappearingMode"))
                object.disappearingMode = options.enums === String ? $root.proto.WebFeatures.Flag[message.disappearingMode] : message.disappearingMode;
            if (message.externalMdOptInAvailable != null && message.hasOwnProperty("externalMdOptInAvailable"))
                object.externalMdOptInAvailable = options.enums === String ? $root.proto.WebFeatures.Flag[message.externalMdOptInAvailable] : message.externalMdOptInAvailable;
            if (message.noDeleteMessageTimeLimit != null && message.hasOwnProperty("noDeleteMessageTimeLimit"))
                object.noDeleteMessageTimeLimit = options.enums === String ? $root.proto.WebFeatures.Flag[message.noDeleteMessageTimeLimit] : message.noDeleteMessageTimeLimit;
            return object;
        };

        /**
         * Converts this WebFeatures to JSON.
         * @function toJSON
         * @memberof proto.WebFeatures
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebFeatures.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Flag enum.
         * @name proto.WebFeatures.Flag
         * @enum {number}
         * @property {number} NOT_STARTED=0 NOT_STARTED value
         * @property {number} FORCE_UPGRADE=1 FORCE_UPGRADE value
         * @property {number} DEVELOPMENT=2 DEVELOPMENT value
         * @property {number} PRODUCTION=3 PRODUCTION value
         */
        WebFeatures.Flag = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NOT_STARTED"] = 0;
            values[valuesById[1] = "FORCE_UPGRADE"] = 1;
            values[valuesById[2] = "DEVELOPMENT"] = 2;
            values[valuesById[3] = "PRODUCTION"] = 3;
            return values;
        })();

        return WebFeatures;
    })();

    proto.WebMessageInfo = (function() {

        /**
         * Properties of a WebMessageInfo.
         * @memberof proto
         * @interface IWebMessageInfo
         * @property {proto.IMessageKey} key WebMessageInfo key
         * @property {proto.IMessage|null} [message] WebMessageInfo message
         * @property {number|Long|null} [messageTimestamp] WebMessageInfo messageTimestamp
         * @property {proto.WebMessageInfo.Status|null} [status] WebMessageInfo status
         * @property {string|null} [participant] WebMessageInfo participant
         * @property {number|Long|null} [messageC2STimestamp] WebMessageInfo messageC2STimestamp
         * @property {boolean|null} [ignore] WebMessageInfo ignore
         * @property {boolean|null} [starred] WebMessageInfo starred
         * @property {boolean|null} [broadcast] WebMessageInfo broadcast
         * @property {string|null} [pushName] WebMessageInfo pushName
         * @property {Uint8Array|null} [mediaCiphertextSha256] WebMessageInfo mediaCiphertextSha256
         * @property {boolean|null} [multicast] WebMessageInfo multicast
         * @property {boolean|null} [urlText] WebMessageInfo urlText
         * @property {boolean|null} [urlNumber] WebMessageInfo urlNumber
         * @property {proto.WebMessageInfo.StubType|null} [messageStubType] WebMessageInfo messageStubType
         * @property {boolean|null} [clearMedia] WebMessageInfo clearMedia
         * @property {Array.<string>|null} [messageStubParameters] WebMessageInfo messageStubParameters
         * @property {number|null} [duration] WebMessageInfo duration
         * @property {Array.<string>|null} [labels] WebMessageInfo labels
         * @property {proto.IPaymentInfo|null} [paymentInfo] WebMessageInfo paymentInfo
         * @property {proto.Message.ILiveLocationMessage|null} [finalLiveLocation] WebMessageInfo finalLiveLocation
         * @property {proto.IPaymentInfo|null} [quotedPaymentInfo] WebMessageInfo quotedPaymentInfo
         * @property {number|Long|null} [ephemeralStartTimestamp] WebMessageInfo ephemeralStartTimestamp
         * @property {number|null} [ephemeralDuration] WebMessageInfo ephemeralDuration
         * @property {boolean|null} [ephemeralOffToOn] WebMessageInfo ephemeralOffToOn
         * @property {boolean|null} [ephemeralOutOfSync] WebMessageInfo ephemeralOutOfSync
         * @property {proto.WebMessageInfo.BizPrivacyStatus|null} [bizPrivacyStatus] WebMessageInfo bizPrivacyStatus
         * @property {string|null} [verifiedBizName] WebMessageInfo verifiedBizName
         * @property {proto.IMediaData|null} [mediaData] WebMessageInfo mediaData
         * @property {proto.IPhotoChange|null} [photoChange] WebMessageInfo photoChange
         * @property {Array.<proto.IUserReceipt>|null} [userReceipt] WebMessageInfo userReceipt
         * @property {Array.<proto.IReaction>|null} [reactions] WebMessageInfo reactions
         * @property {proto.IMediaData|null} [quotedStickerData] WebMessageInfo quotedStickerData
         * @property {Uint8Array|null} [futureproofData] WebMessageInfo futureproofData
         * @property {proto.IStatusPSA|null} [statusPsa] WebMessageInfo statusPsa
         * @property {Array.<proto.IPollUpdate>|null} [pollUpdates] WebMessageInfo pollUpdates
         * @property {proto.IPollAdditionalMetadata|null} [pollAdditionalMetadata] WebMessageInfo pollAdditionalMetadata
         * @property {string|null} [agentId] WebMessageInfo agentId
         * @property {boolean|null} [statusAlreadyViewed] WebMessageInfo statusAlreadyViewed
         * @property {Uint8Array|null} [messageSecret] WebMessageInfo messageSecret
         * @property {proto.IKeepInChat|null} [keepInChat] WebMessageInfo keepInChat
         * @property {string|null} [originalSelfAuthorUserJidString] WebMessageInfo originalSelfAuthorUserJidString
         * @property {number|Long|null} [revokeMessageTimestamp] WebMessageInfo revokeMessageTimestamp
         */

        /**
         * Constructs a new WebMessageInfo.
         * @memberof proto
         * @classdesc Represents a WebMessageInfo.
         * @implements IWebMessageInfo
         * @constructor
         * @param {proto.IWebMessageInfo=} [properties] Properties to set
         */
        function WebMessageInfo(properties) {
            this.messageStubParameters = [];
            this.labels = [];
            this.userReceipt = [];
            this.reactions = [];
            this.pollUpdates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebMessageInfo key.
         * @member {proto.IMessageKey} key
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.key = null;

        /**
         * WebMessageInfo message.
         * @member {proto.IMessage|null|undefined} message
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.message = null;

        /**
         * WebMessageInfo messageTimestamp.
         * @member {number|Long} messageTimestamp
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.messageTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebMessageInfo status.
         * @member {proto.WebMessageInfo.Status} status
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.status = 0;

        /**
         * WebMessageInfo participant.
         * @member {string} participant
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.participant = "";

        /**
         * WebMessageInfo messageC2STimestamp.
         * @member {number|Long} messageC2STimestamp
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.messageC2STimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebMessageInfo ignore.
         * @member {boolean} ignore
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ignore = false;

        /**
         * WebMessageInfo starred.
         * @member {boolean} starred
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.starred = false;

        /**
         * WebMessageInfo broadcast.
         * @member {boolean} broadcast
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.broadcast = false;

        /**
         * WebMessageInfo pushName.
         * @member {string} pushName
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.pushName = "";

        /**
         * WebMessageInfo mediaCiphertextSha256.
         * @member {Uint8Array} mediaCiphertextSha256
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.mediaCiphertextSha256 = $util.newBuffer([]);

        /**
         * WebMessageInfo multicast.
         * @member {boolean} multicast
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.multicast = false;

        /**
         * WebMessageInfo urlText.
         * @member {boolean} urlText
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.urlText = false;

        /**
         * WebMessageInfo urlNumber.
         * @member {boolean} urlNumber
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.urlNumber = false;

        /**
         * WebMessageInfo messageStubType.
         * @member {proto.WebMessageInfo.StubType} messageStubType
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.messageStubType = 0;

        /**
         * WebMessageInfo clearMedia.
         * @member {boolean} clearMedia
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.clearMedia = false;

        /**
         * WebMessageInfo messageStubParameters.
         * @member {Array.<string>} messageStubParameters
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.messageStubParameters = $util.emptyArray;

        /**
         * WebMessageInfo duration.
         * @member {number} duration
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.duration = 0;

        /**
         * WebMessageInfo labels.
         * @member {Array.<string>} labels
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.labels = $util.emptyArray;

        /**
         * WebMessageInfo paymentInfo.
         * @member {proto.IPaymentInfo|null|undefined} paymentInfo
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.paymentInfo = null;

        /**
         * WebMessageInfo finalLiveLocation.
         * @member {proto.Message.ILiveLocationMessage|null|undefined} finalLiveLocation
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.finalLiveLocation = null;

        /**
         * WebMessageInfo quotedPaymentInfo.
         * @member {proto.IPaymentInfo|null|undefined} quotedPaymentInfo
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.quotedPaymentInfo = null;

        /**
         * WebMessageInfo ephemeralStartTimestamp.
         * @member {number|Long} ephemeralStartTimestamp
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ephemeralStartTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebMessageInfo ephemeralDuration.
         * @member {number} ephemeralDuration
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ephemeralDuration = 0;

        /**
         * WebMessageInfo ephemeralOffToOn.
         * @member {boolean} ephemeralOffToOn
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ephemeralOffToOn = false;

        /**
         * WebMessageInfo ephemeralOutOfSync.
         * @member {boolean} ephemeralOutOfSync
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ephemeralOutOfSync = false;

        /**
         * WebMessageInfo bizPrivacyStatus.
         * @member {proto.WebMessageInfo.BizPrivacyStatus} bizPrivacyStatus
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.bizPrivacyStatus = 0;

        /**
         * WebMessageInfo verifiedBizName.
         * @member {string} verifiedBizName
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.verifiedBizName = "";

        /**
         * WebMessageInfo mediaData.
         * @member {proto.IMediaData|null|undefined} mediaData
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.mediaData = null;

        /**
         * WebMessageInfo photoChange.
         * @member {proto.IPhotoChange|null|undefined} photoChange
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.photoChange = null;

        /**
         * WebMessageInfo userReceipt.
         * @member {Array.<proto.IUserReceipt>} userReceipt
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.userReceipt = $util.emptyArray;

        /**
         * WebMessageInfo reactions.
         * @member {Array.<proto.IReaction>} reactions
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.reactions = $util.emptyArray;

        /**
         * WebMessageInfo quotedStickerData.
         * @member {proto.IMediaData|null|undefined} quotedStickerData
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.quotedStickerData = null;

        /**
         * WebMessageInfo futureproofData.
         * @member {Uint8Array} futureproofData
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.futureproofData = $util.newBuffer([]);

        /**
         * WebMessageInfo statusPsa.
         * @member {proto.IStatusPSA|null|undefined} statusPsa
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.statusPsa = null;

        /**
         * WebMessageInfo pollUpdates.
         * @member {Array.<proto.IPollUpdate>} pollUpdates
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.pollUpdates = $util.emptyArray;

        /**
         * WebMessageInfo pollAdditionalMetadata.
         * @member {proto.IPollAdditionalMetadata|null|undefined} pollAdditionalMetadata
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.pollAdditionalMetadata = null;

        /**
         * WebMessageInfo agentId.
         * @member {string} agentId
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.agentId = "";

        /**
         * WebMessageInfo statusAlreadyViewed.
         * @member {boolean} statusAlreadyViewed
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.statusAlreadyViewed = false;

        /**
         * WebMessageInfo messageSecret.
         * @member {Uint8Array} messageSecret
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.messageSecret = $util.newBuffer([]);

        /**
         * WebMessageInfo keepInChat.
         * @member {proto.IKeepInChat|null|undefined} keepInChat
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.keepInChat = null;

        /**
         * WebMessageInfo originalSelfAuthorUserJidString.
         * @member {string} originalSelfAuthorUserJidString
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.originalSelfAuthorUserJidString = "";

        /**
         * WebMessageInfo revokeMessageTimestamp.
         * @member {number|Long} revokeMessageTimestamp
         * @memberof proto.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.revokeMessageTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new WebMessageInfo instance using the specified properties.
         * @function create
         * @memberof proto.WebMessageInfo
         * @static
         * @param {proto.IWebMessageInfo=} [properties] Properties to set
         * @returns {proto.WebMessageInfo} WebMessageInfo instance
         */
        WebMessageInfo.create = function create(properties) {
            return new WebMessageInfo(properties);
        };

        /**
         * Encodes the specified WebMessageInfo message. Does not implicitly {@link proto.WebMessageInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.WebMessageInfo
         * @static
         * @param {proto.IWebMessageInfo} message WebMessageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebMessageInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.proto.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                $root.proto.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.messageTimestamp != null && Object.hasOwnProperty.call(message, "messageTimestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageTimestamp);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            if (message.participant != null && Object.hasOwnProperty.call(message, "participant"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.participant);
            if (message.messageC2STimestamp != null && Object.hasOwnProperty.call(message, "messageC2STimestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.messageC2STimestamp);
            if (message.ignore != null && Object.hasOwnProperty.call(message, "ignore"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ignore);
            if (message.starred != null && Object.hasOwnProperty.call(message, "starred"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.starred);
            if (message.broadcast != null && Object.hasOwnProperty.call(message, "broadcast"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.broadcast);
            if (message.pushName != null && Object.hasOwnProperty.call(message, "pushName"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.pushName);
            if (message.mediaCiphertextSha256 != null && Object.hasOwnProperty.call(message, "mediaCiphertextSha256"))
                writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.mediaCiphertextSha256);
            if (message.multicast != null && Object.hasOwnProperty.call(message, "multicast"))
                writer.uint32(/* id 21, wireType 0 =*/168).bool(message.multicast);
            if (message.urlText != null && Object.hasOwnProperty.call(message, "urlText"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.urlText);
            if (message.urlNumber != null && Object.hasOwnProperty.call(message, "urlNumber"))
                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.urlNumber);
            if (message.messageStubType != null && Object.hasOwnProperty.call(message, "messageStubType"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.messageStubType);
            if (message.clearMedia != null && Object.hasOwnProperty.call(message, "clearMedia"))
                writer.uint32(/* id 25, wireType 0 =*/200).bool(message.clearMedia);
            if (message.messageStubParameters != null && message.messageStubParameters.length)
                for (var i = 0; i < message.messageStubParameters.length; ++i)
                    writer.uint32(/* id 26, wireType 2 =*/210).string(message.messageStubParameters[i]);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.duration);
            if (message.labels != null && message.labels.length)
                for (var i = 0; i < message.labels.length; ++i)
                    writer.uint32(/* id 28, wireType 2 =*/226).string(message.labels[i]);
            if (message.paymentInfo != null && Object.hasOwnProperty.call(message, "paymentInfo"))
                $root.proto.PaymentInfo.encode(message.paymentInfo, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.finalLiveLocation != null && Object.hasOwnProperty.call(message, "finalLiveLocation"))
                $root.proto.Message.LiveLocationMessage.encode(message.finalLiveLocation, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.quotedPaymentInfo != null && Object.hasOwnProperty.call(message, "quotedPaymentInfo"))
                $root.proto.PaymentInfo.encode(message.quotedPaymentInfo, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.ephemeralStartTimestamp != null && Object.hasOwnProperty.call(message, "ephemeralStartTimestamp"))
                writer.uint32(/* id 32, wireType 0 =*/256).uint64(message.ephemeralStartTimestamp);
            if (message.ephemeralDuration != null && Object.hasOwnProperty.call(message, "ephemeralDuration"))
                writer.uint32(/* id 33, wireType 0 =*/264).uint32(message.ephemeralDuration);
            if (message.ephemeralOffToOn != null && Object.hasOwnProperty.call(message, "ephemeralOffToOn"))
                writer.uint32(/* id 34, wireType 0 =*/272).bool(message.ephemeralOffToOn);
            if (message.ephemeralOutOfSync != null && Object.hasOwnProperty.call(message, "ephemeralOutOfSync"))
                writer.uint32(/* id 35, wireType 0 =*/280).bool(message.ephemeralOutOfSync);
            if (message.bizPrivacyStatus != null && Object.hasOwnProperty.call(message, "bizPrivacyStatus"))
                writer.uint32(/* id 36, wireType 0 =*/288).int32(message.bizPrivacyStatus);
            if (message.verifiedBizName != null && Object.hasOwnProperty.call(message, "verifiedBizName"))
                writer.uint32(/* id 37, wireType 2 =*/298).string(message.verifiedBizName);
            if (message.mediaData != null && Object.hasOwnProperty.call(message, "mediaData"))
                $root.proto.MediaData.encode(message.mediaData, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.photoChange != null && Object.hasOwnProperty.call(message, "photoChange"))
                $root.proto.PhotoChange.encode(message.photoChange, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
            if (message.userReceipt != null && message.userReceipt.length)
                for (var i = 0; i < message.userReceipt.length; ++i)
                    $root.proto.UserReceipt.encode(message.userReceipt[i], writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
            if (message.reactions != null && message.reactions.length)
                for (var i = 0; i < message.reactions.length; ++i)
                    $root.proto.Reaction.encode(message.reactions[i], writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
            if (message.quotedStickerData != null && Object.hasOwnProperty.call(message, "quotedStickerData"))
                $root.proto.MediaData.encode(message.quotedStickerData, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            if (message.futureproofData != null && Object.hasOwnProperty.call(message, "futureproofData"))
                writer.uint32(/* id 43, wireType 2 =*/346).bytes(message.futureproofData);
            if (message.statusPsa != null && Object.hasOwnProperty.call(message, "statusPsa"))
                $root.proto.StatusPSA.encode(message.statusPsa, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            if (message.pollUpdates != null && message.pollUpdates.length)
                for (var i = 0; i < message.pollUpdates.length; ++i)
                    $root.proto.PollUpdate.encode(message.pollUpdates[i], writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.pollAdditionalMetadata != null && Object.hasOwnProperty.call(message, "pollAdditionalMetadata"))
                $root.proto.PollAdditionalMetadata.encode(message.pollAdditionalMetadata, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
            if (message.agentId != null && Object.hasOwnProperty.call(message, "agentId"))
                writer.uint32(/* id 47, wireType 2 =*/378).string(message.agentId);
            if (message.statusAlreadyViewed != null && Object.hasOwnProperty.call(message, "statusAlreadyViewed"))
                writer.uint32(/* id 48, wireType 0 =*/384).bool(message.statusAlreadyViewed);
            if (message.messageSecret != null && Object.hasOwnProperty.call(message, "messageSecret"))
                writer.uint32(/* id 49, wireType 2 =*/394).bytes(message.messageSecret);
            if (message.keepInChat != null && Object.hasOwnProperty.call(message, "keepInChat"))
                $root.proto.KeepInChat.encode(message.keepInChat, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
            if (message.originalSelfAuthorUserJidString != null && Object.hasOwnProperty.call(message, "originalSelfAuthorUserJidString"))
                writer.uint32(/* id 51, wireType 2 =*/410).string(message.originalSelfAuthorUserJidString);
            if (message.revokeMessageTimestamp != null && Object.hasOwnProperty.call(message, "revokeMessageTimestamp"))
                writer.uint32(/* id 52, wireType 0 =*/416).uint64(message.revokeMessageTimestamp);
            return writer;
        };

        /**
         * Encodes the specified WebMessageInfo message, length delimited. Does not implicitly {@link proto.WebMessageInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.WebMessageInfo
         * @static
         * @param {proto.IWebMessageInfo} message WebMessageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebMessageInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebMessageInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.WebMessageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.WebMessageInfo} WebMessageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebMessageInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.WebMessageInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.proto.MessageKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.message = $root.proto.Message.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.messageTimestamp = reader.uint64();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                case 5:
                    message.participant = reader.string();
                    break;
                case 6:
                    message.messageC2STimestamp = reader.uint64();
                    break;
                case 16:
                    message.ignore = reader.bool();
                    break;
                case 17:
                    message.starred = reader.bool();
                    break;
                case 18:
                    message.broadcast = reader.bool();
                    break;
                case 19:
                    message.pushName = reader.string();
                    break;
                case 20:
                    message.mediaCiphertextSha256 = reader.bytes();
                    break;
                case 21:
                    message.multicast = reader.bool();
                    break;
                case 22:
                    message.urlText = reader.bool();
                    break;
                case 23:
                    message.urlNumber = reader.bool();
                    break;
                case 24:
                    message.messageStubType = reader.int32();
                    break;
                case 25:
                    message.clearMedia = reader.bool();
                    break;
                case 26:
                    if (!(message.messageStubParameters && message.messageStubParameters.length))
                        message.messageStubParameters = [];
                    message.messageStubParameters.push(reader.string());
                    break;
                case 27:
                    message.duration = reader.uint32();
                    break;
                case 28:
                    if (!(message.labels && message.labels.length))
                        message.labels = [];
                    message.labels.push(reader.string());
                    break;
                case 29:
                    message.paymentInfo = $root.proto.PaymentInfo.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.finalLiveLocation = $root.proto.Message.LiveLocationMessage.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.quotedPaymentInfo = $root.proto.PaymentInfo.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.ephemeralStartTimestamp = reader.uint64();
                    break;
                case 33:
                    message.ephemeralDuration = reader.uint32();
                    break;
                case 34:
                    message.ephemeralOffToOn = reader.bool();
                    break;
                case 35:
                    message.ephemeralOutOfSync = reader.bool();
                    break;
                case 36:
                    message.bizPrivacyStatus = reader.int32();
                    break;
                case 37:
                    message.verifiedBizName = reader.string();
                    break;
                case 38:
                    message.mediaData = $root.proto.MediaData.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.photoChange = $root.proto.PhotoChange.decode(reader, reader.uint32());
                    break;
                case 40:
                    if (!(message.userReceipt && message.userReceipt.length))
                        message.userReceipt = [];
                    message.userReceipt.push($root.proto.UserReceipt.decode(reader, reader.uint32()));
                    break;
                case 41:
                    if (!(message.reactions && message.reactions.length))
                        message.reactions = [];
                    message.reactions.push($root.proto.Reaction.decode(reader, reader.uint32()));
                    break;
                case 42:
                    message.quotedStickerData = $root.proto.MediaData.decode(reader, reader.uint32());
                    break;
                case 43:
                    message.futureproofData = reader.bytes();
                    break;
                case 44:
                    message.statusPsa = $root.proto.StatusPSA.decode(reader, reader.uint32());
                    break;
                case 45:
                    if (!(message.pollUpdates && message.pollUpdates.length))
                        message.pollUpdates = [];
                    message.pollUpdates.push($root.proto.PollUpdate.decode(reader, reader.uint32()));
                    break;
                case 46:
                    message.pollAdditionalMetadata = $root.proto.PollAdditionalMetadata.decode(reader, reader.uint32());
                    break;
                case 47:
                    message.agentId = reader.string();
                    break;
                case 48:
                    message.statusAlreadyViewed = reader.bool();
                    break;
                case 49:
                    message.messageSecret = reader.bytes();
                    break;
                case 50:
                    message.keepInChat = $root.proto.KeepInChat.decode(reader, reader.uint32());
                    break;
                case 51:
                    message.originalSelfAuthorUserJidString = reader.string();
                    break;
                case 52:
                    message.revokeMessageTimestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            return message;
        };

        /**
         * Decodes a WebMessageInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.WebMessageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.WebMessageInfo} WebMessageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebMessageInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebMessageInfo message.
         * @function verify
         * @memberof proto.WebMessageInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebMessageInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.proto.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.message != null && message.hasOwnProperty("message")) {
                var error = $root.proto.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
            if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                if (!$util.isInteger(message.messageTimestamp) && !(message.messageTimestamp && $util.isInteger(message.messageTimestamp.low) && $util.isInteger(message.messageTimestamp.high)))
                    return "messageTimestamp: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.participant != null && message.hasOwnProperty("participant"))
                if (!$util.isString(message.participant))
                    return "participant: string expected";
            if (message.messageC2STimestamp != null && message.hasOwnProperty("messageC2STimestamp"))
                if (!$util.isInteger(message.messageC2STimestamp) && !(message.messageC2STimestamp && $util.isInteger(message.messageC2STimestamp.low) && $util.isInteger(message.messageC2STimestamp.high)))
                    return "messageC2STimestamp: integer|Long expected";
            if (message.ignore != null && message.hasOwnProperty("ignore"))
                if (typeof message.ignore !== "boolean")
                    return "ignore: boolean expected";
            if (message.starred != null && message.hasOwnProperty("starred"))
                if (typeof message.starred !== "boolean")
                    return "starred: boolean expected";
            if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                if (typeof message.broadcast !== "boolean")
                    return "broadcast: boolean expected";
            if (message.pushName != null && message.hasOwnProperty("pushName"))
                if (!$util.isString(message.pushName))
                    return "pushName: string expected";
            if (message.mediaCiphertextSha256 != null && message.hasOwnProperty("mediaCiphertextSha256"))
                if (!(message.mediaCiphertextSha256 && typeof message.mediaCiphertextSha256.length === "number" || $util.isString(message.mediaCiphertextSha256)))
                    return "mediaCiphertextSha256: buffer expected";
            if (message.multicast != null && message.hasOwnProperty("multicast"))
                if (typeof message.multicast !== "boolean")
                    return "multicast: boolean expected";
            if (message.urlText != null && message.hasOwnProperty("urlText"))
                if (typeof message.urlText !== "boolean")
                    return "urlText: boolean expected";
            if (message.urlNumber != null && message.hasOwnProperty("urlNumber"))
                if (typeof message.urlNumber !== "boolean")
                    return "urlNumber: boolean expected";
            if (message.messageStubType != null && message.hasOwnProperty("messageStubType"))
                switch (message.messageStubType) {
                default:
                    return "messageStubType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 117:
                case 118:
                case 119:
                case 120:
                case 121:
                case 122:
                case 123:
                case 124:
                case 125:
                case 126:
                case 127:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                case 150:
                case 151:
                case 152:
                case 153:
                case 154:
                case 155:
                case 156:
                case 157:
                case 158:
                case 159:
                case 160:
                case 161:
                    break;
                }
            if (message.clearMedia != null && message.hasOwnProperty("clearMedia"))
                if (typeof message.clearMedia !== "boolean")
                    return "clearMedia: boolean expected";
            if (message.messageStubParameters != null && message.hasOwnProperty("messageStubParameters")) {
                if (!Array.isArray(message.messageStubParameters))
                    return "messageStubParameters: array expected";
                for (var i = 0; i < message.messageStubParameters.length; ++i)
                    if (!$util.isString(message.messageStubParameters[i]))
                        return "messageStubParameters: string[] expected";
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!Array.isArray(message.labels))
                    return "labels: array expected";
                for (var i = 0; i < message.labels.length; ++i)
                    if (!$util.isString(message.labels[i]))
                        return "labels: string[] expected";
            }
            if (message.paymentInfo != null && message.hasOwnProperty("paymentInfo")) {
                var error = $root.proto.PaymentInfo.verify(message.paymentInfo);
                if (error)
                    return "paymentInfo." + error;
            }
            if (message.finalLiveLocation != null && message.hasOwnProperty("finalLiveLocation")) {
                var error = $root.proto.Message.LiveLocationMessage.verify(message.finalLiveLocation);
                if (error)
                    return "finalLiveLocation." + error;
            }
            if (message.quotedPaymentInfo != null && message.hasOwnProperty("quotedPaymentInfo")) {
                var error = $root.proto.PaymentInfo.verify(message.quotedPaymentInfo);
                if (error)
                    return "quotedPaymentInfo." + error;
            }
            if (message.ephemeralStartTimestamp != null && message.hasOwnProperty("ephemeralStartTimestamp"))
                if (!$util.isInteger(message.ephemeralStartTimestamp) && !(message.ephemeralStartTimestamp && $util.isInteger(message.ephemeralStartTimestamp.low) && $util.isInteger(message.ephemeralStartTimestamp.high)))
                    return "ephemeralStartTimestamp: integer|Long expected";
            if (message.ephemeralDuration != null && message.hasOwnProperty("ephemeralDuration"))
                if (!$util.isInteger(message.ephemeralDuration))
                    return "ephemeralDuration: integer expected";
            if (message.ephemeralOffToOn != null && message.hasOwnProperty("ephemeralOffToOn"))
                if (typeof message.ephemeralOffToOn !== "boolean")
                    return "ephemeralOffToOn: boolean expected";
            if (message.ephemeralOutOfSync != null && message.hasOwnProperty("ephemeralOutOfSync"))
                if (typeof message.ephemeralOutOfSync !== "boolean")
                    return "ephemeralOutOfSync: boolean expected";
            if (message.bizPrivacyStatus != null && message.hasOwnProperty("bizPrivacyStatus"))
                switch (message.bizPrivacyStatus) {
                default:
                    return "bizPrivacyStatus: enum value expected";
                case 0:
                case 2:
                case 1:
                case 3:
                    break;
                }
            if (message.verifiedBizName != null && message.hasOwnProperty("verifiedBizName"))
                if (!$util.isString(message.verifiedBizName))
                    return "verifiedBizName: string expected";
            if (message.mediaData != null && message.hasOwnProperty("mediaData")) {
                var error = $root.proto.MediaData.verify(message.mediaData);
                if (error)
                    return "mediaData." + error;
            }
            if (message.photoChange != null && message.hasOwnProperty("photoChange")) {
                var error = $root.proto.PhotoChange.verify(message.photoChange);
                if (error)
                    return "photoChange." + error;
            }
            if (message.userReceipt != null && message.hasOwnProperty("userReceipt")) {
                if (!Array.isArray(message.userReceipt))
                    return "userReceipt: array expected";
                for (var i = 0; i < message.userReceipt.length; ++i) {
                    var error = $root.proto.UserReceipt.verify(message.userReceipt[i]);
                    if (error)
                        return "userReceipt." + error;
                }
            }
            if (message.reactions != null && message.hasOwnProperty("reactions")) {
                if (!Array.isArray(message.reactions))
                    return "reactions: array expected";
                for (var i = 0; i < message.reactions.length; ++i) {
                    var error = $root.proto.Reaction.verify(message.reactions[i]);
                    if (error)
                        return "reactions." + error;
                }
            }
            if (message.quotedStickerData != null && message.hasOwnProperty("quotedStickerData")) {
                var error = $root.proto.MediaData.verify(message.quotedStickerData);
                if (error)
                    return "quotedStickerData." + error;
            }
            if (message.futureproofData != null && message.hasOwnProperty("futureproofData"))
                if (!(message.futureproofData && typeof message.futureproofData.length === "number" || $util.isString(message.futureproofData)))
                    return "futureproofData: buffer expected";
            if (message.statusPsa != null && message.hasOwnProperty("statusPsa")) {
                var error = $root.proto.StatusPSA.verify(message.statusPsa);
                if (error)
                    return "statusPsa." + error;
            }
            if (message.pollUpdates != null && message.hasOwnProperty("pollUpdates")) {
                if (!Array.isArray(message.pollUpdates))
                    return "pollUpdates: array expected";
                for (var i = 0; i < message.pollUpdates.length; ++i) {
                    var error = $root.proto.PollUpdate.verify(message.pollUpdates[i]);
                    if (error)
                        return "pollUpdates." + error;
                }
            }
            if (message.pollAdditionalMetadata != null && message.hasOwnProperty("pollAdditionalMetadata")) {
                var error = $root.proto.PollAdditionalMetadata.verify(message.pollAdditionalMetadata);
                if (error)
                    return "pollAdditionalMetadata." + error;
            }
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                if (!$util.isString(message.agentId))
                    return "agentId: string expected";
            if (message.statusAlreadyViewed != null && message.hasOwnProperty("statusAlreadyViewed"))
                if (typeof message.statusAlreadyViewed !== "boolean")
                    return "statusAlreadyViewed: boolean expected";
            if (message.messageSecret != null && message.hasOwnProperty("messageSecret"))
                if (!(message.messageSecret && typeof message.messageSecret.length === "number" || $util.isString(message.messageSecret)))
                    return "messageSecret: buffer expected";
            if (message.keepInChat != null && message.hasOwnProperty("keepInChat")) {
                var error = $root.proto.KeepInChat.verify(message.keepInChat);
                if (error)
                    return "keepInChat." + error;
            }
            if (message.originalSelfAuthorUserJidString != null && message.hasOwnProperty("originalSelfAuthorUserJidString"))
                if (!$util.isString(message.originalSelfAuthorUserJidString))
                    return "originalSelfAuthorUserJidString: string expected";
            if (message.revokeMessageTimestamp != null && message.hasOwnProperty("revokeMessageTimestamp"))
                if (!$util.isInteger(message.revokeMessageTimestamp) && !(message.revokeMessageTimestamp && $util.isInteger(message.revokeMessageTimestamp.low) && $util.isInteger(message.revokeMessageTimestamp.high)))
                    return "revokeMessageTimestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a WebMessageInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.WebMessageInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.WebMessageInfo} WebMessageInfo
         */
        WebMessageInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.WebMessageInfo)
                return object;
            var message = new $root.proto.WebMessageInfo();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".proto.WebMessageInfo.key: object expected");
                message.key = $root.proto.MessageKey.fromObject(object.key);
            }
            if (object.message != null) {
                if (typeof object.message !== "object")
                    throw TypeError(".proto.WebMessageInfo.message: object expected");
                message.message = $root.proto.Message.fromObject(object.message);
            }
            if (object.messageTimestamp != null)
                if ($util.Long)
                    (message.messageTimestamp = $util.Long.fromValue(object.messageTimestamp)).unsigned = true;
                else if (typeof object.messageTimestamp === "string")
                    message.messageTimestamp = parseInt(object.messageTimestamp, 10);
                else if (typeof object.messageTimestamp === "number")
                    message.messageTimestamp = object.messageTimestamp;
                else if (typeof object.messageTimestamp === "object")
                    message.messageTimestamp = new $util.LongBits(object.messageTimestamp.low >>> 0, object.messageTimestamp.high >>> 0).toNumber(true);
            switch (object.status) {
            case "ERROR":
            case 0:
                message.status = 0;
                break;
            case "PENDING":
            case 1:
                message.status = 1;
                break;
            case "SERVER_ACK":
            case 2:
                message.status = 2;
                break;
            case "DELIVERY_ACK":
            case 3:
                message.status = 3;
                break;
            case "READ":
            case 4:
                message.status = 4;
                break;
            case "PLAYED":
            case 5:
                message.status = 5;
                break;
            }
            if (object.participant != null)
                message.participant = String(object.participant);
            if (object.messageC2STimestamp != null)
                if ($util.Long)
                    (message.messageC2STimestamp = $util.Long.fromValue(object.messageC2STimestamp)).unsigned = true;
                else if (typeof object.messageC2STimestamp === "string")
                    message.messageC2STimestamp = parseInt(object.messageC2STimestamp, 10);
                else if (typeof object.messageC2STimestamp === "number")
                    message.messageC2STimestamp = object.messageC2STimestamp;
                else if (typeof object.messageC2STimestamp === "object")
                    message.messageC2STimestamp = new $util.LongBits(object.messageC2STimestamp.low >>> 0, object.messageC2STimestamp.high >>> 0).toNumber(true);
            if (object.ignore != null)
                message.ignore = Boolean(object.ignore);
            if (object.starred != null)
                message.starred = Boolean(object.starred);
            if (object.broadcast != null)
                message.broadcast = Boolean(object.broadcast);
            if (object.pushName != null)
                message.pushName = String(object.pushName);
            if (object.mediaCiphertextSha256 != null)
                if (typeof object.mediaCiphertextSha256 === "string")
                    $util.base64.decode(object.mediaCiphertextSha256, message.mediaCiphertextSha256 = $util.newBuffer($util.base64.length(object.mediaCiphertextSha256)), 0);
                else if (object.mediaCiphertextSha256.length)
                    message.mediaCiphertextSha256 = object.mediaCiphertextSha256;
            if (object.multicast != null)
                message.multicast = Boolean(object.multicast);
            if (object.urlText != null)
                message.urlText = Boolean(object.urlText);
            if (object.urlNumber != null)
                message.urlNumber = Boolean(object.urlNumber);
            switch (object.messageStubType) {
            case "UNKNOWN":
            case 0:
                message.messageStubType = 0;
                break;
            case "REVOKE":
            case 1:
                message.messageStubType = 1;
                break;
            case "CIPHERTEXT":
            case 2:
                message.messageStubType = 2;
                break;
            case "FUTUREPROOF":
            case 3:
                message.messageStubType = 3;
                break;
            case "NON_VERIFIED_TRANSITION":
            case 4:
                message.messageStubType = 4;
                break;
            case "UNVERIFIED_TRANSITION":
            case 5:
                message.messageStubType = 5;
                break;
            case "VERIFIED_TRANSITION":
            case 6:
                message.messageStubType = 6;
                break;
            case "VERIFIED_LOW_UNKNOWN":
            case 7:
                message.messageStubType = 7;
                break;
            case "VERIFIED_HIGH":
            case 8:
                message.messageStubType = 8;
                break;
            case "VERIFIED_INITIAL_UNKNOWN":
            case 9:
                message.messageStubType = 9;
                break;
            case "VERIFIED_INITIAL_LOW":
            case 10:
                message.messageStubType = 10;
                break;
            case "VERIFIED_INITIAL_HIGH":
            case 11:
                message.messageStubType = 11;
                break;
            case "VERIFIED_TRANSITION_ANY_TO_NONE":
            case 12:
                message.messageStubType = 12;
                break;
            case "VERIFIED_TRANSITION_ANY_TO_HIGH":
            case 13:
                message.messageStubType = 13;
                break;
            case "VERIFIED_TRANSITION_HIGH_TO_LOW":
            case 14:
                message.messageStubType = 14;
                break;
            case "VERIFIED_TRANSITION_HIGH_TO_UNKNOWN":
            case 15:
                message.messageStubType = 15;
                break;
            case "VERIFIED_TRANSITION_UNKNOWN_TO_LOW":
            case 16:
                message.messageStubType = 16;
                break;
            case "VERIFIED_TRANSITION_LOW_TO_UNKNOWN":
            case 17:
                message.messageStubType = 17;
                break;
            case "VERIFIED_TRANSITION_NONE_TO_LOW":
            case 18:
                message.messageStubType = 18;
                break;
            case "VERIFIED_TRANSITION_NONE_TO_UNKNOWN":
            case 19:
                message.messageStubType = 19;
                break;
            case "GROUP_CREATE":
            case 20:
                message.messageStubType = 20;
                break;
            case "GROUP_CHANGE_SUBJECT":
            case 21:
                message.messageStubType = 21;
                break;
            case "GROUP_CHANGE_ICON":
            case 22:
                message.messageStubType = 22;
                break;
            case "GROUP_CHANGE_INVITE_LINK":
            case 23:
                message.messageStubType = 23;
                break;
            case "GROUP_CHANGE_DESCRIPTION":
            case 24:
                message.messageStubType = 24;
                break;
            case "GROUP_CHANGE_RESTRICT":
            case 25:
                message.messageStubType = 25;
                break;
            case "GROUP_CHANGE_ANNOUNCE":
            case 26:
                message.messageStubType = 26;
                break;
            case "GROUP_PARTICIPANT_ADD":
            case 27:
                message.messageStubType = 27;
                break;
            case "GROUP_PARTICIPANT_REMOVE":
            case 28:
                message.messageStubType = 28;
                break;
            case "GROUP_PARTICIPANT_PROMOTE":
            case 29:
                message.messageStubType = 29;
                break;
            case "GROUP_PARTICIPANT_DEMOTE":
            case 30:
                message.messageStubType = 30;
                break;
            case "GROUP_PARTICIPANT_INVITE":
            case 31:
                message.messageStubType = 31;
                break;
            case "GROUP_PARTICIPANT_LEAVE":
            case 32:
                message.messageStubType = 32;
                break;
            case "GROUP_PARTICIPANT_CHANGE_NUMBER":
            case 33:
                message.messageStubType = 33;
                break;
            case "BROADCAST_CREATE":
            case 34:
                message.messageStubType = 34;
                break;
            case "BROADCAST_ADD":
            case 35:
                message.messageStubType = 35;
                break;
            case "BROADCAST_REMOVE":
            case 36:
                message.messageStubType = 36;
                break;
            case "GENERIC_NOTIFICATION":
            case 37:
                message.messageStubType = 37;
                break;
            case "E2E_IDENTITY_CHANGED":
            case 38:
                message.messageStubType = 38;
                break;
            case "E2E_ENCRYPTED":
            case 39:
                message.messageStubType = 39;
                break;
            case "CALL_MISSED_VOICE":
            case 40:
                message.messageStubType = 40;
                break;
            case "CALL_MISSED_VIDEO":
            case 41:
                message.messageStubType = 41;
                break;
            case "INDIVIDUAL_CHANGE_NUMBER":
            case 42:
                message.messageStubType = 42;
                break;
            case "GROUP_DELETE":
            case 43:
                message.messageStubType = 43;
                break;
            case "GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE":
            case 44:
                message.messageStubType = 44;
                break;
            case "CALL_MISSED_GROUP_VOICE":
            case 45:
                message.messageStubType = 45;
                break;
            case "CALL_MISSED_GROUP_VIDEO":
            case 46:
                message.messageStubType = 46;
                break;
            case "PAYMENT_CIPHERTEXT":
            case 47:
                message.messageStubType = 47;
                break;
            case "PAYMENT_FUTUREPROOF":
            case 48:
                message.messageStubType = 48;
                break;
            case "PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED":
            case 49:
                message.messageStubType = 49;
                break;
            case "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED":
            case 50:
                message.messageStubType = 50;
                break;
            case "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED":
            case 51:
                message.messageStubType = 51;
                break;
            case "PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP":
            case 52:
                message.messageStubType = 52;
                break;
            case "PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP":
            case 53:
                message.messageStubType = 53;
                break;
            case "PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER":
            case 54:
                message.messageStubType = 54;
                break;
            case "PAYMENT_ACTION_SEND_PAYMENT_REMINDER":
            case 55:
                message.messageStubType = 55;
                break;
            case "PAYMENT_ACTION_SEND_PAYMENT_INVITATION":
            case 56:
                message.messageStubType = 56;
                break;
            case "PAYMENT_ACTION_REQUEST_DECLINED":
            case 57:
                message.messageStubType = 57;
                break;
            case "PAYMENT_ACTION_REQUEST_EXPIRED":
            case 58:
                message.messageStubType = 58;
                break;
            case "PAYMENT_ACTION_REQUEST_CANCELLED":
            case 59:
                message.messageStubType = 59;
                break;
            case "BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM":
            case 60:
                message.messageStubType = 60;
                break;
            case "BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP":
            case 61:
                message.messageStubType = 61;
                break;
            case "BIZ_INTRO_TOP":
            case 62:
                message.messageStubType = 62;
                break;
            case "BIZ_INTRO_BOTTOM":
            case 63:
                message.messageStubType = 63;
                break;
            case "BIZ_NAME_CHANGE":
            case 64:
                message.messageStubType = 64;
                break;
            case "BIZ_MOVE_TO_CONSUMER_APP":
            case 65:
                message.messageStubType = 65;
                break;
            case "BIZ_TWO_TIER_MIGRATION_TOP":
            case 66:
                message.messageStubType = 66;
                break;
            case "BIZ_TWO_TIER_MIGRATION_BOTTOM":
            case 67:
                message.messageStubType = 67;
                break;
            case "OVERSIZED":
            case 68:
                message.messageStubType = 68;
                break;
            case "GROUP_CHANGE_NO_FREQUENTLY_FORWARDED":
            case 69:
                message.messageStubType = 69;
                break;
            case "GROUP_V4_ADD_INVITE_SENT":
            case 70:
                message.messageStubType = 70;
                break;
            case "GROUP_PARTICIPANT_ADD_REQUEST_JOIN":
            case 71:
                message.messageStubType = 71;
                break;
            case "CHANGE_EPHEMERAL_SETTING":
            case 72:
                message.messageStubType = 72;
                break;
            case "E2E_DEVICE_CHANGED":
            case 73:
                message.messageStubType = 73;
                break;
            case "VIEWED_ONCE":
            case 74:
                message.messageStubType = 74;
                break;
            case "E2E_ENCRYPTED_NOW":
            case 75:
                message.messageStubType = 75;
                break;
            case "BLUE_MSG_BSP_FB_TO_BSP_PREMISE":
            case 76:
                message.messageStubType = 76;
                break;
            case "BLUE_MSG_BSP_FB_TO_SELF_FB":
            case 77:
                message.messageStubType = 77;
                break;
            case "BLUE_MSG_BSP_FB_TO_SELF_PREMISE":
            case 78:
                message.messageStubType = 78;
                break;
            case "BLUE_MSG_BSP_FB_UNVERIFIED":
            case 79:
                message.messageStubType = 79;
                break;
            case "BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED":
            case 80:
                message.messageStubType = 80;
                break;
            case "BLUE_MSG_BSP_FB_VERIFIED":
            case 81:
                message.messageStubType = 81;
                break;
            case "BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED":
            case 82:
                message.messageStubType = 82;
                break;
            case "BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE":
            case 83:
                message.messageStubType = 83;
                break;
            case "BLUE_MSG_BSP_PREMISE_UNVERIFIED":
            case 84:
                message.messageStubType = 84;
                break;
            case "BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED":
            case 85:
                message.messageStubType = 85;
                break;
            case "BLUE_MSG_BSP_PREMISE_VERIFIED":
            case 86:
                message.messageStubType = 86;
                break;
            case "BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED":
            case 87:
                message.messageStubType = 87;
                break;
            case "BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED":
            case 88:
                message.messageStubType = 88;
                break;
            case "BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED":
            case 89:
                message.messageStubType = 89;
                break;
            case "BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED":
            case 90:
                message.messageStubType = 90;
                break;
            case "BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED":
            case 91:
                message.messageStubType = 91;
                break;
            case "BLUE_MSG_SELF_FB_TO_BSP_PREMISE":
            case 92:
                message.messageStubType = 92;
                break;
            case "BLUE_MSG_SELF_FB_TO_SELF_PREMISE":
            case 93:
                message.messageStubType = 93;
                break;
            case "BLUE_MSG_SELF_FB_UNVERIFIED":
            case 94:
                message.messageStubType = 94;
                break;
            case "BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED":
            case 95:
                message.messageStubType = 95;
                break;
            case "BLUE_MSG_SELF_FB_VERIFIED":
            case 96:
                message.messageStubType = 96;
                break;
            case "BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED":
            case 97:
                message.messageStubType = 97;
                break;
            case "BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE":
            case 98:
                message.messageStubType = 98;
                break;
            case "BLUE_MSG_SELF_PREMISE_UNVERIFIED":
            case 99:
                message.messageStubType = 99;
                break;
            case "BLUE_MSG_SELF_PREMISE_VERIFIED":
            case 100:
                message.messageStubType = 100;
                break;
            case "BLUE_MSG_TO_BSP_FB":
            case 101:
                message.messageStubType = 101;
                break;
            case "BLUE_MSG_TO_CONSUMER":
            case 102:
                message.messageStubType = 102;
                break;
            case "BLUE_MSG_TO_SELF_FB":
            case 103:
                message.messageStubType = 103;
                break;
            case "BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED":
            case 104:
                message.messageStubType = 104;
                break;
            case "BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED":
            case 105:
                message.messageStubType = 105;
                break;
            case "BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED":
            case 106:
                message.messageStubType = 106;
                break;
            case "BLUE_MSG_UNVERIFIED_TO_VERIFIED":
            case 107:
                message.messageStubType = 107;
                break;
            case "BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED":
            case 108:
                message.messageStubType = 108;
                break;
            case "BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED":
            case 109:
                message.messageStubType = 109;
                break;
            case "BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED":
            case 110:
                message.messageStubType = 110;
                break;
            case "BLUE_MSG_VERIFIED_TO_UNVERIFIED":
            case 111:
                message.messageStubType = 111;
                break;
            case "BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED":
            case 112:
                message.messageStubType = 112;
                break;
            case "BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED":
            case 113:
                message.messageStubType = 113;
                break;
            case "BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED":
            case 114:
                message.messageStubType = 114;
                break;
            case "BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED":
            case 115:
                message.messageStubType = 115;
                break;
            case "BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED":
            case 116:
                message.messageStubType = 116;
                break;
            case "BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED":
            case 117:
                message.messageStubType = 117;
                break;
            case "E2E_IDENTITY_UNAVAILABLE":
            case 118:
                message.messageStubType = 118;
                break;
            case "GROUP_CREATING":
            case 119:
                message.messageStubType = 119;
                break;
            case "GROUP_CREATE_FAILED":
            case 120:
                message.messageStubType = 120;
                break;
            case "GROUP_BOUNCED":
            case 121:
                message.messageStubType = 121;
                break;
            case "BLOCK_CONTACT":
            case 122:
                message.messageStubType = 122;
                break;
            case "EPHEMERAL_SETTING_NOT_APPLIED":
            case 123:
                message.messageStubType = 123;
                break;
            case "SYNC_FAILED":
            case 124:
                message.messageStubType = 124;
                break;
            case "SYNCING":
            case 125:
                message.messageStubType = 125;
                break;
            case "BIZ_PRIVACY_MODE_INIT_FB":
            case 126:
                message.messageStubType = 126;
                break;
            case "BIZ_PRIVACY_MODE_INIT_BSP":
            case 127:
                message.messageStubType = 127;
                break;
            case "BIZ_PRIVACY_MODE_TO_FB":
            case 128:
                message.messageStubType = 128;
                break;
            case "BIZ_PRIVACY_MODE_TO_BSP":
            case 129:
                message.messageStubType = 129;
                break;
            case "DISAPPEARING_MODE":
            case 130:
                message.messageStubType = 130;
                break;
            case "E2E_DEVICE_FETCH_FAILED":
            case 131:
                message.messageStubType = 131;
                break;
            case "ADMIN_REVOKE":
            case 132:
                message.messageStubType = 132;
                break;
            case "GROUP_INVITE_LINK_GROWTH_LOCKED":
            case 133:
                message.messageStubType = 133;
                break;
            case "COMMUNITY_LINK_PARENT_GROUP":
            case 134:
                message.messageStubType = 134;
                break;
            case "COMMUNITY_LINK_SIBLING_GROUP":
            case 135:
                message.messageStubType = 135;
                break;
            case "COMMUNITY_LINK_SUB_GROUP":
            case 136:
                message.messageStubType = 136;
                break;
            case "COMMUNITY_UNLINK_PARENT_GROUP":
            case 137:
                message.messageStubType = 137;
                break;
            case "COMMUNITY_UNLINK_SIBLING_GROUP":
            case 138:
                message.messageStubType = 138;
                break;
            case "COMMUNITY_UNLINK_SUB_GROUP":
            case 139:
                message.messageStubType = 139;
                break;
            case "GROUP_PARTICIPANT_ACCEPT":
            case 140:
                message.messageStubType = 140;
                break;
            case "GROUP_PARTICIPANT_LINKED_GROUP_JOIN":
            case 141:
                message.messageStubType = 141;
                break;
            case "COMMUNITY_CREATE":
            case 142:
                message.messageStubType = 142;
                break;
            case "EPHEMERAL_KEEP_IN_CHAT":
            case 143:
                message.messageStubType = 143;
                break;
            case "GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST":
            case 144:
                message.messageStubType = 144;
                break;
            case "GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE":
            case 145:
                message.messageStubType = 145;
                break;
            case "INTEGRITY_UNLINK_PARENT_GROUP":
            case 146:
                message.messageStubType = 146;
                break;
            case "COMMUNITY_PARTICIPANT_PROMOTE":
            case 147:
                message.messageStubType = 147;
                break;
            case "COMMUNITY_PARTICIPANT_DEMOTE":
            case 148:
                message.messageStubType = 148;
                break;
            case "COMMUNITY_PARENT_GROUP_DELETED":
            case 149:
                message.messageStubType = 149;
                break;
            case "COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL":
            case 150:
                message.messageStubType = 150;
                break;
            case "GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP":
            case 151:
                message.messageStubType = 151;
                break;
            case "MASKED_THREAD_CREATED":
            case 152:
                message.messageStubType = 152;
                break;
            case "MASKED_THREAD_UNMASKED":
            case 153:
                message.messageStubType = 153;
                break;
            case "BIZ_CHAT_ASSIGNMENT":
            case 154:
                message.messageStubType = 154;
                break;
            case "CHAT_PSA":
            case 155:
                message.messageStubType = 155;
                break;
            case "CHAT_POLL_CREATION_MESSAGE":
            case 156:
                message.messageStubType = 156;
                break;
            case "CAG_MASKED_THREAD_CREATED":
            case 157:
                message.messageStubType = 157;
                break;
            case "COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED":
            case 158:
                message.messageStubType = 158;
                break;
            case "CAG_INVITE_AUTO_ADD":
            case 159:
                message.messageStubType = 159;
                break;
            case "BIZ_CHAT_ASSIGNMENT_UNASSIGN":
            case 160:
                message.messageStubType = 160;
                break;
            case "CAG_INVITE_AUTO_JOINED":
            case 161:
                message.messageStubType = 161;
                break;
            }
            if (object.clearMedia != null)
                message.clearMedia = Boolean(object.clearMedia);
            if (object.messageStubParameters) {
                if (!Array.isArray(object.messageStubParameters))
                    throw TypeError(".proto.WebMessageInfo.messageStubParameters: array expected");
                message.messageStubParameters = [];
                for (var i = 0; i < object.messageStubParameters.length; ++i)
                    message.messageStubParameters[i] = String(object.messageStubParameters[i]);
            }
            if (object.duration != null)
                message.duration = object.duration >>> 0;
            if (object.labels) {
                if (!Array.isArray(object.labels))
                    throw TypeError(".proto.WebMessageInfo.labels: array expected");
                message.labels = [];
                for (var i = 0; i < object.labels.length; ++i)
                    message.labels[i] = String(object.labels[i]);
            }
            if (object.paymentInfo != null) {
                if (typeof object.paymentInfo !== "object")
                    throw TypeError(".proto.WebMessageInfo.paymentInfo: object expected");
                message.paymentInfo = $root.proto.PaymentInfo.fromObject(object.paymentInfo);
            }
            if (object.finalLiveLocation != null) {
                if (typeof object.finalLiveLocation !== "object")
                    throw TypeError(".proto.WebMessageInfo.finalLiveLocation: object expected");
                message.finalLiveLocation = $root.proto.Message.LiveLocationMessage.fromObject(object.finalLiveLocation);
            }
            if (object.quotedPaymentInfo != null) {
                if (typeof object.quotedPaymentInfo !== "object")
                    throw TypeError(".proto.WebMessageInfo.quotedPaymentInfo: object expected");
                message.quotedPaymentInfo = $root.proto.PaymentInfo.fromObject(object.quotedPaymentInfo);
            }
            if (object.ephemeralStartTimestamp != null)
                if ($util.Long)
                    (message.ephemeralStartTimestamp = $util.Long.fromValue(object.ephemeralStartTimestamp)).unsigned = true;
                else if (typeof object.ephemeralStartTimestamp === "string")
                    message.ephemeralStartTimestamp = parseInt(object.ephemeralStartTimestamp, 10);
                else if (typeof object.ephemeralStartTimestamp === "number")
                    message.ephemeralStartTimestamp = object.ephemeralStartTimestamp;
                else if (typeof object.ephemeralStartTimestamp === "object")
                    message.ephemeralStartTimestamp = new $util.LongBits(object.ephemeralStartTimestamp.low >>> 0, object.ephemeralStartTimestamp.high >>> 0).toNumber(true);
            if (object.ephemeralDuration != null)
                message.ephemeralDuration = object.ephemeralDuration >>> 0;
            if (object.ephemeralOffToOn != null)
                message.ephemeralOffToOn = Boolean(object.ephemeralOffToOn);
            if (object.ephemeralOutOfSync != null)
                message.ephemeralOutOfSync = Boolean(object.ephemeralOutOfSync);
            switch (object.bizPrivacyStatus) {
            case "E2EE":
            case 0:
                message.bizPrivacyStatus = 0;
                break;
            case "FB":
            case 2:
                message.bizPrivacyStatus = 2;
                break;
            case "BSP":
            case 1:
                message.bizPrivacyStatus = 1;
                break;
            case "BSP_AND_FB":
            case 3:
                message.bizPrivacyStatus = 3;
                break;
            }
            if (object.verifiedBizName != null)
                message.verifiedBizName = String(object.verifiedBizName);
            if (object.mediaData != null) {
                if (typeof object.mediaData !== "object")
                    throw TypeError(".proto.WebMessageInfo.mediaData: object expected");
                message.mediaData = $root.proto.MediaData.fromObject(object.mediaData);
            }
            if (object.photoChange != null) {
                if (typeof object.photoChange !== "object")
                    throw TypeError(".proto.WebMessageInfo.photoChange: object expected");
                message.photoChange = $root.proto.PhotoChange.fromObject(object.photoChange);
            }
            if (object.userReceipt) {
                if (!Array.isArray(object.userReceipt))
                    throw TypeError(".proto.WebMessageInfo.userReceipt: array expected");
                message.userReceipt = [];
                for (var i = 0; i < object.userReceipt.length; ++i) {
                    if (typeof object.userReceipt[i] !== "object")
                        throw TypeError(".proto.WebMessageInfo.userReceipt: object expected");
                    message.userReceipt[i] = $root.proto.UserReceipt.fromObject(object.userReceipt[i]);
                }
            }
            if (object.reactions) {
                if (!Array.isArray(object.reactions))
                    throw TypeError(".proto.WebMessageInfo.reactions: array expected");
                message.reactions = [];
                for (var i = 0; i < object.reactions.length; ++i) {
                    if (typeof object.reactions[i] !== "object")
                        throw TypeError(".proto.WebMessageInfo.reactions: object expected");
                    message.reactions[i] = $root.proto.Reaction.fromObject(object.reactions[i]);
                }
            }
            if (object.quotedStickerData != null) {
                if (typeof object.quotedStickerData !== "object")
                    throw TypeError(".proto.WebMessageInfo.quotedStickerData: object expected");
                message.quotedStickerData = $root.proto.MediaData.fromObject(object.quotedStickerData);
            }
            if (object.futureproofData != null)
                if (typeof object.futureproofData === "string")
                    $util.base64.decode(object.futureproofData, message.futureproofData = $util.newBuffer($util.base64.length(object.futureproofData)), 0);
                else if (object.futureproofData.length)
                    message.futureproofData = object.futureproofData;
            if (object.statusPsa != null) {
                if (typeof object.statusPsa !== "object")
                    throw TypeError(".proto.WebMessageInfo.statusPsa: object expected");
                message.statusPsa = $root.proto.StatusPSA.fromObject(object.statusPsa);
            }
            if (object.pollUpdates) {
                if (!Array.isArray(object.pollUpdates))
                    throw TypeError(".proto.WebMessageInfo.pollUpdates: array expected");
                message.pollUpdates = [];
                for (var i = 0; i < object.pollUpdates.length; ++i) {
                    if (typeof object.pollUpdates[i] !== "object")
                        throw TypeError(".proto.WebMessageInfo.pollUpdates: object expected");
                    message.pollUpdates[i] = $root.proto.PollUpdate.fromObject(object.pollUpdates[i]);
                }
            }
            if (object.pollAdditionalMetadata != null) {
                if (typeof object.pollAdditionalMetadata !== "object")
                    throw TypeError(".proto.WebMessageInfo.pollAdditionalMetadata: object expected");
                message.pollAdditionalMetadata = $root.proto.PollAdditionalMetadata.fromObject(object.pollAdditionalMetadata);
            }
            if (object.agentId != null)
                message.agentId = String(object.agentId);
            if (object.statusAlreadyViewed != null)
                message.statusAlreadyViewed = Boolean(object.statusAlreadyViewed);
            if (object.messageSecret != null)
                if (typeof object.messageSecret === "string")
                    $util.base64.decode(object.messageSecret, message.messageSecret = $util.newBuffer($util.base64.length(object.messageSecret)), 0);
                else if (object.messageSecret.length)
                    message.messageSecret = object.messageSecret;
            if (object.keepInChat != null) {
                if (typeof object.keepInChat !== "object")
                    throw TypeError(".proto.WebMessageInfo.keepInChat: object expected");
                message.keepInChat = $root.proto.KeepInChat.fromObject(object.keepInChat);
            }
            if (object.originalSelfAuthorUserJidString != null)
                message.originalSelfAuthorUserJidString = String(object.originalSelfAuthorUserJidString);
            if (object.revokeMessageTimestamp != null)
                if ($util.Long)
                    (message.revokeMessageTimestamp = $util.Long.fromValue(object.revokeMessageTimestamp)).unsigned = true;
                else if (typeof object.revokeMessageTimestamp === "string")
                    message.revokeMessageTimestamp = parseInt(object.revokeMessageTimestamp, 10);
                else if (typeof object.revokeMessageTimestamp === "number")
                    message.revokeMessageTimestamp = object.revokeMessageTimestamp;
                else if (typeof object.revokeMessageTimestamp === "object")
                    message.revokeMessageTimestamp = new $util.LongBits(object.revokeMessageTimestamp.low >>> 0, object.revokeMessageTimestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a WebMessageInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.WebMessageInfo
         * @static
         * @param {proto.WebMessageInfo} message WebMessageInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebMessageInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.messageStubParameters = [];
                object.labels = [];
                object.userReceipt = [];
                object.reactions = [];
                object.pollUpdates = [];
            }
            if (options.defaults) {
                object.key = null;
                object.message = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.messageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.messageTimestamp = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "ERROR" : 0;
                object.participant = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.messageC2STimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.messageC2STimestamp = options.longs === String ? "0" : 0;
                object.ignore = false;
                object.starred = false;
                object.broadcast = false;
                object.pushName = "";
                if (options.bytes === String)
                    object.mediaCiphertextSha256 = "";
                else {
                    object.mediaCiphertextSha256 = [];
                    if (options.bytes !== Array)
                        object.mediaCiphertextSha256 = $util.newBuffer(object.mediaCiphertextSha256);
                }
                object.multicast = false;
                object.urlText = false;
                object.urlNumber = false;
                object.messageStubType = options.enums === String ? "UNKNOWN" : 0;
                object.clearMedia = false;
                object.duration = 0;
                object.paymentInfo = null;
                object.finalLiveLocation = null;
                object.quotedPaymentInfo = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.ephemeralStartTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ephemeralStartTimestamp = options.longs === String ? "0" : 0;
                object.ephemeralDuration = 0;
                object.ephemeralOffToOn = false;
                object.ephemeralOutOfSync = false;
                object.bizPrivacyStatus = options.enums === String ? "E2EE" : 0;
                object.verifiedBizName = "";
                object.mediaData = null;
                object.photoChange = null;
                object.quotedStickerData = null;
                if (options.bytes === String)
                    object.futureproofData = "";
                else {
                    object.futureproofData = [];
                    if (options.bytes !== Array)
                        object.futureproofData = $util.newBuffer(object.futureproofData);
                }
                object.statusPsa = null;
                object.pollAdditionalMetadata = null;
                object.agentId = "";
                object.statusAlreadyViewed = false;
                if (options.bytes === String)
                    object.messageSecret = "";
                else {
                    object.messageSecret = [];
                    if (options.bytes !== Array)
                        object.messageSecret = $util.newBuffer(object.messageSecret);
                }
                object.keepInChat = null;
                object.originalSelfAuthorUserJidString = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.revokeMessageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revokeMessageTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.proto.MessageKey.toObject(message.key, options);
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = $root.proto.Message.toObject(message.message, options);
            if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                if (typeof message.messageTimestamp === "number")
                    object.messageTimestamp = options.longs === String ? String(message.messageTimestamp) : message.messageTimestamp;
                else
                    object.messageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.messageTimestamp) : options.longs === Number ? new $util.LongBits(message.messageTimestamp.low >>> 0, message.messageTimestamp.high >>> 0).toNumber(true) : message.messageTimestamp;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.proto.WebMessageInfo.Status[message.status] : message.status;
            if (message.participant != null && message.hasOwnProperty("participant"))
                object.participant = message.participant;
            if (message.messageC2STimestamp != null && message.hasOwnProperty("messageC2STimestamp"))
                if (typeof message.messageC2STimestamp === "number")
                    object.messageC2STimestamp = options.longs === String ? String(message.messageC2STimestamp) : message.messageC2STimestamp;
                else
                    object.messageC2STimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.messageC2STimestamp) : options.longs === Number ? new $util.LongBits(message.messageC2STimestamp.low >>> 0, message.messageC2STimestamp.high >>> 0).toNumber(true) : message.messageC2STimestamp;
            if (message.ignore != null && message.hasOwnProperty("ignore"))
                object.ignore = message.ignore;
            if (message.starred != null && message.hasOwnProperty("starred"))
                object.starred = message.starred;
            if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                object.broadcast = message.broadcast;
            if (message.pushName != null && message.hasOwnProperty("pushName"))
                object.pushName = message.pushName;
            if (message.mediaCiphertextSha256 != null && message.hasOwnProperty("mediaCiphertextSha256"))
                object.mediaCiphertextSha256 = options.bytes === String ? $util.base64.encode(message.mediaCiphertextSha256, 0, message.mediaCiphertextSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaCiphertextSha256) : message.mediaCiphertextSha256;
            if (message.multicast != null && message.hasOwnProperty("multicast"))
                object.multicast = message.multicast;
            if (message.urlText != null && message.hasOwnProperty("urlText"))
                object.urlText = message.urlText;
            if (message.urlNumber != null && message.hasOwnProperty("urlNumber"))
                object.urlNumber = message.urlNumber;
            if (message.messageStubType != null && message.hasOwnProperty("messageStubType"))
                object.messageStubType = options.enums === String ? $root.proto.WebMessageInfo.StubType[message.messageStubType] : message.messageStubType;
            if (message.clearMedia != null && message.hasOwnProperty("clearMedia"))
                object.clearMedia = message.clearMedia;
            if (message.messageStubParameters && message.messageStubParameters.length) {
                object.messageStubParameters = [];
                for (var j = 0; j < message.messageStubParameters.length; ++j)
                    object.messageStubParameters[j] = message.messageStubParameters[j];
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.labels && message.labels.length) {
                object.labels = [];
                for (var j = 0; j < message.labels.length; ++j)
                    object.labels[j] = message.labels[j];
            }
            if (message.paymentInfo != null && message.hasOwnProperty("paymentInfo"))
                object.paymentInfo = $root.proto.PaymentInfo.toObject(message.paymentInfo, options);
            if (message.finalLiveLocation != null && message.hasOwnProperty("finalLiveLocation"))
                object.finalLiveLocation = $root.proto.Message.LiveLocationMessage.toObject(message.finalLiveLocation, options);
            if (message.quotedPaymentInfo != null && message.hasOwnProperty("quotedPaymentInfo"))
                object.quotedPaymentInfo = $root.proto.PaymentInfo.toObject(message.quotedPaymentInfo, options);
            if (message.ephemeralStartTimestamp != null && message.hasOwnProperty("ephemeralStartTimestamp"))
                if (typeof message.ephemeralStartTimestamp === "number")
                    object.ephemeralStartTimestamp = options.longs === String ? String(message.ephemeralStartTimestamp) : message.ephemeralStartTimestamp;
                else
                    object.ephemeralStartTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.ephemeralStartTimestamp) : options.longs === Number ? new $util.LongBits(message.ephemeralStartTimestamp.low >>> 0, message.ephemeralStartTimestamp.high >>> 0).toNumber(true) : message.ephemeralStartTimestamp;
            if (message.ephemeralDuration != null && message.hasOwnProperty("ephemeralDuration"))
                object.ephemeralDuration = message.ephemeralDuration;
            if (message.ephemeralOffToOn != null && message.hasOwnProperty("ephemeralOffToOn"))
                object.ephemeralOffToOn = message.ephemeralOffToOn;
            if (message.ephemeralOutOfSync != null && message.hasOwnProperty("ephemeralOutOfSync"))
                object.ephemeralOutOfSync = message.ephemeralOutOfSync;
            if (message.bizPrivacyStatus != null && message.hasOwnProperty("bizPrivacyStatus"))
                object.bizPrivacyStatus = options.enums === String ? $root.proto.WebMessageInfo.BizPrivacyStatus[message.bizPrivacyStatus] : message.bizPrivacyStatus;
            if (message.verifiedBizName != null && message.hasOwnProperty("verifiedBizName"))
                object.verifiedBizName = message.verifiedBizName;
            if (message.mediaData != null && message.hasOwnProperty("mediaData"))
                object.mediaData = $root.proto.MediaData.toObject(message.mediaData, options);
            if (message.photoChange != null && message.hasOwnProperty("photoChange"))
                object.photoChange = $root.proto.PhotoChange.toObject(message.photoChange, options);
            if (message.userReceipt && message.userReceipt.length) {
                object.userReceipt = [];
                for (var j = 0; j < message.userReceipt.length; ++j)
                    object.userReceipt[j] = $root.proto.UserReceipt.toObject(message.userReceipt[j], options);
            }
            if (message.reactions && message.reactions.length) {
                object.reactions = [];
                for (var j = 0; j < message.reactions.length; ++j)
                    object.reactions[j] = $root.proto.Reaction.toObject(message.reactions[j], options);
            }
            if (message.quotedStickerData != null && message.hasOwnProperty("quotedStickerData"))
                object.quotedStickerData = $root.proto.MediaData.toObject(message.quotedStickerData, options);
            if (message.futureproofData != null && message.hasOwnProperty("futureproofData"))
                object.futureproofData = options.bytes === String ? $util.base64.encode(message.futureproofData, 0, message.futureproofData.length) : options.bytes === Array ? Array.prototype.slice.call(message.futureproofData) : message.futureproofData;
            if (message.statusPsa != null && message.hasOwnProperty("statusPsa"))
                object.statusPsa = $root.proto.StatusPSA.toObject(message.statusPsa, options);
            if (message.pollUpdates && message.pollUpdates.length) {
                object.pollUpdates = [];
                for (var j = 0; j < message.pollUpdates.length; ++j)
                    object.pollUpdates[j] = $root.proto.PollUpdate.toObject(message.pollUpdates[j], options);
            }
            if (message.pollAdditionalMetadata != null && message.hasOwnProperty("pollAdditionalMetadata"))
                object.pollAdditionalMetadata = $root.proto.PollAdditionalMetadata.toObject(message.pollAdditionalMetadata, options);
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                object.agentId = message.agentId;
            if (message.statusAlreadyViewed != null && message.hasOwnProperty("statusAlreadyViewed"))
                object.statusAlreadyViewed = message.statusAlreadyViewed;
            if (message.messageSecret != null && message.hasOwnProperty("messageSecret"))
                object.messageSecret = options.bytes === String ? $util.base64.encode(message.messageSecret, 0, message.messageSecret.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSecret) : message.messageSecret;
            if (message.keepInChat != null && message.hasOwnProperty("keepInChat"))
                object.keepInChat = $root.proto.KeepInChat.toObject(message.keepInChat, options);
            if (message.originalSelfAuthorUserJidString != null && message.hasOwnProperty("originalSelfAuthorUserJidString"))
                object.originalSelfAuthorUserJidString = message.originalSelfAuthorUserJidString;
            if (message.revokeMessageTimestamp != null && message.hasOwnProperty("revokeMessageTimestamp"))
                if (typeof message.revokeMessageTimestamp === "number")
                    object.revokeMessageTimestamp = options.longs === String ? String(message.revokeMessageTimestamp) : message.revokeMessageTimestamp;
                else
                    object.revokeMessageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.revokeMessageTimestamp) : options.longs === Number ? new $util.LongBits(message.revokeMessageTimestamp.low >>> 0, message.revokeMessageTimestamp.high >>> 0).toNumber(true) : message.revokeMessageTimestamp;
            return object;
        };

        /**
         * Converts this WebMessageInfo to JSON.
         * @function toJSON
         * @memberof proto.WebMessageInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebMessageInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * BizPrivacyStatus enum.
         * @name proto.WebMessageInfo.BizPrivacyStatus
         * @enum {number}
         * @property {number} E2EE=0 E2EE value
         * @property {number} FB=2 FB value
         * @property {number} BSP=1 BSP value
         * @property {number} BSP_AND_FB=3 BSP_AND_FB value
         */
        WebMessageInfo.BizPrivacyStatus = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "E2EE"] = 0;
            values[valuesById[2] = "FB"] = 2;
            values[valuesById[1] = "BSP"] = 1;
            values[valuesById[3] = "BSP_AND_FB"] = 3;
            return values;
        })();

        /**
         * Status enum.
         * @name proto.WebMessageInfo.Status
         * @enum {number}
         * @property {number} ERROR=0 ERROR value
         * @property {number} PENDING=1 PENDING value
         * @property {number} SERVER_ACK=2 SERVER_ACK value
         * @property {number} DELIVERY_ACK=3 DELIVERY_ACK value
         * @property {number} READ=4 READ value
         * @property {number} PLAYED=5 PLAYED value
         */
        WebMessageInfo.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ERROR"] = 0;
            values[valuesById[1] = "PENDING"] = 1;
            values[valuesById[2] = "SERVER_ACK"] = 2;
            values[valuesById[3] = "DELIVERY_ACK"] = 3;
            values[valuesById[4] = "READ"] = 4;
            values[valuesById[5] = "PLAYED"] = 5;
            return values;
        })();

        /**
         * StubType enum.
         * @name proto.WebMessageInfo.StubType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} REVOKE=1 REVOKE value
         * @property {number} CIPHERTEXT=2 CIPHERTEXT value
         * @property {number} FUTUREPROOF=3 FUTUREPROOF value
         * @property {number} NON_VERIFIED_TRANSITION=4 NON_VERIFIED_TRANSITION value
         * @property {number} UNVERIFIED_TRANSITION=5 UNVERIFIED_TRANSITION value
         * @property {number} VERIFIED_TRANSITION=6 VERIFIED_TRANSITION value
         * @property {number} VERIFIED_LOW_UNKNOWN=7 VERIFIED_LOW_UNKNOWN value
         * @property {number} VERIFIED_HIGH=8 VERIFIED_HIGH value
         * @property {number} VERIFIED_INITIAL_UNKNOWN=9 VERIFIED_INITIAL_UNKNOWN value
         * @property {number} VERIFIED_INITIAL_LOW=10 VERIFIED_INITIAL_LOW value
         * @property {number} VERIFIED_INITIAL_HIGH=11 VERIFIED_INITIAL_HIGH value
         * @property {number} VERIFIED_TRANSITION_ANY_TO_NONE=12 VERIFIED_TRANSITION_ANY_TO_NONE value
         * @property {number} VERIFIED_TRANSITION_ANY_TO_HIGH=13 VERIFIED_TRANSITION_ANY_TO_HIGH value
         * @property {number} VERIFIED_TRANSITION_HIGH_TO_LOW=14 VERIFIED_TRANSITION_HIGH_TO_LOW value
         * @property {number} VERIFIED_TRANSITION_HIGH_TO_UNKNOWN=15 VERIFIED_TRANSITION_HIGH_TO_UNKNOWN value
         * @property {number} VERIFIED_TRANSITION_UNKNOWN_TO_LOW=16 VERIFIED_TRANSITION_UNKNOWN_TO_LOW value
         * @property {number} VERIFIED_TRANSITION_LOW_TO_UNKNOWN=17 VERIFIED_TRANSITION_LOW_TO_UNKNOWN value
         * @property {number} VERIFIED_TRANSITION_NONE_TO_LOW=18 VERIFIED_TRANSITION_NONE_TO_LOW value
         * @property {number} VERIFIED_TRANSITION_NONE_TO_UNKNOWN=19 VERIFIED_TRANSITION_NONE_TO_UNKNOWN value
         * @property {number} GROUP_CREATE=20 GROUP_CREATE value
         * @property {number} GROUP_CHANGE_SUBJECT=21 GROUP_CHANGE_SUBJECT value
         * @property {number} GROUP_CHANGE_ICON=22 GROUP_CHANGE_ICON value
         * @property {number} GROUP_CHANGE_INVITE_LINK=23 GROUP_CHANGE_INVITE_LINK value
         * @property {number} GROUP_CHANGE_DESCRIPTION=24 GROUP_CHANGE_DESCRIPTION value
         * @property {number} GROUP_CHANGE_RESTRICT=25 GROUP_CHANGE_RESTRICT value
         * @property {number} GROUP_CHANGE_ANNOUNCE=26 GROUP_CHANGE_ANNOUNCE value
         * @property {number} GROUP_PARTICIPANT_ADD=27 GROUP_PARTICIPANT_ADD value
         * @property {number} GROUP_PARTICIPANT_REMOVE=28 GROUP_PARTICIPANT_REMOVE value
         * @property {number} GROUP_PARTICIPANT_PROMOTE=29 GROUP_PARTICIPANT_PROMOTE value
         * @property {number} GROUP_PARTICIPANT_DEMOTE=30 GROUP_PARTICIPANT_DEMOTE value
         * @property {number} GROUP_PARTICIPANT_INVITE=31 GROUP_PARTICIPANT_INVITE value
         * @property {number} GROUP_PARTICIPANT_LEAVE=32 GROUP_PARTICIPANT_LEAVE value
         * @property {number} GROUP_PARTICIPANT_CHANGE_NUMBER=33 GROUP_PARTICIPANT_CHANGE_NUMBER value
         * @property {number} BROADCAST_CREATE=34 BROADCAST_CREATE value
         * @property {number} BROADCAST_ADD=35 BROADCAST_ADD value
         * @property {number} BROADCAST_REMOVE=36 BROADCAST_REMOVE value
         * @property {number} GENERIC_NOTIFICATION=37 GENERIC_NOTIFICATION value
         * @property {number} E2E_IDENTITY_CHANGED=38 E2E_IDENTITY_CHANGED value
         * @property {number} E2E_ENCRYPTED=39 E2E_ENCRYPTED value
         * @property {number} CALL_MISSED_VOICE=40 CALL_MISSED_VOICE value
         * @property {number} CALL_MISSED_VIDEO=41 CALL_MISSED_VIDEO value
         * @property {number} INDIVIDUAL_CHANGE_NUMBER=42 INDIVIDUAL_CHANGE_NUMBER value
         * @property {number} GROUP_DELETE=43 GROUP_DELETE value
         * @property {number} GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE=44 GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE value
         * @property {number} CALL_MISSED_GROUP_VOICE=45 CALL_MISSED_GROUP_VOICE value
         * @property {number} CALL_MISSED_GROUP_VIDEO=46 CALL_MISSED_GROUP_VIDEO value
         * @property {number} PAYMENT_CIPHERTEXT=47 PAYMENT_CIPHERTEXT value
         * @property {number} PAYMENT_FUTUREPROOF=48 PAYMENT_FUTUREPROOF value
         * @property {number} PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED=49 PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED value
         * @property {number} PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED=50 PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED value
         * @property {number} PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED=51 PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED value
         * @property {number} PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP=52 PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP value
         * @property {number} PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP=53 PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP value
         * @property {number} PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER=54 PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER value
         * @property {number} PAYMENT_ACTION_SEND_PAYMENT_REMINDER=55 PAYMENT_ACTION_SEND_PAYMENT_REMINDER value
         * @property {number} PAYMENT_ACTION_SEND_PAYMENT_INVITATION=56 PAYMENT_ACTION_SEND_PAYMENT_INVITATION value
         * @property {number} PAYMENT_ACTION_REQUEST_DECLINED=57 PAYMENT_ACTION_REQUEST_DECLINED value
         * @property {number} PAYMENT_ACTION_REQUEST_EXPIRED=58 PAYMENT_ACTION_REQUEST_EXPIRED value
         * @property {number} PAYMENT_ACTION_REQUEST_CANCELLED=59 PAYMENT_ACTION_REQUEST_CANCELLED value
         * @property {number} BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM=60 BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM value
         * @property {number} BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP=61 BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP value
         * @property {number} BIZ_INTRO_TOP=62 BIZ_INTRO_TOP value
         * @property {number} BIZ_INTRO_BOTTOM=63 BIZ_INTRO_BOTTOM value
         * @property {number} BIZ_NAME_CHANGE=64 BIZ_NAME_CHANGE value
         * @property {number} BIZ_MOVE_TO_CONSUMER_APP=65 BIZ_MOVE_TO_CONSUMER_APP value
         * @property {number} BIZ_TWO_TIER_MIGRATION_TOP=66 BIZ_TWO_TIER_MIGRATION_TOP value
         * @property {number} BIZ_TWO_TIER_MIGRATION_BOTTOM=67 BIZ_TWO_TIER_MIGRATION_BOTTOM value
         * @property {number} OVERSIZED=68 OVERSIZED value
         * @property {number} GROUP_CHANGE_NO_FREQUENTLY_FORWARDED=69 GROUP_CHANGE_NO_FREQUENTLY_FORWARDED value
         * @property {number} GROUP_V4_ADD_INVITE_SENT=70 GROUP_V4_ADD_INVITE_SENT value
         * @property {number} GROUP_PARTICIPANT_ADD_REQUEST_JOIN=71 GROUP_PARTICIPANT_ADD_REQUEST_JOIN value
         * @property {number} CHANGE_EPHEMERAL_SETTING=72 CHANGE_EPHEMERAL_SETTING value
         * @property {number} E2E_DEVICE_CHANGED=73 E2E_DEVICE_CHANGED value
         * @property {number} VIEWED_ONCE=74 VIEWED_ONCE value
         * @property {number} E2E_ENCRYPTED_NOW=75 E2E_ENCRYPTED_NOW value
         * @property {number} BLUE_MSG_BSP_FB_TO_BSP_PREMISE=76 BLUE_MSG_BSP_FB_TO_BSP_PREMISE value
         * @property {number} BLUE_MSG_BSP_FB_TO_SELF_FB=77 BLUE_MSG_BSP_FB_TO_SELF_FB value
         * @property {number} BLUE_MSG_BSP_FB_TO_SELF_PREMISE=78 BLUE_MSG_BSP_FB_TO_SELF_PREMISE value
         * @property {number} BLUE_MSG_BSP_FB_UNVERIFIED=79 BLUE_MSG_BSP_FB_UNVERIFIED value
         * @property {number} BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED=80 BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED value
         * @property {number} BLUE_MSG_BSP_FB_VERIFIED=81 BLUE_MSG_BSP_FB_VERIFIED value
         * @property {number} BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED=82 BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE=83 BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE value
         * @property {number} BLUE_MSG_BSP_PREMISE_UNVERIFIED=84 BLUE_MSG_BSP_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED=85 BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED value
         * @property {number} BLUE_MSG_BSP_PREMISE_VERIFIED=86 BLUE_MSG_BSP_PREMISE_VERIFIED value
         * @property {number} BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED=87 BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED=88 BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED value
         * @property {number} BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED=89 BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED=90 BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED value
         * @property {number} BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED=91 BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_SELF_FB_TO_BSP_PREMISE=92 BLUE_MSG_SELF_FB_TO_BSP_PREMISE value
         * @property {number} BLUE_MSG_SELF_FB_TO_SELF_PREMISE=93 BLUE_MSG_SELF_FB_TO_SELF_PREMISE value
         * @property {number} BLUE_MSG_SELF_FB_UNVERIFIED=94 BLUE_MSG_SELF_FB_UNVERIFIED value
         * @property {number} BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED=95 BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED value
         * @property {number} BLUE_MSG_SELF_FB_VERIFIED=96 BLUE_MSG_SELF_FB_VERIFIED value
         * @property {number} BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED=97 BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE=98 BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE value
         * @property {number} BLUE_MSG_SELF_PREMISE_UNVERIFIED=99 BLUE_MSG_SELF_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_SELF_PREMISE_VERIFIED=100 BLUE_MSG_SELF_PREMISE_VERIFIED value
         * @property {number} BLUE_MSG_TO_BSP_FB=101 BLUE_MSG_TO_BSP_FB value
         * @property {number} BLUE_MSG_TO_CONSUMER=102 BLUE_MSG_TO_CONSUMER value
         * @property {number} BLUE_MSG_TO_SELF_FB=103 BLUE_MSG_TO_SELF_FB value
         * @property {number} BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED=104 BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED value
         * @property {number} BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED=105 BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED value
         * @property {number} BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED=106 BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED value
         * @property {number} BLUE_MSG_UNVERIFIED_TO_VERIFIED=107 BLUE_MSG_UNVERIFIED_TO_VERIFIED value
         * @property {number} BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED=108 BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED value
         * @property {number} BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED=109 BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED=110 BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED value
         * @property {number} BLUE_MSG_VERIFIED_TO_UNVERIFIED=111 BLUE_MSG_VERIFIED_TO_UNVERIFIED value
         * @property {number} BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED=112 BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED value
         * @property {number} BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED=113 BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED value
         * @property {number} BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED=114 BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED value
         * @property {number} BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED=115 BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED value
         * @property {number} BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED=116 BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED value
         * @property {number} BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED=117 BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED value
         * @property {number} E2E_IDENTITY_UNAVAILABLE=118 E2E_IDENTITY_UNAVAILABLE value
         * @property {number} GROUP_CREATING=119 GROUP_CREATING value
         * @property {number} GROUP_CREATE_FAILED=120 GROUP_CREATE_FAILED value
         * @property {number} GROUP_BOUNCED=121 GROUP_BOUNCED value
         * @property {number} BLOCK_CONTACT=122 BLOCK_CONTACT value
         * @property {number} EPHEMERAL_SETTING_NOT_APPLIED=123 EPHEMERAL_SETTING_NOT_APPLIED value
         * @property {number} SYNC_FAILED=124 SYNC_FAILED value
         * @property {number} SYNCING=125 SYNCING value
         * @property {number} BIZ_PRIVACY_MODE_INIT_FB=126 BIZ_PRIVACY_MODE_INIT_FB value
         * @property {number} BIZ_PRIVACY_MODE_INIT_BSP=127 BIZ_PRIVACY_MODE_INIT_BSP value
         * @property {number} BIZ_PRIVACY_MODE_TO_FB=128 BIZ_PRIVACY_MODE_TO_FB value
         * @property {number} BIZ_PRIVACY_MODE_TO_BSP=129 BIZ_PRIVACY_MODE_TO_BSP value
         * @property {number} DISAPPEARING_MODE=130 DISAPPEARING_MODE value
         * @property {number} E2E_DEVICE_FETCH_FAILED=131 E2E_DEVICE_FETCH_FAILED value
         * @property {number} ADMIN_REVOKE=132 ADMIN_REVOKE value
         * @property {number} GROUP_INVITE_LINK_GROWTH_LOCKED=133 GROUP_INVITE_LINK_GROWTH_LOCKED value
         * @property {number} COMMUNITY_LINK_PARENT_GROUP=134 COMMUNITY_LINK_PARENT_GROUP value
         * @property {number} COMMUNITY_LINK_SIBLING_GROUP=135 COMMUNITY_LINK_SIBLING_GROUP value
         * @property {number} COMMUNITY_LINK_SUB_GROUP=136 COMMUNITY_LINK_SUB_GROUP value
         * @property {number} COMMUNITY_UNLINK_PARENT_GROUP=137 COMMUNITY_UNLINK_PARENT_GROUP value
         * @property {number} COMMUNITY_UNLINK_SIBLING_GROUP=138 COMMUNITY_UNLINK_SIBLING_GROUP value
         * @property {number} COMMUNITY_UNLINK_SUB_GROUP=139 COMMUNITY_UNLINK_SUB_GROUP value
         * @property {number} GROUP_PARTICIPANT_ACCEPT=140 GROUP_PARTICIPANT_ACCEPT value
         * @property {number} GROUP_PARTICIPANT_LINKED_GROUP_JOIN=141 GROUP_PARTICIPANT_LINKED_GROUP_JOIN value
         * @property {number} COMMUNITY_CREATE=142 COMMUNITY_CREATE value
         * @property {number} EPHEMERAL_KEEP_IN_CHAT=143 EPHEMERAL_KEEP_IN_CHAT value
         * @property {number} GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST=144 GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST value
         * @property {number} GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE=145 GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE value
         * @property {number} INTEGRITY_UNLINK_PARENT_GROUP=146 INTEGRITY_UNLINK_PARENT_GROUP value
         * @property {number} COMMUNITY_PARTICIPANT_PROMOTE=147 COMMUNITY_PARTICIPANT_PROMOTE value
         * @property {number} COMMUNITY_PARTICIPANT_DEMOTE=148 COMMUNITY_PARTICIPANT_DEMOTE value
         * @property {number} COMMUNITY_PARENT_GROUP_DELETED=149 COMMUNITY_PARENT_GROUP_DELETED value
         * @property {number} COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL=150 COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL value
         * @property {number} GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP=151 GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP value
         * @property {number} MASKED_THREAD_CREATED=152 MASKED_THREAD_CREATED value
         * @property {number} MASKED_THREAD_UNMASKED=153 MASKED_THREAD_UNMASKED value
         * @property {number} BIZ_CHAT_ASSIGNMENT=154 BIZ_CHAT_ASSIGNMENT value
         * @property {number} CHAT_PSA=155 CHAT_PSA value
         * @property {number} CHAT_POLL_CREATION_MESSAGE=156 CHAT_POLL_CREATION_MESSAGE value
         * @property {number} CAG_MASKED_THREAD_CREATED=157 CAG_MASKED_THREAD_CREATED value
         * @property {number} COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED=158 COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED value
         * @property {number} CAG_INVITE_AUTO_ADD=159 CAG_INVITE_AUTO_ADD value
         * @property {number} BIZ_CHAT_ASSIGNMENT_UNASSIGN=160 BIZ_CHAT_ASSIGNMENT_UNASSIGN value
         * @property {number} CAG_INVITE_AUTO_JOINED=161 CAG_INVITE_AUTO_JOINED value
         */
        WebMessageInfo.StubType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "REVOKE"] = 1;
            values[valuesById[2] = "CIPHERTEXT"] = 2;
            values[valuesById[3] = "FUTUREPROOF"] = 3;
            values[valuesById[4] = "NON_VERIFIED_TRANSITION"] = 4;
            values[valuesById[5] = "UNVERIFIED_TRANSITION"] = 5;
            values[valuesById[6] = "VERIFIED_TRANSITION"] = 6;
            values[valuesById[7] = "VERIFIED_LOW_UNKNOWN"] = 7;
            values[valuesById[8] = "VERIFIED_HIGH"] = 8;
            values[valuesById[9] = "VERIFIED_INITIAL_UNKNOWN"] = 9;
            values[valuesById[10] = "VERIFIED_INITIAL_LOW"] = 10;
            values[valuesById[11] = "VERIFIED_INITIAL_HIGH"] = 11;
            values[valuesById[12] = "VERIFIED_TRANSITION_ANY_TO_NONE"] = 12;
            values[valuesById[13] = "VERIFIED_TRANSITION_ANY_TO_HIGH"] = 13;
            values[valuesById[14] = "VERIFIED_TRANSITION_HIGH_TO_LOW"] = 14;
            values[valuesById[15] = "VERIFIED_TRANSITION_HIGH_TO_UNKNOWN"] = 15;
            values[valuesById[16] = "VERIFIED_TRANSITION_UNKNOWN_TO_LOW"] = 16;
            values[valuesById[17] = "VERIFIED_TRANSITION_LOW_TO_UNKNOWN"] = 17;
            values[valuesById[18] = "VERIFIED_TRANSITION_NONE_TO_LOW"] = 18;
            values[valuesById[19] = "VERIFIED_TRANSITION_NONE_TO_UNKNOWN"] = 19;
            values[valuesById[20] = "GROUP_CREATE"] = 20;
            values[valuesById[21] = "GROUP_CHANGE_SUBJECT"] = 21;
            values[valuesById[22] = "GROUP_CHANGE_ICON"] = 22;
            values[valuesById[23] = "GROUP_CHANGE_INVITE_LINK"] = 23;
            values[valuesById[24] = "GROUP_CHANGE_DESCRIPTION"] = 24;
            values[valuesById[25] = "GROUP_CHANGE_RESTRICT"] = 25;
            values[valuesById[26] = "GROUP_CHANGE_ANNOUNCE"] = 26;
            values[valuesById[27] = "GROUP_PARTICIPANT_ADD"] = 27;
            values[valuesById[28] = "GROUP_PARTICIPANT_REMOVE"] = 28;
            values[valuesById[29] = "GROUP_PARTICIPANT_PROMOTE"] = 29;
            values[valuesById[30] = "GROUP_PARTICIPANT_DEMOTE"] = 30;
            values[valuesById[31] = "GROUP_PARTICIPANT_INVITE"] = 31;
            values[valuesById[32] = "GROUP_PARTICIPANT_LEAVE"] = 32;
            values[valuesById[33] = "GROUP_PARTICIPANT_CHANGE_NUMBER"] = 33;
            values[valuesById[34] = "BROADCAST_CREATE"] = 34;
            values[valuesById[35] = "BROADCAST_ADD"] = 35;
            values[valuesById[36] = "BROADCAST_REMOVE"] = 36;
            values[valuesById[37] = "GENERIC_NOTIFICATION"] = 37;
            values[valuesById[38] = "E2E_IDENTITY_CHANGED"] = 38;
            values[valuesById[39] = "E2E_ENCRYPTED"] = 39;
            values[valuesById[40] = "CALL_MISSED_VOICE"] = 40;
            values[valuesById[41] = "CALL_MISSED_VIDEO"] = 41;
            values[valuesById[42] = "INDIVIDUAL_CHANGE_NUMBER"] = 42;
            values[valuesById[43] = "GROUP_DELETE"] = 43;
            values[valuesById[44] = "GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE"] = 44;
            values[valuesById[45] = "CALL_MISSED_GROUP_VOICE"] = 45;
            values[valuesById[46] = "CALL_MISSED_GROUP_VIDEO"] = 46;
            values[valuesById[47] = "PAYMENT_CIPHERTEXT"] = 47;
            values[valuesById[48] = "PAYMENT_FUTUREPROOF"] = 48;
            values[valuesById[49] = "PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED"] = 49;
            values[valuesById[50] = "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED"] = 50;
            values[valuesById[51] = "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED"] = 51;
            values[valuesById[52] = "PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP"] = 52;
            values[valuesById[53] = "PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP"] = 53;
            values[valuesById[54] = "PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER"] = 54;
            values[valuesById[55] = "PAYMENT_ACTION_SEND_PAYMENT_REMINDER"] = 55;
            values[valuesById[56] = "PAYMENT_ACTION_SEND_PAYMENT_INVITATION"] = 56;
            values[valuesById[57] = "PAYMENT_ACTION_REQUEST_DECLINED"] = 57;
            values[valuesById[58] = "PAYMENT_ACTION_REQUEST_EXPIRED"] = 58;
            values[valuesById[59] = "PAYMENT_ACTION_REQUEST_CANCELLED"] = 59;
            values[valuesById[60] = "BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM"] = 60;
            values[valuesById[61] = "BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP"] = 61;
            values[valuesById[62] = "BIZ_INTRO_TOP"] = 62;
            values[valuesById[63] = "BIZ_INTRO_BOTTOM"] = 63;
            values[valuesById[64] = "BIZ_NAME_CHANGE"] = 64;
            values[valuesById[65] = "BIZ_MOVE_TO_CONSUMER_APP"] = 65;
            values[valuesById[66] = "BIZ_TWO_TIER_MIGRATION_TOP"] = 66;
            values[valuesById[67] = "BIZ_TWO_TIER_MIGRATION_BOTTOM"] = 67;
            values[valuesById[68] = "OVERSIZED"] = 68;
            values[valuesById[69] = "GROUP_CHANGE_NO_FREQUENTLY_FORWARDED"] = 69;
            values[valuesById[70] = "GROUP_V4_ADD_INVITE_SENT"] = 70;
            values[valuesById[71] = "GROUP_PARTICIPANT_ADD_REQUEST_JOIN"] = 71;
            values[valuesById[72] = "CHANGE_EPHEMERAL_SETTING"] = 72;
            values[valuesById[73] = "E2E_DEVICE_CHANGED"] = 73;
            values[valuesById[74] = "VIEWED_ONCE"] = 74;
            values[valuesById[75] = "E2E_ENCRYPTED_NOW"] = 75;
            values[valuesById[76] = "BLUE_MSG_BSP_FB_TO_BSP_PREMISE"] = 76;
            values[valuesById[77] = "BLUE_MSG_BSP_FB_TO_SELF_FB"] = 77;
            values[valuesById[78] = "BLUE_MSG_BSP_FB_TO_SELF_PREMISE"] = 78;
            values[valuesById[79] = "BLUE_MSG_BSP_FB_UNVERIFIED"] = 79;
            values[valuesById[80] = "BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED"] = 80;
            values[valuesById[81] = "BLUE_MSG_BSP_FB_VERIFIED"] = 81;
            values[valuesById[82] = "BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED"] = 82;
            values[valuesById[83] = "BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE"] = 83;
            values[valuesById[84] = "BLUE_MSG_BSP_PREMISE_UNVERIFIED"] = 84;
            values[valuesById[85] = "BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED"] = 85;
            values[valuesById[86] = "BLUE_MSG_BSP_PREMISE_VERIFIED"] = 86;
            values[valuesById[87] = "BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED"] = 87;
            values[valuesById[88] = "BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED"] = 88;
            values[valuesById[89] = "BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED"] = 89;
            values[valuesById[90] = "BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED"] = 90;
            values[valuesById[91] = "BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED"] = 91;
            values[valuesById[92] = "BLUE_MSG_SELF_FB_TO_BSP_PREMISE"] = 92;
            values[valuesById[93] = "BLUE_MSG_SELF_FB_TO_SELF_PREMISE"] = 93;
            values[valuesById[94] = "BLUE_MSG_SELF_FB_UNVERIFIED"] = 94;
            values[valuesById[95] = "BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED"] = 95;
            values[valuesById[96] = "BLUE_MSG_SELF_FB_VERIFIED"] = 96;
            values[valuesById[97] = "BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED"] = 97;
            values[valuesById[98] = "BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE"] = 98;
            values[valuesById[99] = "BLUE_MSG_SELF_PREMISE_UNVERIFIED"] = 99;
            values[valuesById[100] = "BLUE_MSG_SELF_PREMISE_VERIFIED"] = 100;
            values[valuesById[101] = "BLUE_MSG_TO_BSP_FB"] = 101;
            values[valuesById[102] = "BLUE_MSG_TO_CONSUMER"] = 102;
            values[valuesById[103] = "BLUE_MSG_TO_SELF_FB"] = 103;
            values[valuesById[104] = "BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED"] = 104;
            values[valuesById[105] = "BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED"] = 105;
            values[valuesById[106] = "BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED"] = 106;
            values[valuesById[107] = "BLUE_MSG_UNVERIFIED_TO_VERIFIED"] = 107;
            values[valuesById[108] = "BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED"] = 108;
            values[valuesById[109] = "BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED"] = 109;
            values[valuesById[110] = "BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED"] = 110;
            values[valuesById[111] = "BLUE_MSG_VERIFIED_TO_UNVERIFIED"] = 111;
            values[valuesById[112] = "BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED"] = 112;
            values[valuesById[113] = "BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED"] = 113;
            values[valuesById[114] = "BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED"] = 114;
            values[valuesById[115] = "BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED"] = 115;
            values[valuesById[116] = "BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED"] = 116;
            values[valuesById[117] = "BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED"] = 117;
            values[valuesById[118] = "E2E_IDENTITY_UNAVAILABLE"] = 118;
            values[valuesById[119] = "GROUP_CREATING"] = 119;
            values[valuesById[120] = "GROUP_CREATE_FAILED"] = 120;
            values[valuesById[121] = "GROUP_BOUNCED"] = 121;
            values[valuesById[122] = "BLOCK_CONTACT"] = 122;
            values[valuesById[123] = "EPHEMERAL_SETTING_NOT_APPLIED"] = 123;
            values[valuesById[124] = "SYNC_FAILED"] = 124;
            values[valuesById[125] = "SYNCING"] = 125;
            values[valuesById[126] = "BIZ_PRIVACY_MODE_INIT_FB"] = 126;
            values[valuesById[127] = "BIZ_PRIVACY_MODE_INIT_BSP"] = 127;
            values[valuesById[128] = "BIZ_PRIVACY_MODE_TO_FB"] = 128;
            values[valuesById[129] = "BIZ_PRIVACY_MODE_TO_BSP"] = 129;
            values[valuesById[130] = "DISAPPEARING_MODE"] = 130;
            values[valuesById[131] = "E2E_DEVICE_FETCH_FAILED"] = 131;
            values[valuesById[132] = "ADMIN_REVOKE"] = 132;
            values[valuesById[133] = "GROUP_INVITE_LINK_GROWTH_LOCKED"] = 133;
            values[valuesById[134] = "COMMUNITY_LINK_PARENT_GROUP"] = 134;
            values[valuesById[135] = "COMMUNITY_LINK_SIBLING_GROUP"] = 135;
            values[valuesById[136] = "COMMUNITY_LINK_SUB_GROUP"] = 136;
            values[valuesById[137] = "COMMUNITY_UNLINK_PARENT_GROUP"] = 137;
            values[valuesById[138] = "COMMUNITY_UNLINK_SIBLING_GROUP"] = 138;
            values[valuesById[139] = "COMMUNITY_UNLINK_SUB_GROUP"] = 139;
            values[valuesById[140] = "GROUP_PARTICIPANT_ACCEPT"] = 140;
            values[valuesById[141] = "GROUP_PARTICIPANT_LINKED_GROUP_JOIN"] = 141;
            values[valuesById[142] = "COMMUNITY_CREATE"] = 142;
            values[valuesById[143] = "EPHEMERAL_KEEP_IN_CHAT"] = 143;
            values[valuesById[144] = "GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST"] = 144;
            values[valuesById[145] = "GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE"] = 145;
            values[valuesById[146] = "INTEGRITY_UNLINK_PARENT_GROUP"] = 146;
            values[valuesById[147] = "COMMUNITY_PARTICIPANT_PROMOTE"] = 147;
            values[valuesById[148] = "COMMUNITY_PARTICIPANT_DEMOTE"] = 148;
            values[valuesById[149] = "COMMUNITY_PARENT_GROUP_DELETED"] = 149;
            values[valuesById[150] = "COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL"] = 150;
            values[valuesById[151] = "GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP"] = 151;
            values[valuesById[152] = "MASKED_THREAD_CREATED"] = 152;
            values[valuesById[153] = "MASKED_THREAD_UNMASKED"] = 153;
            values[valuesById[154] = "BIZ_CHAT_ASSIGNMENT"] = 154;
            values[valuesById[155] = "CHAT_PSA"] = 155;
            values[valuesById[156] = "CHAT_POLL_CREATION_MESSAGE"] = 156;
            values[valuesById[157] = "CAG_MASKED_THREAD_CREATED"] = 157;
            values[valuesById[158] = "COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED"] = 158;
            values[valuesById[159] = "CAG_INVITE_AUTO_ADD"] = 159;
            values[valuesById[160] = "BIZ_CHAT_ASSIGNMENT_UNASSIGN"] = 160;
            values[valuesById[161] = "CAG_INVITE_AUTO_JOINED"] = 161;
            return values;
        })();

        return WebMessageInfo;
    })();

    proto.WebNotificationsInfo = (function() {

        /**
         * Properties of a WebNotificationsInfo.
         * @memberof proto
         * @interface IWebNotificationsInfo
         * @property {number|Long|null} [timestamp] WebNotificationsInfo timestamp
         * @property {number|null} [unreadChats] WebNotificationsInfo unreadChats
         * @property {number|null} [notifyMessageCount] WebNotificationsInfo notifyMessageCount
         * @property {Array.<proto.IWebMessageInfo>|null} [notifyMessages] WebNotificationsInfo notifyMessages
         */

        /**
         * Constructs a new WebNotificationsInfo.
         * @memberof proto
         * @classdesc Represents a WebNotificationsInfo.
         * @implements IWebNotificationsInfo
         * @constructor
         * @param {proto.IWebNotificationsInfo=} [properties] Properties to set
         */
        function WebNotificationsInfo(properties) {
            this.notifyMessages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebNotificationsInfo timestamp.
         * @member {number|Long} timestamp
         * @memberof proto.WebNotificationsInfo
         * @instance
         */
        WebNotificationsInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebNotificationsInfo unreadChats.
         * @member {number} unreadChats
         * @memberof proto.WebNotificationsInfo
         * @instance
         */
        WebNotificationsInfo.prototype.unreadChats = 0;

        /**
         * WebNotificationsInfo notifyMessageCount.
         * @member {number} notifyMessageCount
         * @memberof proto.WebNotificationsInfo
         * @instance
         */
        WebNotificationsInfo.prototype.notifyMessageCount = 0;

        /**
         * WebNotificationsInfo notifyMessages.
         * @member {Array.<proto.IWebMessageInfo>} notifyMessages
         * @memberof proto.WebNotificationsInfo
         * @instance
         */
        WebNotificationsInfo.prototype.notifyMessages = $util.emptyArray;

        /**
         * Creates a new WebNotificationsInfo instance using the specified properties.
         * @function create
         * @memberof proto.WebNotificationsInfo
         * @static
         * @param {proto.IWebNotificationsInfo=} [properties] Properties to set
         * @returns {proto.WebNotificationsInfo} WebNotificationsInfo instance
         */
        WebNotificationsInfo.create = function create(properties) {
            return new WebNotificationsInfo(properties);
        };

        /**
         * Encodes the specified WebNotificationsInfo message. Does not implicitly {@link proto.WebNotificationsInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.WebNotificationsInfo
         * @static
         * @param {proto.IWebNotificationsInfo} message WebNotificationsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebNotificationsInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
            if (message.unreadChats != null && Object.hasOwnProperty.call(message, "unreadChats"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.unreadChats);
            if (message.notifyMessageCount != null && Object.hasOwnProperty.call(message, "notifyMessageCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.notifyMessageCount);
            if (message.notifyMessages != null && message.notifyMessages.length)
                for (var i = 0; i < message.notifyMessages.length; ++i)
                    $root.proto.WebMessageInfo.encode(message.notifyMessages[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WebNotificationsInfo message, length delimited. Does not implicitly {@link proto.WebNotificationsInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.WebNotificationsInfo
         * @static
         * @param {proto.IWebNotificationsInfo} message WebNotificationsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebNotificationsInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebNotificationsInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.WebNotificationsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.WebNotificationsInfo} WebNotificationsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebNotificationsInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.WebNotificationsInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.timestamp = reader.uint64();
                    break;
                case 3:
                    message.unreadChats = reader.uint32();
                    break;
                case 4:
                    message.notifyMessageCount = reader.uint32();
                    break;
                case 5:
                    if (!(message.notifyMessages && message.notifyMessages.length))
                        message.notifyMessages = [];
                    message.notifyMessages.push($root.proto.WebMessageInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebNotificationsInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.WebNotificationsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.WebNotificationsInfo} WebNotificationsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebNotificationsInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebNotificationsInfo message.
         * @function verify
         * @memberof proto.WebNotificationsInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebNotificationsInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.unreadChats != null && message.hasOwnProperty("unreadChats"))
                if (!$util.isInteger(message.unreadChats))
                    return "unreadChats: integer expected";
            if (message.notifyMessageCount != null && message.hasOwnProperty("notifyMessageCount"))
                if (!$util.isInteger(message.notifyMessageCount))
                    return "notifyMessageCount: integer expected";
            if (message.notifyMessages != null && message.hasOwnProperty("notifyMessages")) {
                if (!Array.isArray(message.notifyMessages))
                    return "notifyMessages: array expected";
                for (var i = 0; i < message.notifyMessages.length; ++i) {
                    var error = $root.proto.WebMessageInfo.verify(message.notifyMessages[i]);
                    if (error)
                        return "notifyMessages." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WebNotificationsInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.WebNotificationsInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.WebNotificationsInfo} WebNotificationsInfo
         */
        WebNotificationsInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.WebNotificationsInfo)
                return object;
            var message = new $root.proto.WebNotificationsInfo();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.unreadChats != null)
                message.unreadChats = object.unreadChats >>> 0;
            if (object.notifyMessageCount != null)
                message.notifyMessageCount = object.notifyMessageCount >>> 0;
            if (object.notifyMessages) {
                if (!Array.isArray(object.notifyMessages))
                    throw TypeError(".proto.WebNotificationsInfo.notifyMessages: array expected");
                message.notifyMessages = [];
                for (var i = 0; i < object.notifyMessages.length; ++i) {
                    if (typeof object.notifyMessages[i] !== "object")
                        throw TypeError(".proto.WebNotificationsInfo.notifyMessages: object expected");
                    message.notifyMessages[i] = $root.proto.WebMessageInfo.fromObject(object.notifyMessages[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WebNotificationsInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.WebNotificationsInfo
         * @static
         * @param {proto.WebNotificationsInfo} message WebNotificationsInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebNotificationsInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.notifyMessages = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.unreadChats = 0;
                object.notifyMessageCount = 0;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.unreadChats != null && message.hasOwnProperty("unreadChats"))
                object.unreadChats = message.unreadChats;
            if (message.notifyMessageCount != null && message.hasOwnProperty("notifyMessageCount"))
                object.notifyMessageCount = message.notifyMessageCount;
            if (message.notifyMessages && message.notifyMessages.length) {
                object.notifyMessages = [];
                for (var j = 0; j < message.notifyMessages.length; ++j)
                    object.notifyMessages[j] = $root.proto.WebMessageInfo.toObject(message.notifyMessages[j], options);
            }
            return object;
        };

        /**
         * Converts this WebNotificationsInfo to JSON.
         * @function toJSON
         * @memberof proto.WebNotificationsInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebNotificationsInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WebNotificationsInfo;
    })();

    return proto;
})();

module.exports = $root;
